{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with the Kili Python SDK","text":""},{"location":"#what-is-kili","title":"What is Kili?","text":"<p>Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here.</p> <p>If you are looking for the Kili product documentation, it is located here.</p>"},{"location":"#the-kili-python-sdk","title":"The Kili Python SDK","text":"<p>Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>You only need Python 3.7 or higher.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the Kili client with pip:</p> <pre><code>pip install kili\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <ul> <li>Instantiate the Kili client:</li> </ul> <pre><code>from kili.client import Kili\nkili = Kili()\n</code></pre>  <p>Great!</p> <p>You can now begin to use the Kili Python SDK</p>   <p>Info</p> <p>You can also pass the API key as an argument of the <code>Kili</code> initialization: <code>python kili = Kili(api_key='&lt;you api key value here&gt;')</code></p>"},{"location":"label_export/","title":"Exporting kili projects","text":"<p>There are several ways to export labels from a Kili project.</p>"},{"location":"label_export/#with-the-cli","title":"With the CLI","text":"<p>You can export a project using the <code>kili project export</code> command: <pre><code>kili project export \\\n        --project-id &lt;project_id&gt; \\\n        --output-format yolo_v5 \\\n        --output-file /tmp/export.zip\n</code></pre> More options here.</p>"},{"location":"label_export/#with-the-python-sdk","title":"With the Python SDK","text":"<p>You can also use the Python SDK: <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"yolo_v5\",\n)\n</code></pre> More details here.</p>"},{"location":"label_export/#from-the-kili-ui","title":"From the Kili UI","text":"<p>You can refer to this Kili documentation page.</p>"},{"location":"label_export/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface     Kili (raw) \u2705 \u2705 \u2705   Kili (simple) \u2705 \u274c \u274c   YOLO V4 \u2705 \u2705 \u2705   YOLO V5 \u2705 \u2705 \u2705   YOLO V7 \u274c \u2705 \u2705   Pascal VOC \u2705 \u2705 \u2705   COCO \u274c \u2705 \u2705    <p>And more to come!</p>"},{"location":"cli/","title":"Getting started with the Kili CLI","text":""},{"location":"cli/#what-is-kili-cli","title":"What is Kili CLI","text":"<p>Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.</p>"},{"location":"cli/#authentication","title":"Authentication","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre>  <p>Info</p>  <p>While launching commands, you can also provide you API key through the <code>--api-key</code> option. If you set your api key in the <code>KILI_API_KEY</code> environment variable and provide it once again through the <code>--api-key</code> option, Kili CLI will use the api key value provided in command options.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>The main command is <code>kili</code>. It currently has only one subcommand <code>project</code> that entails all the commands for project management :</p> <pre><code>kili project [COMMAND]\n</code></pre>"},{"location":"cli/#workflow-example","title":"Workflow example","text":"<p>Let's take an example where you want to start a project from scratch  You can download ressources to run this example here. Once in the current directory where all files are stored, you can run the following commands:</p>"},{"location":"cli/#create-a-project","title":"Create a project","text":"<p>To create an IMAGE project:</p> <pre><code>kili project create \\\n            json_interface.json \\\n            --title \"Quality inspection\" \\\n            --input-type IMAGE \\\n            --description \"Steel defects on production line\"\n</code></pre> <p>Ouput:</p> <pre><code>ID                         URL\n&lt;project_id&gt;               https://cloud.kili-technology.com/label/projects/&lt;project_id&gt;/\n</code></pre>"},{"location":"cli/#list-your-projects","title":"List your projects","text":"<pre><code>kili project list --max 10\n</code></pre> <p>Ouput:</p> <pre><code>TITLE                                ID                      PROGRESS  DESCRIPTION\nQuality inspection                   &lt;project_id&gt;                0.0%  Steel defects on production line...\n</code></pre>"},{"location":"cli/#recover-your-project-id","title":"Recover your project ID","text":"<pre><code>export project_id=$(kili project list \\\n              | grep -m1 \"Quality inspection\" \\\n              | awk '{print $3}')\n</code></pre>"},{"location":"cli/#add-a-member-to-your-project","title":"Add a member to your project","text":"<pre><code>kili project member add \\\n                &lt;email_adress&gt; \\\n                --project-id $project_id \\\n                --role REVIEWER\n</code></pre> <p>Ouput:</p> <pre><code>1 member(s) have been successfully added to project: &lt;project_id&gt;\n</code></pre>"},{"location":"cli/#list-the-projects-members","title":"List the project's members","text":"<pre><code>kili project member list --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>ROLE      NAME            EMAIL                ID                         ORGANIZATION\nADMIN     &lt;your_name&gt;     &lt;your_email&gt;         &lt;your_member_id&gt;           &lt;your_organization&gt;\nREVIEWER  &lt;reviewer_name&gt; &lt;email_adress&gt;       &lt;member_id&gt;                &lt;your_organization&gt;\n</code></pre>"},{"location":"cli/#import-data-to-your-project","title":"Import data to your project","text":"<p>To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths)</p> <pre><code>kili project import \\\n    assets \\\n    --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>40 files have been successfully imported\n</code></pre>"},{"location":"cli/#import-labels-to-your-project","title":"Import labels to your project","text":"<p>To import labels, provide a list of files or folders.</p> <p>You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example).  File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre> <p>If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface.</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre>"},{"location":"cli/#get-metrics-of-your-project","title":"Get metrics of your project","text":"<pre><code>kili project describe $project_id\n</code></pre> <p>Ouput:</p> <pre><code>Title        Quality inspection\nDescription  Steel defects on production line\n\nDataset KPIs\n------------\nTotal number of assets      40\nNumber of remaining assets  10\nSkipped assets              0\nProgress                    25.0%\n\nQuality KPIs\n------------\nProject consensus           N/A\nProject honeypot            N/A\nNumber of reviewed assets   0\nNumber of open issues       0\nNumber of solved issues     0\nNumber of open questions    0\nNumber of solved questions  0\n</code></pre>"},{"location":"cli/reference/","title":"kili","text":"<p>Kili Command line Interface</p> <p>To get all the available commands, please type: <code>kili project --help</code>.</p> <p>Usage:</p> <pre><code>kili [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--version</code> boolean Show the version and exit. <code>False</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#project","title":"project","text":"<p>Commands to interact with a Kili project</p> <p>Usage:</p> <pre><code>kili project [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#copy","title":"copy","text":"<p>Copy a Kili project.</p> <p>The copy can include or not the json interface, quality settings and members of the source project. By default, the json interface, quality settings and projects members are copied.</p> <p>If no <code>title</code> is provided, the source project title will be used. If no description is provided, the description will be set to an empty string.</p> <p>Returns the new project id and title once the copy is finished.</p>  <p>Examples</p> <p>Copy a project and set a new title and new description: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --title \"New project title\" \\\n    --description \"New project description\"\n</code></pre> Copy the json interface but not the members: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --with-json-interface \\\n    --without-members\n</code></pre></p>  <p>Usage:</p> <pre><code>kili project copy [OPTIONS] FROM_PROJECT_ID\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--title</code> text New project title. None   <code>--description</code> text New project description. None   <code>--with-json-interface</code> / <code>--without-json-interface</code> boolean Copy json interface. <code>True</code>   <code>--with-quality-settings</code> / <code>--without-quality-settings</code> boolean Copy quality settings. <code>True</code>   <code>--with-members</code> / <code>--without-members</code> boolean Copy members. <code>True</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#create","title":"create","text":"<p>Create a Kili project</p> <p>interface must be a path pointing to your json interface file</p> <p>If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied).</p>  <p>Examples</p> <p><pre><code>kili project create \\\n     path/to/interface.json \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre> <pre><code>kili project create \\\n    --from-project &lt;project_id_src&gt; \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre></p>  <p>To build a Kili project interface, please visit: </p> <p>https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings</p> <p>Usage:</p> <pre><code>kili project create [OPTIONS] [INTERFACE]\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--from-project</code> text project_id of another Kili project None   <code>--title</code> text Project Title. _required   <code>--input-type</code> choice (<code>AUDIO</code> | <code>IMAGE</code> | <code>PDF</code> | <code>TEXT</code> | <code>TIME_SERIES</code> | <code>VIDEO</code> | <code>VIDEO_LEGACY</code>) Project input data type. Please check your license to see which ones you have access to. _required   <code>--description</code> text Project description. ``   <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#describe","title":"describe","text":"<p>Show project description and analytics.</p>  <p>Examples</p> <pre><code>kili project describe --project-id &lt;project_id&gt;\n</code></pre>  <p>Usage:</p> <pre><code>kili project describe [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#export","title":"export","text":"<p>Export the Kili labels of a project to a given format.</p> <p>The supported formats are:</p> <ul> <li>YOLO V4, V5, V7 for object detection tasks (bounding box).</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (semantic or bounding box)</li> <li>Pascal VOC for object detection tasks.</li> </ul>  <p>Examples</p> <p><pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format coco \\\n    --output-file /tmp/export.zip\n</code></pre> <pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format yolo_v5 \\\n    --output-file /tmp/export_split.zip \\\n    --layout split\n</code></pre></p>   <p>Unsupported exports</p> <p>Currently, this command does not support the export of videos that have not been cut into separated frames.</p> <p>For such exports, please use the Kili UI.</p>  <p>Usage:</p> <pre><code>kili project export [OPTIONS]\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--output-format</code> choice (<code>raw</code> | <code>kili</code> | <code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>coco</code> | <code>pascal_voc</code>) Format into which the label data will be converted _required   <code>--output-file</code> text File into which the labels are saved. _required   <code>--layout</code> choice (<code>split</code> | <code>merged</code>) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. <code>merged</code>   <code>--single-file</code> boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). <code>False</code>   <code>--with-assets</code> / <code>--without-assets</code> boolean Download assets in the export. <code>True</code>   <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--verbose</code> boolean Show more logs <code>False</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#import","title":"import","text":"<p>Add assets into a project</p> <p>Files can be paths to files or to folders. You can provide several paths separated by spaces.</p> <p>If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns:</p> <ul> <li><code>external_id</code>: external id of the asset.</li> <li><code>content</code>: paths to the asset file or a url hosting the asset.</li> </ul>  <p>Examples</p> <p><pre><code>kili project import \\\n    dir1/dir2/ dir1/dir3/test1.png \\\n    --project-id &lt;project_id&gt;\n</code></pre> <pre><code>kili project import \\\n    dir1/dir3/video.mp4 \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre> <pre><code>kili project import \\\n    --from-csv assets_list.csv \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre></p>   <p>Unsupported imports</p> <p>Currently, this command does not support:</p> <ul> <li>the import of videos from local frames, rich text and time series assets</li> <li>the import of assets with metadata or with a custom external_id</li> </ul> <p>For such imports, please use the <code>append_many_to_dataset</code> method in the Kili SDK.</p>  <p>Usage:</p> <pre><code>kili project import [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--from-csv</code> path path to a csv file with required columns:external_id, content required columns: None   <code>--frames</code> boolean Only for a frame project, import videos as frames. The import time is longer with this option. <code>False</code>   <code>--fps</code> integer Only for a frame project, import videos with a specific frame rate None   <code>--verbose</code> boolean Show more logs <code>False</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#label","title":"label","text":"<p>Import labels or predictions</p> <p>Files can be paths to files or to folders.  You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id.</p>  <p>Examples</p> <p>To import default labels: <pre><code>kili project label \\\n    dir/labels/ dir/ground-truth/image1.json \\\n    --project-id &lt;project_id&gt;\n</code></pre> To import labels as predictions: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> To import labels as predictions in the Yolo v5 format into a target job: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-v5 \\\n    --metadata-file classes.yml \\\n    --target-job IMAGE_DETECTION_JOB \\\n    --input-format yolo_v5\n</code></pre></p>  <p>Usage:</p> <pre><code>kili project label [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--prediction</code> boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface <code>False</code>   <code>--model-name</code> text Name of the model that generated predictions, if labels are sent as predictions None   <code>--verbose</code> boolean Show more logs <code>False</code>   <code>--input-format</code> choice (<code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>kili</code> | <code>raw</code>) Format in which the labels are encoded <code>kili</code>   <code>--metadata-file</code> text File containing format metadata (if relevant to the input format) None   <code>--target-job</code> text Job name in the project where to upload the labels (if relevant to the input format) None   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list","title":"list","text":"<p>List your projects</p>  <p>Examples</p> <pre><code>kili project list --max 10 --stdout-format pretty\n</code></pre>  <p>Usage:</p> <pre><code>kili project list [OPTIONS]\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code>   <code>--max</code> integer Maximum number of project to display. <code>100</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#member","title":"member","text":"<p>Commands to interact with Kili project members</p> <p>Usage:</p> <pre><code>kili project member [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#add","title":"add","text":"<p>Add members to a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p>  <p>Examples</p> <p><pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com jane.doe@test.com\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p>  <p>Usage:</p> <pre><code>kili project member add [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None   <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None   <code>--from-project</code> text project_id of another Kili project None   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list_1","title":"list","text":"<p>List the members of the project</p>  <p>Examples</p> <pre><code>kili project member list &lt;project_id&gt; --stdout-format pretty\n</code></pre>  <p>Usage:</p> <pre><code>kili project member list [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#rm","title":"rm","text":"<p>Remove members from a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p>  <p>Examples</p> <p><pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --all\n</code></pre></p>  <p>Usage:</p> <pre><code>kili project member rm [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None   <code>--all</code> boolean Remove all users from project <code>False</code>   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#update","title":"update","text":"<p>Update member's role of a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p>  <p>Examples</p> <p><pre><code>kili project member update\\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p>  <p>Usage:</p> <pre><code>kili project member update [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p>    Name Type Description Default     <code>--api-key</code> text Your Kili API key. None   <code>--endpoint</code> text Kili API Endpoint. None   <code>--project-id</code> text Id of the project _required   <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None   <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None   <code>--from-project</code> text project_id of another Kili project None   <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"sdk/api_key/","title":"API Key module","text":""},{"location":"sdk/api_key/#queries","title":"Queries","text":"<p>Set of ApiKey queries</p>  Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>class QueriesApiKey:\n    \"\"\"\n    Set of ApiKey queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of API keys that match a set of constraints.\n\n        !!! info\n            You can only query your own API keys\n\n        Args:\n            api_key_id: Identifier of the API key to retrieve.\n            user_id: Identifier of the user.\n            api_key: Value of the API key.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields.\n            first: Maximum number of API keys to return.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the API key is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.api_keys(user_id=user_id)\n            &gt;&gt;&gt; kili.api_keys(api_key=api_key)\n            &gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n        \"\"\"\n\n        saved_args = locals()\n        count_args = {\n            k: v for (k, v) in saved_args.items() if k in [\"user_id\", \"api_key_id\", \"api_key\"]\n        }\n        disable_tqdm = disable_tqdm or as_generator\n\n        payload_query = {\n            \"where\": {\n                \"user\": {\"id\": user_id, \"apiKey\": api_key},\n                \"id\": api_key_id,\n            },\n        }\n\n        api_keys_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_api_keys,\n            count_args,\n            self._query_api_keys,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return api_keys_generator\n        return list(api_keys_generator)\n\n    def _query_api_keys(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_api_keys = gql_api_keys(fragment_builder(fields, ApiKeyType))\n        result = self.auth.client.execute(_gql_api_keys, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Count and return the number of api keys with the given constraints.\n\n        Args:\n            api_key_id: Identifier of the API key to retrieve.\n            user_id: Identifier of the user.\n            api_key: Value of the api key.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n            3\n            &gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n            1\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"user\": {\"id\": user_id, \"apiKey\": api_key},\n                \"id\": api_key_id,\n            },\n        }\n        result = self.auth.client.execute(GQL_API_KEYS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","title":"<code>api_keys(self, api_key_id=None, user_id=None, api_key=None, skip=0, fields=['id', 'name', 'createdAt', 'revoked'], first=None, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of API keys that match a set of constraints.</p>  <p>Info</p> <p>You can only query your own API keys</p>  <p>Parameters:</p>    Name Type Description Default     <code>api_key_id</code> <code>Optional[str]</code> <p>Identifier of the API key to retrieve.</p> <code>None</code>   <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code>   <code>api_key</code> <code>Optional[str]</code> <p>Value of the API key.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['id', 'name', 'createdAt', 'revoked']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of API keys to return.</p> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the API key is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.api_keys(user_id=user_id)\n&gt;&gt;&gt; kili.api_keys(api_key=api_key)\n&gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n</code></pre>  Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>@typechecked\ndef api_keys(\n    self,\n    api_key_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n    first: Optional[int] = None,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of API keys that match a set of constraints.\n\n    !!! info\n        You can only query your own API keys\n\n    Args:\n        api_key_id: Identifier of the API key to retrieve.\n        user_id: Identifier of the user.\n        api_key: Value of the API key.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields.\n        first: Maximum number of API keys to return.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the API key is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.api_keys(user_id=user_id)\n        &gt;&gt;&gt; kili.api_keys(api_key=api_key)\n        &gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n    \"\"\"\n\n    saved_args = locals()\n    count_args = {\n        k: v for (k, v) in saved_args.items() if k in [\"user_id\", \"api_key_id\", \"api_key\"]\n    }\n    disable_tqdm = disable_tqdm or as_generator\n\n    payload_query = {\n        \"where\": {\n            \"user\": {\"id\": user_id, \"apiKey\": api_key},\n            \"id\": api_key_id,\n        },\n    }\n\n    api_keys_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_api_keys,\n        count_args,\n        self._query_api_keys,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return api_keys_generator\n    return list(api_keys_generator)\n</code></pre>"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","title":"<code>count_api_keys(self, api_key_id=None, user_id=None, api_key=None)</code>","text":"<p>Count and return the number of api keys with the given constraints.</p> <p>Parameters:</p>    Name Type Description Default     <code>api_key_id</code> <code>Optional[str]</code> <p>Identifier of the API key to retrieve.</p> <code>None</code>   <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code>   <code>api_key</code> <code>Optional[str]</code> <p>Value of the api key.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n3\n&gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n1\n</code></pre>  Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>@typechecked\ndef count_api_keys(\n    self,\n    api_key_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Count and return the number of api keys with the given constraints.\n\n    Args:\n        api_key_id: Identifier of the API key to retrieve.\n        user_id: Identifier of the user.\n        api_key: Value of the api key.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n        3\n        &gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n        1\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"user\": {\"id\": user_id, \"apiKey\": api_key},\n            \"id\": api_key_id,\n        },\n    }\n    result = self.auth.client.execute(GQL_API_KEYS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/asset/","title":"Asset module","text":""},{"location":"sdk/asset/#queries","title":"Queries","text":"<p>Set of Asset queries</p>  Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>class QueriesAsset:\n    \"\"\"\n    Set of Asset queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,  # pylint: disable=redefined-builtin\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        as_generator: bool = False,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n    ) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n        # pylint: disable=line-too-long\n        \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset to retrieve.\n            asset_id_in: A list of the IDs of the assets to retrieve.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                    See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n            first: Maximum number of assets to return.\n            consensus_mark_gt: Minimum amount of consensus for the asset.\n            consensus_mark_lt: Maximum amount of consensus for the asset.\n            external_id_contains: Returned assets have an external id that belongs to that list, if given.\n            metadata_where: Filters by the values of the metadata of the asset.\n            honeypot_mark_gt: Minimum amount of honeypot for the asset.\n            honeypot_mark_lt : Maximum amount of honeypot for the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose status belongs to that list, if given.\n            label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number.\n            label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Returned assets should have a label whose creation date is greater than this date.\n            label_created_at_lt: Returned assets should have a label whose creation date is lower than this date.\n            label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number\n            label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number\n            skipped: Returned assets should be skipped\n            updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n            updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n            format: If equal to 'pandas', returns a pandas DataFrame\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the assets is returned.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            download_media: Tell is the media have to be downloaded or not.\n            local_media_dir: Directory where the media are downloaded if `download_media` is True.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Example:\n            ```\n            # returns the assets list of the project\n            &gt;&gt;&gt; kili.assets(project_id)\n            &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n            # returns a generator of the project assets\n            &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n            ```\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n        if format == \"pandas\" and as_generator:\n            raise ValueError(\n                'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n            )\n\n        saved_args = locals()\n        count_args = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            not in [\n                \"skip\",\n                \"first\",\n                \"disable_tqdm\",\n                \"format\",\n                \"fields\",\n                \"self\",\n                \"as_generator\",\n                \"message\",\n                \"download_media\",\n                \"local_media_dir\",\n            ]\n        }\n\n        # using tqdm with a generator is messy, so it is always disabled\n        disable_tqdm = disable_tqdm or as_generator\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        payload_query = {\n            \"where\": {\n                \"id\": asset_id,\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"externalIdStrictlyIn\": external_id_contains,\n                \"statusIn\": status_in,\n                \"consensusMarkGte\": consensus_mark_gt,\n                \"consensusMarkLte\": consensus_mark_lt,\n                \"honeypotMarkGte\": honeypot_mark_gt,\n                \"honeypotMarkLte\": honeypot_mark_lt,\n                \"idIn\": asset_id_in,\n                \"metadata\": metadata_where,\n                \"label\": {\n                    \"typeIn\": label_type_in,\n                    \"authorIn\": label_author_in,\n                    \"consensusMarkGte\": label_consensus_mark_gt,\n                    \"consensusMarkLte\": label_consensus_mark_lt,\n                    \"createdAt\": label_created_at,\n                    \"createdAtGte\": label_created_at_gt,\n                    \"createdAtLte\": label_created_at_lt,\n                    \"honeypotMarkGte\": label_honeypot_mark_gt,\n                    \"honeypotMarkLte\": label_honeypot_mark_lt,\n                    \"search\": label_category_search,\n                },\n                \"skipped\": skipped,\n                \"updatedAtGte\": updated_at_gte,\n                \"updatedAtLte\": updated_at_lte,\n            },\n        }\n\n        post_call_process = get_post_assets_call_process(\n            download_media, local_media_dir, project_id\n        )\n\n        asset_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_assets,\n            count_args,\n            self._query_assets,\n            payload_query,\n            fields,\n            disable_tqdm,\n            post_call_process,\n        )\n\n        if format == \"pandas\":\n            return pd.DataFrame(list(asset_generator))\n        if as_generator:\n            return asset_generator\n        return list(asset_generator)\n\n    def _query_assets(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_assets = gql_assets(fragment_builder(fields, AssetType))\n        result = self.auth.client.execute(_gql_assets, payload)\n        assets = format_result(\"data\", result, _object=List[Asset])\n        return assets\n\n    @typechecked\n    def count_assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        external_id_contains: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        status_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        skipped: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"Count and return the number of assets with the given constraints.\n\n        Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n        Args:\n            project_id: Identifier of the project\n            asset_id: The unique id of the asset to retrieve.\n            asset_id_in: A list of the ids of the assets to retrieve.\n            external_id_contains: Returned assets should have an external id\n                that belongs to that list, if given.\n            metadata_where: Filters by the values of the metadata of the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            consensus_mark_gt: Minimum amount of consensus for the asset.\n            consensus_mark_lt: Maximum amount of consensus for the asset.\n            honeypot_mark_gt: Minimum amount of honeypot for the asset.\n            honeypot_mark_lt: Maximum amount of consensus for the asset.\n            label_type_in: Returned assets should have a label\n                whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label\n                whose status belongs to that list, if given.\n            label_consensus_mark_gt: Returned assets should have a label\n                whose consensus is greater than this number.\n            label_consensus_mark_lt: Returned assets should have a label\n                whose consensus is lower than this number.\n            label_created_at: Returned assets should have a label\n                whose creation date is equal to this date.\n            label_created_at_gt: Returned assets should have a label\n                whose creation date is greater than this date.\n            label_created_at_lt: Returned assets should have a label\n                whose creation date is lower than this date.\n            label_honeypot_mark_gt: Returned assets should have a label\n                whose honeypot is greater than this number.\n            label_honeypot_mark_lt: Returned assets should have a label\n                whose honeypot is lower than this number.\n            skipped: Returned assets should be skipped\n            updated_at_gte: Returned assets should have a label\n                whose update date is greated or equal to this date.\n            updated_at_lte: Returned assets should have a label\n                whose update date is lower or equal to this date.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n            250\n            &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n            1\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n        \"\"\"\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        variables = {\n            \"where\": {\n                \"id\": asset_id,\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"externalIdStrictlyIn\": external_id_contains,\n                \"statusIn\": status_in,\n                \"consensusMarkGte\": consensus_mark_gt,\n                \"consensusMarkLte\": consensus_mark_lt,\n                \"honeypotMarkGte\": honeypot_mark_gt,\n                \"honeypotMarkLte\": honeypot_mark_lt,\n                \"idIn\": asset_id_in,\n                \"metadata\": metadata_where,\n                \"label\": {\n                    \"typeIn\": label_type_in,\n                    \"authorIn\": label_author_in,\n                    \"consensusMarkGte\": label_consensus_mark_gt,\n                    \"consensusMarkLte\": label_consensus_mark_lt,\n                    \"createdAt\": label_created_at,\n                    \"createdAtGte\": label_created_at_gt,\n                    \"createdAtLte\": label_created_at_lt,\n                    \"honeypotMarkGte\": label_honeypot_mark_gt,\n                    \"honeypotMarkLte\": label_honeypot_mark_lt,\n                    \"search\": label_category_search,\n                },\n                \"skipped\": skipped,\n                \"updatedAtGte\": updated_at_gte,\n                \"updatedAtLte\": updated_at_lte,\n            }\n        }\n        result = self.auth.client.execute(GQL_ASSETS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets","title":"<code>assets(self, project_id, asset_id=None, skip=0, fields=['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'], asset_id_in=None, consensus_mark_gt=None, consensus_mark_lt=None, disable_tqdm=False, external_id_contains=None, first=None, format=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, label_type_in=None, metadata_where=None, skipped=None, status_in=None, updated_at_gte=None, updated_at_lte=None, as_generator=False, label_category_search=None, download_media=False, local_media_dir=None)</code>","text":"<p>Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset to retrieve.</p> <code>None</code>   <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the IDs of the assets to retrieve.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets.     See the documentation for all possible fields.</p> <code>['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of assets to return.</p> <code>None</code>   <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code>   <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code>   <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Returned assets have an external id that belongs to that list, if given.</p> <code>None</code>   <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code>   <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code>   <code>honeypot_mark_lt</code>  <p>Maximum amount of honeypot for the asset.</p> <code>None</code>   <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code></p> <code>None</code>   <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code>   <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose status belongs to that list, if given.</p> <code>None</code>   <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater than this number.</p> <code>None</code>   <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower than this number.</p> <code>None</code>   <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code>   <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater than this date.</p> <code>None</code>   <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower than this date.</p> <code>None</code>   <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater than this number</p> <code>None</code>   <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower than this number</p> <code>None</code>   <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped</p> <code>None</code>   <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greated or equal to this date.</p> <code>None</code>   <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code>   <code>format</code> <code>Optional[str]</code> <p>If equal to 'pandas', returns a pandas DataFrame</p> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the assets is returned.</p> <code>False</code>   <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code>   <code>download_media</code> <code>bool</code> <p>Tell is the media have to be downloaded or not.</p> <code>False</code>   <code>local_media_dir</code> <code>Optional[str]</code> <p>Directory where the media are downloaded if <code>download_media</code> is True.</p> <code>None</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>Union[Iterable[Dict], pandas.core.frame.DataFrame]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code># returns the assets list of the project\n&gt;&gt;&gt; kili.assets(project_id)\n&gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n# returns a generator of the project assets\n&gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n</code></pre>  <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul>   <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\nlabel_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\nlabel_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre>   Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"content\",\n        \"createdAt\",\n        \"externalId\",\n        \"id\",\n        \"isHoneypot\",\n        \"jsonMetadata\",\n        \"labels.author.id\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.id\",\n        \"labels.jsonResponse\",\n        \"skipped\",\n        \"status\",\n    ],\n    asset_id_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    disable_tqdm: bool = False,\n    external_id_contains: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    format: Optional[str] = None,  # pylint: disable=redefined-builtin\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    skipped: Optional[bool] = None,\n    status_in: Optional[List[str]] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    as_generator: bool = False,\n    label_category_search: Optional[str] = None,\n    download_media: bool = False,\n    local_media_dir: Optional[str] = None,\n) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n    # pylint: disable=line-too-long\n    \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset to retrieve.\n        asset_id_in: A list of the IDs of the assets to retrieve.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n        first: Maximum number of assets to return.\n        consensus_mark_gt: Minimum amount of consensus for the asset.\n        consensus_mark_lt: Maximum amount of consensus for the asset.\n        external_id_contains: Returned assets have an external id that belongs to that list, if given.\n        metadata_where: Filters by the values of the metadata of the asset.\n        honeypot_mark_gt: Minimum amount of honeypot for the asset.\n        honeypot_mark_lt : Maximum amount of honeypot for the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose status belongs to that list, if given.\n        label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number.\n        label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Returned assets should have a label whose creation date is greater than this date.\n        label_created_at_lt: Returned assets should have a label whose creation date is lower than this date.\n        label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number\n        label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number\n        skipped: Returned assets should be skipped\n        updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n        updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n        format: If equal to 'pandas', returns a pandas DataFrame\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the assets is returned.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        download_media: Tell is the media have to be downloaded or not.\n        local_media_dir: Directory where the media are downloaded if `download_media` is True.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Example:\n        ```\n        # returns the assets list of the project\n        &gt;&gt;&gt; kili.assets(project_id)\n        &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n        # returns a generator of the project assets\n        &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n        ```\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n    if format == \"pandas\" and as_generator:\n        raise ValueError(\n            'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n        )\n\n    saved_args = locals()\n    count_args = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        not in [\n            \"skip\",\n            \"first\",\n            \"disable_tqdm\",\n            \"format\",\n            \"fields\",\n            \"self\",\n            \"as_generator\",\n            \"message\",\n            \"download_media\",\n            \"local_media_dir\",\n        ]\n    }\n\n    # using tqdm with a generator is messy, so it is always disabled\n    disable_tqdm = disable_tqdm or as_generator\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    payload_query = {\n        \"where\": {\n            \"id\": asset_id,\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"externalIdStrictlyIn\": external_id_contains,\n            \"statusIn\": status_in,\n            \"consensusMarkGte\": consensus_mark_gt,\n            \"consensusMarkLte\": consensus_mark_lt,\n            \"honeypotMarkGte\": honeypot_mark_gt,\n            \"honeypotMarkLte\": honeypot_mark_lt,\n            \"idIn\": asset_id_in,\n            \"metadata\": metadata_where,\n            \"label\": {\n                \"typeIn\": label_type_in,\n                \"authorIn\": label_author_in,\n                \"consensusMarkGte\": label_consensus_mark_gt,\n                \"consensusMarkLte\": label_consensus_mark_lt,\n                \"createdAt\": label_created_at,\n                \"createdAtGte\": label_created_at_gt,\n                \"createdAtLte\": label_created_at_lt,\n                \"honeypotMarkGte\": label_honeypot_mark_gt,\n                \"honeypotMarkLte\": label_honeypot_mark_lt,\n                \"search\": label_category_search,\n            },\n            \"skipped\": skipped,\n            \"updatedAtGte\": updated_at_gte,\n            \"updatedAtLte\": updated_at_lte,\n        },\n    }\n\n    post_call_process = get_post_assets_call_process(\n        download_media, local_media_dir, project_id\n    )\n\n    asset_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_assets,\n        count_args,\n        self._query_assets,\n        payload_query,\n        fields,\n        disable_tqdm,\n        post_call_process,\n    )\n\n    if format == \"pandas\":\n        return pd.DataFrame(list(asset_generator))\n    if as_generator:\n        return asset_generator\n    return list(asset_generator)\n</code></pre>"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","title":"<code>count_assets(self, project_id, asset_id=None, asset_id_in=None, external_id_contains=None, metadata_where=None, status_in=None, consensus_mark_gt=None, consensus_mark_lt=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_type_in=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, skipped=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None)</code>","text":"<p>Count and return the number of assets with the given constraints.</p> <p>Parameters beginning with 'label_' apply to labels, others apply to assets.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>asset_id</code> <code>Optional[str]</code> <p>The unique id of the asset to retrieve.</p> <code>None</code>   <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the ids of the assets to retrieve.</p> <code>None</code>   <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Returned assets should have an external id that belongs to that list, if given.</p> <code>None</code>   <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code>   <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code>   <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code>   <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code>   <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code>   <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code>   <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code>   <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose status belongs to that list, if given.</p> <code>None</code>   <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater than this number.</p> <code>None</code>   <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower than this number.</p> <code>None</code>   <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code>   <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater than this date.</p> <code>None</code>   <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower than this date.</p> <code>None</code>   <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater than this number.</p> <code>None</code>   <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower than this number.</p> <code>None</code>   <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped</p> <code>None</code>   <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greated or equal to this date.</p> <code>None</code>   <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_assets(project_id=project_id)\n250\n&gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n1\n</code></pre>  <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul>   Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef count_assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    external_id_contains: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    status_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    skipped: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n) -&gt; int:\n    \"\"\"Count and return the number of assets with the given constraints.\n\n    Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n    Args:\n        project_id: Identifier of the project\n        asset_id: The unique id of the asset to retrieve.\n        asset_id_in: A list of the ids of the assets to retrieve.\n        external_id_contains: Returned assets should have an external id\n            that belongs to that list, if given.\n        metadata_where: Filters by the values of the metadata of the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        consensus_mark_gt: Minimum amount of consensus for the asset.\n        consensus_mark_lt: Maximum amount of consensus for the asset.\n        honeypot_mark_gt: Minimum amount of honeypot for the asset.\n        honeypot_mark_lt: Maximum amount of consensus for the asset.\n        label_type_in: Returned assets should have a label\n            whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label\n            whose status belongs to that list, if given.\n        label_consensus_mark_gt: Returned assets should have a label\n            whose consensus is greater than this number.\n        label_consensus_mark_lt: Returned assets should have a label\n            whose consensus is lower than this number.\n        label_created_at: Returned assets should have a label\n            whose creation date is equal to this date.\n        label_created_at_gt: Returned assets should have a label\n            whose creation date is greater than this date.\n        label_created_at_lt: Returned assets should have a label\n            whose creation date is lower than this date.\n        label_honeypot_mark_gt: Returned assets should have a label\n            whose honeypot is greater than this number.\n        label_honeypot_mark_lt: Returned assets should have a label\n            whose honeypot is lower than this number.\n        skipped: Returned assets should be skipped\n        updated_at_gte: Returned assets should have a label\n            whose update date is greated or equal to this date.\n        updated_at_lte: Returned assets should have a label\n            whose update date is lower or equal to this date.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n        250\n        &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n        1\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n    \"\"\"\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    variables = {\n        \"where\": {\n            \"id\": asset_id,\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"externalIdStrictlyIn\": external_id_contains,\n            \"statusIn\": status_in,\n            \"consensusMarkGte\": consensus_mark_gt,\n            \"consensusMarkLte\": consensus_mark_lt,\n            \"honeypotMarkGte\": honeypot_mark_gt,\n            \"honeypotMarkLte\": honeypot_mark_lt,\n            \"idIn\": asset_id_in,\n            \"metadata\": metadata_where,\n            \"label\": {\n                \"typeIn\": label_type_in,\n                \"authorIn\": label_author_in,\n                \"consensusMarkGte\": label_consensus_mark_gt,\n                \"consensusMarkLte\": label_consensus_mark_lt,\n                \"createdAt\": label_created_at,\n                \"createdAtGte\": label_created_at_gt,\n                \"createdAtLte\": label_created_at_lt,\n                \"honeypotMarkGte\": label_honeypot_mark_gt,\n                \"honeypotMarkLte\": label_honeypot_mark_lt,\n                \"search\": label_category_search,\n            },\n            \"skipped\": skipped,\n            \"updatedAtGte\": updated_at_gte,\n            \"updatedAtLte\": updated_at_lte,\n        }\n    }\n    result = self.auth.client.execute(GQL_ASSETS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/asset/#mutations","title":"Mutations","text":"<p>Set of Asset mutations</p>  Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>class MutationsAsset:\n    \"\"\"\n    Set of Asset mutations\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth: KiliAuth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_many_to_dataset(\n        self,\n        project_id: str,\n        content_array: Optional[List[str]] = None,\n        external_id_array: Optional[List[str]] = None,\n        id_array: Optional[List[str]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        status_array: Optional[List[str]] = None,\n        json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n        json_metadata_array: Optional[List[dict]] = None,\n        disable_tqdm: bool = False,\n    ) -&gt; Dict[str, str]:\n        # pylint: disable=line-too-long\n        \"\"\"Append assets to a project.\n\n        Args:\n            project_id: Identifier of the project\n            content_array: List of elements added to the assets of the project\n                Must not be None except if you provide json_content_array.\n\n                - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n                - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                    images/pdf on your computer.\n                - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n                existing video files on your computer. If you want to import video from frames, look at the json_content\n                section below.\n                - For an `VIDEO_LEGACY` project, the content can be only be URLs\n            external_id_array: List of external ids given to identify the assets.\n                If None, random identifiers are created.\n            is_honeypot_array:  Whether to use the asset for honeypot\n            status_array: By default, all imported assets are set to `TODO`. Other options:\n                `ONGOING`, `LABELED`, `REVIEWED`.\n            json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n                - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                    list of URLs to images or a list of paths to images.\n                - For `TEXT` projects, each element is a json_content dict,\n                    formatted according to documentation [on how to import\n                rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb)\n            json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n                - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                    Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n                - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                    Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n            disable_tqdm: If `True`, the progress bar will be disabled\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_many_to_dataset(\n                    project_id=project_id,\n                    content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n        !!! example \"Recipe\"\n            - For more detailed examples on how to import assets,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n            - For more detailed examples on how to import text assets,\n                see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb).\n        \"\"\"\n\n        if content_array is None and json_content_array is None:\n            raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n        nb_data = (\n            len(content_array)\n            if content_array is not None\n            else len(json_content_array)  # type:ignore\n        )\n        field_mapping = {\n            \"content\": content_array,\n            \"json_content\": json_content_array,\n            \"external_id\": external_id_array,\n            \"id\": id_array,\n            \"status\": status_array,\n            \"json_metadata\": json_metadata_array,\n            \"is_honeypot\": is_honeypot_array,\n        }\n        assets = [{}] * nb_data\n        for key, value in field_mapping.items():\n            if value is not None:\n                assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n        result = import_assets(\n            self.auth, project_id=project_id, assets=assets, disable_tqdm=disable_tqdm\n        )\n        return result\n\n    @typechecked\n    # pylint: disable=unused-argument\n    def update_properties_in_assets(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        priorities: Optional[List[int]] = None,\n        json_metadatas: Optional[List[Union[dict, str]]] = None,\n        consensus_marks: Optional[List[float]] = None,\n        honeypot_marks: Optional[List[float]] = None,\n        to_be_labeled_by_array: Optional[List[List[str]]] = None,\n        contents: Optional[List[str]] = None,\n        json_contents: Optional[List[str]] = None,\n        status_array: Optional[List[str]] = None,\n        is_used_for_consensus_array: Optional[List[bool]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n        \"\"\"Update the properties of one or more assets.\n\n        Args:\n            asset_ids: The internal asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            priorities: You can change the priority of the assets.\n                By default, all assets have a priority of 0.\n            json_metadatas: The metadata given to an asset should be stored\n                in a json like dict with keys `imageUrl`, `text`, `url`:\n                `json_metadata = {'imageUrl': '','text': '','url': ''}`\n            consensus_marks: Should be between 0 and 1.\n            honeypot_marks: Should be between 0 and 1.\n            to_be_labeled_by_array: If given, each element of the list should contain the emails of\n                the labelers authorized to label the asset.\n            contents: - For a NLP project, the content can be directly in text format.\n                - For an Image / Video / Pdf project, the content must be hosted on a web server,\n                and you point Kili to your data by giving the URLs.\n            json_contents: - For a NLP project, the `json_content`\n                is a text formatted using RichText.\n                - For a Video project, the`json_content` is a json containg urls pointing\n                    to each frame of the video.\n            status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n                `TO_REVIEW`, `REVIEWED`.\n            is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n            is_honeypot_array: Whether to use the asset for honeypot.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_assets(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    consensus_marks=[1, 0.7],\n                    contents=[None, 'https://to/second/asset.png'],\n                    honeypot_marks=[0.8, 0.5],\n                    is_honeypot_array=[True, True],\n                    is_used_for_consensus_array=[True, False],\n                    priorities=[None, 2],\n                    status_array=['LABELED', 'REVIEWED'],\n                    to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n                )\n        \"\"\"\n        if asset_ids is not None and external_ids is not None:\n            warnings.warn(\n                \"The use of `external_ids` argument has changed. It is now used to identify which\"\n                \" properties of which assets to update. Please use\"\n                \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\",\n                DeprecationWarning,\n            )\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        saved_args = locals()\n        parameters = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            in [\n                \"asset_ids\",\n                \"priorities\",\n                \"json_metadatas\",\n                \"consensus_marks\",\n                \"honeypot_marks\",\n                \"to_be_labeled_by_array\",\n                \"contents\",\n                \"json_contents\",\n                \"status_array\",\n                \"is_used_for_consensus_array\",\n                \"is_honeypot_array\",\n            ]\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"priority\": batch[\"priorities\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"consensusMark\": batch[\"consensus_marks\"],\n                \"honeypotMark\": batch[\"honeypot_marks\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n                \"content\": batch[\"contents\"],\n                \"jsonContent\": batch[\"json_contents\"],\n                \"status\": batch[\"status_array\"],\n                \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n                \"isHoneypot\": batch[\"is_honeypot_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def change_asset_external_ids(\n        self,\n        new_external_ids: List[str],\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n        \"\"\"Update the external IDs of one or more assets.\n\n        Args:\n            new_external_ids: The new external IDs of the assets.\n            asset_ids: The asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.change_asset_external_ids(\n                    new_external_ids=[\"asset1\", \"asset2\"],\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        parameters = {\n            \"asset_ids\": asset_ids,\n            \"new_external_ids\": new_external_ids,\n            \"json_metadatas\": None,\n            \"to_be_labeled_by_array\": None,\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"externalId\": batch[\"new_external_ids\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def delete_many_from_dataset(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Asset:\n        \"\"\"Delete assets from a project.\n\n        Args:\n            asset_ids: The list of asset internal IDs to delete.\n            external_ids: The list of asset external IDs to delete.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        results = _mutate_from_paginated_call(\n            self, properties_to_batch, generate_variables, GQL_DELETE_MANY_FROM_DATASET\n        )\n        return format_result(\"data\", results[0], Asset)\n\n    @typechecked\n    def add_to_review(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Add assets to review.\n\n        !!! warning\n            Assets without any label will be ignored.\n\n        Args:\n            asset_ids: The asset internal IDs to add to review.\n            external_ids: The asset external IDs to add to review.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to review.\n            `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.add_to_review(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                        ],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n        )\n        result = format_result(\"data\", results[0])\n        if isinstance(result, dict) and \"id\" in result:\n            assets_in_review = QueriesAsset(self.auth).assets(\n                project_id=result[\"id\"],\n                asset_id_in=asset_ids,\n                fields=[\"id\"],\n                disable_tqdm=True,\n                status_in=[\"TO_REVIEW\"],\n            )\n            result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n            return result\n        return result\n\n    @typechecked\n    def send_back_to_queue(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Send assets back to queue.\n\n        Args:\n            asset_ids: List of internal IDs of assets to send back to queue.\n            external_ids: List of external IDs of assets to send back to queue.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.send_back_to_queue(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                        ],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        results = _mutate_from_paginated_call(\n            self, properties_to_batch, generate_variables, GQL_SEND_BACK_ASSETS_TO_QUEUE\n        )\n        result = format_result(\"data\", results[0])\n        assets_in_queue = QueriesAsset(self.auth).assets(\n            project_id=result[\"id\"],\n            asset_id_in=asset_ids,\n            fields=[\"id\"],\n            disable_tqdm=True,\n            status_in=[\"ONGOING\"],\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n        return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.add_to_review","title":"<code>add_to_review(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Add assets to review.</p>  <p>Warning</p> <p>Assets without any label will be ignored.</p>  <p>Parameters:</p>    Name Type Description Default     <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset internal IDs to add to review.</p> <code>None</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>The asset external IDs to add to review.</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to review. <code>None</code> if no assets have changed status (already had <code>TO_REVIEW</code> status for example). An error message if mutation failed.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.add_to_review(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n            ],\n    )\n</code></pre>  Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef add_to_review(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Add assets to review.\n\n    !!! warning\n        Assets without any label will be ignored.\n\n    Args:\n        asset_ids: The asset internal IDs to add to review.\n        external_ids: The asset external IDs to add to review.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to review.\n        `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.add_to_review(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n    )\n    result = format_result(\"data\", results[0])\n    if isinstance(result, dict) and \"id\" in result:\n        assets_in_review = QueriesAsset(self.auth).assets(\n            project_id=result[\"id\"],\n            asset_id_in=asset_ids,\n            fields=[\"id\"],\n            disable_tqdm=True,\n            status_in=[\"TO_REVIEW\"],\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n        return result\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","title":"<code>append_many_to_dataset(self, project_id, content_array=None, external_id_array=None, id_array=None, is_honeypot_array=None, status_array=None, json_content_array=None, json_metadata_array=None, disable_tqdm=False)</code>","text":"<p>Append assets to a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>content_array</code> <code>Optional[List[str]]</code> <p>List of elements added to the assets of the project Must not be None except if you provide json_content_array.</p> <ul> <li>For a <code>TEXT</code> project, the content can be either raw text, or URLs to TEXT assets.</li> <li>For an <code>IMAGE</code> / <code>PDF</code> project, the content can be either URLs or paths to existing     images/pdf on your computer.</li> <li>For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below.</li> <li>For an <code>VIDEO_LEGACY</code> project, the content can be only be URLs</li> </ul> <code>None</code>   <code>external_id_array</code> <code>Optional[List[str]]</code> <p>List of external ids given to identify the assets. If None, random identifiers are created.</p> <code>None</code>   <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot</p> <code>None</code>   <code>status_array</code> <code>Optional[List[str]]</code> <p>By default, all imported assets are set to <code>TODO</code>. Other options: <code>ONGOING</code>, <code>LABELED</code>, <code>REVIEWED</code>.</p> <code>None</code>   <code>json_content_array</code> <code>Optional[List[List[Union[dict, str]]]]</code> <p>Useful for <code>VIDEO</code> or <code>TEXT</code> projects only.</p> <ul> <li>For <code>VIDEO</code> projects, each element is a sequence of frames, i.e. a     list of URLs to images or a list of paths to images.</li> <li>For <code>TEXT</code> projects, each element is a json_content dict,     formatted according to documentation on how to import rich-text assets</li> </ul> <code>None</code>   <code>json_metadata_array</code> <code>Optional[List[dict]]</code> <p>The metadata given to each asset should be stored in a json like dict with keys.</p> <ul> <li>Add metadata visible on the asset with the following keys: <code>imageUrl</code>, <code>text</code>, <code>url</code>.     Example for one asset: <code>json_metadata_array = [{'imageUrl': '','text': '','url': ''}]</code>.</li> <li>For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).     Example for one asset: <code>json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]</code>.</li> </ul> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Dict[str, str]</code> <p>A result object which indicates if the mutation was successful, or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_many_to_dataset(\n        project_id=project_id,\n        content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n</code></pre>  <p>Recipe</p> <ul> <li>For more detailed examples on how to import assets,     see the recipe.</li> <li>For more detailed examples on how to import text assets,     see the recipe.</li> </ul>   Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef append_many_to_dataset(\n    self,\n    project_id: str,\n    content_array: Optional[List[str]] = None,\n    external_id_array: Optional[List[str]] = None,\n    id_array: Optional[List[str]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    status_array: Optional[List[str]] = None,\n    json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n    json_metadata_array: Optional[List[dict]] = None,\n    disable_tqdm: bool = False,\n) -&gt; Dict[str, str]:\n    # pylint: disable=line-too-long\n    \"\"\"Append assets to a project.\n\n    Args:\n        project_id: Identifier of the project\n        content_array: List of elements added to the assets of the project\n            Must not be None except if you provide json_content_array.\n\n            - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n            - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                images/pdf on your computer.\n            - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n            existing video files on your computer. If you want to import video from frames, look at the json_content\n            section below.\n            - For an `VIDEO_LEGACY` project, the content can be only be URLs\n        external_id_array: List of external ids given to identify the assets.\n            If None, random identifiers are created.\n        is_honeypot_array:  Whether to use the asset for honeypot\n        status_array: By default, all imported assets are set to `TODO`. Other options:\n            `ONGOING`, `LABELED`, `REVIEWED`.\n        json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n            - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                list of URLs to images or a list of paths to images.\n            - For `TEXT` projects, each element is a json_content dict,\n                formatted according to documentation [on how to import\n            rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb)\n        json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n            - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n            - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n        disable_tqdm: If `True`, the progress bar will be disabled\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_many_to_dataset(\n                project_id=project_id,\n                content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n    !!! example \"Recipe\"\n        - For more detailed examples on how to import assets,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n        - For more detailed examples on how to import text assets,\n            see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb).\n    \"\"\"\n\n    if content_array is None and json_content_array is None:\n        raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n    nb_data = (\n        len(content_array)\n        if content_array is not None\n        else len(json_content_array)  # type:ignore\n    )\n    field_mapping = {\n        \"content\": content_array,\n        \"json_content\": json_content_array,\n        \"external_id\": external_id_array,\n        \"id\": id_array,\n        \"status\": status_array,\n        \"json_metadata\": json_metadata_array,\n        \"is_honeypot\": is_honeypot_array,\n    }\n    assets = [{}] * nb_data\n    for key, value in field_mapping.items():\n        if value is not None:\n            assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n    result = import_assets(\n        self.auth, project_id=project_id, assets=assets, disable_tqdm=disable_tqdm\n    )\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.change_asset_external_ids","title":"<code>change_asset_external_ids(self, new_external_ids, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Update the external IDs of one or more assets.</p> <p>Parameters:</p>    Name Type Description Default     <code>new_external_ids</code> <code>List[str]</code> <p>The new external IDs of the assets.</p> required   <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify.</p> <code>None</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.change_asset_external_ids(\n        new_external_ids=[\"asset1\", \"asset2\"],\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n    )\n</code></pre>  Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef change_asset_external_ids(\n    self,\n    new_external_ids: List[str],\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n    \"\"\"Update the external IDs of one or more assets.\n\n    Args:\n        new_external_ids: The new external IDs of the assets.\n        asset_ids: The asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.change_asset_external_ids(\n                new_external_ids=[\"asset1\", \"asset2\"],\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    parameters = {\n        \"asset_ids\": asset_ids,\n        \"new_external_ids\": new_external_ids,\n        \"json_metadatas\": None,\n        \"to_be_labeled_by_array\": None,\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"externalId\": batch[\"new_external_ids\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","title":"<code>delete_many_from_dataset(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Delete assets from a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The list of asset internal IDs to delete.</p> <code>None</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>The list of asset external IDs to delete.</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Asset</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef delete_many_from_dataset(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Asset:\n    \"\"\"Delete assets from a project.\n\n    Args:\n        asset_ids: The list of asset internal IDs to delete.\n        external_ids: The list of asset external IDs to delete.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    results = _mutate_from_paginated_call(\n        self, properties_to_batch, generate_variables, GQL_DELETE_MANY_FROM_DATASET\n    )\n    return format_result(\"data\", results[0], Asset)\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.send_back_to_queue","title":"<code>send_back_to_queue(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Send assets back to queue.</p> <p>Parameters:</p>    Name Type Description Default     <code>asset_ids</code> <code>Optional[List[str]]</code> <p>List of internal IDs of assets to send back to queue.</p> <code>None</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>List of external IDs of assets to send back to queue.</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Dict[str, Any]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to queue. An error message if mutation failed.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.send_back_to_queue(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n            ],\n    )\n</code></pre>  Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef send_back_to_queue(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Send assets back to queue.\n\n    Args:\n        asset_ids: List of internal IDs of assets to send back to queue.\n        external_ids: List of external IDs of assets to send back to queue.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.send_back_to_queue(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    results = _mutate_from_paginated_call(\n        self, properties_to_batch, generate_variables, GQL_SEND_BACK_ASSETS_TO_QUEUE\n    )\n    result = format_result(\"data\", results[0])\n    assets_in_queue = QueriesAsset(self.auth).assets(\n        project_id=result[\"id\"],\n        asset_id_in=asset_ids,\n        fields=[\"id\"],\n        disable_tqdm=True,\n        status_in=[\"ONGOING\"],\n    )\n    result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","title":"<code>update_properties_in_assets(self, asset_ids=None, external_ids=None, priorities=None, json_metadatas=None, consensus_marks=None, honeypot_marks=None, to_be_labeled_by_array=None, contents=None, json_contents=None, status_array=None, is_used_for_consensus_array=None, is_honeypot_array=None, project_id=None)</code>","text":"<p>Update the properties of one or more assets.</p> <p>Parameters:</p>    Name Type Description Default     <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The internal asset IDs to modify.</p> <code>None</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code>   <code>priorities</code> <code>Optional[List[int]]</code> <p>You can change the priority of the assets. By default, all assets have a priority of 0.</p> <code>None</code>   <code>json_metadatas</code> <code>Optional[List[Union[dict, str]]]</code> <p>The metadata given to an asset should be stored in a json like dict with keys <code>imageUrl</code>, <code>text</code>, <code>url</code>: <code>json_metadata = {'imageUrl': '','text': '','url': ''}</code></p> <code>None</code>   <code>consensus_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code>   <code>honeypot_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code>   <code>to_be_labeled_by_array</code> <code>Optional[List[List[str]]]</code> <p>If given, each element of the list should contain the emails of the labelers authorized to label the asset.</p> <code>None</code>   <code>contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the content can be directly in text format.</li> <li>For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs.</li> </ul> <code>None</code>   <code>json_contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the <code>json_content</code> is a text formatted using RichText.</li> <li>For a Video project, the<code>json_content</code> is a json containg urls pointing     to each frame of the video.</li> </ul> <code>None</code>   <code>status_array</code> <code>Optional[List[str]]</code> <p>Each element should be in <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code>, <code>REVIEWED</code>.</p> <code>None</code>   <code>is_used_for_consensus_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset to compute consensus kpis or not.</p> <code>None</code>   <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot.</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_assets(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        consensus_marks=[1, 0.7],\n        contents=[None, 'https://to/second/asset.png'],\n        honeypot_marks=[0.8, 0.5],\n        is_honeypot_array=[True, True],\n        is_used_for_consensus_array=[True, False],\n        priorities=[None, 2],\n        status_array=['LABELED', 'REVIEWED'],\n        to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n    )\n</code></pre>  Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\n# pylint: disable=unused-argument\ndef update_properties_in_assets(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    priorities: Optional[List[int]] = None,\n    json_metadatas: Optional[List[Union[dict, str]]] = None,\n    consensus_marks: Optional[List[float]] = None,\n    honeypot_marks: Optional[List[float]] = None,\n    to_be_labeled_by_array: Optional[List[List[str]]] = None,\n    contents: Optional[List[str]] = None,\n    json_contents: Optional[List[str]] = None,\n    status_array: Optional[List[str]] = None,\n    is_used_for_consensus_array: Optional[List[bool]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n    \"\"\"Update the properties of one or more assets.\n\n    Args:\n        asset_ids: The internal asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        priorities: You can change the priority of the assets.\n            By default, all assets have a priority of 0.\n        json_metadatas: The metadata given to an asset should be stored\n            in a json like dict with keys `imageUrl`, `text`, `url`:\n            `json_metadata = {'imageUrl': '','text': '','url': ''}`\n        consensus_marks: Should be between 0 and 1.\n        honeypot_marks: Should be between 0 and 1.\n        to_be_labeled_by_array: If given, each element of the list should contain the emails of\n            the labelers authorized to label the asset.\n        contents: - For a NLP project, the content can be directly in text format.\n            - For an Image / Video / Pdf project, the content must be hosted on a web server,\n            and you point Kili to your data by giving the URLs.\n        json_contents: - For a NLP project, the `json_content`\n            is a text formatted using RichText.\n            - For a Video project, the`json_content` is a json containg urls pointing\n                to each frame of the video.\n        status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n            `TO_REVIEW`, `REVIEWED`.\n        is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n        is_honeypot_array: Whether to use the asset for honeypot.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_assets(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                consensus_marks=[1, 0.7],\n                contents=[None, 'https://to/second/asset.png'],\n                honeypot_marks=[0.8, 0.5],\n                is_honeypot_array=[True, True],\n                is_used_for_consensus_array=[True, False],\n                priorities=[None, 2],\n                status_array=['LABELED', 'REVIEWED'],\n                to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n            )\n    \"\"\"\n    if asset_ids is not None and external_ids is not None:\n        warnings.warn(\n            \"The use of `external_ids` argument has changed. It is now used to identify which\"\n            \" properties of which assets to update. Please use\"\n            \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\",\n            DeprecationWarning,\n        )\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    saved_args = locals()\n    parameters = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        in [\n            \"asset_ids\",\n            \"priorities\",\n            \"json_metadatas\",\n            \"consensus_marks\",\n            \"honeypot_marks\",\n            \"to_be_labeled_by_array\",\n            \"contents\",\n            \"json_contents\",\n            \"status_array\",\n            \"is_used_for_consensus_array\",\n            \"is_honeypot_array\",\n        ]\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"priority\": batch[\"priorities\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"consensusMark\": batch[\"consensus_marks\"],\n            \"honeypotMark\": batch[\"honeypot_marks\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            \"content\": batch[\"contents\"],\n            \"jsonContent\": batch[\"json_contents\"],\n            \"status\": batch[\"status_array\"],\n            \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n            \"isHoneypot\": batch[\"is_honeypot_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/issue/","title":"Issue module","text":""},{"location":"sdk/issue/#queries","title":"Queries","text":"<p>Set of Issue queries.</p>  Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>class QueriesIssue:\n    \"\"\"Set of Issue queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of issues that match a set of criteria.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n            first: Maximum number of issues to return.\n            skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the issues is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n        \"\"\"\n        count_args = {\"project_id\": project_id}\n        disable_tqdm = disable_tqdm or as_generator\n        payload_query = {\n            \"where\": {\n                \"project\": {\n                    \"id\": project_id,\n                },\n            },\n        }\n\n        issues_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_issues,\n            count_args,\n            self._query_issues,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return issues_generator\n        return list(issues_generator)\n\n    def _query_issues(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_issues = gql_issues(fragment_builder(fields, IssueType))\n        result = self.auth.client.execute(_gql_issues, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_issues(self, project_id: Optional[str] = None) -&gt; int:\n        \"\"\"Count and return the number of api keys with the given constraints.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n\n        Returns:\n            The number of issues with the parameters provided\n\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"project\": {\n                    \"id\": project_id,\n                },\n            },\n        }\n        result = self.auth.client.execute(GQL_ISSUES_COUNT, variables)\n        count = format_result(\"data\", result)\n        return int(count)\n</code></pre>"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","title":"<code>count_issues(self, project_id=None)</code>","text":"<p>Count and return the number of api keys with the given constraints.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>Optional[str]</code> <p>Project ID the issue belongs to.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>int</code> <p>The number of issues with the parameters provided</p>     Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef count_issues(self, project_id: Optional[str] = None) -&gt; int:\n    \"\"\"Count and return the number of api keys with the given constraints.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n\n    Returns:\n        The number of issues with the parameters provided\n\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"project\": {\n                \"id\": project_id,\n            },\n        },\n    }\n    result = self.auth.client.execute(GQL_ISSUES_COUNT, variables)\n    count = format_result(\"data\", result)\n    return int(count)\n</code></pre>"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.issues","title":"<code>issues(self, project_id, fields=['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'], first=None, skip=0, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of issues that match a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of issues to return.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of issues to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the issues is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n</code></pre>  Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef issues(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"id\",\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"issueNumber\",\n        \"status\",\n        \"type\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of issues that match a set of criteria.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n        first: Maximum number of issues to return.\n        skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the issues is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n    \"\"\"\n    count_args = {\"project_id\": project_id}\n    disable_tqdm = disable_tqdm or as_generator\n    payload_query = {\n        \"where\": {\n            \"project\": {\n                \"id\": project_id,\n            },\n        },\n    }\n\n    issues_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_issues,\n        count_args,\n        self._query_issues,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return issues_generator\n    return list(issues_generator)\n</code></pre>"},{"location":"sdk/issue/#mutations","title":"Mutations","text":"<p>Set of Issue mutations.</p>  Source code in <code>kili/mutations/issue/__init__.py</code> <pre><code>class MutationsIssue:\n    \"\"\"Set of Issue mutations.\"\"\"\n\n    # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_to_issues(\n        self,\n        label_id: str,\n        project_id: str,\n        object_mid: Optional[str] = None,\n        text: Optional[str] = None,\n        type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n    ) -&gt; Dict:\n        \"\"\"Create an issue.\n\n        Args:\n            label_id: Id of the label to add an issue to\n            object_mid: Mid of the object in the label to associate the issue to\n            type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n            text: If given, write a comment related to the issue\n            project_id: Id of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        issue_number = get_issue_number(self.auth, project_id, type_)\n        try:\n            asset_id = cast(\n                List[Dict],\n                list(\n                    QueriesLabel(self.auth).labels(\n                        project_id=project_id,\n                        label_id=label_id,\n                        fields=[\"labelOf.id\"],\n                        disable_tqdm=True,\n                    )\n                )[0][\"labelOf\"][\"id\"],\n            )\n        except:\n            # pylint: disable=raise-missing-from\n            raise ValueError(\n                f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n            )\n        variables = {\n            \"data\": {\n                \"issueNumber\": issue_number,\n                \"labelID\": label_id,\n                \"objectMid\": object_mid,\n                \"type\": type_,\n            },\n            \"where\": {\"id\": asset_id},\n        }\n        if text:\n            variables[\"data\"][\"text\"] = text\n\n        result = self.auth.client.execute(GQL_APPEND_TO_ISSUES, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/issue/#kili.mutations.issue.__init__.MutationsIssue.append_to_issues","title":"<code>append_to_issues(self, label_id, project_id, object_mid=None, text=None, type_='ISSUE')</code>","text":"<p>Create an issue.</p> <p>Parameters:</p>    Name Type Description Default     <code>label_id</code> <code>str</code> <p>Id of the label to add an issue to</p> required   <code>object_mid</code> <code>Optional[str]</code> <p>Mid of the object in the label to associate the issue to</p> <code>None</code>   <code>type_</code> <code>typing_extensions.Literal['ISSUE', 'QUESTION']</code> <p>type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"</p> <code>'ISSUE'</code>   <code>text</code> <code>Optional[str]</code> <p>If given, write a comment related to the issue</p> <code>None</code>   <code>project_id</code> <code>str</code> <p>Id of the project</p> required    <p>Returns:</p>    Type Description     <code>Dict</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/issue/__init__.py</code> <pre><code>@typechecked\ndef append_to_issues(\n    self,\n    label_id: str,\n    project_id: str,\n    object_mid: Optional[str] = None,\n    text: Optional[str] = None,\n    type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n) -&gt; Dict:\n    \"\"\"Create an issue.\n\n    Args:\n        label_id: Id of the label to add an issue to\n        object_mid: Mid of the object in the label to associate the issue to\n        type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n        text: If given, write a comment related to the issue\n        project_id: Id of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    issue_number = get_issue_number(self.auth, project_id, type_)\n    try:\n        asset_id = cast(\n            List[Dict],\n            list(\n                QueriesLabel(self.auth).labels(\n                    project_id=project_id,\n                    label_id=label_id,\n                    fields=[\"labelOf.id\"],\n                    disable_tqdm=True,\n                )\n            )[0][\"labelOf\"][\"id\"],\n        )\n    except:\n        # pylint: disable=raise-missing-from\n        raise ValueError(\n            f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n        )\n    variables = {\n        \"data\": {\n            \"issueNumber\": issue_number,\n            \"labelID\": label_id,\n            \"objectMid\": object_mid,\n            \"type\": type_,\n        },\n        \"where\": {\"id\": asset_id},\n    }\n    if text:\n        variables[\"data\"][\"text\"] = text\n\n    result = self.auth.client.execute(GQL_APPEND_TO_ISSUES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/label/","title":"Label module","text":""},{"location":"sdk/label/#queries","title":"Queries","text":"<p>Set of Label queries.</p>  Source code in <code>kili/queries/label/__init__.py</code> <pre><code>class QueriesLabel:\n    \"\"\"Set of Label queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n        category_search: Optional[str] = None,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have a label whose status belongs to that list, if given.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n\n        saved_args = locals()\n        count_args = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            not in [\n                \"as_generator\",\n                \"disable_tqdm\",\n                \"fields\",\n                \"first\",\n                \"id_contains\",\n                \"self\",\n                \"skip\",\n                \"message\",\n            ]\n        }\n\n        # using tqdm with a generator is messy, so it is always disabled\n        disable_tqdm = disable_tqdm or as_generator\n\n        if category_search:\n            validate_category_search_query(category_search)\n\n        payload_query = {\n            \"where\": {\n                \"id\": label_id,\n                \"asset\": {\n                    \"id\": asset_id,\n                    \"externalIdStrictlyIn\": asset_external_id_in,\n                    \"statusIn\": asset_status_in,\n                },\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"user\": {\n                    \"id\": user_id,\n                },\n                \"createdAt\": created_at,\n                \"createdAtGte\": created_at_gte,\n                \"createdAtLte\": created_at_lte,\n                \"authorIn\": author_in,\n                \"honeypotMarkGte\": honeypot_mark_gte,\n                \"honeypotMarkLte\": honeypot_mark_lte,\n                \"idIn\": id_contains,\n                \"search\": category_search,\n                \"typeIn\": type_in,\n            },\n        }\n\n        labels_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_labels,\n            count_args,\n            self._query_labels,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return labels_generator\n        return list(labels_generator)\n\n    def _query_labels(\n        self, skip: int, first: int, payload: dict, fields: List[str]\n    ) -&gt; Iterable[Dict]:\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_labels = gql_labels(fragment_builder(fields, LabelType))\n        result = self.auth.client.execute(_gql_labels, payload)\n        return format_result(\"data\", result, _object=List[LabelType])  # type:ignore\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def export_labels_as_df(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"createdAt\",\n            \"id\",\n            \"labelType\",\n        ],\n        asset_fields: List[str] = [\"externalId\"],\n    ) -&gt; pd.DataFrame:\n        # pylint: disable=line-too-long\n        \"\"\"Get the labels of a project as a pandas DataFrame.\n\n        Args:\n            project_id: Identifier of the project\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            asset_fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n        Returns:\n            pandas DataFrame containing the labels.\n        \"\"\"\n\n        projects = QueriesProject(self.auth).projects(project_id)\n        assert len(list(projects)) == 1, NO_ACCESS_RIGHT\n        assets = QueriesAsset(self.auth).assets(\n            project_id=project_id,\n            fields=asset_fields + [\"labels.\" + field for field in fields],\n        )\n        labels = [\n            dict(\n                label,\n                **dict((f\"asset_{key}\", asset[key]) for key in asset if key != \"labels\"),\n            )\n            for asset in assets\n            for label in asset[\"labels\"]\n        ]\n        labels_df = pd.DataFrame(labels)\n        return labels_df\n\n    @typechecked\n    def count_labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        label_id: Optional[str] = None,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        category_search: Optional[str] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n        \"\"\"Get the number of labels for the given parameters.\n\n        Args:\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have a label whose status belongs to that list, if given.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            label_id: Identifier of the label.\n            project_id: Identifier of the project.\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of labels with the parameters provided\n        \"\"\"\n\n        if category_search:\n            validate_category_search_query(category_search)\n\n        variables = {\n            \"where\": {\n                \"id\": label_id,\n                \"asset\": {\n                    \"id\": asset_id,\n                    \"externalIdStrictlyIn\": asset_external_id_in,\n                    \"statusIn\": asset_status_in,\n                },\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"user\": {\n                    \"id\": user_id,\n                },\n                \"createdAt\": created_at,\n                \"createdAtGte\": created_at_gte,\n                \"createdAtLte\": created_at_lte,\n                \"authorIn\": author_in,\n                \"honeypotMarkGte\": honeypot_mark_gte,\n                \"honeypotMarkLte\": honeypot_mark_lte,\n                \"search\": category_search,\n                \"typeIn\": type_in,\n            }\n        }\n        result = self.auth.client.execute(GQL_LABELS_COUNT, variables)\n        return format_result(\"data\", result, int)\n\n    def export_labels(\n        self,\n        project_id: str,\n        filename: str,\n        fmt: LabelFormat,\n        asset_ids: Optional[List[str]] = None,\n        layout: SplitOption = \"split\",\n        single_file: bool = False,\n        disable_tqdm: bool = False,\n        with_assets: bool = True,\n        external_ids: Optional[List[str]] = None,\n    ):\n        \"\"\"\n        Export the project labels with the requested format into the requested output path.\n\n        Args:\n            project_id: Identifier of the project.\n            filename: Relative or full path of the archive that will contain\n                the exported data.\n            fmt: Format of the exported labels.\n            asset_ids: Optional list of the assets internal IDs from which to export the labels.\n            layout: Layout of the exported files: \"split\" means there is one folder\n                per job, \"merged\" that there is one folder with every labels.\n            single_file: Layout of the exported labels. Single file mode is\n                only available for some specific formats (COCO and Kili).\n            disable_tqdm: Disable the progress bar if True.\n            with_assets: Download the assets in the export.\n            external_ids: Optional list of the assets external IDs from which to export the labels.\n\n        !!! Info\n            The supported formats are:\n\n            - Yolo V4, V5, V7 for object detection tasks (bounding box)\n\n            - Kili for all tasks.\n\n            - COCO for semantic segmentation tasks (bounding box and semantic segmentation)\n\n            - Pascal VOC for object detection tasks.\n\n        !!! Example\n            ```\n            from kili.client import Kili\n            kili = Kili()\n            kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n            ```\n        \"\"\"\n        if external_ids is not None and asset_ids is None:\n            id_map = infer_ids_from_external_ids(\n                kili=self, asset_external_ids=external_ids, project_id=project_id\n            )\n            asset_ids = [id_map[id] for id in external_ids]\n\n        try:\n            services.export_labels(\n                self,\n                asset_ids=asset_ids,\n                project_id=cast(ProjectId, project_id),\n                export_type=\"latest\",\n                label_format=fmt,\n                split_option=layout,\n                single_file=single_file,\n                output_file=filename,\n                disable_tqdm=disable_tqdm,\n                log_level=\"WARNING\",\n                with_assets=with_assets,\n            )\n        except NoCompatibleJobError as excp:\n            print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.count_labels","title":"<code>count_labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, label_id=None, type_in=None, user_id=None, category_search=None)</code>","text":"<p>Get the number of labels for the given parameters.</p> <p>Parameters:</p>    Name Type Description Default     <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code>   <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code>   <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code>   <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose status belongs to that list, if given.</p> <code>None</code>   <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code>   <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code>   <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code>   <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code>   <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code>   <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code>   <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code>   <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>int</code> <p>The number of labels with the parameters provided</p>     Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef count_labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    label_id: Optional[str] = None,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    category_search: Optional[str] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n    \"\"\"Get the number of labels for the given parameters.\n\n    Args:\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have a label whose status belongs to that list, if given.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        label_id: Identifier of the label.\n        project_id: Identifier of the project.\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of labels with the parameters provided\n    \"\"\"\n\n    if category_search:\n        validate_category_search_query(category_search)\n\n    variables = {\n        \"where\": {\n            \"id\": label_id,\n            \"asset\": {\n                \"id\": asset_id,\n                \"externalIdStrictlyIn\": asset_external_id_in,\n                \"statusIn\": asset_status_in,\n            },\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"user\": {\n                \"id\": user_id,\n            },\n            \"createdAt\": created_at,\n            \"createdAtGte\": created_at_gte,\n            \"createdAtLte\": created_at_lte,\n            \"authorIn\": author_in,\n            \"honeypotMarkGte\": honeypot_mark_gte,\n            \"honeypotMarkLte\": honeypot_mark_lte,\n            \"search\": category_search,\n            \"typeIn\": type_in,\n        }\n    }\n    result = self.auth.client.execute(GQL_LABELS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels","title":"<code>export_labels(self, project_id, filename, fmt, asset_ids=None, layout='split', single_file=False, disable_tqdm=False, with_assets=True, external_ids=None)</code>","text":"<p>Export the project labels with the requested format into the requested output path.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>filename</code> <code>str</code> <p>Relative or full path of the archive that will contain the exported data.</p> required   <code>fmt</code> <code>typing_extensions.Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc']</code> <p>Format of the exported labels.</p> required   <code>asset_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets internal IDs from which to export the labels.</p> <code>None</code>   <code>layout</code> <code>typing_extensions.Literal['split', 'merged']</code> <p>Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels.</p> <code>'split'</code>   <code>single_file</code> <code>bool</code> <p>Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili).</p> <code>False</code>   <code>disable_tqdm</code> <code>bool</code> <p>Disable the progress bar if True.</p> <code>False</code>   <code>with_assets</code> <code>bool</code> <p>Download the assets in the export.</p> <code>True</code>   <code>external_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets external IDs from which to export the labels.</p> <code>None</code>     <p>Info</p> <p>The supported formats are:</p> <ul> <li> <p>Yolo V4, V5, V7 for object detection tasks (bounding box)</p> </li> <li> <p>Kili for all tasks.</p> </li> <li> <p>COCO for semantic segmentation tasks (bounding box and semantic segmentation)</p> </li> <li> <p>Pascal VOC for object detection tasks.</p> </li> </ul>   <p>Example</p> <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n</code></pre>   Source code in <code>kili/queries/label/__init__.py</code> <pre><code>def export_labels(\n    self,\n    project_id: str,\n    filename: str,\n    fmt: LabelFormat,\n    asset_ids: Optional[List[str]] = None,\n    layout: SplitOption = \"split\",\n    single_file: bool = False,\n    disable_tqdm: bool = False,\n    with_assets: bool = True,\n    external_ids: Optional[List[str]] = None,\n):\n    \"\"\"\n    Export the project labels with the requested format into the requested output path.\n\n    Args:\n        project_id: Identifier of the project.\n        filename: Relative or full path of the archive that will contain\n            the exported data.\n        fmt: Format of the exported labels.\n        asset_ids: Optional list of the assets internal IDs from which to export the labels.\n        layout: Layout of the exported files: \"split\" means there is one folder\n            per job, \"merged\" that there is one folder with every labels.\n        single_file: Layout of the exported labels. Single file mode is\n            only available for some specific formats (COCO and Kili).\n        disable_tqdm: Disable the progress bar if True.\n        with_assets: Download the assets in the export.\n        external_ids: Optional list of the assets external IDs from which to export the labels.\n\n    !!! Info\n        The supported formats are:\n\n        - Yolo V4, V5, V7 for object detection tasks (bounding box)\n\n        - Kili for all tasks.\n\n        - COCO for semantic segmentation tasks (bounding box and semantic segmentation)\n\n        - Pascal VOC for object detection tasks.\n\n    !!! Example\n        ```\n        from kili.client import Kili\n        kili = Kili()\n        kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n        ```\n    \"\"\"\n    if external_ids is not None and asset_ids is None:\n        id_map = infer_ids_from_external_ids(\n            kili=self, asset_external_ids=external_ids, project_id=project_id\n        )\n        asset_ids = [id_map[id] for id in external_ids]\n\n    try:\n        services.export_labels(\n            self,\n            asset_ids=asset_ids,\n            project_id=cast(ProjectId, project_id),\n            export_type=\"latest\",\n            label_format=fmt,\n            split_option=layout,\n            single_file=single_file,\n            output_file=filename,\n            disable_tqdm=disable_tqdm,\n            log_level=\"WARNING\",\n            with_assets=with_assets,\n        )\n    except NoCompatibleJobError as excp:\n        print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","title":"<code>export_labels_as_df(self, project_id, fields=['author.email', 'author.id', 'createdAt', 'id', 'labelType'], asset_fields=['externalId'])</code>","text":"<p>Get the labels of a project as a pandas DataFrame.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'createdAt', 'id', 'labelType']</code>   <code>asset_fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['externalId']</code>    <p>Returns:</p>    Type Description     <code>DataFrame</code> <p>pandas DataFrame containing the labels.</p>     Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef export_labels_as_df(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"createdAt\",\n        \"id\",\n        \"labelType\",\n    ],\n    asset_fields: List[str] = [\"externalId\"],\n) -&gt; pd.DataFrame:\n    # pylint: disable=line-too-long\n    \"\"\"Get the labels of a project as a pandas DataFrame.\n\n    Args:\n        project_id: Identifier of the project\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        asset_fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n    Returns:\n        pandas DataFrame containing the labels.\n    \"\"\"\n\n    projects = QueriesProject(self.auth).projects(project_id)\n    assert len(list(projects)) == 1, NO_ACCESS_RIGHT\n    assets = QueriesAsset(self.auth).assets(\n        project_id=project_id,\n        fields=asset_fields + [\"labels.\" + field for field in fields],\n    )\n    labels = [\n        dict(\n            label,\n            **dict((f\"asset_{key}\", asset[key]) for key in asset if key != \"labels\"),\n        )\n        for asset in assets\n        for label in asset[\"labels\"]\n    ]\n    labels_df = pd.DataFrame(labels)\n    return labels_df\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.labels","title":"<code>labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'], first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, type_in=None, user_id=None, disable_tqdm=False, as_generator=False, category_search=None)</code>","text":"<p>Get a label list or a label generator from a project based on a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code>   <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code>   <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code>   <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose status belongs to that list, if given.</p> <code>None</code>   <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code>   <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code>   <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code>   <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code>   <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code>   <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code>   <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code>   <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful, else an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n</code></pre>  <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\ncategory_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\ncategory_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre>   Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"secondsToLabel\",\n    ],\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n    category_search: Optional[str] = None,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have a label whose status belongs to that list, if given.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n\n    saved_args = locals()\n    count_args = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        not in [\n            \"as_generator\",\n            \"disable_tqdm\",\n            \"fields\",\n            \"first\",\n            \"id_contains\",\n            \"self\",\n            \"skip\",\n            \"message\",\n        ]\n    }\n\n    # using tqdm with a generator is messy, so it is always disabled\n    disable_tqdm = disable_tqdm or as_generator\n\n    if category_search:\n        validate_category_search_query(category_search)\n\n    payload_query = {\n        \"where\": {\n            \"id\": label_id,\n            \"asset\": {\n                \"id\": asset_id,\n                \"externalIdStrictlyIn\": asset_external_id_in,\n                \"statusIn\": asset_status_in,\n            },\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"user\": {\n                \"id\": user_id,\n            },\n            \"createdAt\": created_at,\n            \"createdAtGte\": created_at_gte,\n            \"createdAtLte\": created_at_lte,\n            \"authorIn\": author_in,\n            \"honeypotMarkGte\": honeypot_mark_gte,\n            \"honeypotMarkLte\": honeypot_mark_lte,\n            \"idIn\": id_contains,\n            \"search\": category_search,\n            \"typeIn\": type_in,\n        },\n    }\n\n    labels_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_labels,\n        count_args,\n        self._query_labels,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return labels_generator\n    return list(labels_generator)\n</code></pre>"},{"location":"sdk/label/#mutations","title":"Mutations","text":"<p>Set of Label mutations.</p>  Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>class MutationsLabel:\n    \"\"\"Set of Label mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initializes the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def create_predictions(\n        self,\n        project_id: str,\n        external_id_array: Optional[List[str]] = None,\n        model_name_array: Optional[List[str]] = None,\n        json_response_array: Optional[List[dict]] = None,\n        model_name: Optional[str] = None,\n        asset_id_array: Optional[List[str]] = None,\n    ) -&gt; dict:\n        # pylint: disable=line-too-long\n        \"\"\"Create predictions for specific assets.\n\n        Args:\n            project_id: Identifier of the project.\n            external_id_array: The external IDs of the assets for which we want to add predictions.\n            model_name_array: In case you want to precise from which model the label originated.\n            json_response_array: The predictions are given here. For examples,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n            asset_id_array: The internal IDs of the assets for which we want to add predictions.\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n        \"\"\"\n        if json_response_array is None or len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one prediction to upload\"\n            )\n        assert_all_arrays_have_same_size(\n            [external_id_array, json_response_array, model_name_array, asset_id_array]\n        )\n        if model_name is None:\n            if model_name_array is None:\n                raise ValueError(\"You must provide a model name with the model_name argument \")\n            if len(set(model_name_array)) &gt; 1:\n                raise ValueError(\n                    \"Creating predictions from different models is not supported anymore. Separate\"\n                    \" your calls by models.\"\n                )\n            warnings.warn(\n                \"The use of `model_name_array` is deprecated. Creating predictions from different\"\n                \" models is not supported anymore. Please use `model_name` argument instead to\"\n                \" provide the predictions model name.\",\n                DeprecationWarning,\n            )\n            model_name = model_name_array[0]\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n            }\n            for (asset_id, asset_external_id, json_response) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                )\n            )\n        ]\n        services.import_labels_from_dict(self, project_id, labels, \"PREDICTION\", model_name)\n        return {\"id\": project_id}\n\n    @deprecate(\n        msg=(\n            \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n            \" function allows to import several labels 10 times faster.\"\n        )\n    )\n    @typechecked\n    def append_to_labels(\n        self,\n        json_response: dict,\n        author_id: Optional[str] = None,\n        label_asset_external_id: Optional[str] = None,\n        label_asset_id: Optional[str] = None,\n        label_type: str = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        seconds_to_label: Optional[int] = 0,\n    ):\n        \"\"\"\n        !!! danger \"[DEPRECATED]\"\n            append_to_labels method is deprecated. Please use append_labels instead.\n            This new function allows to import several labels 10 times faster.\n\n        Append a label to an asset.\n\n        Args:\n            json_response: Label is given here\n            author_id: ID of the author of the label\n            label_asset_external_id: External identifier of the asset\n            label_asset_id: Identifier of the asset\n            project_id: Identifier of the project\n            label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n            seconds_to_label: Time to create the label\n\n        !!! warning\n            Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n\n        \"\"\"\n        if author_id is None:\n            author_id = self.auth.user_id\n        check_asset_identifier_arguments(\n            project_id,\n            [label_asset_id] if label_asset_id else None,\n            [label_asset_external_id] if label_asset_external_id else None,\n        )\n        if label_asset_id is None:\n            assert label_asset_external_id and project_id\n            label_asset_id = infer_ids_from_external_ids(\n                self, [label_asset_external_id], project_id\n            )[label_asset_external_id]\n        variables = {\n            \"data\": {\n                \"authorID\": author_id,\n                \"jsonResponse\": dumps(json_response),\n                \"labelType\": label_type,\n                \"secondsToLabel\": seconds_to_label,\n            },\n            \"where\": {\"id\": label_asset_id},\n        }\n        result = self.auth.client.execute(GQL_APPEND_TO_LABELS, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def append_labels(  # pylint: disable=dangerous-default-value\n        self,\n        asset_id_array: Optional[List[str]] = None,\n        json_response_array: List[Dict] = [],\n        author_id_array: Optional[List[str]] = None,\n        seconds_to_label_array: Optional[List[int]] = None,\n        model_name: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        asset_external_id_array: Optional[List[str]] = None,\n    ) -&gt; List:\n        \"\"\"Append labels to assets.\n\n        Args:\n            asset_id_array: list of asset internal ids to append labels on\n            json_response_array: list of labels to append\n            author_id_array: list of the author id of the labels\n            seconds_to_label_array: list of times taken to produce the label, in seconds\n            model_name: Only useful when uploading predictions.\n                Name of the model when uploading predictions\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n            project_id: Identifier of the project\n            asset_external_id_array: list of asset external ids to append labels on\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(\n                    asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                    json_response_array=[{...}, {...}]\n                )\n        \"\"\"\n        if len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one label to upload\"\n            )\n        check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n        assert_all_arrays_have_same_size(\n            [\n                seconds_to_label_array,\n                author_id_array,\n                json_response_array,\n                asset_external_id_array,\n                asset_id_array,\n            ]\n        )\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n                \"seconds_to_label\": seconds_to_label,\n                \"author_id\": author_id,\n            }\n            for (asset_id, asset_external_id, json_response, seconds_to_label, author_id,) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    asset_external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                    seconds_to_label_array or [None] * len(json_response_array),\n                    author_id_array or [None] * len(json_response_array),\n                )\n            )\n        ]\n        return services.import_labels_from_dict(self, project_id, labels, label_type, model_name)\n\n    @typechecked\n    def update_properties_in_label(\n        self,\n        label_id: str,\n        seconds_to_label: Optional[int] = None,\n        model_name: Optional[str] = None,\n        json_response: Optional[dict] = None,\n    ) -&gt; Label:\n        \"\"\"Update properties of a label.\n\n        Args:\n            label_id: Identifier of the label\n            seconds_to_label: Time to create the label\n            model_name: Name of the model\n            json_response: The label is given here\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n        \"\"\"\n        formatted_json_response = None if json_response is None else dumps(json_response)\n        variables = {\n            \"labelID\": label_id,\n            \"secondsToLabel\": seconds_to_label,\n            \"modelName\": model_name,\n            \"jsonResponse\": formatted_json_response,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def create_honeypot(\n        self,\n        json_response: dict,\n        asset_external_id: Optional[str] = None,\n        asset_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Label:\n        \"\"\"Create honeypot for an asset.\n\n        !!! info\n            Uses the given `json_response` to create a `REVIEW` label.\n            This enables Kili to compute a`honeypotMark`,\n            which measures the similarity between this label and other labels.\n\n        Args:\n            json_response: The JSON response of the honeypot label of the asset\n            asset_id: Identifier of the asset\n                Either provide asset_id or asset_external_id and project_id\n            asset_external_id: External identifier of the asset\n                Either provide asset_id or asset_external_id and project_id\n            project_id: Identifier of the project\n                Either provide asset_id or asset_external_id and project_id\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        if asset_id is None:\n            if asset_external_id is None or project_id is None:\n                raise Exception(\"Either provide asset_id or external_id and project_id\")\n            asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n                asset_external_id\n            ]\n\n        variables = {\n            \"data\": {\"jsonResponse\": dumps(json_response)},\n            \"where\": {\"id\": asset_id},\n        }\n        result = self.auth.client.execute(GQL_CREATE_HONEYPOT, variables)\n        return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_labels","title":"<code>append_labels(self, asset_id_array=None, json_response_array=[], author_id_array=None, seconds_to_label_array=None, model_name=None, label_type='DEFAULT', project_id=None, asset_external_id_array=None)</code>","text":"<p>Append labels to assets.</p> <p>Parameters:</p>    Name Type Description Default     <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>list of asset internal ids to append labels on</p> <code>None</code>   <code>json_response_array</code> <code>List[Dict]</code> <p>list of labels to append</p> <code>[]</code>   <code>author_id_array</code> <code>Optional[List[str]]</code> <p>list of the author id of the labels</p> <code>None</code>   <code>seconds_to_label_array</code> <code>Optional[List[int]]</code> <p>list of times taken to produce the label, in seconds</p> <code>None</code>   <code>model_name</code> <code>Optional[str]</code> <p>Only useful when uploading predictions. Name of the model when uploading predictions</p> <code>None</code>   <code>label_type</code> <code>typing_extensions.Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code></p> <code>'DEFAULT'</code>   <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project</p> <code>None</code>   <code>asset_external_id_array</code> <code>Optional[List[str]]</code> <p>list of asset external ids to append labels on</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>List</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(\n        asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n        json_response_array=[{...}, {...}]\n    )\n</code></pre>  Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef append_labels(  # pylint: disable=dangerous-default-value\n    self,\n    asset_id_array: Optional[List[str]] = None,\n    json_response_array: List[Dict] = [],\n    author_id_array: Optional[List[str]] = None,\n    seconds_to_label_array: Optional[List[int]] = None,\n    model_name: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    asset_external_id_array: Optional[List[str]] = None,\n) -&gt; List:\n    \"\"\"Append labels to assets.\n\n    Args:\n        asset_id_array: list of asset internal ids to append labels on\n        json_response_array: list of labels to append\n        author_id_array: list of the author id of the labels\n        seconds_to_label_array: list of times taken to produce the label, in seconds\n        model_name: Only useful when uploading predictions.\n            Name of the model when uploading predictions\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n        project_id: Identifier of the project\n        asset_external_id_array: list of asset external ids to append labels on\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(\n                asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                json_response_array=[{...}, {...}]\n            )\n    \"\"\"\n    if len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one label to upload\"\n        )\n    check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n    assert_all_arrays_have_same_size(\n        [\n            seconds_to_label_array,\n            author_id_array,\n            json_response_array,\n            asset_external_id_array,\n            asset_id_array,\n        ]\n    )\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n            \"seconds_to_label\": seconds_to_label,\n            \"author_id\": author_id,\n        }\n        for (asset_id, asset_external_id, json_response, seconds_to_label, author_id,) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                asset_external_id_array or [None] * len(json_response_array),\n                json_response_array,\n                seconds_to_label_array or [None] * len(json_response_array),\n                author_id_array or [None] * len(json_response_array),\n            )\n        )\n    ]\n    return services.import_labels_from_dict(self, project_id, labels, label_type, model_name)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","title":"<code>append_to_labels(self, json_response, author_id=None, label_asset_external_id=None, label_asset_id=None, label_type='DEFAULT', project_id=None, seconds_to_label=0)</code>","text":"<p>[DEPRECATED]</p> <p>append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster.</p>  <p>Append a label to an asset.</p> <p>Parameters:</p>    Name Type Description Default     <code>json_response</code> <code>dict</code> <p>Label is given here</p> required   <code>author_id</code> <code>Optional[str]</code> <p>ID of the author of the label</p> <code>None</code>   <code>label_asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset</p> <code>None</code>   <code>label_asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project</p> <code>None</code>   <code>label_type</code> <code>str</code> <p>Can be one of <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code></p> <code>'DEFAULT'</code>   <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label</p> <code>0</code>     <p>Warning</p> <p>Either provide <code>label_asset_id</code> or <code>label_asset_external_id</code> and <code>project_id</code></p>  <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n</code></pre>  Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@deprecate(\n    msg=(\n        \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n        \" function allows to import several labels 10 times faster.\"\n    )\n)\n@typechecked\ndef append_to_labels(\n    self,\n    json_response: dict,\n    author_id: Optional[str] = None,\n    label_asset_external_id: Optional[str] = None,\n    label_asset_id: Optional[str] = None,\n    label_type: str = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    seconds_to_label: Optional[int] = 0,\n):\n    \"\"\"\n    !!! danger \"[DEPRECATED]\"\n        append_to_labels method is deprecated. Please use append_labels instead.\n        This new function allows to import several labels 10 times faster.\n\n    Append a label to an asset.\n\n    Args:\n        json_response: Label is given here\n        author_id: ID of the author of the label\n        label_asset_external_id: External identifier of the asset\n        label_asset_id: Identifier of the asset\n        project_id: Identifier of the project\n        label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n        seconds_to_label: Time to create the label\n\n    !!! warning\n        Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n\n    \"\"\"\n    if author_id is None:\n        author_id = self.auth.user_id\n    check_asset_identifier_arguments(\n        project_id,\n        [label_asset_id] if label_asset_id else None,\n        [label_asset_external_id] if label_asset_external_id else None,\n    )\n    if label_asset_id is None:\n        assert label_asset_external_id and project_id\n        label_asset_id = infer_ids_from_external_ids(\n            self, [label_asset_external_id], project_id\n        )[label_asset_external_id]\n    variables = {\n        \"data\": {\n            \"authorID\": author_id,\n            \"jsonResponse\": dumps(json_response),\n            \"labelType\": label_type,\n            \"secondsToLabel\": seconds_to_label,\n        },\n        \"where\": {\"id\": label_asset_id},\n    }\n    result = self.auth.client.execute(GQL_APPEND_TO_LABELS, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","title":"<code>create_honeypot(self, json_response, asset_external_id=None, asset_id=None, project_id=None)</code>","text":"<p>Create honeypot for an asset.</p>  <p>Info</p> <p>Uses the given <code>json_response</code> to create a <code>REVIEW</code> label. This enables Kili to compute a<code>honeypotMark</code>, which measures the similarity between this label and other labels.</p>  <p>Parameters:</p>    Name Type Description Default     <code>json_response</code> <code>dict</code> <p>The JSON response of the honeypot label of the asset</p> required   <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset Either provide asset_id or asset_external_id and project_id</p> <code>None</code>   <code>asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset Either provide asset_id or asset_external_id and project_id</p> <code>None</code>   <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project Either provide asset_id or asset_external_id and project_id</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_honeypot(\n    self,\n    json_response: dict,\n    asset_external_id: Optional[str] = None,\n    asset_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n) -&gt; Label:\n    \"\"\"Create honeypot for an asset.\n\n    !!! info\n        Uses the given `json_response` to create a `REVIEW` label.\n        This enables Kili to compute a`honeypotMark`,\n        which measures the similarity between this label and other labels.\n\n    Args:\n        json_response: The JSON response of the honeypot label of the asset\n        asset_id: Identifier of the asset\n            Either provide asset_id or asset_external_id and project_id\n        asset_external_id: External identifier of the asset\n            Either provide asset_id or asset_external_id and project_id\n        project_id: Identifier of the project\n            Either provide asset_id or asset_external_id and project_id\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    if asset_id is None:\n        if asset_external_id is None or project_id is None:\n            raise Exception(\"Either provide asset_id or external_id and project_id\")\n        asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n            asset_external_id\n        ]\n\n    variables = {\n        \"data\": {\"jsonResponse\": dumps(json_response)},\n        \"where\": {\"id\": asset_id},\n    }\n    result = self.auth.client.execute(GQL_CREATE_HONEYPOT, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","title":"<code>create_predictions(self, project_id, external_id_array=None, model_name_array=None, json_response_array=None, model_name=None, asset_id_array=None)</code>","text":"<p>Create predictions for specific assets.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>external_id_array</code> <code>Optional[List[str]]</code> <p>The external IDs of the assets for which we want to add predictions.</p> <code>None</code>   <code>model_name_array</code> <code>Optional[List[str]]</code> <p>In case you want to precise from which model the label originated.</p> <code>None</code>   <code>json_response_array</code> <code>Optional[List[dict]]</code> <p>The predictions are given here. For examples, see the recipe.</p> <code>None</code>   <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>The internal IDs of the assets for which we want to add predictions.</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>dict</code> <p>A result object which indicates if the mutation was successful, or an error message.</p>     <p>Recipe</p> <p>For more detailed examples on how to create predictions, see the recipe.</p>   Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_predictions(\n    self,\n    project_id: str,\n    external_id_array: Optional[List[str]] = None,\n    model_name_array: Optional[List[str]] = None,\n    json_response_array: Optional[List[dict]] = None,\n    model_name: Optional[str] = None,\n    asset_id_array: Optional[List[str]] = None,\n) -&gt; dict:\n    # pylint: disable=line-too-long\n    \"\"\"Create predictions for specific assets.\n\n    Args:\n        project_id: Identifier of the project.\n        external_id_array: The external IDs of the assets for which we want to add predictions.\n        model_name_array: In case you want to precise from which model the label originated.\n        json_response_array: The predictions are given here. For examples,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n        asset_id_array: The internal IDs of the assets for which we want to add predictions.\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n    \"\"\"\n    if json_response_array is None or len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one prediction to upload\"\n        )\n    assert_all_arrays_have_same_size(\n        [external_id_array, json_response_array, model_name_array, asset_id_array]\n    )\n    if model_name is None:\n        if model_name_array is None:\n            raise ValueError(\"You must provide a model name with the model_name argument \")\n        if len(set(model_name_array)) &gt; 1:\n            raise ValueError(\n                \"Creating predictions from different models is not supported anymore. Separate\"\n                \" your calls by models.\"\n            )\n        warnings.warn(\n            \"The use of `model_name_array` is deprecated. Creating predictions from different\"\n            \" models is not supported anymore. Please use `model_name` argument instead to\"\n            \" provide the predictions model name.\",\n            DeprecationWarning,\n        )\n        model_name = model_name_array[0]\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n        }\n        for (asset_id, asset_external_id, json_response) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                external_id_array or [None] * len(json_response_array),\n                json_response_array,\n            )\n        )\n    ]\n    services.import_labels_from_dict(self, project_id, labels, \"PREDICTION\", model_name)\n    return {\"id\": project_id}\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","title":"<code>update_properties_in_label(self, label_id, seconds_to_label=None, model_name=None, json_response=None)</code>","text":"<p>Update properties of a label.</p> <p>Parameters:</p>    Name Type Description Default     <code>label_id</code> <code>str</code> <p>Identifier of the label</p> required   <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label</p> <code>None</code>   <code>model_name</code> <code>Optional[str]</code> <p>Name of the model</p> <code>None</code>   <code>json_response</code> <code>Optional[dict]</code> <p>The label is given here</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n</code></pre>  Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_label(\n    self,\n    label_id: str,\n    seconds_to_label: Optional[int] = None,\n    model_name: Optional[str] = None,\n    json_response: Optional[dict] = None,\n) -&gt; Label:\n    \"\"\"Update properties of a label.\n\n    Args:\n        label_id: Identifier of the label\n        seconds_to_label: Time to create the label\n        model_name: Name of the model\n        json_response: The label is given here\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n    \"\"\"\n    formatted_json_response = None if json_response is None else dumps(json_response)\n    variables = {\n        \"labelID\": label_id,\n        \"secondsToLabel\": seconds_to_label,\n        \"modelName\": model_name,\n        \"jsonResponse\": formatted_json_response,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#subscriptions","title":"Subscriptions","text":"<p>Set of Label subscriptions.</p>  Source code in <code>kili/subscriptions/label/__init__.py</code> <pre><code>class SubscriptionsLabel:\n    \"\"\"Set of Label subscriptions.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def label_created_or_updated(\n        self, project_id: str, callback: Callable[[str, str], None]\n    ) -&gt; SubscriptionGraphQLClient:\n        # pylint: disable=line-too-long\n        \"\"\"\n        Subscribe a callback to a project, which is executed when a label is created or updated.\n\n        Args:\n            project_id: Identifier of the project\n            callback: This function takes as input the id of the asset and its content.\n\n        Returns:\n            A subscription client.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to use Webhooks,\n            See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb)\n        \"\"\"\n        ws_endpoint = self.auth.client.endpoint.replace(\"http\", \"ws\")\n        websocket = SubscriptionGraphQLClient(ws_endpoint)\n        headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n        authorization = f\"{self.auth.client.token}\"\n        headers[\"Authorization\"] = authorization\n        variables = {\"projectID\": project_id}\n        websocket.subscribe(\n            GQL_LABEL_CREATED_OR_UPDATED,\n            variables=variables,\n            callback=callback,\n            headers=headers,\n            authorization=authorization,\n        )\n        return websocket\n</code></pre>"},{"location":"sdk/label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","title":"<code>label_created_or_updated(self, project_id, callback)</code>","text":"<p>Subscribe a callback to a project, which is executed when a label is created or updated.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>callback</code> <code>Callable[[str, str], NoneType]</code> <p>This function takes as input the id of the asset and its content.</p> required    <p>Returns:</p>    Type Description     <code>SubscriptionGraphQLClient</code> <p>A subscription client.</p>     <p>Recipe</p> <p>For more detailed examples on how to use Webhooks, See the related recipe</p>   Source code in <code>kili/subscriptions/label/__init__.py</code> <pre><code>@typechecked\ndef label_created_or_updated(\n    self, project_id: str, callback: Callable[[str, str], None]\n) -&gt; SubscriptionGraphQLClient:\n    # pylint: disable=line-too-long\n    \"\"\"\n    Subscribe a callback to a project, which is executed when a label is created or updated.\n\n    Args:\n        project_id: Identifier of the project\n        callback: This function takes as input the id of the asset and its content.\n\n    Returns:\n        A subscription client.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to use Webhooks,\n        See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb)\n    \"\"\"\n    ws_endpoint = self.auth.client.endpoint.replace(\"http\", \"ws\")\n    websocket = SubscriptionGraphQLClient(ws_endpoint)\n    headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n    authorization = f\"{self.auth.client.token}\"\n    headers[\"Authorization\"] = authorization\n    variables = {\"projectID\": project_id}\n    websocket.subscribe(\n        GQL_LABEL_CREATED_OR_UPDATED,\n        variables=variables,\n        callback=callback,\n        headers=headers,\n        authorization=authorization,\n    )\n    return websocket\n</code></pre>"},{"location":"sdk/notification/","title":"Notification module","text":""},{"location":"sdk/notification/#queries","title":"Queries","text":"<p>Set of Notification queries.</p>  Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>class QueriesNotification:\n    \"\"\"Set of Notification queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n        Args:\n            fields: All the fields to request among the possible fields for the notifications\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n            first: Number of notifications to query\n            has_been_seen: If the notifications returned should have been seen.\n            notification_id: If given, will return the notification which has this id\n            skip: Number of notifications to skip (they are ordered by their date of creation,\n                first to last).\n            user_id: If given, returns the notifications of a specific user\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the notifications is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n\n        count_args = {\"has_been_seen\": has_been_seen, \"user_id\": user_id}\n        disable_tqdm = disable_tqdm or as_generator or notification_id is not None\n        payload_query = {\n            \"where\": {\n                \"id\": notification_id,\n                \"user\": {\n                    \"id\": user_id,\n                },\n                \"hasBeenSeen\": has_been_seen,\n            },\n        }\n        notifications_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_notifications,\n            count_args,\n            self._query_notifications,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return notifications_generator\n        return list(notifications_generator)\n\n    def _query_notifications(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_notifications = gql_notifications(fragment_builder(fields, Notification))\n        result = self.auth.client.execute(_gql_notifications, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_notifications(\n        self, has_been_seen: Optional[bool] = None, user_id: Optional[str] = None\n    ) -&gt; int:\n        \"\"\"Count the number of notifications.\n\n        Args:\n            has_been_seen: Filter on notifications that have been seen.\n            user_id: Filter on the notifications of a specific user\n\n        Returns:\n            The number of notifications with the parameters provided\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"user\": {\n                    \"id\": user_id,\n                },\n                \"hasBeenSeen\": has_been_seen,\n            },\n        }\n        result = self.auth.client.execute(GQL_NOTIFICATIONS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","title":"<code>count_notifications(self, has_been_seen=None, user_id=None)</code>","text":"<p>Count the number of notifications.</p> <p>Parameters:</p>    Name Type Description Default     <code>has_been_seen</code> <code>Optional[bool]</code> <p>Filter on notifications that have been seen.</p> <code>None</code>   <code>user_id</code> <code>Optional[str]</code> <p>Filter on the notifications of a specific user</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>int</code> <p>The number of notifications with the parameters provided</p>     Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef count_notifications(\n    self, has_been_seen: Optional[bool] = None, user_id: Optional[str] = None\n) -&gt; int:\n    \"\"\"Count the number of notifications.\n\n    Args:\n        has_been_seen: Filter on notifications that have been seen.\n        user_id: Filter on the notifications of a specific user\n\n    Returns:\n        The number of notifications with the parameters provided\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"user\": {\n                \"id\": user_id,\n            },\n            \"hasBeenSeen\": has_been_seen,\n        },\n    }\n    result = self.auth.client.execute(GQL_NOTIFICATIONS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.notifications","title":"<code>notifications(self, fields=['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'], first=None, has_been_seen=None, notification_id=None, skip=0, user_id=None, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of notifications respecting a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the notifications See the documentation for all possible fields.</p> <code>['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID']</code>   <code>first</code> <code>Optional[int]</code> <p>Number of notifications to query</p> <code>None</code>   <code>has_been_seen</code> <code>Optional[bool]</code> <p>If the notifications returned should have been seen.</p> <code>None</code>   <code>notification_id</code> <code>Optional[str]</code> <p>If given, will return the notification which has this id</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of notifications to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>user_id</code> <code>Optional[str]</code> <p>If given, returns the notifications of a specific user</p> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the notifications is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>     Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef notifications(\n    self,\n    fields: List[str] = [\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"id\",\n        \"message\",\n        \"status\",\n        \"userID\",\n    ],\n    first: Optional[int] = None,\n    has_been_seen: Optional[bool] = None,\n    notification_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n    Args:\n        fields: All the fields to request among the possible fields for the notifications\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n        first: Number of notifications to query\n        has_been_seen: If the notifications returned should have been seen.\n        notification_id: If given, will return the notification which has this id\n        skip: Number of notifications to skip (they are ordered by their date of creation,\n            first to last).\n        user_id: If given, returns the notifications of a specific user\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the notifications is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n\n    count_args = {\"has_been_seen\": has_been_seen, \"user_id\": user_id}\n    disable_tqdm = disable_tqdm or as_generator or notification_id is not None\n    payload_query = {\n        \"where\": {\n            \"id\": notification_id,\n            \"user\": {\n                \"id\": user_id,\n            },\n            \"hasBeenSeen\": has_been_seen,\n        },\n    }\n    notifications_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_notifications,\n        count_args,\n        self._query_notifications,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return notifications_generator\n    return list(notifications_generator)\n</code></pre>"},{"location":"sdk/organization/","title":"Organization module","text":""},{"location":"sdk/organization/#queries","title":"Queries","text":"<p>Set of Organization queries</p>  Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>class QueriesOrganization:\n    \"\"\"\n    Set of Organization queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n        Args:\n            email : Email of a user of the organization\n            organization_id : Identifier of the organization\n            fields: All the fields to request among the possible fields for the organizations.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n            first: Maximum number of organizations to return.\n            skip: Number of skipped organizations (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the organizations is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n            [{'users': [{'email': 'john@doe.com'}]}]\n        \"\"\"\n\n        count_args = {\"email\": email, \"organization_id\": organization_id}\n        disable_tqdm = disable_tqdm or as_generator\n\n        payload_query = {\n            \"where\": {\n                \"id\": organization_id,\n                \"user\": {\n                    \"email\": email,\n                },\n            }\n        }\n\n        organizations_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_organizations,\n            count_args,\n            self._query_organizations,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return organizations_generator\n        return list(organizations_generator)\n\n    def _query_organizations(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_organizations = gql_organizations(fragment_builder(fields, Organization))\n        result = self.auth.client.execute(_gql_organizations, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_organizations(\n        self, email: Optional[str] = None, organization_id: Optional[str] = None\n    ) -&gt; int:\n        \"\"\"Count organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"id\": organization_id,\n                \"user\": {\n                    \"email\": email,\n                },\n            }\n        }\n        result = self.auth.client.execute(GQL_ORGANIZATIONS_COUNT, variables)\n        return format_result(\"data\", result, int)\n\n    @typechecked\n    def organization_metrics(\n        self,\n        organization_id: str,\n        start_date: datetime,\n        end_date: datetime,\n    ):\n        \"\"\"Get organization metrics.\n\n        Args:\n            organization_id: Identifier of the organization\n            start_date: Start date of the metrics computation\n            end_date: End date of the metrics computation\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        if start_date is None:\n            start_date = datetime.now()\n        if end_date is None:\n            end_date = datetime.now()\n        variables = {\n            \"where\": {\n                \"organizationId\": organization_id,\n                \"startDate\": start_date.isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n                \"endDate\": end_date.isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n            }\n        }\n        result = self.auth.client.execute(GQL_ORGANIZATION_METRICS, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","title":"<code>count_organizations(self, email=None, organization_id=None)</code>","text":"<p>Count organizations that match a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code>   <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p>     Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef count_organizations(\n    self, email: Optional[str] = None, organization_id: Optional[str] = None\n) -&gt; int:\n    \"\"\"Count organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"id\": organization_id,\n            \"user\": {\n                \"email\": email,\n            },\n        }\n    }\n    result = self.auth.client.execute(GQL_ORGANIZATIONS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","title":"<code>organization_metrics(self, organization_id, start_date, end_date)</code>","text":"<p>Get organization metrics.</p> <p>Parameters:</p>    Name Type Description Default     <code>organization_id</code> <code>str</code> <p>Identifier of the organization</p> required   <code>start_date</code> <code>datetime</code> <p>Start date of the metrics computation</p> required   <code>end_date</code> <code>datetime</code> <p>End date of the metrics computation</p> required    <p>Returns:</p>    Type Description      <p>A result object which contains the query if it was successful,     or an error message.</p>     Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organization_metrics(\n    self,\n    organization_id: str,\n    start_date: datetime,\n    end_date: datetime,\n):\n    \"\"\"Get organization metrics.\n\n    Args:\n        organization_id: Identifier of the organization\n        start_date: Start date of the metrics computation\n        end_date: End date of the metrics computation\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    if start_date is None:\n        start_date = datetime.now()\n    if end_date is None:\n        end_date = datetime.now()\n    variables = {\n        \"where\": {\n            \"organizationId\": organization_id,\n            \"startDate\": start_date.isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n            \"endDate\": end_date.isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n        }\n    }\n    result = self.auth.client.execute(GQL_ORGANIZATION_METRICS, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","title":"<code>organizations(self, email=None, organization_id=None, fields=['id', 'name'], first=None, skip=0, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of organizations that match a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code>  <p>Email of a user of the organization</p> <code>None</code>   <code>organization_id</code>  <p>Identifier of the organization</p> <code>None</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the organizations. See the documentation for all possible fields.</p> <code>['id', 'name']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of organizations to return.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of skipped organizations (they are ordered by creation date)</p> <code>0</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the organizations is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n[{'users': [{'email': 'john@doe.com'}]}]\n</code></pre>  Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organizations(\n    self,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"id\", \"name\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n    Args:\n        email : Email of a user of the organization\n        organization_id : Identifier of the organization\n        fields: All the fields to request among the possible fields for the organizations.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n        first: Maximum number of organizations to return.\n        skip: Number of skipped organizations (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the organizations is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n        [{'users': [{'email': 'john@doe.com'}]}]\n    \"\"\"\n\n    count_args = {\"email\": email, \"organization_id\": organization_id}\n    disable_tqdm = disable_tqdm or as_generator\n\n    payload_query = {\n        \"where\": {\n            \"id\": organization_id,\n            \"user\": {\n                \"email\": email,\n            },\n        }\n    }\n\n    organizations_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_organizations,\n        count_args,\n        self._query_organizations,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return organizations_generator\n    return list(organizations_generator)\n</code></pre>"},{"location":"sdk/project/","title":"Project module","text":""},{"location":"sdk/project/#queries","title":"Queries","text":"<p>Set of Project queries.</p>  Source code in <code>kili/queries/project/__init__.py</code> <pre><code>class QueriesProject:\n    \"\"\"Set of Project queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[Dict], Generator]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of projects that match a set of criteria.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings.\n            updated_at_gte: Returned projects should have a label whose update date is greater or equal\n                to this date.\n            updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n            skip: Number of projects to skip (they are ordered by their creation).\n            fields: All the fields to request among the possible fields for the projects.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n            first: Maximum number of projects to return.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the projects is returned.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; # List all my projects\n            &gt;&gt;&gt; kili.projects()\n        \"\"\"\n\n        saved_args = locals()\n        count_args = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            in [\n                \"project_id\",\n                \"search_query\",\n                \"should_relaunch_kpi_computation\",\n                \"updated_at_gte\",\n                \"updated_at_lte\",\n            ]\n        }\n        disable_tqdm = disable_tqdm or as_generator\n\n        payload_query = {\n            \"where\": {\n                \"id\": project_id,\n                \"searchQuery\": search_query,\n                \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n                \"updatedAtGte\": updated_at_gte,\n                \"updatedAtLte\": updated_at_lte,\n            },\n        }\n\n        projects_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_projects,\n            count_args,\n            self._query_projects,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return projects_generator\n        return list(projects_generator)\n\n    def _query_projects(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_projects = gql_projects(fragment_builder(fields, Project))\n        result = self.auth.client.execute(_gql_projects, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n        \"\"\"\n        Counts the number of projects with a search_query\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot\n                or consensus settings\n            updated_at_gte: Returned projects should have a label\n                whose update date is greater\n                or equal to this date.\n            updated_at_lte: Returned projects should have a label\n                whose update date is lower or equal to this date.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of projects with the parameters provided\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"id\": project_id,\n                \"searchQuery\": search_query,\n                \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n                \"updatedAtGte\": updated_at_gte,\n                \"updatedAtLte\": updated_at_lte,\n            }\n        }\n        result = self.auth.client.execute(GQL_PROJECTS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.count_projects","title":"<code>count_projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None)</code>","text":"<p>Counts the number of projects with a search_query</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code>   <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code>   <code>should_relaunch_kpi_computation</code>  <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code>   <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code>   <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>int</code> <p>The number of projects with the parameters provided</p>     Source code in <code>kili/queries/project/__init__.py</code> <pre><code>@typechecked\ndef count_projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n    \"\"\"\n    Counts the number of projects with a search_query\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot\n            or consensus settings\n        updated_at_gte: Returned projects should have a label\n            whose update date is greater\n            or equal to this date.\n        updated_at_lte: Returned projects should have a label\n            whose update date is lower or equal to this date.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of projects with the parameters provided\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"id\": project_id,\n            \"searchQuery\": search_query,\n            \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n            \"updatedAtGte\": updated_at_gte,\n            \"updatedAtLte\": updated_at_lte,\n        }\n    }\n    result = self.auth.client.execute(GQL_PROJECTS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.projects","title":"<code>projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, skip=0, fields=['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'], first=None, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of projects that match a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code>   <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code>   <code>should_relaunch_kpi_computation</code>  <p>Technical field, added to indicate changes in honeypot or consensus settings.</p> <code>None</code>   <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code>   <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of projects to skip (they are ordered by their creation).</p> <code>0</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projects. See the documentation for all possible fields.</p> <code>['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of projects to return.</p> <code>None</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the projects is returned.</p> <code>False</code>     <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p>  <p>Returns:</p>    Type Description     <code>Union[List[Dict], Generator]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all my projects\n&gt;&gt;&gt; kili.projects()\n</code></pre>  Source code in <code>kili/queries/project/__init__.py</code> <pre><code>@typechecked\ndef projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"consensusTotCoverage\",\n        \"id\",\n        \"inputType\",\n        \"jsonInterface\",\n        \"minConsensusSize\",\n        \"reviewCoverage\",\n        \"roles.id\",\n        \"roles.role\",\n        \"roles.user.email\",\n        \"roles.user.id\",\n        \"title\",\n    ],\n    first: Optional[int] = None,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[Dict], Generator]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of projects that match a set of criteria.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings.\n        updated_at_gte: Returned projects should have a label whose update date is greater or equal\n            to this date.\n        updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n        skip: Number of projects to skip (they are ordered by their creation).\n        fields: All the fields to request among the possible fields for the projects.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n        first: Maximum number of projects to return.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the projects is returned.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; # List all my projects\n        &gt;&gt;&gt; kili.projects()\n    \"\"\"\n\n    saved_args = locals()\n    count_args = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        in [\n            \"project_id\",\n            \"search_query\",\n            \"should_relaunch_kpi_computation\",\n            \"updated_at_gte\",\n            \"updated_at_lte\",\n        ]\n    }\n    disable_tqdm = disable_tqdm or as_generator\n\n    payload_query = {\n        \"where\": {\n            \"id\": project_id,\n            \"searchQuery\": search_query,\n            \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n            \"updatedAtGte\": updated_at_gte,\n            \"updatedAtLte\": updated_at_lte,\n        },\n    }\n\n    projects_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_projects,\n        count_args,\n        self._query_projects,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return projects_generator\n    return list(projects_generator)\n</code></pre>"},{"location":"sdk/project/#mutations","title":"Mutations","text":"<p>Set of Project mutations.</p>  Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>class MutationsProject:\n    \"\"\"Set of Project mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth: KiliAuth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_to_roles(\n        self, project_id: str, user_email: str, role: str = \"LABELER\"\n    ) -&gt; Dict[str, Union[str, dict, list, None]]:\n        \"\"\"Add a user to a project.\n\n        !!! info\n            If the user does not exist in your organization, he/she is invited and added\n                both to your organization and project. This function can also be used to change\n                the role of the user in the project.\n\n        Args:\n            project_id: Identifier of the project\n            user_email: The email of the user.\n                This email is used as the unique identifier of the user.\n            role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n        \"\"\"\n        variables = {\n            \"data\": {\"role\": role, \"userEmail\": user_email},\n            \"where\": {\"id\": project_id},\n        }\n        result = self.auth.client.execute(GQL_APPEND_TO_ROLES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_properties_in_project(\n        self,\n        project_id: str,\n        can_navigate_between_assets: Optional[bool] = None,\n        can_skip_asset: Optional[bool] = None,\n        consensus_mark: Optional[float] = None,\n        consensus_tot_coverage: Optional[int] = None,\n        description: Optional[str] = None,\n        honeypot_mark: Optional[float] = None,\n        instructions: Optional[str] = None,\n        input_type: Optional[str] = None,\n        json_interface: Optional[dict] = None,\n        min_consensus_size: Optional[int] = None,\n        number_of_assets: Optional[int] = None,\n        number_of_skipped_assets: Optional[int] = None,\n        number_of_remaining_assets: Optional[int] = None,\n        number_of_reviewed_assets: Optional[int] = None,\n        review_coverage: Optional[int] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        title: Optional[str] = None,\n        use_honeypot: Optional[bool] = None,\n        metadata_types: Optional[dict] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update properties of a project.\n\n        Args:\n            project_id: Identifier of the project.\n            can_navigate_between_assets:\n                Activate / Deactivate the use of next and previous buttons in labeling interface.\n            can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n            consensus_mark: Should be between 0 and 1.\n            consensus_tot_coverage: Should be between 0 and 100.\n                It is the percentage of the dataset that will be annotated several times.\n            description : Description of the project.\n            honeypot_mark : Should be between 0 and 1\n            instructions : Instructions of the project.\n            input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`,\n                `VIDEO`, `VIDEO_LEGACY`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            min_consensus_size: Should be between 1 and 10\n                Number of people that will annotate the same asset, for consensus computation.\n            number_of_assets: Defaults to 0\n            number_of_skipped_assets: Defaults to 0\n            number_of_remaining_assets: Defaults to 0\n            number_of_reviewed_assets: Defaults to 0\n            review_coverage: Allow to set the percentage of assets\n                that will be queued in the review interface.\n                Should be between 0 and 100\n            should_relaunch_kpi_computation: Technical field, added to indicate changes\n                in honeypot or consensus settings\n            title: Title of the project\n            use_honeypot: Activate / Deactivate the use of honeypot in the project\n            metadata_types: Types of the project metadata.\n                Should be a `dict` of metadata fields name as keys and metadata types as values.\n                Currently, possible types are: `string`, `number`\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n        !!! example \"Change Metadata Types\"\n            Metadata fields are by default interpreted as `string` types. To change the type\n            of a metadata field, you can use the `update_properties_in_project` function with the\n            metadata_types argument. `metadata_types` is given as a dict of metadata field names\n            as keys and metadata types as values.\n            Example:\n            ```\n            kili.update_properties_in_project(\n                project_id = project_id,\n                metadata_types = {\n                    'customConsensus': 'number',\n                    'sensitiveData': 'string',\n                    'uploadedFromCloud': 'string',\n                    'modelLabelErrorScore': 'number'\n                }\n            )\n            ```\n            Not providing a type for a metadata field or providing an unsupported one\n            will default to the `string` type.\n        \"\"\"\n        verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n        variables = {\n            \"canNavigateBetweenAssets\": can_navigate_between_assets,\n            \"canSkipAsset\": can_skip_asset,\n            \"consensusMark\": consensus_mark,\n            \"consensusTotCoverage\": consensus_tot_coverage,\n            \"description\": description,\n            \"honeypotMark\": honeypot_mark,\n            \"instructions\": instructions,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n            \"metadataTypes\": metadata_types,\n            \"minConsensusSize\": min_consensus_size,\n            \"numberOfAssets\": number_of_assets,\n            \"numberOfSkippedAssets\": number_of_skipped_assets,\n            \"numberOfRemainingAssets\": number_of_remaining_assets,\n            \"numberOfReviewedAssets\": number_of_reviewed_assets,\n            \"projectID\": project_id,\n            \"reviewCoverage\": review_coverage,\n            \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n            \"title\": title,\n            \"useHoneyPot\": use_honeypot,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        result = format_result(\"data\", result)\n\n        variables.pop(\"projectID\")\n        variables = {k: v for k, v in variables.items() if v is not None}\n\n        new_project_settings = QueriesProject(self.auth).projects(  # type:ignore\n            project_id=project_id, fields=list(variables.keys()), disable_tqdm=True\n        )[0]\n\n        result = {**result, **new_project_settings}\n        return result\n\n    @typechecked\n    def create_project(\n        self,\n        input_type: str,\n        json_interface: dict,\n        title: str,\n        description: str = \"\",\n        project_type: Optional[str] = None,\n    ) -&gt; Dict:\n        # pylint: disable=line-too-long\n        \"\"\"Create a project.\n\n        Args:\n            input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}\n            json_interface: The json parameters of the project, see Edit your interface.\n            title: Title of the project\n            description: Description of the project\n            project_type:\n                Currently, one of {\n                    `IMAGE_CLASSIFICATION_SINGLE`,\n                    `IMAGE_CLASSIFICATION_MULTI`,\n                    `IMAGE_OBJECT_DETECTION_RECTANGLE`,\n                    `IMAGE_OBJECT_DETECTION_POLYGON`,\n                    `IMAGE_OBJECT_DETECTION_SEMANTIC`,\n                    `OCR, PDF_CLASSIFICATION_SINGLE`,\n                    `PDF_CLASSIFICATION_MULTI`,\n                    `TEXT_CLASSIFICATION_SINGLE`,\n                    `TEXT_CLASSIFICATION_MULTI`,\n                    `TEXT_TRANSCRIPTION, TEXT_NER`,\n                    `VIDEO_CLASSIFICATION_SINGLE`,\n                    `VIDEO_FRAME_CLASSIFICATION`,\n                    `VIDEO_FRAME_OBJECT_TRACKING`,\n                    `SPEECH_TO_TEXT`\n                }\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create projects,\n                see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"description\": description,\n                \"inputType\": input_type,\n                \"jsonInterface\": dumps(json_interface),\n                \"projectType\": project_type,\n                \"title\": title,\n            }\n        }\n        result = self.auth.client.execute(GQL_CREATE_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n        \"\"\"Update properties of a role.\n\n        !!! info\n            To be able to change someone's role, you must be either of:\n\n            - an admin of the project\n            - a team manager of the project\n            - an admin of the organization\n\n        Args:\n            role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n            project_id: Identifier of the project\n            user_id: The email or identifier of the user with updated role\n            role: The new role.\n                Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"roleID\": role_id,\n            \"projectID\": project_id,\n            \"userID\": user_id,\n            \"role\": role,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_from_roles(self, role_id: str):\n        \"\"\"Delete users by their role_id.\n\n        Args:\n            role_id: Identifier of the project user (not the ID of the user)\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": role_id}}\n        result = self.auth.client.execute(GQL_DELETE_FROM_ROLES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def internal_delete_project(self, project_id: str):\n        \"\"\"Delete project permanently.\n        WARNING: This resolver is for internal use by Kili Technology only.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"projectID\": project_id}\n        result = self.auth.client.execute(GQL_DELETE_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_project(self, project_id: str) -&gt; str:\n        \"\"\"\n        Delete a project permanently.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": project_id}}\n        result = self.auth.client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def archive_project(self, project_id: str):\n        \"\"\"\n        Archive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": True,\n        }\n\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def unarchive_project(self, project_id: str):\n        \"\"\"\n        Unarchive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": False,\n        }\n\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def copy_project(  # pylint: disable=too-many-arguments\n        self,\n        from_project_id: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        copy_json_interface: bool = True,\n        copy_quality_settings: bool = True,\n        copy_members: bool = True,\n    ) -&gt; str:\n        \"\"\"Copy an existing project.\n\n        Copy an existing source project from its ID.\n\n        Args:\n            from_project_id: Project ID to copy from.\n            title: Title for the new project. Defaults to source project\n                title if `None` is provided.\n            description: Description for the new project. Defaults to empty string\n                if `None` is provided.\n            copy_json_interface: Copy the json interface from the source project to the new one.\n            copy_quality_settings: Copy the quality settings from the source project to the new one.\n            copy_members: Copy the members from the source project to the new one.\n\n        Returns:\n            The created project ID.\n\n        Examples:\n            &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n        \"\"\"\n        return CopyProject(self.auth).copy_project(\n            from_project_id,\n            title,\n            description,\n            copy_json_interface,\n            copy_quality_settings,\n            copy_members,\n        )\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","title":"<code>append_to_roles(self, project_id, user_email, role='LABELER')</code>","text":"<p>Add a user to a project.</p>  <p>Info</p> <p>If the user does not exist in your organization, he/she is invited and added     both to your organization and project. This function can also be used to change     the role of the user in the project.</p>  <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>user_email</code> <code>str</code> <p>The email of the user. This email is used as the unique identifier of the user.</p> required   <code>role</code> <code>str</code> <p>One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.</p> <code>'LABELER'</code>    <p>Returns:</p>    Type Description     <code>Dict[str, Union[str, dict, list]]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n</code></pre>  Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef append_to_roles(\n    self, project_id: str, user_email: str, role: str = \"LABELER\"\n) -&gt; Dict[str, Union[str, dict, list, None]]:\n    \"\"\"Add a user to a project.\n\n    !!! info\n        If the user does not exist in your organization, he/she is invited and added\n            both to your organization and project. This function can also be used to change\n            the role of the user in the project.\n\n    Args:\n        project_id: Identifier of the project\n        user_email: The email of the user.\n            This email is used as the unique identifier of the user.\n        role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n    \"\"\"\n    variables = {\n        \"data\": {\"role\": role, \"userEmail\": user_email},\n        \"where\": {\"id\": project_id},\n    }\n    result = self.auth.client.execute(GQL_APPEND_TO_ROLES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.archive_project","title":"<code>archive_project(self, project_id)</code>","text":"<p>Archive a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef archive_project(self, project_id: str):\n    \"\"\"\n    Archive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": True,\n    }\n\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.copy_project","title":"<code>copy_project(self, from_project_id, title=None, description=None, copy_json_interface=True, copy_quality_settings=True, copy_members=True)</code>","text":"<p>Copy an existing project.</p> <p>Copy an existing source project from its ID.</p> <p>Parameters:</p>    Name Type Description Default     <code>from_project_id</code> <code>str</code> <p>Project ID to copy from.</p> required   <code>title</code> <code>Optional[str]</code> <p>Title for the new project. Defaults to source project title if <code>None</code> is provided.</p> <code>None</code>   <code>description</code> <code>Optional[str]</code> <p>Description for the new project. Defaults to empty string if <code>None</code> is provided.</p> <code>None</code>   <code>copy_json_interface</code> <code>bool</code> <p>Copy the json interface from the source project to the new one.</p> <code>True</code>   <code>copy_quality_settings</code> <code>bool</code> <p>Copy the quality settings from the source project to the new one.</p> <code>True</code>   <code>copy_members</code> <code>bool</code> <p>Copy the members from the source project to the new one.</p> <code>True</code>    <p>Returns:</p>    Type Description     <code>str</code> <p>The created project ID.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n</code></pre>  Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef copy_project(  # pylint: disable=too-many-arguments\n    self,\n    from_project_id: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    copy_json_interface: bool = True,\n    copy_quality_settings: bool = True,\n    copy_members: bool = True,\n) -&gt; str:\n    \"\"\"Copy an existing project.\n\n    Copy an existing source project from its ID.\n\n    Args:\n        from_project_id: Project ID to copy from.\n        title: Title for the new project. Defaults to source project\n            title if `None` is provided.\n        description: Description for the new project. Defaults to empty string\n            if `None` is provided.\n        copy_json_interface: Copy the json interface from the source project to the new one.\n        copy_quality_settings: Copy the quality settings from the source project to the new one.\n        copy_members: Copy the members from the source project to the new one.\n\n    Returns:\n        The created project ID.\n\n    Examples:\n        &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n    \"\"\"\n    return CopyProject(self.auth).copy_project(\n        from_project_id,\n        title,\n        description,\n        copy_json_interface,\n        copy_quality_settings,\n        copy_members,\n    )\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.create_project","title":"<code>create_project(self, input_type, json_interface, title, description='', project_type=None)</code>","text":"<p>Create a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>input_type</code> <code>str</code> <p>Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}</p> required   <code>json_interface</code> <code>dict</code> <p>The json parameters of the project, see Edit your interface.</p> required   <code>title</code> <code>str</code> <p>Title of the project</p> required   <code>description</code> <code>str</code> <p>Description of the project</p> <code>''</code>   <code>project_type</code> <code>Optional[str]</code> <p>Currently, one of {     <code>IMAGE_CLASSIFICATION_SINGLE</code>,     <code>IMAGE_CLASSIFICATION_MULTI</code>,     <code>IMAGE_OBJECT_DETECTION_RECTANGLE</code>,     <code>IMAGE_OBJECT_DETECTION_POLYGON</code>,     <code>IMAGE_OBJECT_DETECTION_SEMANTIC</code>,     <code>OCR, PDF_CLASSIFICATION_SINGLE</code>,     <code>PDF_CLASSIFICATION_MULTI</code>,     <code>TEXT_CLASSIFICATION_SINGLE</code>,     <code>TEXT_CLASSIFICATION_MULTI</code>,     <code>TEXT_TRANSCRIPTION, TEXT_NER</code>,     <code>VIDEO_CLASSIFICATION_SINGLE</code>,     <code>VIDEO_FRAME_CLASSIFICATION</code>,     <code>VIDEO_FRAME_OBJECT_TRACKING</code>,     <code>SPEECH_TO_TEXT</code> }</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Dict</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n</code></pre>  <p>Recipe</p> <p>For more detailed examples on how to create projects,     see the recipe.</p>   Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef create_project(\n    self,\n    input_type: str,\n    json_interface: dict,\n    title: str,\n    description: str = \"\",\n    project_type: Optional[str] = None,\n) -&gt; Dict:\n    # pylint: disable=line-too-long\n    \"\"\"Create a project.\n\n    Args:\n        input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}\n        json_interface: The json parameters of the project, see Edit your interface.\n        title: Title of the project\n        description: Description of the project\n        project_type:\n            Currently, one of {\n                `IMAGE_CLASSIFICATION_SINGLE`,\n                `IMAGE_CLASSIFICATION_MULTI`,\n                `IMAGE_OBJECT_DETECTION_RECTANGLE`,\n                `IMAGE_OBJECT_DETECTION_POLYGON`,\n                `IMAGE_OBJECT_DETECTION_SEMANTIC`,\n                `OCR, PDF_CLASSIFICATION_SINGLE`,\n                `PDF_CLASSIFICATION_MULTI`,\n                `TEXT_CLASSIFICATION_SINGLE`,\n                `TEXT_CLASSIFICATION_MULTI`,\n                `TEXT_TRANSCRIPTION, TEXT_NER`,\n                `VIDEO_CLASSIFICATION_SINGLE`,\n                `VIDEO_FRAME_CLASSIFICATION`,\n                `VIDEO_FRAME_OBJECT_TRACKING`,\n                `SPEECH_TO_TEXT`\n            }\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create projects,\n            see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"description\": description,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface),\n            \"projectType\": project_type,\n            \"title\": title,\n        }\n    }\n    result = self.auth.client.execute(GQL_CREATE_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","title":"<code>delete_from_roles(self, role_id)</code>","text":"<p>Delete users by their role_id.</p> <p>Parameters:</p>    Name Type Description Default     <code>role_id</code> <code>str</code> <p>Identifier of the project user (not the ID of the user)</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_from_roles(self, role_id: str):\n    \"\"\"Delete users by their role_id.\n\n    Args:\n        role_id: Identifier of the project user (not the ID of the user)\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": role_id}}\n    result = self.auth.client.execute(GQL_DELETE_FROM_ROLES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_project","title":"<code>delete_project(self, project_id)</code>","text":"<p>Delete a project permanently.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required    <p>Returns:</p>    Type Description     <code>str</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_project(self, project_id: str) -&gt; str:\n    \"\"\"\n    Delete a project permanently.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": project_id}}\n    result = self.auth.client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.unarchive_project","title":"<code>unarchive_project(self, project_id)</code>","text":"<p>Unarchive a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef unarchive_project(self, project_id: str):\n    \"\"\"\n    Unarchive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": False,\n    }\n\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","title":"<code>update_properties_in_project(self, project_id, can_navigate_between_assets=None, can_skip_asset=None, consensus_mark=None, consensus_tot_coverage=None, description=None, honeypot_mark=None, instructions=None, input_type=None, json_interface=None, min_consensus_size=None, number_of_assets=None, number_of_skipped_assets=None, number_of_remaining_assets=None, number_of_reviewed_assets=None, review_coverage=None, should_relaunch_kpi_computation=None, title=None, use_honeypot=None, metadata_types=None)</code>","text":"<p>Update properties of a project.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required   <code>can_navigate_between_assets</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of next and previous buttons in labeling interface.</p> <code>None</code>   <code>can_skip_asset</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of skip button in labeling interface.</p> <code>None</code>   <code>consensus_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1.</p> <code>None</code>   <code>consensus_tot_coverage</code> <code>Optional[int]</code> <p>Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times.</p> <code>None</code>   <code>description</code>  <p>Description of the project.</p> <code>None</code>   <code>honeypot_mark</code>  <p>Should be between 0 and 1</p> <code>None</code>   <code>instructions</code>  <p>Instructions of the project.</p> <code>None</code>   <code>input_type</code> <code>Optional[str]</code> <p>Currently, one of <code>AUDIO</code>, <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code>, <code>VIDEO</code>, <code>VIDEO_LEGACY</code>.</p> <code>None</code>   <code>json_interface</code> <code>Optional[dict]</code> <p>The json parameters of the project, see Edit your interface.</p> <code>None</code>   <code>min_consensus_size</code> <code>Optional[int]</code> <p>Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation.</p> <code>None</code>   <code>number_of_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code>   <code>number_of_skipped_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code>   <code>number_of_remaining_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code>   <code>number_of_reviewed_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code>   <code>review_coverage</code> <code>Optional[int]</code> <p>Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100</p> <code>None</code>   <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code>   <code>title</code> <code>Optional[str]</code> <p>Title of the project</p> <code>None</code>   <code>use_honeypot</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of honeypot in the project</p> <code>None</code>   <code>metadata_types</code> <code>Optional[dict]</code> <p>Types of the project metadata. Should be a <code>dict</code> of metadata fields name as keys and metadata types as values. Currently, possible types are: <code>string</code>, <code>number</code></p> <code>None</code>    <p>Returns:</p>    Type Description     <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n</code></pre>  <p>Change Metadata Types</p> <p>Metadata fields are by default interpreted as <code>string</code> types. To change the type of a metadata field, you can use the <code>update_properties_in_project</code> function with the metadata_types argument. <code>metadata_types</code> is given as a dict of metadata field names as keys and metadata types as values. Example: <pre><code>kili.update_properties_in_project(\n    project_id = project_id,\n    metadata_types = {\n        'customConsensus': 'number',\n        'sensitiveData': 'string',\n        'uploadedFromCloud': 'string',\n        'modelLabelErrorScore': 'number'\n    }\n)\n</code></pre> Not providing a type for a metadata field or providing an unsupported one will default to the <code>string</code> type.</p>   Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project(\n    self,\n    project_id: str,\n    can_navigate_between_assets: Optional[bool] = None,\n    can_skip_asset: Optional[bool] = None,\n    consensus_mark: Optional[float] = None,\n    consensus_tot_coverage: Optional[int] = None,\n    description: Optional[str] = None,\n    honeypot_mark: Optional[float] = None,\n    instructions: Optional[str] = None,\n    input_type: Optional[str] = None,\n    json_interface: Optional[dict] = None,\n    min_consensus_size: Optional[int] = None,\n    number_of_assets: Optional[int] = None,\n    number_of_skipped_assets: Optional[int] = None,\n    number_of_remaining_assets: Optional[int] = None,\n    number_of_reviewed_assets: Optional[int] = None,\n    review_coverage: Optional[int] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    title: Optional[str] = None,\n    use_honeypot: Optional[bool] = None,\n    metadata_types: Optional[dict] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update properties of a project.\n\n    Args:\n        project_id: Identifier of the project.\n        can_navigate_between_assets:\n            Activate / Deactivate the use of next and previous buttons in labeling interface.\n        can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n        consensus_mark: Should be between 0 and 1.\n        consensus_tot_coverage: Should be between 0 and 100.\n            It is the percentage of the dataset that will be annotated several times.\n        description : Description of the project.\n        honeypot_mark : Should be between 0 and 1\n        instructions : Instructions of the project.\n        input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`,\n            `VIDEO`, `VIDEO_LEGACY`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        min_consensus_size: Should be between 1 and 10\n            Number of people that will annotate the same asset, for consensus computation.\n        number_of_assets: Defaults to 0\n        number_of_skipped_assets: Defaults to 0\n        number_of_remaining_assets: Defaults to 0\n        number_of_reviewed_assets: Defaults to 0\n        review_coverage: Allow to set the percentage of assets\n            that will be queued in the review interface.\n            Should be between 0 and 100\n        should_relaunch_kpi_computation: Technical field, added to indicate changes\n            in honeypot or consensus settings\n        title: Title of the project\n        use_honeypot: Activate / Deactivate the use of honeypot in the project\n        metadata_types: Types of the project metadata.\n            Should be a `dict` of metadata fields name as keys and metadata types as values.\n            Currently, possible types are: `string`, `number`\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n    !!! example \"Change Metadata Types\"\n        Metadata fields are by default interpreted as `string` types. To change the type\n        of a metadata field, you can use the `update_properties_in_project` function with the\n        metadata_types argument. `metadata_types` is given as a dict of metadata field names\n        as keys and metadata types as values.\n        Example:\n        ```\n        kili.update_properties_in_project(\n            project_id = project_id,\n            metadata_types = {\n                'customConsensus': 'number',\n                'sensitiveData': 'string',\n                'uploadedFromCloud': 'string',\n                'modelLabelErrorScore': 'number'\n            }\n        )\n        ```\n        Not providing a type for a metadata field or providing an unsupported one\n        will default to the `string` type.\n    \"\"\"\n    verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n    variables = {\n        \"canNavigateBetweenAssets\": can_navigate_between_assets,\n        \"canSkipAsset\": can_skip_asset,\n        \"consensusMark\": consensus_mark,\n        \"consensusTotCoverage\": consensus_tot_coverage,\n        \"description\": description,\n        \"honeypotMark\": honeypot_mark,\n        \"instructions\": instructions,\n        \"inputType\": input_type,\n        \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n        \"metadataTypes\": metadata_types,\n        \"minConsensusSize\": min_consensus_size,\n        \"numberOfAssets\": number_of_assets,\n        \"numberOfSkippedAssets\": number_of_skipped_assets,\n        \"numberOfRemainingAssets\": number_of_remaining_assets,\n        \"numberOfReviewedAssets\": number_of_reviewed_assets,\n        \"projectID\": project_id,\n        \"reviewCoverage\": review_coverage,\n        \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n        \"title\": title,\n        \"useHoneyPot\": use_honeypot,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    result = format_result(\"data\", result)\n\n    variables.pop(\"projectID\")\n    variables = {k: v for k, v in variables.items() if v is not None}\n\n    new_project_settings = QueriesProject(self.auth).projects(  # type:ignore\n        project_id=project_id, fields=list(variables.keys()), disable_tqdm=True\n    )[0]\n\n    result = {**result, **new_project_settings}\n    return result\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","title":"<code>update_properties_in_role(self, role_id, project_id, user_id, role)</code>","text":"<p>Update properties of a role.</p>  <p>Info</p> <p>To be able to change someone's role, you must be either of:</p> <ul> <li>an admin of the project</li> <li>a team manager of the project</li> <li>an admin of the organization</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>role_id</code> <code>str</code> <p>Role identifier of the user. E.g. : 'to-be-deactivated'</p> required   <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>user_id</code> <code>str</code> <p>The email or identifier of the user with updated role</p> required   <code>role</code> <code>str</code> <p>The new role. Possible choices are: <code>ADMIN</code>, <code>TEAM_MANAGER</code>, <code>REVIEWER</code>, <code>LABELER</code></p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n    \"\"\"Update properties of a role.\n\n    !!! info\n        To be able to change someone's role, you must be either of:\n\n        - an admin of the project\n        - a team manager of the project\n        - an admin of the organization\n\n    Args:\n        role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n        project_id: Identifier of the project\n        user_id: The email or identifier of the user with updated role\n        role: The new role.\n            Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"roleID\": role_id,\n        \"projectID\": project_id,\n        \"userID\": user_id,\n        \"role\": role,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_user/","title":"Project User module","text":""},{"location":"sdk/project_user/#queries","title":"Queries","text":"<p>Set of ProjectUser queries.</p>  Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>class QueriesProjectUser:\n    \"\"\"Set of ProjectUser queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value,invalid-name\n    @typechecked\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,  # pylint: disable=redefined-builtin\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Return project users (possibly with their KPIs) that match a set of criteria\n\n\n        Args:\n            project_id: Identifier of the project\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the projectUsers\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of project users to skip\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # Retrieve consensus marks of all users in project\n            &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n            ```\n        \"\"\"\n        count_args = {\n            \"email\": email,\n            \"id\": id,\n            \"organization_id\": organization_id,\n            \"project_id\": project_id,\n        }\n        disable_tqdm = disable_tqdm or as_generator\n        payload_query = {\n            \"where\": {\n                \"id\": id,\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"user\": {\n                    \"email\": email,\n                    \"organization\": {\n                        \"id\": organization_id,\n                    },\n                },\n            }\n        }\n\n        project_users_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_project_users,\n            count_args,\n            self._query_project_users,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return project_users_generator\n        return list(project_users_generator)\n\n    def _query_project_users(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_project_users = gql_project_users(fragment_builder(fields, ProjectUser))\n        result = self.auth.client.execute(_gql_project_users, payload)\n        return format_result(\"data\", result)\n\n    # pylint: disable=invalid-name\n    @typechecked\n    def count_project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,  # pylint: disable=redefined-builtin\n        organization_id: Optional[str] = None,\n    ) -&gt; int:\n        \"\"\"\n        Counts the number of projects and their users that match a set of criteria\n\n        Args:\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            project_id: Identifier of the project\n\n        Returns:\n            The number of project users with the parameters provided\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"id\": id,\n                \"project\": {\n                    \"id\": project_id,\n                },\n                \"user\": {\n                    \"email\": email,\n                    \"organization\": {\n                        \"id\": organization_id,\n                    },\n                },\n            }\n        }\n        result = self.auth.client.execute(GQL_PROJECT_USERS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","title":"<code>count_project_users(self, project_id, email=None, id=None, organization_id=None)</code>","text":"<p>Counts the number of projects and their users that match a set of criteria</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code>   <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code>   <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required    <p>Returns:</p>    Type Description     <code>int</code> <p>The number of project users with the parameters provided</p>     Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef count_project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,  # pylint: disable=redefined-builtin\n    organization_id: Optional[str] = None,\n) -&gt; int:\n    \"\"\"\n    Counts the number of projects and their users that match a set of criteria\n\n    Args:\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        project_id: Identifier of the project\n\n    Returns:\n        The number of project users with the parameters provided\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"id\": id,\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"user\": {\n                \"email\": email,\n                \"organization\": {\n                    \"id\": organization_id,\n                },\n            },\n        }\n    }\n    result = self.auth.client.execute(GQL_PROJECT_USERS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","title":"<code>project_users(self, project_id, email=None, id=None, organization_id=None, fields=['activated', 'id', 'role', 'starred', 'user.email', 'user.id'], first=None, skip=0, disable_tqdm=False, as_generator=False)</code>","text":"<p>Return project users (possibly with their KPIs) that match a set of criteria</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required   <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code>   <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields.</p> <code>['activated', 'id', 'role', 'starred', 'user.email', 'user.id']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of project users to skip</p> <code>0</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project users is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code># Retrieve consensus marks of all users in project\n&gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n</code></pre>  Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,  # pylint: disable=redefined-builtin\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\n        \"activated\",\n        \"id\",\n        \"role\",\n        \"starred\",\n        \"user.email\",\n        \"user.id\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Return project users (possibly with their KPIs) that match a set of criteria\n\n\n    Args:\n        project_id: Identifier of the project\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the projectUsers\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of project users to skip\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # Retrieve consensus marks of all users in project\n        &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n        ```\n    \"\"\"\n    count_args = {\n        \"email\": email,\n        \"id\": id,\n        \"organization_id\": organization_id,\n        \"project_id\": project_id,\n    }\n    disable_tqdm = disable_tqdm or as_generator\n    payload_query = {\n        \"where\": {\n            \"id\": id,\n            \"project\": {\n                \"id\": project_id,\n            },\n            \"user\": {\n                \"email\": email,\n                \"organization\": {\n                    \"id\": organization_id,\n                },\n            },\n        }\n    }\n\n    project_users_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_project_users,\n        count_args,\n        self._query_project_users,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return project_users_generator\n    return list(project_users_generator)\n</code></pre>"},{"location":"sdk/project_version/","title":"Project Version module","text":""},{"location":"sdk/project_version/#queries","title":"Queries","text":"<p>Set of ProjectVersion queries.</p>  Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>class QueriesProjectVersion:\n    \"\"\"Set of ProjectVersion queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n        Args:\n            project_id: Filter on Id of project\n            fields: All the fields to request among the possible fields for the project versions\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n            first: Number of project versions to query\n            skip: Number of project versions to skip (they are ordered by their date\n                of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project versions is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        count_args = {\"project_id\": project_id}\n        disable_tqdm = disable_tqdm or as_generator\n        payload_query = {\n            \"where\": {\n                \"projectId\": project_id,\n            },\n        }\n        project_versions_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_project_versions,\n            count_args,\n            self._query_project_versions,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return project_versions_generator\n        return list(project_versions_generator)\n\n    def _query_project_versions(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_project_version = gql_project_version(fragment_builder(fields, ProjectVersionType))\n        result = self.auth.client.execute(_gql_project_version, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_project_versions(self, project_id: str) -&gt; int:\n        \"\"\"Count the number of project versions.\n\n        Args:\n            project_id: Filter on ID of project\n\n        Returns:\n            The number of project versions with the parameters provided\n        \"\"\"\n        variables = {\n            \"where\": {\"projectId\": project_id},\n        }\n        result = self.auth.client.execute(GQL_PROJECT_VERSION_COUNT, variables)\n        count = format_result(\"data\", result)\n        return int(count)\n</code></pre>"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","title":"<code>count_project_versions(self, project_id)</code>","text":"<p>Count the number of project versions.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Filter on ID of project</p> required    <p>Returns:</p>    Type Description     <code>int</code> <p>The number of project versions with the parameters provided</p>     Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef count_project_versions(self, project_id: str) -&gt; int:\n    \"\"\"Count the number of project versions.\n\n    Args:\n        project_id: Filter on ID of project\n\n    Returns:\n        The number of project versions with the parameters provided\n    \"\"\"\n    variables = {\n        \"where\": {\"projectId\": project_id},\n    }\n    result = self.auth.client.execute(GQL_PROJECT_VERSION_COUNT, variables)\n    count = format_result(\"data\", result)\n    return int(count)\n</code></pre>"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","title":"<code>project_version(self, project_id, first=None, skip=0, fields=['createdAt', 'id', 'content', 'name', 'projectId'], disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of project versions respecting a set of criteria.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_id</code> <code>str</code> <p>Filter on Id of project</p> required   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the project versions See the documentation for all possible fields.</p> <code>['createdAt', 'id', 'content', 'name', 'projectId']</code>   <code>first</code> <code>Optional[int]</code> <p>Number of project versions to query</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of project versions to skip (they are ordered by their date of creation, first to last).</p> <code>0</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project versions is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>     Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef project_version(\n    self,\n    project_id: str,\n    first: Optional[int] = None,\n    skip: int = 0,\n    fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n    Args:\n        project_id: Filter on Id of project\n        fields: All the fields to request among the possible fields for the project versions\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n        first: Number of project versions to query\n        skip: Number of project versions to skip (they are ordered by their date\n            of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project versions is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    count_args = {\"project_id\": project_id}\n    disable_tqdm = disable_tqdm or as_generator\n    payload_query = {\n        \"where\": {\n            \"projectId\": project_id,\n        },\n    }\n    project_versions_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_project_versions,\n        count_args,\n        self._query_project_versions,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return project_versions_generator\n    return list(project_versions_generator)\n</code></pre>"},{"location":"sdk/project_version/#mutations","title":"Mutations","text":"<p>Set of ProjectVersion mutations.</p>  Source code in <code>kili/mutations/project_version/__init__.py</code> <pre><code>class MutationsProjectVersion:\n    \"\"\"Set of ProjectVersion mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n        \"\"\"Update properties of a project version.\n\n        Args:\n            project_version_id: Identifier of the project version\n            content: Link to download the project version\n\n        Returns:\n            A result object which indicates if the mutation was successful.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project_version(\n                    project_version_id=project_version_id,\n                    content='test')\n        \"\"\"\n        variables = {\n            \"content\": content,\n            \"id\": project_version_id,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","title":"<code>update_properties_in_project_version(self, project_version_id, content)</code>","text":"<p>Update properties of a project version.</p> <p>Parameters:</p>    Name Type Description Default     <code>project_version_id</code> <code>str</code> <p>Identifier of the project version</p> required   <code>content</code> <code>Optional[str]</code> <p>Link to download the project version</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful.</p>    <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project_version(\n        project_version_id=project_version_id,\n        content='test')\n</code></pre>  Source code in <code>kili/mutations/project_version/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n    \"\"\"Update properties of a project version.\n\n    Args:\n        project_version_id: Identifier of the project version\n        content: Link to download the project version\n\n    Returns:\n        A result object which indicates if the mutation was successful.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project_version(\n                project_version_id=project_version_id,\n                content='test')\n    \"\"\"\n    variables = {\n        \"content\": content,\n        \"id\": project_version_id,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/","title":"User module","text":""},{"location":"sdk/user/#queries","title":"Queries","text":"<p>Set of User queries.</p>  Source code in <code>kili/queries/user/__init__.py</code> <pre><code>class QueriesUser:\n    \"\"\"Set of User queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        as_generator: bool = False,\n    ) -&gt; Union[List[dict], Generator[dict, None, None]]:\n        # pylint: disable=line-too-long\n        \"\"\"Get a generator or a list of users given a set of criteria\n\n        Args:\n            api_key: Query an user by its API Key\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the users.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of skipped users (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # List all users in my organization\n            &gt;&gt;&gt; organization = kili.organizations()\n            &gt;&gt;&gt; organization_id = organizations[0]['id]\n            &gt;&gt;&gt; kili.users(organization_id=organization_id)\n            ```\n        \"\"\"\n\n        count_args = {\"organization_id\": organization_id}\n        disable_tqdm = disable_tqdm or as_generator or (api_key or email) is not None\n        payload_query = {\n            \"where\": {\n                \"apiKey\": api_key,\n                \"email\": email,\n                \"organization\": {\n                    \"id\": organization_id,\n                },\n            }\n        }\n\n        users_generator = row_generator_from_paginated_calls(\n            skip,\n            first,\n            self.count_users,\n            count_args,\n            self._query_users,\n            payload_query,\n            fields,\n            disable_tqdm,\n        )\n\n        if as_generator:\n            return users_generator\n        return list(users_generator)\n\n    def _query_users(self, skip: int, first: int, payload: dict, fields: List[str]):\n        payload.update({\"skip\": skip, \"first\": first})\n        _gql_users = gql_users(fragment_builder(fields, User))\n        result = self.auth.client.execute(_gql_users, payload)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def count_users(self, organization_id: Optional[str] = None) -&gt; int:\n        \"\"\"Get user count based on a set of constraints.\n\n        Args:\n            organization_id: Identifier of the user's organization\n\n        Returns:\n            The number of organizations with the parameters provided\n        \"\"\"\n        variables = {\n            \"where\": {\n                \"organization\": {\n                    \"id\": organization_id,\n                }\n            }\n        }\n        result = self.auth.client.execute(GQL_USERS_COUNT, variables)\n        return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.count_users","title":"<code>count_users(self, organization_id=None)</code>","text":"<p>Get user count based on a set of constraints.</p> <p>Parameters:</p>    Name Type Description Default     <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code>    <p>Returns:</p>    Type Description     <code>int</code> <p>The number of organizations with the parameters provided</p>     Source code in <code>kili/queries/user/__init__.py</code> <pre><code>@typechecked\ndef count_users(self, organization_id: Optional[str] = None) -&gt; int:\n    \"\"\"Get user count based on a set of constraints.\n\n    Args:\n        organization_id: Identifier of the user's organization\n\n    Returns:\n        The number of organizations with the parameters provided\n    \"\"\"\n    variables = {\n        \"where\": {\n            \"organization\": {\n                \"id\": organization_id,\n            }\n        }\n    }\n    result = self.auth.client.execute(GQL_USERS_COUNT, variables)\n    return format_result(\"data\", result, int)\n</code></pre>"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.users","title":"<code>users(self, api_key=None, email=None, organization_id=None, fields=['email', 'id', 'firstname', 'lastname'], first=None, skip=0, disable_tqdm=False, as_generator=False)</code>","text":"<p>Get a generator or a list of users given a set of criteria</p> <p>Parameters:</p>    Name Type Description Default     <code>api_key</code> <code>Optional[str]</code> <p>Query an user by its API Key</p> <code>None</code>   <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code>   <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code>   <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the users. See the documentation for all possible fields.</p> <code>['email', 'id', 'firstname', 'lastname']</code>   <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code>   <code>skip</code> <code>int</code> <p>Number of skipped users (they are ordered by creation date)</p> <code>0</code>   <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code>   <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the users is returned.</p> <code>False</code>    <p>Returns:</p>    Type Description     <code>Union[List[dict], Generator[dict, NoneType]]</code> <p>A result object which contains the query if it was successful,     or an error message.</p>    <p>Examples:</p> <pre><code># List all users in my organization\n&gt;&gt;&gt; organization = kili.organizations()\n&gt;&gt;&gt; organization_id = organizations[0]['id]\n&gt;&gt;&gt; kili.users(organization_id=organization_id)\n</code></pre>  Source code in <code>kili/queries/user/__init__.py</code> <pre><code>@typechecked\ndef users(\n    self,\n    api_key: Optional[str] = None,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    as_generator: bool = False,\n) -&gt; Union[List[dict], Generator[dict, None, None]]:\n    # pylint: disable=line-too-long\n    \"\"\"Get a generator or a list of users given a set of criteria\n\n    Args:\n        api_key: Query an user by its API Key\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the users.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of skipped users (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # List all users in my organization\n        &gt;&gt;&gt; organization = kili.organizations()\n        &gt;&gt;&gt; organization_id = organizations[0]['id]\n        &gt;&gt;&gt; kili.users(organization_id=organization_id)\n        ```\n    \"\"\"\n\n    count_args = {\"organization_id\": organization_id}\n    disable_tqdm = disable_tqdm or as_generator or (api_key or email) is not None\n    payload_query = {\n        \"where\": {\n            \"apiKey\": api_key,\n            \"email\": email,\n            \"organization\": {\n                \"id\": organization_id,\n            },\n        }\n    }\n\n    users_generator = row_generator_from_paginated_calls(\n        skip,\n        first,\n        self.count_users,\n        count_args,\n        self._query_users,\n        payload_query,\n        fields,\n        disable_tqdm,\n    )\n\n    if as_generator:\n        return users_generator\n    return list(users_generator)\n</code></pre>"},{"location":"sdk/user/#mutations","title":"Mutations","text":"<p>Set of User mutations.</p>  Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>class MutationsUser:\n    \"\"\"Set of User mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n        \"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def create_user(\n        self,\n        email: str,\n        password: str,\n        organization_role: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n    ):\n        \"\"\"Add a user to your organization.\n\n        Args:\n            email: Email of the new user, used as user's unique identifier.\n            password: On the first sign in, he will use this password and be able to change it.\n            organization_role: One of \"ADMIN\", \"USER\".\n            firstname: First name of the new user.\n            lastname: Last name of the new user.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"email\": email,\n                \"password\": password,\n                \"organizationRole\": organization_role,\n            }\n        }\n        if firstname is not None:\n            variables[\"data\"][\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"data\"][\"lastname\"] = lastname\n        result = self.auth.client.execute(GQL_CREATE_USER, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_password(\n        self, email: str, old_password: str, new_password_1: str, new_password_2: str\n    ):\n        \"\"\"Allow to modify the password that you use to connect to Kili. \\\n        This resolver only works for on-premise installations without Auth0.\n\n        Args:\n            email : Email of the person whose password has to be updated.\n            old_password : The old password\n            new_password_1: The new password\n            new_password_2: A confirmation field for the new password\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"oldPassword\": old_password,\n                \"newPassword1\": new_password_1,\n                \"newPassword2\": new_password_2,\n            },\n            \"where\": {\"email\": email},\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PASSWORD, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def reset_password(self, email: str):\n        \"\"\"Reset password.\n\n        This resolver only works for on-premise installations without Auth0,\n        if your organization allows Kili to send emails.\n\n        Args:\n            email: Email of the person whose password has to be reset.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"email\": email}}\n        result = self.auth.client.execute(GQL_RESET_PASSWORD, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_properties_in_user(\n        self,\n        email: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        organization_role: Optional[str] = None,\n        activated: Optional[bool] = None,\n    ):\n        \"\"\"Update the properties of a user.\n\n        Args:\n            email: The email is the identifier of the user.\n            firstname:Change the first name of the user.\n            lastname: Change the last name of the user.\n            organization_id: Change the organization the user is related to.\n            organization_role: Change the role of the user.\n                One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n            activated: In case we want to deactivate a user, but keep it.\n\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables: Dict[str, Any] = {\n            \"email\": email,\n        }\n        if firstname is not None:\n            variables[\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"lastname\"] = lastname\n        if organization_id is not None:\n            variables[\"organizationId\"] = organization_id\n        if organization_role is not None:\n            variables[\"organizationRole\"] = organization_role\n        if activated is not None:\n            variables[\"activated\"] = activated\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.create_user","title":"<code>create_user(self, email, password, organization_role, firstname=None, lastname=None)</code>","text":"<p>Add a user to your organization.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code> <code>str</code> <p>Email of the new user, used as user's unique identifier.</p> required   <code>password</code> <code>str</code> <p>On the first sign in, he will use this password and be able to change it.</p> required   <code>organization_role</code> <code>str</code> <p>One of \"ADMIN\", \"USER\".</p> required   <code>firstname</code> <code>Optional[str]</code> <p>First name of the new user.</p> <code>None</code>   <code>lastname</code> <code>Optional[str]</code> <p>Last name of the new user.</p> <code>None</code>    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef create_user(\n    self,\n    email: str,\n    password: str,\n    organization_role: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n):\n    \"\"\"Add a user to your organization.\n\n    Args:\n        email: Email of the new user, used as user's unique identifier.\n        password: On the first sign in, he will use this password and be able to change it.\n        organization_role: One of \"ADMIN\", \"USER\".\n        firstname: First name of the new user.\n        lastname: Last name of the new user.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"email\": email,\n            \"password\": password,\n            \"organizationRole\": organization_role,\n        }\n    }\n    if firstname is not None:\n        variables[\"data\"][\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"data\"][\"lastname\"] = lastname\n    result = self.auth.client.execute(GQL_CREATE_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.reset_password","title":"<code>reset_password(self, email)</code>","text":"<p>Reset password.</p> <p>This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code> <code>str</code> <p>Email of the person whose password has to be reset.</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef reset_password(self, email: str):\n    \"\"\"Reset password.\n\n    This resolver only works for on-premise installations without Auth0,\n    if your organization allows Kili to send emails.\n\n    Args:\n        email: Email of the person whose password has to be reset.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"email\": email}}\n    result = self.auth.client.execute(GQL_RESET_PASSWORD, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_password","title":"<code>update_password(self, email, old_password, new_password_1, new_password_2)</code>","text":"<p>Allow to modify the password that you use to connect to Kili.         This resolver only works for on-premise installations without Auth0.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code>  <p>Email of the person whose password has to be updated.</p> required   <code>old_password</code>  <p>The old password</p> required   <code>new_password_1</code> <code>str</code> <p>The new password</p> required   <code>new_password_2</code> <code>str</code> <p>A confirmation field for the new password</p> required    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_password(\n    self, email: str, old_password: str, new_password_1: str, new_password_2: str\n):\n    \"\"\"Allow to modify the password that you use to connect to Kili. \\\n    This resolver only works for on-premise installations without Auth0.\n\n    Args:\n        email : Email of the person whose password has to be updated.\n        old_password : The old password\n        new_password_1: The new password\n        new_password_2: A confirmation field for the new password\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"oldPassword\": old_password,\n            \"newPassword1\": new_password_1,\n            \"newPassword2\": new_password_2,\n        },\n        \"where\": {\"email\": email},\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PASSWORD, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","title":"<code>update_properties_in_user(self, email, firstname=None, lastname=None, organization_id=None, organization_role=None, activated=None)</code>","text":"<p>Update the properties of a user.</p> <p>Parameters:</p>    Name Type Description Default     <code>email</code> <code>str</code> <p>The email is the identifier of the user.</p> required   <code>firstname</code> <code>Optional[str]</code> <p>Change the first name of the user.</p> <code>None</code>   <code>lastname</code> <code>Optional[str]</code> <p>Change the last name of the user.</p> <code>None</code>   <code>organization_id</code> <code>Optional[str]</code> <p>Change the organization the user is related to.</p> <code>None</code>   <code>organization_role</code> <code>Optional[str]</code> <p>Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".</p> <code>None</code>   <code>activated</code> <code>Optional[bool]</code> <p>In case we want to deactivate a user, but keep it.</p> <code>None</code>    <p>Returns:</p>    Type Description      <p>A result object which indicates if the mutation was successful,     or an error message.</p>     Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_user(\n    self,\n    email: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    organization_role: Optional[str] = None,\n    activated: Optional[bool] = None,\n):\n    \"\"\"Update the properties of a user.\n\n    Args:\n        email: The email is the identifier of the user.\n        firstname:Change the first name of the user.\n        lastname: Change the last name of the user.\n        organization_id: Change the organization the user is related to.\n        organization_role: Change the role of the user.\n            One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n        activated: In case we want to deactivate a user, but keep it.\n\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables: Dict[str, Any] = {\n        \"email\": email,\n    }\n    if firstname is not None:\n        variables[\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"lastname\"] = lastname\n    if organization_id is not None:\n        variables[\"organizationId\"] = organization_id\n    if organization_role is not None:\n        variables[\"organizationRole\"] = organization_role\n    if activated is not None:\n        variables[\"activated\"] = activated\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/","title":"How to export a Kili project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#outline","title":"Outline","text":"<p>This tutorial explains the multiple ways to export a Kili project. It describes a per-label method involving label filtering and conversion, and also the solutions performing a full-project export. The methods are illustrated with code snippets.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","title":"Export methods","text":"<p>With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it:</p> <ul> <li>Fetch the assets and/or the labels one by one using <code>.assets</code> or <code>.labels</code>, perform the data transformation yourself, then write the data to one or several output files.</li> <li>Export the whole project as a dataset. To do that, use the <code>.export_labels</code> method that creates an archive containing the labels in your chosen format.</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","title":"Preliminary steps","text":"<ol> <li>Fetch the project ID from the Kili UI (in Settings / Admin):    </li> <li>Ensure that your Kili API key as been set as an environment variable:  <pre><code>export KILI_API_KEY=&lt;YOUR_API_KEY&gt;\n</code></pre></li> <li> <p>Install Kili if it has not been done already. <pre><code>pip install --upgrade kili\n</code></pre></p> </li> <li> <p>Import packages and instantiate <code>Kili</code>: <pre><code>from kili.client import Kili\nfrom pathlib import Path\nkili = Kili()\n</code></pre></p> </li> </ol>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","title":"Exporting assets and labels one by one","text":"<p>To retrieve all assets of a project one by one, perform the following steps:</p>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","title":"Exporting the latest labels per asset","text":"<ol> <li>First, fetch the assets: <pre><code>assets = kili.assets(\"&lt;your_project_id&gt;\", fields=[\"externalId\", \"latestLabel.jsonResponse\"])\n</code></pre></li> <li>Now if you print an asset, you will see that you can access its <code>latestLabel</code>: <pre><code>print(assets[0])\n{'latestLabel': {'jsonResponse': {'CLASSIFICATION_JOB': {'categories': [{'name': 'VEHICLE'}]}}}, 'externalId': '0'}\n</code></pre></li> <li>You can now get your label this way, and for example write the category name into a <code>0.txt</code> file: <pre><code>for asset in assets:\n    if asset[\"latestLabel\"]: # covers the assets without label\n        class_ = asset[\"latestLabel\"][\"jsonResponse\"][\"CLASSIFICATION_JOB\"][\"categories\"][0][\"name\"]\n        with (Path(\"/tmp\") / (asset[\"externalId\"] + \".txt\")).open(\"w\", encoding=\"utf-8\") as f:\n            f.write(class_)\n</code></pre></li> </ol>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","title":"Filtering specific labels per asset through the method filters","text":"<p>You can specify label filters directly in the <code>.assets</code> and the <code>.labels</code> methods. The available filters are listed in the arguments of these methods.</p> <p>When done, you can write the conversion code to obtain the data in the format that you need.</p> <p>Get only the assets that have labels with a consensus mark above 0.7 <pre><code>assets = kili.assets(\"&lt;your_project_id&gt;\", fields=[\"externalId\", \"labels.jsonResponse\"], label_consensus_mark_gt=0.7)\n# + asset conversion code\n</code></pre></p> <p>Get all the labels with a consensus mark above 0.7 <pre><code>labels = kili.labels(\"&lt;your_project_id&gt;\", fields=[\"labelOf.externalId\", \"jsonResponse\"], consensus_mark_gt=0.7)\n# + label conversion code\n</code></pre></p> <p>Get all the labels done by a specific project member <pre><code>labels = kili.labels(\"&lt;your_project_id&gt;\", fields=[\"labelOf.externalId\", \"jsonResponse\"], author_in=[\"John Smith\"])\n# + label conversion code\n</code></pre> will directly return a list of labels authored by John Smith. In the <code>author_in</code> , you can also pass the first name, the last name, or the first name + last name of the user for which you want to fetch the labels.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","title":"Filtering specific labels per asset through the label properties","text":"<p>You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field <code>\"labels.isLatestReviewLabelForUser\"</code> to check if the label is the latest per user. <pre><code>from kili.client import Kili\nfrom pathlib import Path\nimport json\n\nassets = kili.assets(\"&lt;your_project_id&gt;\", fields=[\"externalId\", \"labels.jsonResponse\", \"labels.isLatestReviewLabelForUser\"])\n\nfor asset in assets:\n    if asset[\"labels\"]: # covers the assets without annotations\n        for label in asset[\"labels\"]:\n            if label[\"isLatestReviewLabelForUser\"] and \"JOB_0\" in label[\"jsonResponse\"]:\n                annotation = label[\"jsonResponse\"][\"JOB_0\"]\n                with (Path(\"/tmp\") / (asset[\"externalId\"] + \".json\")).open(\"w\", encoding=\"utf-8\") as f:\n                    f.write(json.dumps(annotation))\n                break # once we find a latest label done by a reviewer, we move on to the next asset.\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","title":"Filtering the latest label per annotator","text":"<p>When working on project with consensus enabled, it can be useful to export the latest label made by each annotator: <pre><code>from kili.client import Kili\nfrom collections import defaultdict\nfrom pathlib import Path\nimport json\n\n\nkili = Kili()\nassets = kili.assets(\n    \"clb54wfkn01zb0kyadscgaf5j\",\n    fields=[\n        \"externalId\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.labelType\",\n        \"labels.jsonResponse\",\n    ],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:\n        latest_label_by_user = defaultdict(list)\n        for label in asset[\"labels\"]:\n            if label[\"labelType\"] == \"DEFAULT\":\n                latest_label_by_user[label[\"author\"][\"email\"]].append(label)\n        latest_label_per_user = {\n            email: max(labels, key=lambda x: x[\"createdAt\"])\n            for email, labels in latest_label_by_user.items()\n        }\n        with (Path(\"/tmp\") / (asset[\"externalId\"] + \".json\")).open(\"w\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(latest_label_per_user))\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","title":"Exporting a whole project","text":"<p>There is also a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface     Kili (raw) \u2705 \u2705 \u2705   Kili (simple) \u2705 \u274c \u274c   YOLO V4 \u2705 \u2705 \u2705   YOLO V5 \u2705 \u2705 \u2705   YOLO V7 \u274c \u2705 \u2705   Pascal VOC \u2705 \u2705 \u2705   COCO \u274c \u2705 \u2705"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","title":"The <code>.export_labels</code> method","text":"<p>The <code>.export_labels</code> method enables the export of a full project. It does the following preprocessing:</p> <ul> <li>Only fetches the labels of types <code>\"DEFAULT\"</code> and <code>\"REVIEW\"</code> (see the label types explanations).</li> <li>If specified, selects a subset of asset ids.</li> <li>Exports labels to one of the standard formats (only available for a restricted set of ML tasks).</li> <li>The <code>with_assets</code> argument lets you decide if you want to include the assets in the export.</li> <li>The <code>export_type</code> argument tells if the latest label or all the labels are exported.</li> <li>The <code>split_option</code> argument tells if the export contains one folder for all the jobs, or one folder per job.</li> <li>The <code>single_file</code> argument tells if the labels data should be exported into one single file. Note that some formats are single file or multiple files only:<ul> <li>Kili: single file or multiple files.</li> <li>YOLO: multiple files only.</li> <li>Pascal VOC: multiple files only.</li> <li>COCO: single-file only.</li> </ul> </li> </ul> <p>For all the formats, in the output archive, a README.kili.txt file is also created. Here is an example of its contents: <pre><code>Exported Labels from KILI\n=========================\n\n- Project name: Awesome annotation project\n- Project identifier: abcdefghijklmnop\n- Project description: This project contains labels, most of which are awesome.\n- Export date: 20221125-093324\n- Exported format: kili\n- Exported labels: latest\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","title":"Kili format, one file per asset","text":"<p>The following code snippet exports all the assets payloads and the associated labels, with one json file per asset, into the <code>/tmp/export.zip</code> folder. <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;your_project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"kili\",\n)\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","title":"Kili format, one file for the whole project","text":"<p>This code snippet exports the assets payloads and the associated labels in one file for the whole project, into the <code>/tmp/export.zip</code> folder. <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;your_project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"kili\",\n    single_file = True,\n)\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","title":"YOLO formats","text":"<p>You can also export to on of the YOLO format, when you have at least one Object Detection job with bounding boxes. You can choose the <code>\"yolo_v4\"</code>, <code>\"yolo_v5\"</code> or <code>\"yolo_v7\"</code>. The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, it produces one file per asset in the Yolo format, containing the last <code>DEFAULT</code> or <code>REVIEW</code> label that has been produced. Each YOLO label has the following shape: <pre><code>2        0.25 0.67 0.26 0.34\n^        ^    ^    ^    ^\nclass    x    y    w    h\n</code></pre> where:</p> <ul> <li><code>class</code> is the class index in the classes list contained in the YOLO metadata file.</li> <li><code>x</code> is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>y</code> is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>w</code> is the width relative to the image width (between 0.0 and 1.0) of the bounding box.</li> <li><code>h</code> is the height relative to the image height (between 0.0 and 1.0) of the bounding box.</li> </ul> <p>Here is an example of a YOLO annotation over an image:  </p> <p>Here is how to export to YOLO (in this example, YOLOv5): <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;your_project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"yolo_v5\",\n)\n</code></pre></p> <p>Please note that a standard YOLO file format must also include the path root to the assets, and also the <code>train</code>, <code>val</code> and <code>test</code> subfolders. Since this is up to the ML engineer or Data scientist to know which data goes where, we do not provide this layout.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","title":"COCO format","text":"<p>To export your data into the COCO format, run the following code: <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;your_project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"coco\",\n)\n</code></pre></p> <p>This will create an archive containing both:</p> <ul> <li>The COCO annotation file.</li> <li>A folder <code>data/</code> with all the assets.</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#summary","title":"Summary","text":"<p>In this tutorial, we have seen several ways to export labels from a Kili project:</p> <ul> <li>Using <code>.assets</code> and <code>.labels</code> and their filtering arguments, a subset of assets or labels can be selected and then exported.</li> <li>Using <code>.export_labels</code>, the whole project can be exported into a standard output format.</li> </ul>"}]}