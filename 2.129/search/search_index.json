{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with the Kili Python SDK","text":""},{"location":"#what-is-kili","title":"What is Kili?","text":"<p>Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here.</p> <p>If you are looking for the Kili product documentation, it is located here.</p>"},{"location":"#the-kili-python-sdk","title":"The Kili Python SDK","text":"<p>Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>You only need Python 3.7 or higher.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the Kili client with pip:</p> <pre><code>pip install kili\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <ul> <li>Instantiate the Kili client:</li> </ul> <pre><code>from kili.client import Kili\nkili = Kili()\n</code></pre> <p>Info</p> <p>You can also pass the API key as an argument during <code>Kili</code> initialization:</p> <pre><code>kili = Kili(api_key='&lt;you api key value here&gt;')\n</code></pre> <p>Great!</p> <p>You can now begin to use the Kili Python SDK</p>"},{"location":"label_export/","title":"Exporting kili projects","text":"<p>There are several ways to export labels from a Kili project.</p>"},{"location":"label_export/#with-the-cli","title":"With the CLI","text":"<p>You can export a project using the <code>kili project export</code> command: <pre><code>kili project export \\\n--project-id &lt;project_id&gt; \\\n--output-format yolo_v5 \\\n--output-file /tmp/export.zip\n</code></pre> More options here.</p>"},{"location":"label_export/#with-the-python-sdk","title":"With the Python SDK","text":"<p>You can also use the Python SDK: <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\n    project_id = \"&lt;project_id&gt;\",\n    filename = \"/tmp/export.zip\",\n    fmt = \"yolo_v5\",\n)\n</code></pre> More details here.</p>"},{"location":"label_export/#from-the-kili-ui","title":"From the Kili UI","text":"<p>You can refer to this Kili documentation page.</p>"},{"location":"label_export/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 <p>And more to come!</p>"},{"location":"cli/","title":"Getting started with the Kili CLI","text":""},{"location":"cli/#what-is-kili-cli","title":"What is Kili CLI","text":"<p>Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.</p>"},{"location":"cli/#authentication","title":"Authentication","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <p>Info</p> <p>While launching commands, you can also provide you API key through the <code>--api-key</code> option. If you set your api key in the <code>KILI_API_KEY</code> environment variable and provide it once again through the <code>--api-key</code> option, Kili CLI will use the api key value provided in command options.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>The main command is <code>kili</code>. It currently has only one subcommand <code>project</code> that entails all the commands for project management :</p> <pre><code>kili project [COMMAND]\n</code></pre>"},{"location":"cli/#workflow-example","title":"Workflow example","text":"<p>Let's take an example where you want to start a project from scratch  You can download ressources to run this example here. Once in the current directory where all files are stored, you can run the following commands:</p>"},{"location":"cli/#create-a-project","title":"Create a project","text":"<p>To create an IMAGE project:</p> <pre><code>kili project create \\\n            json_interface.json \\\n            --title \"Quality inspection\" \\\n            --input-type IMAGE \\\n            --description \"Steel defects on production line\"\n</code></pre> <p>Ouput:</p> <pre><code>ID                         URL\n&lt;project_id&gt;               https://cloud.kili-technology.com/label/projects/&lt;project_id&gt;/\n</code></pre>"},{"location":"cli/#list-your-projects","title":"List your projects","text":"<pre><code>kili project list --max 10\n</code></pre> <p>Ouput:</p> <pre><code>TITLE                                ID                      PROGRESS  DESCRIPTION\nQuality inspection                   &lt;project_id&gt;                0.0%  Steel defects on production line...\n</code></pre>"},{"location":"cli/#recover-your-project-id","title":"Recover your project ID","text":"<pre><code>export project_id=$(kili project list \\\n              | grep -m1 \"Quality inspection\" \\\n              | awk '{print $3}')\n</code></pre>"},{"location":"cli/#add-a-member-to-your-project","title":"Add a member to your project","text":"<pre><code>kili project member add \\\n                &lt;email_adress&gt; \\\n                --project-id $project_id \\\n                --role REVIEWER\n</code></pre> <p>Ouput:</p> <pre><code>1 member(s) have been successfully added to project: &lt;project_id&gt;\n</code></pre>"},{"location":"cli/#list-the-projects-members","title":"List the project's members","text":"<pre><code>kili project member list --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>ROLE      NAME            EMAIL                ID                         ORGANIZATION\nADMIN     &lt;your_name&gt;     &lt;your_email&gt;         &lt;your_member_id&gt;           &lt;your_organization&gt;\nREVIEWER  &lt;reviewer_name&gt; &lt;email_adress&gt;       &lt;member_id&gt;                &lt;your_organization&gt;\n</code></pre>"},{"location":"cli/#import-data-to-your-project","title":"Import data to your project","text":"<p>To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths)</p> <pre><code>kili project import \\\n    assets \\\n    --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>40 files have been successfully imported\n</code></pre>"},{"location":"cli/#import-labels-to-your-project","title":"Import labels to your project","text":"<p>To import labels, provide a list of files or folders.</p> <p>You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example).  File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre> <p>If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface.</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre>"},{"location":"cli/#get-metrics-of-your-project","title":"Get metrics of your project","text":"<pre><code>kili project describe $project_id\n</code></pre> <p>Ouput:</p> <pre><code>Title        Quality inspection\nDescription  Steel defects on production line\n\nDataset KPIs\n------------\nTotal number of assets      40\nNumber of remaining assets  10\nSkipped assets              0\nProgress                    25.0%\n\nQuality KPIs\n------------\nProject consensus           N/A\nProject honeypot            N/A\nNumber of reviewed assets   0\nNumber of open issues       0\nNumber of solved issues     0\nNumber of open questions    0\nNumber of solved questions  0\n</code></pre>"},{"location":"cli/reference/","title":"kili","text":"<p>Kili Command line Interface</p> <p>To get all the available commands, please type: <code>kili project --help</code>.</p> <p>Usage:</p> <pre><code>kili [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#project","title":"project","text":"<p>Commands to interact with a Kili project</p> <p>Usage:</p> <pre><code>kili project [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#copy","title":"copy","text":"<p>Copy an existing Kili project.</p> <p>The copy can include or not the json interface, quality settings, members, assets and labels of the source project.</p> <p>By default, only the json interface, quality settings and project members are copied.</p> <p>If no <code>title</code> is provided, the source project title will be used. If no description is provided, the description will be set to an empty string.</p> <p>Returns the new project id and title once the copy is finished.</p> <p>Examples</p> <p>Copy a project and set a new title and new description: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --title \"New project title\" \\\n    --description \"New project description\"\n</code></pre> Copy the json interface but not the members: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --with-json-interface \\\n    --without-members\n</code></pre></p> <p>Usage:</p> <pre><code>kili project copy [OPTIONS] FROM_PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--title</code> text New project title. None <code>--description</code> text New project description. None <code>--with-json-interface</code> / <code>--without-json-interface</code> boolean Copy json interface. <code>True</code> <code>--with-quality-settings</code> / <code>--without-quality-settings</code> boolean Copy quality settings. <code>True</code> <code>--with-members</code> / <code>--without-members</code> boolean Copy members. <code>True</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Copy assets. <code>False</code> <code>--with-labels</code> / <code>--without-labels</code> boolean Copy labels. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#create","title":"create","text":"<p>Create a Kili project</p> <p>interface must be a path pointing to your json interface file</p> <p>If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied).</p> <p>Examples</p> <p><pre><code>kili project create \\\n     path/to/interface.json \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre> <pre><code>kili project create \\\n    --from-project &lt;project_id_src&gt; \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre></p> <p>To build a Kili project interface, please visit: </p> <p>https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings</p> <p>Usage:</p> <pre><code>kili project create [OPTIONS] [INTERFACE]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--from-project</code> text project_id of another Kili project None <code>--title</code> text Project Title. _required <code>--input-type</code> choice (<code>AUDIO</code> | <code>IMAGE</code> | <code>PDF</code> | <code>TEXT</code> | <code>TIME_SERIES</code> | <code>VIDEO</code> | <code>VIDEO_LEGACY</code>) Project input data type. Please check your license to see which ones you have access to. _required <code>--description</code> text Project description. `` <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#describe","title":"describe","text":"<p>Show project description and analytics.</p> <p>Examples</p> <pre><code>kili project describe --project-id &lt;project_id&gt;\n</code></pre> <p>Usage:</p> <pre><code>kili project describe [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#export","title":"export","text":"<p>Export the Kili labels of a project to a given format.</p> <p>The supported formats are:</p> <ul> <li>YOLO V4, V5, V7 for object detection tasks (bounding box).</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (semantic or bounding box)</li> <li>Pascal VOC for object detection tasks.</li> </ul> <p>Cloud storage<p>Export is not allowed for projects connected to a cloud storage.</p> </p> <p>Examples</p> <p><pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format coco \\\n    --output-file /tmp/export.zip\n</code></pre> <pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format yolo_v5 \\\n    --output-file /tmp/export_split.zip \\\n    --layout split\n</code></pre></p> <p>Unsupported exports</p> <p>Currently, this command does not support the export of videos that have not been cut into separated frames.</p> <p>For such exports, please use the Kili UI.</p> <p>Usage:</p> <pre><code>kili project export [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--output-format</code> choice (<code>raw</code> | <code>kili</code> | <code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>coco</code> | <code>pascal_voc</code>) Format into which the label data will be converted _required <code>--output-file</code> text File into which the labels are saved. _required <code>--layout</code> choice (<code>split</code> | <code>merged</code>) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. <code>merged</code> <code>--single-file</code> boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). <code>False</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Download assets in the export. <code>True</code> <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--verbose</code> boolean Show more logs <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#import","title":"import","text":"<p>Add assets into a project</p> <p>Files can be paths to files or to folders. You can provide several paths separated by spaces.</p> <p>If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns:</p> <ul> <li><code>external_id</code>: external id of the asset.</li> <li><code>content</code>: paths to the asset file or a url hosting the asset.</li> </ul> <p>Examples</p> <p><pre><code>kili project import \\\n    dir1/dir2/ dir1/dir3/test1.png \\\n    --project-id &lt;project_id&gt;\n</code></pre> <pre><code>kili project import \\\n    dir1/dir3/video.mp4 \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre> <pre><code>kili project import \\\n    --from-csv assets_list.csv \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre></p> <p>Unsupported imports</p> <p>Currently, this command does not support:</p> <ul> <li>the import of videos from local frames, rich text and time series assets</li> <li>the import of assets with metadata or with a custom external_id</li> </ul> <p>For such imports, please use the <code>append_many_to_dataset</code> method in the Kili SDK.</p> <p>Usage:</p> <pre><code>kili project import [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:external_id, content required columns: None <code>--frames</code> boolean Only for a frame project, import videos as frames. The import time is longer with this option. <code>False</code> <code>--fps</code> integer Only for a frame project, import videos with a specific frame rate None <code>--verbose</code> boolean Show more logs <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#label","title":"label","text":"<p>Import labels or predictions</p> <p>Files can be paths to files or to folders.  You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id.</p> <p>Examples</p> <p>To import default labels: <pre><code>kili project label \\\n    dir/labels/ dir/ground-truth/image1.json \\\n    --project-id &lt;project_id&gt;\n</code></pre> To import labels as predictions: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> To import labels as predictions in the Yolo v5 format into a target job: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-v5 \\\n    --metadata-file classes.yml \\\n    --target-job IMAGE_DETECTION_JOB \\\n    --input-format yolo_v5\n</code></pre></p> <p>Usage:</p> <pre><code>kili project label [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--prediction</code> boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface <code>False</code> <code>--model-name</code> text Name of the model that generated predictions, if labels are sent as predictions None <code>--verbose</code> boolean Show more logs <code>False</code> <code>--input-format</code> choice (<code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>kili</code> | <code>raw</code>) Format in which the labels are encoded <code>kili</code> <code>--metadata-file</code> text File containing format metadata (if relevant to the input format) None <code>--target-job</code> text Job name in the project where to upload the labels (if relevant to the input format) None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list","title":"list","text":"<p>List your projects</p> <p>Examples</p> <pre><code>kili project list --max 10 --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--max</code> integer Maximum number of project to display. <code>100</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#member","title":"member","text":"<p>Commands to interact with Kili project members</p> <p>Usage:</p> <pre><code>kili project member [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#add","title":"add","text":"<p>Add members to a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com jane.doe@test.com\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member add [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list_1","title":"list","text":"<p>List the members of the project</p> <p>Examples</p> <pre><code>kili project member list &lt;project_id&gt; --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project member list [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#rm","title":"rm","text":"<p>Remove members from a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --all\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member rm [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--all</code> boolean Remove all users from project <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#update","title":"update","text":"<p>Update member's role of a Kili project</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member update\\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member update [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"sdk/api_key/","title":"API Key module","text":""},{"location":"sdk/api_key/#queries","title":"Queries","text":"<p>Set of ApiKey queries</p> Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>class QueriesApiKey:\n\"\"\"\n    Set of ApiKey queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of API keys that match a set of constraints.\n\n        !!! info\n            You can only query your own API keys\n\n        Args:\n            api_key_id: Identifier of the API key to retrieve.\n            user_id: Identifier of the user.\n            api_key: Value of the API key.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields.\n            first: Maximum number of API keys to return.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the API key is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.api_keys(user_id=user_id)\n            &gt;&gt;&gt; kili.api_keys(api_key=api_key)\n            &gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n        \"\"\"\n        where = APIKeyWhere(api_key_id=api_key_id, user_id=user_id, api_key=api_key)\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        api_keys_gen = APIKeyQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return api_keys_gen\n        return list(api_keys_gen)\n\n    @typechecked\n    def count_api_keys(\n        self,\n        api_key_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Count and return the number of api keys with the given constraints.\n\n        Args:\n            api_key_id: Identifier of the API key to retrieve.\n            user_id: Identifier of the user.\n            api_key: Value of the api key.\n\n        Returns:\n            The number of API Keys matching params if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n            3\n            &gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n            1\n        \"\"\"\n        where = APIKeyWhere(api_key_id=api_key_id, user_id=user_id, api_key=api_key)\n        return APIKeyQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","title":"<code>api_keys(self, api_key_id=None, user_id=None, api_key=None, skip=0, fields=['id', 'name', 'createdAt', 'revoked'], first=None, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of API keys that match a set of constraints.</p> <p>Info</p> <p>You can only query your own API keys</p> <p>Parameters:</p> Name Type Description Default <code>api_key_id</code> <code>Optional[str]</code> <p>Identifier of the API key to retrieve.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Value of the API key.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['id', 'name', 'createdAt', 'revoked']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of API keys to return.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the API key is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.api_keys(user_id=user_id)\n&gt;&gt;&gt; kili.api_keys(api_key=api_key)\n&gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n</code></pre> Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>@typechecked\ndef api_keys(\n    self,\n    api_key_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\"id\", \"name\", \"createdAt\", \"revoked\"],\n    first: Optional[int] = None,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of API keys that match a set of constraints.\n\n    !!! info\n        You can only query your own API keys\n\n    Args:\n        api_key_id: Identifier of the API key to retrieve.\n        user_id: Identifier of the user.\n        api_key: Value of the API key.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields.\n        first: Maximum number of API keys to return.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the API key is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.api_keys(user_id=user_id)\n        &gt;&gt;&gt; kili.api_keys(api_key=api_key)\n        &gt;&gt;&gt; kili.api_keys(api_key=api_key, as_generator=False)\n    \"\"\"\n    where = APIKeyWhere(api_key_id=api_key_id, user_id=user_id, api_key=api_key)\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    api_keys_gen = APIKeyQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return api_keys_gen\n    return list(api_keys_gen)\n</code></pre>"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","title":"<code>count_api_keys(self, api_key_id=None, user_id=None, api_key=None)</code>","text":"<p>Count and return the number of api keys with the given constraints.</p> <p>Parameters:</p> Name Type Description Default <code>api_key_id</code> <code>Optional[str]</code> <p>Identifier of the API key to retrieve.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Value of the api key.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of API Keys matching params if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n3\n&gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n1\n</code></pre> Source code in <code>kili/queries/api_key/__init__.py</code> <pre><code>@typechecked\ndef count_api_keys(\n    self,\n    api_key_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n) -&gt; int:\n\"\"\"Count and return the number of api keys with the given constraints.\n\n    Args:\n        api_key_id: Identifier of the API key to retrieve.\n        user_id: Identifier of the user.\n        api_key: Value of the api key.\n\n    Returns:\n        The number of API Keys matching params if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_api_keys(user_id=user_id)\n        3\n        &gt;&gt;&gt; kili.count_api_keys(api_key=api_key)\n        1\n    \"\"\"\n    where = APIKeyWhere(api_key_id=api_key_id, user_id=user_id, api_key=api_key)\n    return APIKeyQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/asset/","title":"Asset module","text":""},{"location":"sdk/asset/#queries","title":"Queries","text":"<p>Set of Asset queries</p> Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>class QueriesAsset:\n\"\"\"\n    Set of Asset queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals,dangerous-default-value,redefined-builtin\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n        # pylint: disable=line-too-long\n\"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset to retrieve.\n            asset_id_in: A list of the IDs of the assets to retrieve.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                    See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n            first: Maximum number of assets to return.\n            consensus_mark_gt: Minimum amount of consensus for the asset.\n            consensus_mark_lt: Maximum amount of consensus for the asset.\n            external_id_contains: Returned assets have an external id that belongs to that list, if given.\n            metadata_where: Filters by the values of the metadata of the asset.\n            honeypot_mark_gt: Minimum amount of honeypot for the asset.\n            honeypot_mark_lt : Maximum amount of honeypot for the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose status belongs to that list, if given.\n            label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number.\n            label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Returned assets should have a label whose creation date is greater than this date.\n            label_created_at_lt: Returned assets should have a label whose creation date is lower than this date.\n            label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number\n            label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number\n            skipped: Returned assets should be skipped\n            updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n            updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n            format: If equal to 'pandas', returns a pandas DataFrame\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the assets is returned.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            download_media: Tell is the media have to be downloaded or not.\n            local_media_dir: Directory where the media are downloaded if `download_media` is True.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Example:\n            ```\n            # returns the assets list of the project\n            &gt;&gt;&gt; kili.assets(project_id)\n            &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n            # returns a generator of the project assets\n            &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n            ```\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n        if format == \"pandas\" and as_generator:\n            raise ValueError(\n                'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n            )\n\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        where = AssetWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            consensus_mark_gt=consensus_mark_gt,\n            consensus_mark_lt=consensus_mark_lt,\n            external_id_contains=external_id_contains,\n            honeypot_mark_gt=honeypot_mark_gt,\n            honeypot_mark_lt=honeypot_mark_lt,\n            label_author_in=label_author_in,\n            label_consensus_mark_gt=label_consensus_mark_gt,\n            label_consensus_mark_lt=label_consensus_mark_lt,\n            label_created_at=label_created_at,\n            label_created_at_gt=label_created_at_gt,\n            label_created_at_lt=label_created_at_lt,\n            label_honeypot_mark_gt=label_honeypot_mark_gt,\n            label_honeypot_mark_lt=label_honeypot_mark_lt,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        post_call_function, fields = get_download_assets_function(\n            self, download_media, fields, project_id, local_media_dir\n        )\n        assets_gen = AssetQuery(self.auth.client)(where, fields, options, post_call_function)\n\n        if format == \"pandas\":\n            return pd.DataFrame(list(assets_gen))\n        if as_generator:\n            return assets_gen\n        return list(assets_gen)\n\n    @typechecked\n    def count_assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        external_id_contains: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        status_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        skipped: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Count and return the number of assets with the given constraints.\n\n        Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n        Args:\n            project_id: Identifier of the project\n            asset_id: The unique id of the asset to retrieve.\n            asset_id_in: A list of the ids of the assets to retrieve.\n            external_id_contains: Returned assets should have an external id\n                that belongs to that list, if given.\n            metadata_where: Filters by the values of the metadata of the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            consensus_mark_gt: Minimum amount of consensus for the asset.\n            consensus_mark_lt: Maximum amount of consensus for the asset.\n            honeypot_mark_gt: Minimum amount of honeypot for the asset.\n            honeypot_mark_lt: Maximum amount of consensus for the asset.\n            label_type_in: Returned assets should have a label\n                whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label\n                whose status belongs to that list, if given.\n            label_consensus_mark_gt: Returned assets should have a label\n                whose consensus is greater than this number.\n            label_consensus_mark_lt: Returned assets should have a label\n                whose consensus is lower than this number.\n            label_created_at: Returned assets should have a label\n                whose creation date is equal to this date.\n            label_created_at_gt: Returned assets should have a label\n                whose creation date is greater than this date.\n            label_created_at_lt: Returned assets should have a label\n                whose creation date is lower than this date.\n            label_honeypot_mark_gt: Returned assets should have a label\n                whose honeypot is greater than this number.\n            label_honeypot_mark_lt: Returned assets should have a label\n                whose honeypot is lower than this number.\n            skipped: Returned assets should be skipped\n            updated_at_gte: Returned assets should have a label\n                whose update date is greated or equal to this date.\n            updated_at_lte: Returned assets should have a label\n                whose update date is lower or equal to this date.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n            250\n            &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n            1\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n        \"\"\"\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        where = AssetWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            consensus_mark_gt=consensus_mark_gt,\n            consensus_mark_lt=consensus_mark_lt,\n            external_id_contains=external_id_contains,\n            honeypot_mark_gt=honeypot_mark_gt,\n            honeypot_mark_lt=honeypot_mark_lt,\n            label_author_in=label_author_in,\n            label_consensus_mark_gt=label_consensus_mark_gt,\n            label_consensus_mark_lt=label_consensus_mark_lt,\n            label_created_at=label_created_at,\n            label_created_at_gt=label_created_at_gt,\n            label_created_at_lt=label_created_at_lt,\n            label_honeypot_mark_gt=label_honeypot_mark_gt,\n            label_honeypot_mark_lt=label_honeypot_mark_lt,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n        )\n        return AssetQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets","title":"<code>assets(self, project_id, asset_id=None, skip=0, fields=['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'], asset_id_in=None, consensus_mark_gt=None, consensus_mark_lt=None, disable_tqdm=False, external_id_contains=None, first=None, format=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, label_type_in=None, metadata_where=None, skipped=None, status_in=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None, download_media=False, local_media_dir=None, *, as_generator=False)</code>","text":"<p>Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the IDs of the assets to retrieve.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets.     See the documentation for all possible fields.</p> <code>['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of assets to return.</p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Returned assets have an external id that belongs to that list, if given.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_lt</code> <p>Maximum amount of honeypot for the asset.</p> <code>None</code> <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose status belongs to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater than this number.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower than this number.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater than this date.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower than this date.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater than this number</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower than this number</p> <code>None</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greated or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>If equal to 'pandas', returns a pandas DataFrame</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the assets is returned.</p> <code>False</code> <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code> <code>download_media</code> <code>bool</code> <p>Tell is the media have to be downloaded or not.</p> <code>False</code> <code>local_media_dir</code> <code>Optional[str]</code> <p>Directory where the media are downloaded if <code>download_media</code> is True.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Union[Iterable[Dict], pandas.core.frame.DataFrame]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code># returns the assets list of the project\n&gt;&gt;&gt; kili.assets(project_id)\n&gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n# returns a generator of the project assets\n&gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\nlabel_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\nlabel_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre> Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"content\",\n        \"createdAt\",\n        \"externalId\",\n        \"id\",\n        \"isHoneypot\",\n        \"jsonMetadata\",\n        \"labels.author.id\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.id\",\n        \"labels.jsonResponse\",\n        \"skipped\",\n        \"status\",\n    ],\n    asset_id_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    disable_tqdm: bool = False,\n    external_id_contains: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    format: Optional[str] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    skipped: Optional[bool] = None,\n    status_in: Optional[List[str]] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n    download_media: bool = False,\n    local_media_dir: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n    # pylint: disable=line-too-long\n\"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset to retrieve.\n        asset_id_in: A list of the IDs of the assets to retrieve.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n        first: Maximum number of assets to return.\n        consensus_mark_gt: Minimum amount of consensus for the asset.\n        consensus_mark_lt: Maximum amount of consensus for the asset.\n        external_id_contains: Returned assets have an external id that belongs to that list, if given.\n        metadata_where: Filters by the values of the metadata of the asset.\n        honeypot_mark_gt: Minimum amount of honeypot for the asset.\n        honeypot_mark_lt : Maximum amount of honeypot for the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose status belongs to that list, if given.\n        label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number.\n        label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Returned assets should have a label whose creation date is greater than this date.\n        label_created_at_lt: Returned assets should have a label whose creation date is lower than this date.\n        label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number\n        label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number\n        skipped: Returned assets should be skipped\n        updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n        updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n        format: If equal to 'pandas', returns a pandas DataFrame\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the assets is returned.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        download_media: Tell is the media have to be downloaded or not.\n        local_media_dir: Directory where the media are downloaded if `download_media` is True.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Example:\n        ```\n        # returns the assets list of the project\n        &gt;&gt;&gt; kili.assets(project_id)\n        &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n        # returns a generator of the project assets\n        &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n        ```\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n    if format == \"pandas\" and as_generator:\n        raise ValueError(\n            'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n        )\n\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    where = AssetWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        consensus_mark_gt=consensus_mark_gt,\n        consensus_mark_lt=consensus_mark_lt,\n        external_id_contains=external_id_contains,\n        honeypot_mark_gt=honeypot_mark_gt,\n        honeypot_mark_lt=honeypot_mark_lt,\n        label_author_in=label_author_in,\n        label_consensus_mark_gt=label_consensus_mark_gt,\n        label_consensus_mark_lt=label_consensus_mark_lt,\n        label_created_at=label_created_at,\n        label_created_at_gt=label_created_at_gt,\n        label_created_at_lt=label_created_at_lt,\n        label_honeypot_mark_gt=label_honeypot_mark_gt,\n        label_honeypot_mark_lt=label_honeypot_mark_lt,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    post_call_function, fields = get_download_assets_function(\n        self, download_media, fields, project_id, local_media_dir\n    )\n    assets_gen = AssetQuery(self.auth.client)(where, fields, options, post_call_function)\n\n    if format == \"pandas\":\n        return pd.DataFrame(list(assets_gen))\n    if as_generator:\n        return assets_gen\n    return list(assets_gen)\n</code></pre>"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","title":"<code>count_assets(self, project_id, asset_id=None, asset_id_in=None, external_id_contains=None, metadata_where=None, status_in=None, consensus_mark_gt=None, consensus_mark_lt=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_type_in=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, skipped=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None)</code>","text":"<p>Count and return the number of assets with the given constraints.</p> <p>Parameters beginning with 'label_' apply to labels, others apply to assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>asset_id</code> <code>Optional[str]</code> <p>The unique id of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the ids of the assets to retrieve.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Returned assets should have an external id that belongs to that list, if given.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose status belongs to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater than this number.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower than this number.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater than this date.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower than this date.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greated or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_assets(project_id=project_id)\n250\n&gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n1\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> Source code in <code>kili/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef count_assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    external_id_contains: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    status_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    skipped: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n) -&gt; int:\n\"\"\"Count and return the number of assets with the given constraints.\n\n    Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n    Args:\n        project_id: Identifier of the project\n        asset_id: The unique id of the asset to retrieve.\n        asset_id_in: A list of the ids of the assets to retrieve.\n        external_id_contains: Returned assets should have an external id\n            that belongs to that list, if given.\n        metadata_where: Filters by the values of the metadata of the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        consensus_mark_gt: Minimum amount of consensus for the asset.\n        consensus_mark_lt: Maximum amount of consensus for the asset.\n        honeypot_mark_gt: Minimum amount of honeypot for the asset.\n        honeypot_mark_lt: Maximum amount of consensus for the asset.\n        label_type_in: Returned assets should have a label\n            whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label\n            whose status belongs to that list, if given.\n        label_consensus_mark_gt: Returned assets should have a label\n            whose consensus is greater than this number.\n        label_consensus_mark_lt: Returned assets should have a label\n            whose consensus is lower than this number.\n        label_created_at: Returned assets should have a label\n            whose creation date is equal to this date.\n        label_created_at_gt: Returned assets should have a label\n            whose creation date is greater than this date.\n        label_created_at_lt: Returned assets should have a label\n            whose creation date is lower than this date.\n        label_honeypot_mark_gt: Returned assets should have a label\n            whose honeypot is greater than this number.\n        label_honeypot_mark_lt: Returned assets should have a label\n            whose honeypot is lower than this number.\n        skipped: Returned assets should be skipped\n        updated_at_gte: Returned assets should have a label\n            whose update date is greated or equal to this date.\n        updated_at_lte: Returned assets should have a label\n            whose update date is lower or equal to this date.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n        250\n        &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n        1\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n    \"\"\"\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    where = AssetWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        consensus_mark_gt=consensus_mark_gt,\n        consensus_mark_lt=consensus_mark_lt,\n        external_id_contains=external_id_contains,\n        honeypot_mark_gt=honeypot_mark_gt,\n        honeypot_mark_lt=honeypot_mark_lt,\n        label_author_in=label_author_in,\n        label_consensus_mark_gt=label_consensus_mark_gt,\n        label_consensus_mark_lt=label_consensus_mark_lt,\n        label_created_at=label_created_at,\n        label_created_at_gt=label_created_at_gt,\n        label_created_at_lt=label_created_at_lt,\n        label_honeypot_mark_gt=label_honeypot_mark_gt,\n        label_honeypot_mark_lt=label_honeypot_mark_lt,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n    )\n    return AssetQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/asset/#mutations","title":"Mutations","text":"<p>Set of Asset mutations</p> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>class MutationsAsset:\n\"\"\"\n    Set of Asset mutations\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth: KiliAuth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_many_to_dataset(\n        self,\n        project_id: str,\n        content_array: Optional[List[str]] = None,\n        external_id_array: Optional[List[str]] = None,\n        id_array: Optional[List[str]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        status_array: Optional[List[str]] = None,\n        json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n        json_metadata_array: Optional[List[dict]] = None,\n        disable_tqdm: bool = False,\n        wait_until_availability: bool = True,\n    ) -&gt; Dict[str, str]:\n        # pylint: disable=line-too-long\n\"\"\"Append assets to a project.\n\n        Args:\n            project_id: Identifier of the project\n            content_array: List of elements added to the assets of the project\n                Must not be None except if you provide json_content_array.\n\n                - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n                - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                    images/pdf on your computer.\n                - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n                existing video files on your computer. If you want to import video from frames, look at the json_content\n                section below.\n                - For an `VIDEO_LEGACY` project, the content can be only be URLs\n            external_id_array: List of external ids given to identify the assets.\n                If None, random identifiers are created.\n            is_honeypot_array:  Whether to use the asset for honeypot\n            status_array: By default, all imported assets are set to `TODO`. Other options:\n                `ONGOING`, `LABELED`, `REVIEWED`.\n            json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n                - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                    list of URLs to images or a list of paths to images.\n                - For `TEXT` projects, each element is a json_content dict,\n                    formatted according to documentation [on how to import\n                rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb)\n            json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n                - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                    Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n                - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                    Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n                If `False`, the function will return faster but the assets might not be fully processed by the server.\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_many_to_dataset(\n                    project_id=project_id,\n                    content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n        !!! example \"Recipe\"\n            - For more detailed examples on how to import assets,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n            - For more detailed examples on how to import text assets,\n                see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb).\n        \"\"\"\n\n        if content_array is None and json_content_array is None:\n            raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n        nb_data = (\n            len(content_array)\n            if content_array is not None\n            else len(json_content_array)  # type:ignore\n        )\n\n        field_mapping = {\n            \"content\": content_array,\n            \"json_content\": json_content_array,\n            \"external_id\": external_id_array,\n            \"id\": id_array,\n            \"status\": status_array,\n            \"json_metadata\": json_metadata_array,\n            \"is_honeypot\": is_honeypot_array,\n        }\n        assets = [{}] * nb_data\n        for key, value in field_mapping.items():\n            if value is not None:\n                assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n        result = import_assets(\n            self.auth,\n            project_id=project_id,\n            assets=assets,\n            disable_tqdm=disable_tqdm,\n            verify=wait_until_availability,\n        )\n        return result\n\n    @typechecked\n    # pylint: disable=unused-argument\n    def update_properties_in_assets(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        priorities: Optional[List[int]] = None,\n        json_metadatas: Optional[List[Union[dict, str]]] = None,\n        consensus_marks: Optional[List[float]] = None,\n        honeypot_marks: Optional[List[float]] = None,\n        to_be_labeled_by_array: Optional[List[List[str]]] = None,\n        contents: Optional[List[str]] = None,\n        json_contents: Optional[List[str]] = None,\n        status_array: Optional[List[str]] = None,\n        is_used_for_consensus_array: Optional[List[bool]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n\"\"\"Update the properties of one or more assets.\n\n        Args:\n            asset_ids: The internal asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            priorities: You can change the priority of the assets.\n                By default, all assets have a priority of 0.\n            json_metadatas: The metadata given to an asset should be stored\n                in a json like dict with keys `imageUrl`, `text`, `url`:\n                `json_metadata = {'imageUrl': '','text': '','url': ''}`\n            consensus_marks: Should be between 0 and 1.\n            honeypot_marks: Should be between 0 and 1.\n            to_be_labeled_by_array: If given, each element of the list should contain the emails of\n                the labelers authorized to label the asset.\n            contents: - For a NLP project, the content can be directly in text format.\n                - For an Image / Video / Pdf project, the content must be hosted on a web server,\n                and you point Kili to your data by giving the URLs.\n            json_contents: - For a NLP project, the `json_content`\n                is a text formatted using RichText.\n                - For a Video project, the`json_content` is a json containg urls pointing\n                    to each frame of the video.\n            status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n                `TO_REVIEW`, `REVIEWED`.\n            is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n            is_honeypot_array: Whether to use the asset for honeypot.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_assets(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    consensus_marks=[1, 0.7],\n                    contents=[None, 'https://to/second/asset.png'],\n                    honeypot_marks=[0.8, 0.5],\n                    is_honeypot_array=[True, True],\n                    is_used_for_consensus_array=[True, False],\n                    priorities=[None, 2],\n                    status_array=['LABELED', 'REVIEWED'],\n                    to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n                )\n        \"\"\"\n        if asset_ids is not None and external_ids is not None:\n            warnings.warn(\n                (\n                    \"The use of `external_ids` argument has changed. It is now used to identify\"\n                    \" which properties of which assets to update. Please use\"\n                    \" `kili.change_asset_external_ids()` method instead to change asset external\"\n                    \" IDs.\"\n                ),\n                DeprecationWarning,\n            )\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        saved_args = locals()\n        parameters = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            in [\n                \"asset_ids\",\n                \"priorities\",\n                \"json_metadatas\",\n                \"consensus_marks\",\n                \"honeypot_marks\",\n                \"to_be_labeled_by_array\",\n                \"contents\",\n                \"json_contents\",\n                \"status_array\",\n                \"is_used_for_consensus_array\",\n                \"is_honeypot_array\",\n            ]\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"priority\": batch[\"priorities\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"consensusMark\": batch[\"consensus_marks\"],\n                \"honeypotMark\": batch[\"honeypot_marks\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n                \"content\": batch[\"contents\"],\n                \"jsonContent\": batch[\"json_contents\"],\n                \"status\": batch[\"status_array\"],\n                \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n                \"isHoneypot\": batch[\"is_honeypot_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def change_asset_external_ids(\n        self,\n        new_external_ids: List[str],\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n\"\"\"Update the external IDs of one or more assets.\n\n        Args:\n            new_external_ids: The new external IDs of the assets.\n            asset_ids: The asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.change_asset_external_ids(\n                    new_external_ids=[\"asset1\", \"asset2\"],\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        parameters = {\n            \"asset_ids\": asset_ids,\n            \"new_external_ids\": new_external_ids,\n            \"json_metadatas\": None,\n            \"to_be_labeled_by_array\": None,\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"externalId\": batch[\"new_external_ids\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def delete_many_from_dataset(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Asset:\n\"\"\"Delete assets from a project.\n\n        Args:\n            asset_ids: The list of asset internal IDs to delete.\n            external_ids: The list of asset external IDs to delete.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_kili = AssetQuery(self.auth.client).count(\n                AssetWhere(\n                    project_id=results[0][\"data\"][\"data\"][\"id\"],\n                    asset_id_in=asset_ids,\n                )\n            )\n            if nb_assets_in_kili &gt; 0:\n                raise MutationError(\"Failed to delete some assets.\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_DELETE_MANY_FROM_DATASET,\n            last_batch_callback=verify_last_batch,\n        )\n        return format_result(\"data\", results[0], Asset)\n\n    @typechecked\n    def add_to_review(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Add assets to review.\n\n        !!! warning\n            Assets without any label will be ignored.\n\n        Args:\n            asset_ids: The asset internal IDs to add to review.\n            external_ids: The asset external IDs to add to review.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to review.\n            `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.add_to_review(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n            try:\n                project_id = results[0][\"data\"][\"data\"][\"id\"]\n            except TypeError:\n                return  # No assets have changed status\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_review = AssetQuery(self.auth.client).count(\n                AssetWhere(\n                    project_id=project_id,\n                    asset_id_in=asset_ids,\n                    status_in=[\"TO_REVIEW\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_review:\n                raise MutationError(\"Failed to send some assets to review\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n            last_batch_callback=verify_last_batch,\n        )\n        result = format_result(\"data\", results[0])\n        # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n        # it happens when no assets have been sent to review\n        if isinstance(result, dict) and \"id\" in result:\n            assets_in_review = AssetQuery(self.auth.client)(\n                AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"TO_REVIEW\"]),\n                [\"id\"],\n                QueryOptions(disable_tqdm=True),\n            )\n            result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n            return result\n        return result\n\n    @typechecked\n    def send_back_to_queue(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n\"\"\"Send assets back to queue.\n\n        Args:\n            asset_ids: List of internal IDs of assets to send back to queue.\n            external_ids: List of external IDs of assets to send back to queue.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.send_back_to_queue(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                        ],\n                )\n        \"\"\"\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_queue = AssetQuery(self.auth.client).count(\n                AssetWhere(\n                    project_id=results[0][\"data\"][\"data\"][\"id\"],\n                    asset_id_in=asset_ids,\n                    status_in=[\"ONGOING\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_queue:\n                raise MutationError(\"Failed to send some assets back to queue\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_SEND_BACK_ASSETS_TO_QUEUE,\n            last_batch_callback=verify_last_batch,\n        )\n        result = format_result(\"data\", results[0])\n        assets_in_queue = AssetQuery(self.auth.client)(\n            AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"ONGOING\"]),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n        return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.add_to_review","title":"<code>add_to_review(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Add assets to review.</p> <p>Warning</p> <p>Assets without any label will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset internal IDs to add to review.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The asset external IDs to add to review.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to review. <code>None</code> if no assets have changed status (already had <code>TO_REVIEW</code> status for example). An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.add_to_review(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n        ],\n    )\n</code></pre> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef add_to_review(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Add assets to review.\n\n    !!! warning\n        Assets without any label will be ignored.\n\n    Args:\n        asset_ids: The asset internal IDs to add to review.\n        external_ids: The asset external IDs to add to review.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to review.\n        `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.add_to_review(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                ],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n        try:\n            project_id = results[0][\"data\"][\"data\"][\"id\"]\n        except TypeError:\n            return  # No assets have changed status\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_review = AssetQuery(self.auth.client).count(\n            AssetWhere(\n                project_id=project_id,\n                asset_id_in=asset_ids,\n                status_in=[\"TO_REVIEW\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_review:\n            raise MutationError(\"Failed to send some assets to review\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n        last_batch_callback=verify_last_batch,\n    )\n    result = format_result(\"data\", results[0])\n    # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n    # it happens when no assets have been sent to review\n    if isinstance(result, dict) and \"id\" in result:\n        assets_in_review = AssetQuery(self.auth.client)(\n            AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"TO_REVIEW\"]),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n        return result\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","title":"<code>append_many_to_dataset(self, project_id, content_array=None, external_id_array=None, id_array=None, is_honeypot_array=None, status_array=None, json_content_array=None, json_metadata_array=None, disable_tqdm=False, wait_until_availability=True)</code>","text":"<p>Append assets to a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>content_array</code> <code>Optional[List[str]]</code> <p>List of elements added to the assets of the project Must not be None except if you provide json_content_array.</p> <ul> <li>For a <code>TEXT</code> project, the content can be either raw text, or URLs to TEXT assets.</li> <li>For an <code>IMAGE</code> / <code>PDF</code> project, the content can be either URLs or paths to existing     images/pdf on your computer.</li> <li>For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below.</li> <li>For an <code>VIDEO_LEGACY</code> project, the content can be only be URLs</li> </ul> <code>None</code> <code>external_id_array</code> <code>Optional[List[str]]</code> <p>List of external ids given to identify the assets. If None, random identifiers are created.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot</p> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>By default, all imported assets are set to <code>TODO</code>. Other options: <code>ONGOING</code>, <code>LABELED</code>, <code>REVIEWED</code>.</p> <code>None</code> <code>json_content_array</code> <code>Optional[List[List[Union[dict, str]]]]</code> <p>Useful for <code>VIDEO</code> or <code>TEXT</code> projects only.</p> <ul> <li>For <code>VIDEO</code> projects, each element is a sequence of frames, i.e. a     list of URLs to images or a list of paths to images.</li> <li>For <code>TEXT</code> projects, each element is a json_content dict,     formatted according to documentation on how to import rich-text assets</li> </ul> <code>None</code> <code>json_metadata_array</code> <code>Optional[List[dict]]</code> <p>The metadata given to each asset should be stored in a json like dict with keys.</p> <ul> <li>Add metadata visible on the asset with the following keys: <code>imageUrl</code>, <code>text</code>, <code>url</code>.     Example for one asset: <code>json_metadata_array = [{'imageUrl': '','text': '','url': ''}]</code>.</li> <li>For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).     Example for one asset: <code>json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]</code>.</li> </ul> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>wait_until_availability</code> <code>bool</code> <p>If <code>True</code>, the function will return once the assets are fully imported in Kili. If <code>False</code>, the function will return faster but the assets might not be fully processed by the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_many_to_dataset(\n        project_id=project_id,\n        content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n</code></pre> <p>Recipe</p> <ul> <li>For more detailed examples on how to import assets,     see the recipe.</li> <li>For more detailed examples on how to import text assets,     see the recipe.</li> </ul> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef append_many_to_dataset(\n    self,\n    project_id: str,\n    content_array: Optional[List[str]] = None,\n    external_id_array: Optional[List[str]] = None,\n    id_array: Optional[List[str]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    status_array: Optional[List[str]] = None,\n    json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n    json_metadata_array: Optional[List[dict]] = None,\n    disable_tqdm: bool = False,\n    wait_until_availability: bool = True,\n) -&gt; Dict[str, str]:\n    # pylint: disable=line-too-long\n\"\"\"Append assets to a project.\n\n    Args:\n        project_id: Identifier of the project\n        content_array: List of elements added to the assets of the project\n            Must not be None except if you provide json_content_array.\n\n            - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n            - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                images/pdf on your computer.\n            - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n            existing video files on your computer. If you want to import video from frames, look at the json_content\n            section below.\n            - For an `VIDEO_LEGACY` project, the content can be only be URLs\n        external_id_array: List of external ids given to identify the assets.\n            If None, random identifiers are created.\n        is_honeypot_array:  Whether to use the asset for honeypot\n        status_array: By default, all imported assets are set to `TODO`. Other options:\n            `ONGOING`, `LABELED`, `REVIEWED`.\n        json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n            - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                list of URLs to images or a list of paths to images.\n            - For `TEXT` projects, each element is a json_content dict,\n                formatted according to documentation [on how to import\n            rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb)\n        json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n            - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n            - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n            If `False`, the function will return faster but the assets might not be fully processed by the server.\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_many_to_dataset(\n                project_id=project_id,\n                content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n    !!! example \"Recipe\"\n        - For more detailed examples on how to import assets,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n        - For more detailed examples on how to import text assets,\n            see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb).\n    \"\"\"\n\n    if content_array is None and json_content_array is None:\n        raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n    nb_data = (\n        len(content_array)\n        if content_array is not None\n        else len(json_content_array)  # type:ignore\n    )\n\n    field_mapping = {\n        \"content\": content_array,\n        \"json_content\": json_content_array,\n        \"external_id\": external_id_array,\n        \"id\": id_array,\n        \"status\": status_array,\n        \"json_metadata\": json_metadata_array,\n        \"is_honeypot\": is_honeypot_array,\n    }\n    assets = [{}] * nb_data\n    for key, value in field_mapping.items():\n        if value is not None:\n            assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n    result = import_assets(\n        self.auth,\n        project_id=project_id,\n        assets=assets,\n        disable_tqdm=disable_tqdm,\n        verify=wait_until_availability,\n    )\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.change_asset_external_ids","title":"<code>change_asset_external_ids(self, new_external_ids, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Update the external IDs of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>new_external_ids</code> <code>List[str]</code> <p>The new external IDs of the assets.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.change_asset_external_ids(\n        new_external_ids=[\"asset1\", \"asset2\"],\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n    )\n</code></pre> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef change_asset_external_ids(\n    self,\n    new_external_ids: List[str],\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n\"\"\"Update the external IDs of one or more assets.\n\n    Args:\n        new_external_ids: The new external IDs of the assets.\n        asset_ids: The asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.change_asset_external_ids(\n                new_external_ids=[\"asset1\", \"asset2\"],\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    parameters = {\n        \"asset_ids\": asset_ids,\n        \"new_external_ids\": new_external_ids,\n        \"json_metadatas\": None,\n        \"to_be_labeled_by_array\": None,\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"externalId\": batch[\"new_external_ids\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","title":"<code>delete_many_from_dataset(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Delete assets from a project.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The list of asset internal IDs to delete.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The list of asset external IDs to delete.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Asset</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef delete_many_from_dataset(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Asset:\n\"\"\"Delete assets from a project.\n\n    Args:\n        asset_ids: The list of asset internal IDs to delete.\n        external_ids: The list of asset external IDs to delete.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_kili = AssetQuery(self.auth.client).count(\n            AssetWhere(\n                project_id=results[0][\"data\"][\"data\"][\"id\"],\n                asset_id_in=asset_ids,\n            )\n        )\n        if nb_assets_in_kili &gt; 0:\n            raise MutationError(\"Failed to delete some assets.\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_DELETE_MANY_FROM_DATASET,\n        last_batch_callback=verify_last_batch,\n    )\n    return format_result(\"data\", results[0], Asset)\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.send_back_to_queue","title":"<code>send_back_to_queue(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Send assets back to queue.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>List of internal IDs of assets to send back to queue.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>List of external IDs of assets to send back to queue.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to queue. An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.send_back_to_queue(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n            ],\n    )\n</code></pre> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef send_back_to_queue(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n\"\"\"Send assets back to queue.\n\n    Args:\n        asset_ids: List of internal IDs of assets to send back to queue.\n        external_ids: List of external IDs of assets to send back to queue.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.send_back_to_queue(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n            )\n    \"\"\"\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_queue = AssetQuery(self.auth.client).count(\n            AssetWhere(\n                project_id=results[0][\"data\"][\"data\"][\"id\"],\n                asset_id_in=asset_ids,\n                status_in=[\"ONGOING\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_queue:\n            raise MutationError(\"Failed to send some assets back to queue\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_SEND_BACK_ASSETS_TO_QUEUE,\n        last_batch_callback=verify_last_batch,\n    )\n    result = format_result(\"data\", results[0])\n    assets_in_queue = AssetQuery(self.auth.client)(\n        AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"ONGOING\"]),\n        [\"id\"],\n        QueryOptions(disable_tqdm=True),\n    )\n    result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","title":"<code>update_properties_in_assets(self, asset_ids=None, external_ids=None, priorities=None, json_metadatas=None, consensus_marks=None, honeypot_marks=None, to_be_labeled_by_array=None, contents=None, json_contents=None, status_array=None, is_used_for_consensus_array=None, is_honeypot_array=None, project_id=None)</code>","text":"<p>Update the properties of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The internal asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>priorities</code> <code>Optional[List[int]]</code> <p>You can change the priority of the assets. By default, all assets have a priority of 0.</p> <code>None</code> <code>json_metadatas</code> <code>Optional[List[Union[dict, str]]]</code> <p>The metadata given to an asset should be stored in a json like dict with keys <code>imageUrl</code>, <code>text</code>, <code>url</code>: <code>json_metadata = {'imageUrl': '','text': '','url': ''}</code></p> <code>None</code> <code>consensus_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>honeypot_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>to_be_labeled_by_array</code> <code>Optional[List[List[str]]]</code> <p>If given, each element of the list should contain the emails of the labelers authorized to label the asset.</p> <code>None</code> <code>contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the content can be directly in text format.</li> <li>For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs.</li> </ul> <code>None</code> <code>json_contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the <code>json_content</code> is a text formatted using RichText.</li> <li>For a Video project, the<code>json_content</code> is a json containg urls pointing     to each frame of the video.</li> </ul> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>Each element should be in <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code>, <code>REVIEWED</code>.</p> <code>None</code> <code>is_used_for_consensus_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset to compute consensus kpis or not.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_assets(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        consensus_marks=[1, 0.7],\n        contents=[None, 'https://to/second/asset.png'],\n        honeypot_marks=[0.8, 0.5],\n        is_honeypot_array=[True, True],\n        is_used_for_consensus_array=[True, False],\n        priorities=[None, 2],\n        status_array=['LABELED', 'REVIEWED'],\n        to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n    )\n</code></pre> Source code in <code>kili/mutations/asset/__init__.py</code> <pre><code>@typechecked\n# pylint: disable=unused-argument\ndef update_properties_in_assets(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    priorities: Optional[List[int]] = None,\n    json_metadatas: Optional[List[Union[dict, str]]] = None,\n    consensus_marks: Optional[List[float]] = None,\n    honeypot_marks: Optional[List[float]] = None,\n    to_be_labeled_by_array: Optional[List[List[str]]] = None,\n    contents: Optional[List[str]] = None,\n    json_contents: Optional[List[str]] = None,\n    status_array: Optional[List[str]] = None,\n    is_used_for_consensus_array: Optional[List[bool]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n\"\"\"Update the properties of one or more assets.\n\n    Args:\n        asset_ids: The internal asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        priorities: You can change the priority of the assets.\n            By default, all assets have a priority of 0.\n        json_metadatas: The metadata given to an asset should be stored\n            in a json like dict with keys `imageUrl`, `text`, `url`:\n            `json_metadata = {'imageUrl': '','text': '','url': ''}`\n        consensus_marks: Should be between 0 and 1.\n        honeypot_marks: Should be between 0 and 1.\n        to_be_labeled_by_array: If given, each element of the list should contain the emails of\n            the labelers authorized to label the asset.\n        contents: - For a NLP project, the content can be directly in text format.\n            - For an Image / Video / Pdf project, the content must be hosted on a web server,\n            and you point Kili to your data by giving the URLs.\n        json_contents: - For a NLP project, the `json_content`\n            is a text formatted using RichText.\n            - For a Video project, the`json_content` is a json containg urls pointing\n                to each frame of the video.\n        status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n            `TO_REVIEW`, `REVIEWED`.\n        is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n        is_honeypot_array: Whether to use the asset for honeypot.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_assets(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                consensus_marks=[1, 0.7],\n                contents=[None, 'https://to/second/asset.png'],\n                honeypot_marks=[0.8, 0.5],\n                is_honeypot_array=[True, True],\n                is_used_for_consensus_array=[True, False],\n                priorities=[None, 2],\n                status_array=['LABELED', 'REVIEWED'],\n                to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n            )\n    \"\"\"\n    if asset_ids is not None and external_ids is not None:\n        warnings.warn(\n            (\n                \"The use of `external_ids` argument has changed. It is now used to identify\"\n                \" which properties of which assets to update. Please use\"\n                \" `kili.change_asset_external_ids()` method instead to change asset external\"\n                \" IDs.\"\n            ),\n            DeprecationWarning,\n        )\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    saved_args = locals()\n    parameters = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        in [\n            \"asset_ids\",\n            \"priorities\",\n            \"json_metadatas\",\n            \"consensus_marks\",\n            \"honeypot_marks\",\n            \"to_be_labeled_by_array\",\n            \"contents\",\n            \"json_contents\",\n            \"status_array\",\n            \"is_used_for_consensus_array\",\n            \"is_honeypot_array\",\n        ]\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"priority\": batch[\"priorities\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"consensusMark\": batch[\"consensus_marks\"],\n            \"honeypotMark\": batch[\"honeypot_marks\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            \"content\": batch[\"contents\"],\n            \"jsonContent\": batch[\"json_contents\"],\n            \"status\": batch[\"status_array\"],\n            \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n            \"isHoneypot\": batch[\"is_honeypot_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/issue/","title":"Issue module","text":""},{"location":"sdk/issue/#queries","title":"Queries","text":"<p>Set of Issue queries.</p> Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>class QueriesIssue:\n\"\"\"Set of Issue queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of issues that match a set of criteria.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n            first: Maximum number of issues to return.\n            skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the issues is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n        \"\"\"\n        where = IssueWhere(project_id=project_id)\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        issues_gen = IssueQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return issues_gen\n        return list(issues_gen)\n\n    @typechecked\n    def count_issues(self, project_id: Optional[str] = None) -&gt; int:\n\"\"\"Count and return the number of api keys with the given constraints.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n\n        Returns:\n            The number of issues with the parameters provided\n\n        \"\"\"\n        if not project_id:\n            warnings.warn(\n                (\n                    \"It is now required to provide a project_id when calling count_issues. This\"\n                    \" change will be enforced from 01/02/2023\"\n                ),\n                DeprecationWarning,\n            )\n        where = IssueWhere(project_id=project_id)\n        return IssueQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","title":"<code>count_issues(self, project_id=None)</code>","text":"<p>Count and return the number of api keys with the given constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Project ID the issue belongs to.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of issues with the parameters provided</p> Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef count_issues(self, project_id: Optional[str] = None) -&gt; int:\n\"\"\"Count and return the number of api keys with the given constraints.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n\n    Returns:\n        The number of issues with the parameters provided\n\n    \"\"\"\n    if not project_id:\n        warnings.warn(\n            (\n                \"It is now required to provide a project_id when calling count_issues. This\"\n                \" change will be enforced from 01/02/2023\"\n            ),\n            DeprecationWarning,\n        )\n    where = IssueWhere(project_id=project_id)\n    return IssueQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.issues","title":"<code>issues(self, project_id, fields=['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of issues that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of issues to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of issues to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the issues is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n</code></pre> Source code in <code>kili/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef issues(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"id\",\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"issueNumber\",\n        \"status\",\n        \"type\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of issues that match a set of criteria.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n        first: Maximum number of issues to return.\n        skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the issues is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n    \"\"\"\n    where = IssueWhere(project_id=project_id)\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    issues_gen = IssueQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return issues_gen\n    return list(issues_gen)\n</code></pre>"},{"location":"sdk/issue/#mutations","title":"Mutations","text":"<p>Set of Issue mutations.</p> Source code in <code>kili/mutations/issue/__init__.py</code> <pre><code>class MutationsIssue:\n\"\"\"Set of Issue mutations.\"\"\"\n\n    # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_to_issues(\n        self,\n        label_id: str,\n        project_id: str,\n        object_mid: Optional[str] = None,\n        text: Optional[str] = None,\n        type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n    ) -&gt; Dict:\n\"\"\"Create an issue.\n\n        Args:\n            label_id: Id of the label to add an issue to\n            object_mid: Mid of the object in the label to associate the issue to\n            type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n            text: If given, write a comment related to the issue\n            project_id: Id of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        issue_number = get_issue_number(self.auth, project_id, type_)\n        try:\n            options = QueryOptions(disable_tqdm=True)\n            where = LabelWhere(\n                project_id=project_id,\n                label_id=label_id,\n            )\n            asset_id: str = list(\n                LabelQuery(self.auth.client)(where=where, fields=[\"labelOf.id\"], options=options)\n            )[0][\"labelOf\"][\"id\"]\n        except:\n            # pylint: disable=raise-missing-from\n            raise ValueError(\n                f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n            )\n        variables = {\n            \"data\": {\n                \"issueNumber\": issue_number,\n                \"labelID\": label_id,\n                \"objectMid\": object_mid,\n                \"type\": type_,\n            },\n            \"where\": {\"id\": asset_id},\n        }\n        if text:\n            variables[\"data\"][\"text\"] = text\n\n        result = self.auth.client.execute(GQL_APPEND_TO_ISSUES, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/issue/#kili.mutations.issue.__init__.MutationsIssue.append_to_issues","title":"<code>append_to_issues(self, label_id, project_id, object_mid=None, text=None, type_='ISSUE')</code>","text":"<p>Create an issue.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>Id of the label to add an issue to</p> required <code>object_mid</code> <code>Optional[str]</code> <p>Mid of the object in the label to associate the issue to</p> <code>None</code> <code>type_</code> <code>typing_extensions.Literal['ISSUE', 'QUESTION']</code> <p>type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"</p> <code>'ISSUE'</code> <code>text</code> <code>Optional[str]</code> <p>If given, write a comment related to the issue</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Id of the project</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/issue/__init__.py</code> <pre><code>@typechecked\ndef append_to_issues(\n    self,\n    label_id: str,\n    project_id: str,\n    object_mid: Optional[str] = None,\n    text: Optional[str] = None,\n    type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n) -&gt; Dict:\n\"\"\"Create an issue.\n\n    Args:\n        label_id: Id of the label to add an issue to\n        object_mid: Mid of the object in the label to associate the issue to\n        type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n        text: If given, write a comment related to the issue\n        project_id: Id of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    issue_number = get_issue_number(self.auth, project_id, type_)\n    try:\n        options = QueryOptions(disable_tqdm=True)\n        where = LabelWhere(\n            project_id=project_id,\n            label_id=label_id,\n        )\n        asset_id: str = list(\n            LabelQuery(self.auth.client)(where=where, fields=[\"labelOf.id\"], options=options)\n        )[0][\"labelOf\"][\"id\"]\n    except:\n        # pylint: disable=raise-missing-from\n        raise ValueError(\n            f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n        )\n    variables = {\n        \"data\": {\n            \"issueNumber\": issue_number,\n            \"labelID\": label_id,\n            \"objectMid\": object_mid,\n            \"type\": type_,\n        },\n        \"where\": {\"id\": asset_id},\n    }\n    if text:\n        variables[\"data\"][\"text\"] = text\n\n    result = self.auth.client.execute(GQL_APPEND_TO_ISSUES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/label/","title":"Label module","text":""},{"location":"sdk/label/#queries","title":"Queries","text":"<p>Set of Label queries.</p> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>class QueriesLabel:\n\"\"\"Set of Label queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n\n        if category_search:\n            validate_category_search_query(category_search)\n\n        where = LabelWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            type_in=type_in,\n            user_id=user_id,\n            category_search=category_search,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        labels_gen = LabelQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return labels_gen\n        return list(labels_gen)\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get prediction labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n        \"\"\"\n        if fields is None:\n            fields = [\n                \"author.email\",\n                \"author.id\",\n                \"id\",\n                \"jsonResponse\",\n                \"labelType\",\n                \"modelName\",\n            ]\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"PREDICTION\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # type: ignore\n        )\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get inference labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n        \"\"\"\n        if fields is None:\n            fields = [\n                \"author.email\",\n                \"author.id\",\n                \"id\",\n                \"jsonResponse\",\n                \"labelType\",\n                \"modelName\",\n            ]\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"INFERENCE\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # type: ignore\n        )\n\n    @typechecked\n    def export_labels_as_df(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"createdAt\",\n            \"id\",\n            \"labelType\",\n        ],\n        asset_fields: List[str] = [\"externalId\"],\n    ) -&gt; pd.DataFrame:\n        # pylint: disable=line-too-long\n\"\"\"Get the labels of a project as a pandas DataFrame.\n\n        Args:\n            project_id: Identifier of the project\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            asset_fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n        Returns:\n            pandas DataFrame containing the labels.\n        \"\"\"\n\n        services.get_project(self, project_id, [\"id\"])\n        assets_gen = AssetQuery(self.auth.client)(\n            AssetWhere(project_id=project_id),\n            asset_fields + [\"labels.\" + field for field in fields],\n            QueryOptions(disable_tqdm=False),\n        )\n        labels = [\n            dict(\n                label,\n                **dict((f\"asset_{key}\", asset[key]) for key in asset if key != \"labels\"),\n            )\n            for asset in assets_gen\n            for label in asset[\"labels\"]\n        ]\n        labels_df = pd.DataFrame(labels)\n        return labels_df\n\n    @typechecked\n    def count_labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        label_id: Optional[str] = None,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        category_search: Optional[str] = None,\n        id_contains: Optional[List[str]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n\"\"\"Get the number of labels for the given parameters.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have a label whose status belongs to that list, if given.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            label_id: Identifier of the label.\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            category_search: Query to filter labels based on the content of their jsonResponse\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of labels with the parameters provided\n        \"\"\"\n\n        if category_search:\n            validate_category_search_query(category_search)\n\n        where = LabelWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            type_in=type_in,\n            user_id=user_id,\n            category_search=category_search,\n        )\n        return LabelQuery(self.auth.client).count(where)\n\n    def export_labels(\n        self,\n        project_id: str,\n        filename: str,\n        fmt: LabelFormat,\n        asset_ids: Optional[List[str]] = None,\n        layout: SplitOption = \"split\",\n        single_file: bool = False,\n        disable_tqdm: bool = False,\n        with_assets: bool = True,\n        external_ids: Optional[List[str]] = None,\n    ):\n\"\"\"\n        Export the project labels with the requested format into the requested output path.\n\n        Args:\n            project_id: Identifier of the project.\n            filename: Relative or full path of the archive that will contain\n                the exported data.\n            fmt: Format of the exported labels.\n            asset_ids: Optional list of the assets internal IDs from which to export the labels.\n            layout: Layout of the exported files. \"split\" means there is one folder\n                per job, \"merged\" that there is one folder with every labels.\n            single_file: Layout of the exported labels. Single file mode is\n                only available for some specific formats (COCO and Kili).\n            disable_tqdm: Disable the progress bar if True.\n            with_assets: Download the assets in the export.\n            external_ids: Optional list of the assets external IDs from which to export the labels.\n\n        !!! warning\n            Export is not allowed for projects connected to a cloud storage.\n\n        !!! Info\n            The supported formats are:\n\n            - Yolo V4, V5, V7 for object detection tasks (bounding box)\n\n            - Kili for all tasks.\n\n            - COCO for semantic segmentation tasks (bounding box and semantic segmentation)\n\n            - Pascal VOC for object detection tasks.\n\n        !!! Example\n            ```\n            from kili.client import Kili\n            kili = Kili()\n            kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n            ```\n        \"\"\"\n        if external_ids is not None and asset_ids is None:\n            id_map = infer_ids_from_external_ids(\n                kili=self, asset_external_ids=external_ids, project_id=project_id\n            )\n            asset_ids = [id_map[id] for id in external_ids]\n\n        try:\n            services.export_labels(\n                self,\n                asset_ids=asset_ids,\n                project_id=cast(ProjectId, project_id),\n                export_type=\"latest\",\n                label_format=fmt,\n                split_option=layout,\n                single_file=single_file,\n                output_file=filename,\n                disable_tqdm=disable_tqdm,\n                log_level=\"WARNING\",\n                with_assets=with_assets,\n            )\n        except NoCompatibleJobError as excp:\n            print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.count_labels","title":"<code>count_labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, label_id=None, type_in=None, user_id=None, category_search=None, id_contains=None)</code>","text":"<p>Get the number of labels for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose status belongs to that list, if given.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of labels with the parameters provided</p> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef count_labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    label_id: Optional[str] = None,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    category_search: Optional[str] = None,\n    id_contains: Optional[List[str]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n\"\"\"Get the number of labels for the given parameters.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have a label whose status belongs to that list, if given.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        label_id: Identifier of the label.\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        category_search: Query to filter labels based on the content of their jsonResponse\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of labels with the parameters provided\n    \"\"\"\n\n    if category_search:\n        validate_category_search_query(category_search)\n\n    where = LabelWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        type_in=type_in,\n        user_id=user_id,\n        category_search=category_search,\n    )\n    return LabelQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels","title":"<code>export_labels(self, project_id, filename, fmt, asset_ids=None, layout='split', single_file=False, disable_tqdm=False, with_assets=True, external_ids=None)</code>","text":"<p>Export the project labels with the requested format into the requested output path.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>filename</code> <code>str</code> <p>Relative or full path of the archive that will contain the exported data.</p> required <code>fmt</code> <code>typing_extensions.Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc']</code> <p>Format of the exported labels.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets internal IDs from which to export the labels.</p> <code>None</code> <code>layout</code> <code>typing_extensions.Literal['split', 'merged']</code> <p>Layout of the exported files. \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels.</p> <code>'split'</code> <code>single_file</code> <code>bool</code> <p>Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili).</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable the progress bar if True.</p> <code>False</code> <code>with_assets</code> <code>bool</code> <p>Download the assets in the export.</p> <code>True</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets external IDs from which to export the labels.</p> <code>None</code> <p>Warning</p> <p>Export is not allowed for projects connected to a cloud storage.</p> <p>Info</p> <p>The supported formats are:</p> <ul> <li> <p>Yolo V4, V5, V7 for object detection tasks (bounding box)</p> </li> <li> <p>Kili for all tasks.</p> </li> <li> <p>COCO for semantic segmentation tasks (bounding box and semantic segmentation)</p> </li> <li> <p>Pascal VOC for object detection tasks.</p> </li> </ul> <p>Example</p> <pre><code>from kili.client import Kili\nkili = Kili()\nkili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n</code></pre> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>def export_labels(\n    self,\n    project_id: str,\n    filename: str,\n    fmt: LabelFormat,\n    asset_ids: Optional[List[str]] = None,\n    layout: SplitOption = \"split\",\n    single_file: bool = False,\n    disable_tqdm: bool = False,\n    with_assets: bool = True,\n    external_ids: Optional[List[str]] = None,\n):\n\"\"\"\n    Export the project labels with the requested format into the requested output path.\n\n    Args:\n        project_id: Identifier of the project.\n        filename: Relative or full path of the archive that will contain\n            the exported data.\n        fmt: Format of the exported labels.\n        asset_ids: Optional list of the assets internal IDs from which to export the labels.\n        layout: Layout of the exported files. \"split\" means there is one folder\n            per job, \"merged\" that there is one folder with every labels.\n        single_file: Layout of the exported labels. Single file mode is\n            only available for some specific formats (COCO and Kili).\n        disable_tqdm: Disable the progress bar if True.\n        with_assets: Download the assets in the export.\n        external_ids: Optional list of the assets external IDs from which to export the labels.\n\n    !!! warning\n        Export is not allowed for projects connected to a cloud storage.\n\n    !!! Info\n        The supported formats are:\n\n        - Yolo V4, V5, V7 for object detection tasks (bounding box)\n\n        - Kili for all tasks.\n\n        - COCO for semantic segmentation tasks (bounding box and semantic segmentation)\n\n        - Pascal VOC for object detection tasks.\n\n    !!! Example\n        ```\n        from kili.client import Kili\n        kili = Kili()\n        kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n        ```\n    \"\"\"\n    if external_ids is not None and asset_ids is None:\n        id_map = infer_ids_from_external_ids(\n            kili=self, asset_external_ids=external_ids, project_id=project_id\n        )\n        asset_ids = [id_map[id] for id in external_ids]\n\n    try:\n        services.export_labels(\n            self,\n            asset_ids=asset_ids,\n            project_id=cast(ProjectId, project_id),\n            export_type=\"latest\",\n            label_format=fmt,\n            split_option=layout,\n            single_file=single_file,\n            output_file=filename,\n            disable_tqdm=disable_tqdm,\n            log_level=\"WARNING\",\n            with_assets=with_assets,\n        )\n    except NoCompatibleJobError as excp:\n        print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","title":"<code>export_labels_as_df(self, project_id, fields=['author.email', 'author.id', 'createdAt', 'id', 'labelType'], asset_fields=['externalId'])</code>","text":"<p>Get the labels of a project as a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'createdAt', 'id', 'labelType']</code> <code>asset_fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['externalId']</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas DataFrame containing the labels.</p> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef export_labels_as_df(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"createdAt\",\n        \"id\",\n        \"labelType\",\n    ],\n    asset_fields: List[str] = [\"externalId\"],\n) -&gt; pd.DataFrame:\n    # pylint: disable=line-too-long\n\"\"\"Get the labels of a project as a pandas DataFrame.\n\n    Args:\n        project_id: Identifier of the project\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        asset_fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n    Returns:\n        pandas DataFrame containing the labels.\n    \"\"\"\n\n    services.get_project(self, project_id, [\"id\"])\n    assets_gen = AssetQuery(self.auth.client)(\n        AssetWhere(project_id=project_id),\n        asset_fields + [\"labels.\" + field for field in fields],\n        QueryOptions(disable_tqdm=False),\n    )\n    labels = [\n        dict(\n            label,\n            **dict((f\"asset_{key}\", asset[key]) for key in asset if key != \"labels\"),\n        )\n        for asset in assets_gen\n        for label in asset[\"labels\"]\n    ]\n    labels_df = pd.DataFrame(labels)\n    return labels_df\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.inferences","title":"<code>inferences(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=None, first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=False, category_search=None, *, as_generator=False)</code>","text":"<p>Get inference labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"INFERENCE\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>None</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n</code></pre> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef inferences(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get inference labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n    \"\"\"\n    if fields is None:\n        fields = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ]\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"INFERENCE\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # type: ignore\n    )\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.labels","title":"<code>labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'], first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, type_in=None, user_id=None, disable_tqdm=False, category_search=None, *, as_generator=False)</code>","text":"<p>Get a label list or a label generator from a project based on a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n</code></pre> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\ncategory_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\ncategory_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"secondsToLabel\",\n    ],\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n\n    if category_search:\n        validate_category_search_query(category_search)\n\n    where = LabelWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        type_in=type_in,\n        user_id=user_id,\n        category_search=category_search,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    labels_gen = LabelQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return labels_gen\n    return list(labels_gen)\n</code></pre>"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.predictions","title":"<code>predictions(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=None, first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=False, category_search=None, *, as_generator=False)</code>","text":"<p>Get prediction labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"PREDICTION\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>None</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n</code></pre> Source code in <code>kili/queries/label/__init__.py</code> <pre><code>@typechecked\ndef predictions(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get prediction labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n    \"\"\"\n    if fields is None:\n        fields = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ]\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"PREDICTION\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # type: ignore\n    )\n</code></pre>"},{"location":"sdk/label/#mutations","title":"Mutations","text":"<p>Set of Label mutations.</p> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>class MutationsLabel:\n\"\"\"Set of Label mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    def __init__(self, auth):\n\"\"\"Initializes the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def create_predictions(\n        self,\n        project_id: str,\n        external_id_array: Optional[List[str]] = None,\n        model_name_array: Optional[List[str]] = None,\n        json_response_array: Optional[List[dict]] = None,\n        model_name: Optional[str] = None,\n        asset_id_array: Optional[List[str]] = None,\n    ) -&gt; dict:\n        # pylint: disable=line-too-long\n\"\"\"Create predictions for specific assets.\n\n        Args:\n            project_id: Identifier of the project.\n            external_id_array: The external IDs of the assets for which we want to add predictions.\n            model_name_array: [Deprecated] use `model_name` instead.\n            json_response_array: The predictions are given here. For examples,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n            model_name: The name of the model that generated the predictions\n            asset_id_array: The internal IDs of the assets for which we want to add predictions.\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n        !!! warning \"model name\"\n            The use of `model_name_array` is deprecated. Creating predictions from different\n            models is not supported anymore. Please use `model_name` argument instead to\n            provide the predictions model name.\"\n        \"\"\"\n        if json_response_array is None or len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one prediction to upload\"\n            )\n        assert_all_arrays_have_same_size(\n            [external_id_array, json_response_array, model_name_array, asset_id_array]\n        )\n        if model_name is None:\n            if model_name_array is None:\n                raise ValueError(\"You must provide a model name with the model_name argument \")\n            if len(set(model_name_array)) &gt; 1:\n                raise ValueError(\n                    \"Creating predictions from different models is not supported anymore. Separate\"\n                    \" your calls by models.\"\n                )\n            warnings.warn(\n                (\n                    \"The use of `model_name_array` is deprecated. Creating predictions from\"\n                    \" different models is not supported anymore. Please use `model_name` argument\"\n                    \" instead to provide the predictions model name.\"\n                ),\n                DeprecationWarning,\n            )\n            model_name = model_name_array[0]\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n            }\n            for (asset_id, asset_external_id, json_response) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                )\n            )\n        ]\n        services.import_labels_from_dict(self, project_id, labels, \"PREDICTION\", model_name)\n        return {\"id\": project_id}\n\n    @deprecate(\n        msg=(\n            \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n            \" function allows to import several labels 10 times faster.\"\n        )\n    )\n    @typechecked\n    def append_to_labels(\n        self,\n        json_response: dict,\n        author_id: Optional[str] = None,\n        label_asset_external_id: Optional[str] = None,\n        label_asset_id: Optional[str] = None,\n        label_type: str = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        seconds_to_label: Optional[int] = 0,\n    ):\n\"\"\"\n        !!! danger \"[DEPRECATED]\"\n            append_to_labels method is deprecated. Please use append_labels instead.\n            This new function allows to import several labels 10 times faster.\n\n        Append a label to an asset.\n\n        Args:\n            json_response: Label is given here\n            author_id: ID of the author of the label\n            label_asset_external_id: External identifier of the asset\n            label_asset_id: Identifier of the asset\n            project_id: Identifier of the project\n            label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n            seconds_to_label: Time to create the label\n\n        !!! warning\n            Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n\n        \"\"\"\n        if author_id is None:\n            author_id = self.auth.user_id\n        check_asset_identifier_arguments(\n            project_id,\n            [label_asset_id] if label_asset_id else None,\n            [label_asset_external_id] if label_asset_external_id else None,\n        )\n        if label_asset_id is None:\n            assert label_asset_external_id and project_id\n            label_asset_id = infer_ids_from_external_ids(\n                self, [label_asset_external_id], project_id\n            )[label_asset_external_id]\n        variables = {\n            \"data\": {\n                \"authorID\": author_id,\n                \"jsonResponse\": dumps(json_response),\n                \"labelType\": label_type,\n                \"secondsToLabel\": seconds_to_label,\n            },\n            \"where\": {\"id\": label_asset_id},\n        }\n        result = self.auth.client.execute(GQL_APPEND_TO_LABELS, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def append_labels(  # pylint: disable=dangerous-default-value\n        self,\n        asset_id_array: Optional[List[str]] = None,\n        json_response_array: List[Dict] = [],\n        author_id_array: Optional[List[str]] = None,\n        seconds_to_label_array: Optional[List[int]] = None,\n        model_name: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        asset_external_id_array: Optional[List[str]] = None,\n        disable_tqdm: bool = False,\n    ) -&gt; List:\n\"\"\"Append labels to assets.\n\n        Args:\n            asset_id_array: list of asset internal ids to append labels on\n            json_response_array: list of labels to append\n            author_id_array: list of the author id of the labels\n            seconds_to_label_array: list of times taken to produce the label, in seconds\n            model_name: Only useful when uploading predictions.\n                Name of the model when uploading predictions\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n            project_id: Identifier of the project\n            asset_external_id_array: list of asset external ids to append labels on\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(\n                    asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                    json_response_array=[{...}, {...}]\n                )\n        \"\"\"\n        if len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one label to upload\"\n            )\n        check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n        assert_all_arrays_have_same_size(\n            [\n                seconds_to_label_array,\n                author_id_array,\n                json_response_array,\n                asset_external_id_array,\n                asset_id_array,\n            ]\n        )\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n                \"seconds_to_label\": seconds_to_label,\n                \"author_id\": author_id,\n            }\n            for (asset_id, asset_external_id, json_response, seconds_to_label, author_id) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    asset_external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                    seconds_to_label_array or [None] * len(json_response_array),\n                    author_id_array or [None] * len(json_response_array),\n                )\n            )\n        ]\n        return services.import_labels_from_dict(\n            self, project_id, labels, label_type, model_name, disable_tqdm\n        )\n\n    @typechecked\n    def update_properties_in_label(\n        self,\n        label_id: str,\n        seconds_to_label: Optional[int] = None,\n        model_name: Optional[str] = None,\n        json_response: Optional[dict] = None,\n    ) -&gt; Label:\n\"\"\"Update properties of a label.\n\n        Args:\n            label_id: Identifier of the label\n            seconds_to_label: Time to create the label\n            model_name: Name of the model\n            json_response: The label is given here\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n        \"\"\"\n        formatted_json_response = None if json_response is None else dumps(json_response)\n        variables = {\n            \"labelID\": label_id,\n            \"secondsToLabel\": seconds_to_label,\n            \"modelName\": model_name,\n            \"jsonResponse\": formatted_json_response,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def create_honeypot(\n        self,\n        json_response: dict,\n        asset_external_id: Optional[str] = None,\n        asset_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Label:\n\"\"\"Create honeypot for an asset.\n\n        !!! info\n            Uses the given `json_response` to create a `REVIEW` label.\n            This enables Kili to compute a`honeypotMark`,\n            which measures the similarity between this label and other labels.\n\n        Args:\n            json_response: The JSON response of the honeypot label of the asset\n            asset_id: Identifier of the asset\n                Either provide asset_id or asset_external_id and project_id\n            asset_external_id: External identifier of the asset\n                Either provide asset_id or asset_external_id and project_id\n            project_id: Identifier of the project\n                Either provide asset_id or asset_external_id and project_id\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        if asset_id is None:\n            if asset_external_id is None or project_id is None:\n                raise ValueError(\"Either provide asset_id or external_id and project_id\")\n            asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n                asset_external_id\n            ]\n\n        variables = {\n            \"data\": {\"jsonResponse\": dumps(json_response)},\n            \"where\": {\"id\": asset_id},\n        }\n        result = self.auth.client.execute(GQL_CREATE_HONEYPOT, variables)\n        return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_labels","title":"<code>append_labels(self, asset_id_array=None, json_response_array=[], author_id_array=None, seconds_to_label_array=None, model_name=None, label_type='DEFAULT', project_id=None, asset_external_id_array=None, disable_tqdm=False)</code>","text":"<p>Append labels to assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>list of asset internal ids to append labels on</p> <code>None</code> <code>json_response_array</code> <code>List[Dict]</code> <p>list of labels to append</p> <code>[]</code> <code>author_id_array</code> <code>Optional[List[str]]</code> <p>list of the author id of the labels</p> <code>None</code> <code>seconds_to_label_array</code> <code>Optional[List[int]]</code> <p>list of times taken to produce the label, in seconds</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Only useful when uploading predictions. Name of the model when uploading predictions</p> <code>None</code> <code>label_type</code> <code>typing_extensions.Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code></p> <code>'DEFAULT'</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project</p> <code>None</code> <code>asset_external_id_array</code> <code>Optional[List[str]]</code> <p>list of asset external ids to append labels on</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(\n        asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n        json_response_array=[{...}, {...}]\n    )\n</code></pre> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef append_labels(  # pylint: disable=dangerous-default-value\n    self,\n    asset_id_array: Optional[List[str]] = None,\n    json_response_array: List[Dict] = [],\n    author_id_array: Optional[List[str]] = None,\n    seconds_to_label_array: Optional[List[int]] = None,\n    model_name: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    asset_external_id_array: Optional[List[str]] = None,\n    disable_tqdm: bool = False,\n) -&gt; List:\n\"\"\"Append labels to assets.\n\n    Args:\n        asset_id_array: list of asset internal ids to append labels on\n        json_response_array: list of labels to append\n        author_id_array: list of the author id of the labels\n        seconds_to_label_array: list of times taken to produce the label, in seconds\n        model_name: Only useful when uploading predictions.\n            Name of the model when uploading predictions\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n        project_id: Identifier of the project\n        asset_external_id_array: list of asset external ids to append labels on\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(\n                asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                json_response_array=[{...}, {...}]\n            )\n    \"\"\"\n    if len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one label to upload\"\n        )\n    check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n    assert_all_arrays_have_same_size(\n        [\n            seconds_to_label_array,\n            author_id_array,\n            json_response_array,\n            asset_external_id_array,\n            asset_id_array,\n        ]\n    )\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n            \"seconds_to_label\": seconds_to_label,\n            \"author_id\": author_id,\n        }\n        for (asset_id, asset_external_id, json_response, seconds_to_label, author_id) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                asset_external_id_array or [None] * len(json_response_array),\n                json_response_array,\n                seconds_to_label_array or [None] * len(json_response_array),\n                author_id_array or [None] * len(json_response_array),\n            )\n        )\n    ]\n    return services.import_labels_from_dict(\n        self, project_id, labels, label_type, model_name, disable_tqdm\n    )\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","title":"<code>append_to_labels(self, json_response, author_id=None, label_asset_external_id=None, label_asset_id=None, label_type='DEFAULT', project_id=None, seconds_to_label=0)</code>","text":"<p>[DEPRECATED]</p> <p>append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster.</p> <p>Append a label to an asset.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>Label is given here</p> required <code>author_id</code> <code>Optional[str]</code> <p>ID of the author of the label</p> <code>None</code> <code>label_asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset</p> <code>None</code> <code>label_asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project</p> <code>None</code> <code>label_type</code> <code>str</code> <p>Can be one of <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code></p> <code>'DEFAULT'</code> <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label</p> <code>0</code> <p>Warning</p> <p>Either provide <code>label_asset_id</code> or <code>label_asset_external_id</code> and <code>project_id</code></p> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n</code></pre> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@deprecate(\n    msg=(\n        \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n        \" function allows to import several labels 10 times faster.\"\n    )\n)\n@typechecked\ndef append_to_labels(\n    self,\n    json_response: dict,\n    author_id: Optional[str] = None,\n    label_asset_external_id: Optional[str] = None,\n    label_asset_id: Optional[str] = None,\n    label_type: str = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    seconds_to_label: Optional[int] = 0,\n):\n\"\"\"\n    !!! danger \"[DEPRECATED]\"\n        append_to_labels method is deprecated. Please use append_labels instead.\n        This new function allows to import several labels 10 times faster.\n\n    Append a label to an asset.\n\n    Args:\n        json_response: Label is given here\n        author_id: ID of the author of the label\n        label_asset_external_id: External identifier of the asset\n        label_asset_id: Identifier of the asset\n        project_id: Identifier of the project\n        label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`\n        seconds_to_label: Time to create the label\n\n    !!! warning\n        Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n\n    \"\"\"\n    if author_id is None:\n        author_id = self.auth.user_id\n    check_asset_identifier_arguments(\n        project_id,\n        [label_asset_id] if label_asset_id else None,\n        [label_asset_external_id] if label_asset_external_id else None,\n    )\n    if label_asset_id is None:\n        assert label_asset_external_id and project_id\n        label_asset_id = infer_ids_from_external_ids(\n            self, [label_asset_external_id], project_id\n        )[label_asset_external_id]\n    variables = {\n        \"data\": {\n            \"authorID\": author_id,\n            \"jsonResponse\": dumps(json_response),\n            \"labelType\": label_type,\n            \"secondsToLabel\": seconds_to_label,\n        },\n        \"where\": {\"id\": label_asset_id},\n    }\n    result = self.auth.client.execute(GQL_APPEND_TO_LABELS, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","title":"<code>create_honeypot(self, json_response, asset_external_id=None, asset_id=None, project_id=None)</code>","text":"<p>Create honeypot for an asset.</p> <p>Info</p> <p>Uses the given <code>json_response</code> to create a <code>REVIEW</code> label. This enables Kili to compute a<code>honeypotMark</code>, which measures the similarity between this label and other labels.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>The JSON response of the honeypot label of the asset</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset Either provide asset_id or asset_external_id and project_id</p> <code>None</code> <code>asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset Either provide asset_id or asset_external_id and project_id</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project Either provide asset_id or asset_external_id and project_id</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_honeypot(\n    self,\n    json_response: dict,\n    asset_external_id: Optional[str] = None,\n    asset_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n) -&gt; Label:\n\"\"\"Create honeypot for an asset.\n\n    !!! info\n        Uses the given `json_response` to create a `REVIEW` label.\n        This enables Kili to compute a`honeypotMark`,\n        which measures the similarity between this label and other labels.\n\n    Args:\n        json_response: The JSON response of the honeypot label of the asset\n        asset_id: Identifier of the asset\n            Either provide asset_id or asset_external_id and project_id\n        asset_external_id: External identifier of the asset\n            Either provide asset_id or asset_external_id and project_id\n        project_id: Identifier of the project\n            Either provide asset_id or asset_external_id and project_id\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    if asset_id is None:\n        if asset_external_id is None or project_id is None:\n            raise ValueError(\"Either provide asset_id or external_id and project_id\")\n        asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n            asset_external_id\n        ]\n\n    variables = {\n        \"data\": {\"jsonResponse\": dumps(json_response)},\n        \"where\": {\"id\": asset_id},\n    }\n    result = self.auth.client.execute(GQL_CREATE_HONEYPOT, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","title":"<code>create_predictions(self, project_id, external_id_array=None, model_name_array=None, json_response_array=None, model_name=None, asset_id_array=None)</code>","text":"<p>Create predictions for specific assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>external_id_array</code> <code>Optional[List[str]]</code> <p>The external IDs of the assets for which we want to add predictions.</p> <code>None</code> <code>model_name_array</code> <code>Optional[List[str]]</code> <p>[Deprecated] use <code>model_name</code> instead.</p> <code>None</code> <code>json_response_array</code> <code>Optional[List[dict]]</code> <p>The predictions are given here. For examples, see the recipe.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>The name of the model that generated the predictions</p> <code>None</code> <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>The internal IDs of the assets for which we want to add predictions.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Recipe</p> <p>For more detailed examples on how to create predictions, see the recipe.</p> <p>model name</p> <p>The use of <code>model_name_array</code> is deprecated. Creating predictions from different models is not supported anymore. Please use <code>model_name</code> argument instead to provide the predictions model name.\"</p> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_predictions(\n    self,\n    project_id: str,\n    external_id_array: Optional[List[str]] = None,\n    model_name_array: Optional[List[str]] = None,\n    json_response_array: Optional[List[dict]] = None,\n    model_name: Optional[str] = None,\n    asset_id_array: Optional[List[str]] = None,\n) -&gt; dict:\n    # pylint: disable=line-too-long\n\"\"\"Create predictions for specific assets.\n\n    Args:\n        project_id: Identifier of the project.\n        external_id_array: The external IDs of the assets for which we want to add predictions.\n        model_name_array: [Deprecated] use `model_name` instead.\n        json_response_array: The predictions are given here. For examples,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n        model_name: The name of the model that generated the predictions\n        asset_id_array: The internal IDs of the assets for which we want to add predictions.\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n    !!! warning \"model name\"\n        The use of `model_name_array` is deprecated. Creating predictions from different\n        models is not supported anymore. Please use `model_name` argument instead to\n        provide the predictions model name.\"\n    \"\"\"\n    if json_response_array is None or len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one prediction to upload\"\n        )\n    assert_all_arrays_have_same_size(\n        [external_id_array, json_response_array, model_name_array, asset_id_array]\n    )\n    if model_name is None:\n        if model_name_array is None:\n            raise ValueError(\"You must provide a model name with the model_name argument \")\n        if len(set(model_name_array)) &gt; 1:\n            raise ValueError(\n                \"Creating predictions from different models is not supported anymore. Separate\"\n                \" your calls by models.\"\n            )\n        warnings.warn(\n            (\n                \"The use of `model_name_array` is deprecated. Creating predictions from\"\n                \" different models is not supported anymore. Please use `model_name` argument\"\n                \" instead to provide the predictions model name.\"\n            ),\n            DeprecationWarning,\n        )\n        model_name = model_name_array[0]\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n        }\n        for (asset_id, asset_external_id, json_response) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                external_id_array or [None] * len(json_response_array),\n                json_response_array,\n            )\n        )\n    ]\n    services.import_labels_from_dict(self, project_id, labels, \"PREDICTION\", model_name)\n    return {\"id\": project_id}\n</code></pre>"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","title":"<code>update_properties_in_label(self, label_id, seconds_to_label=None, model_name=None, json_response=None)</code>","text":"<p>Update properties of a label.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>Identifier of the label</p> required <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model</p> <code>None</code> <code>json_response</code> <code>Optional[dict]</code> <p>The label is given here</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n</code></pre> Source code in <code>kili/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_label(\n    self,\n    label_id: str,\n    seconds_to_label: Optional[int] = None,\n    model_name: Optional[str] = None,\n    json_response: Optional[dict] = None,\n) -&gt; Label:\n\"\"\"Update properties of a label.\n\n    Args:\n        label_id: Identifier of the label\n        seconds_to_label: Time to create the label\n        model_name: Name of the model\n        json_response: The label is given here\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n    \"\"\"\n    formatted_json_response = None if json_response is None else dumps(json_response)\n    variables = {\n        \"labelID\": label_id,\n        \"secondsToLabel\": seconds_to_label,\n        \"modelName\": model_name,\n        \"jsonResponse\": formatted_json_response,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#subscriptions","title":"Subscriptions","text":"<p>Set of Label subscriptions.</p> Source code in <code>kili/subscriptions/label/__init__.py</code> <pre><code>class SubscriptionsLabel:\n\"\"\"Set of Label subscriptions.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def label_created_or_updated(\n        self, project_id: str, callback: Callable[[str, str], None]\n    ) -&gt; SubscriptionGraphQLClient:\n        # pylint: disable=line-too-long\n\"\"\"\n        Subscribe a callback to a project, which is executed when a label is created or updated.\n\n        Args:\n            project_id: Identifier of the project\n            callback: This function takes as input the id of the asset and its content.\n\n        Returns:\n            A subscription client.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to use Webhooks,\n            See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb)\n        \"\"\"\n        ws_endpoint = self.auth.client.endpoint.replace(\"http\", \"ws\")\n        websocket = SubscriptionGraphQLClient(ws_endpoint)\n        headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n        authorization = f\"{self.auth.client.token}\"\n        headers[\"Authorization\"] = authorization\n        variables = {\"projectID\": project_id}\n        websocket.subscribe(\n            GQL_LABEL_CREATED_OR_UPDATED,\n            variables=variables,\n            callback=callback,\n            headers=headers,\n            authorization=authorization,\n        )\n        return websocket\n</code></pre>"},{"location":"sdk/label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","title":"<code>label_created_or_updated(self, project_id, callback)</code>","text":"<p>Subscribe a callback to a project, which is executed when a label is created or updated.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>callback</code> <code>Callable[[str, str], NoneType]</code> <p>This function takes as input the id of the asset and its content.</p> required <p>Returns:</p> Type Description <code>SubscriptionGraphQLClient</code> <p>A subscription client.</p> <p>Recipe</p> <p>For more detailed examples on how to use Webhooks, See the related recipe</p> Source code in <code>kili/subscriptions/label/__init__.py</code> <pre><code>@typechecked\ndef label_created_or_updated(\n    self, project_id: str, callback: Callable[[str, str], None]\n) -&gt; SubscriptionGraphQLClient:\n    # pylint: disable=line-too-long\n\"\"\"\n    Subscribe a callback to a project, which is executed when a label is created or updated.\n\n    Args:\n        project_id: Identifier of the project\n        callback: This function takes as input the id of the asset and its content.\n\n    Returns:\n        A subscription client.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to use Webhooks,\n        See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb)\n    \"\"\"\n    ws_endpoint = self.auth.client.endpoint.replace(\"http\", \"ws\")\n    websocket = SubscriptionGraphQLClient(ws_endpoint)\n    headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n    authorization = f\"{self.auth.client.token}\"\n    headers[\"Authorization\"] = authorization\n    variables = {\"projectID\": project_id}\n    websocket.subscribe(\n        GQL_LABEL_CREATED_OR_UPDATED,\n        variables=variables,\n        callback=callback,\n        headers=headers,\n        authorization=authorization,\n    )\n    return websocket\n</code></pre>"},{"location":"sdk/notification/","title":"Notification module","text":""},{"location":"sdk/notification/#queries","title":"Queries","text":"<p>Set of Notification queries.</p> Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>class QueriesNotification:\n\"\"\"Set of Notification queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n        Args:\n            fields: All the fields to request among the possible fields for the notifications\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n            first: Number of notifications to query\n            has_been_seen: If the notifications returned should have been seen.\n            notification_id: If given, will return the notification which has this id\n            skip: Number of notifications to skip (they are ordered by their date of creation,\n                first to last).\n            user_id: If given, returns the notifications of a specific user\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the notifications is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n\n        where = NotificationWhere(\n            has_been_seen=has_been_seen,\n            notification_id=notification_id,\n            user_id=user_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        notifications_gen = NotificationQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return notifications_gen\n        return list(notifications_gen)\n\n    @typechecked\n    def count_notifications(\n        self,\n        has_been_seen: Optional[bool] = None,\n        user_id: Optional[str] = None,\n        notification_id: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Count the number of notifications.\n\n        Args:\n            has_been_seen: Filter on notifications that have been seen.\n            user_id: Filter on the notifications of a specific user\n\n        Returns:\n            The number of notifications with the parameters provided\n        \"\"\"\n        where = NotificationWhere(\n            has_been_seen=has_been_seen,\n            notification_id=notification_id,\n            user_id=user_id,\n        )\n        return NotificationQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","title":"<code>count_notifications(self, has_been_seen=None, user_id=None, notification_id=None)</code>","text":"<p>Count the number of notifications.</p> <p>Parameters:</p> Name Type Description Default <code>has_been_seen</code> <code>Optional[bool]</code> <p>Filter on notifications that have been seen.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Filter on the notifications of a specific user</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of notifications with the parameters provided</p> Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef count_notifications(\n    self,\n    has_been_seen: Optional[bool] = None,\n    user_id: Optional[str] = None,\n    notification_id: Optional[str] = None,\n) -&gt; int:\n\"\"\"Count the number of notifications.\n\n    Args:\n        has_been_seen: Filter on notifications that have been seen.\n        user_id: Filter on the notifications of a specific user\n\n    Returns:\n        The number of notifications with the parameters provided\n    \"\"\"\n    where = NotificationWhere(\n        has_been_seen=has_been_seen,\n        notification_id=notification_id,\n        user_id=user_id,\n    )\n    return NotificationQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.notifications","title":"<code>notifications(self, fields=['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'], first=None, has_been_seen=None, notification_id=None, skip=0, user_id=None, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of notifications respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the notifications See the documentation for all possible fields.</p> <code>['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID']</code> <code>first</code> <code>Optional[int]</code> <p>Number of notifications to query</p> <code>None</code> <code>has_been_seen</code> <code>Optional[bool]</code> <p>If the notifications returned should have been seen.</p> <code>None</code> <code>notification_id</code> <code>Optional[str]</code> <p>If given, will return the notification which has this id</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of notifications to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>If given, returns the notifications of a specific user</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the notifications is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef notifications(\n    self,\n    fields: List[str] = [\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"id\",\n        \"message\",\n        \"status\",\n        \"userID\",\n    ],\n    first: Optional[int] = None,\n    has_been_seen: Optional[bool] = None,\n    notification_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n    Args:\n        fields: All the fields to request among the possible fields for the notifications\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n        first: Number of notifications to query\n        has_been_seen: If the notifications returned should have been seen.\n        notification_id: If given, will return the notification which has this id\n        skip: Number of notifications to skip (they are ordered by their date of creation,\n            first to last).\n        user_id: If given, returns the notifications of a specific user\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the notifications is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n\n    where = NotificationWhere(\n        has_been_seen=has_been_seen,\n        notification_id=notification_id,\n        user_id=user_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    notifications_gen = NotificationQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return notifications_gen\n    return list(notifications_gen)\n</code></pre>"},{"location":"sdk/organization/","title":"Organization module","text":""},{"location":"sdk/organization/#queries","title":"Queries","text":"<p>Set of Organization queries</p> Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>class QueriesOrganization:\n\"\"\"\n    Set of Organization queries\n    \"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n        Args:\n            email : Email of a user of the organization\n            organization_id : Identifier of the organization\n            fields: All the fields to request among the possible fields for the organizations.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n            first: Maximum number of organizations to return.\n            skip: Number of skipped organizations (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the organizations is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n            [{'users': [{'email': 'john@doe.com'}]}]\n        \"\"\"\n\n        where = OrganizationWhere(\n            email=email,\n            organization_id=organization_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        organizations_gen = OrganizationQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return organizations_gen\n        return list(organizations_gen)\n\n    @typechecked\n    def count_organizations(\n        self, email: Optional[str] = None, organization_id: Optional[str] = None\n    ) -&gt; int:\n\"\"\"Count organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        where = OrganizationWhere(\n            email=email,\n            organization_id=organization_id,\n        )\n        return OrganizationQuery(self.auth.client).count(where)\n\n    @typechecked\n    def organization_metrics(\n        self,\n        organization_id: str,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -&gt; Dict:\n\"\"\"Get organization metrics.\n\n        Args:\n            organization_id: Identifier of the organization\n            start_date: Start date of the metrics computation\n            end_date: End date of the metrics computation\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        if start_date is None:\n            start_date = datetime.now()\n        if end_date is None:\n            end_date = datetime.now()\n        where = OrganizationMetricsWhere(\n            organization_id=organization_id, start_date=start_date, end_date=end_date\n        )\n        return OrganizationQuery(self.auth.client).metrics(where)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","title":"<code>count_organizations(self, email=None, organization_id=None)</code>","text":"<p>Count organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef count_organizations(\n    self, email: Optional[str] = None, organization_id: Optional[str] = None\n) -&gt; int:\n\"\"\"Count organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    where = OrganizationWhere(\n        email=email,\n        organization_id=organization_id,\n    )\n    return OrganizationQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","title":"<code>organization_metrics(self, organization_id, start_date=None, end_date=None)</code>","text":"<p>Get organization metrics.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>str</code> <p>Identifier of the organization</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Start date of the metrics computation</p> <code>None</code> <code>end_date</code> <code>Optional[datetime.datetime]</code> <p>End date of the metrics computation</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organization_metrics(\n    self,\n    organization_id: str,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n) -&gt; Dict:\n\"\"\"Get organization metrics.\n\n    Args:\n        organization_id: Identifier of the organization\n        start_date: Start date of the metrics computation\n        end_date: End date of the metrics computation\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    if start_date is None:\n        start_date = datetime.now()\n    if end_date is None:\n        end_date = datetime.now()\n    where = OrganizationMetricsWhere(\n        organization_id=organization_id, start_date=start_date, end_date=end_date\n    )\n    return OrganizationQuery(self.auth.client).metrics(where)\n</code></pre>"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","title":"<code>organizations(self, email=None, organization_id=None, fields=['id', 'name'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <p>Identifier of the organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the organizations. See the documentation for all possible fields.</p> <code>['id', 'name']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of organizations to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped organizations (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the organizations is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n[{'users': [{'email': 'john@doe.com'}]}]\n</code></pre> Source code in <code>kili/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organizations(\n    self,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"id\", \"name\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n    Args:\n        email : Email of a user of the organization\n        organization_id : Identifier of the organization\n        fields: All the fields to request among the possible fields for the organizations.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n        first: Maximum number of organizations to return.\n        skip: Number of skipped organizations (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the organizations is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n        [{'users': [{'email': 'john@doe.com'}]}]\n    \"\"\"\n\n    where = OrganizationWhere(\n        email=email,\n        organization_id=organization_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    organizations_gen = OrganizationQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return organizations_gen\n    return list(organizations_gen)\n</code></pre>"},{"location":"sdk/plugins/","title":"Plugin module","text":""},{"location":"sdk/plugins/#plugins-structure","title":"Plugins structure","text":"<p>A plugin is an uploaded Python script triggered by an event. It can be defined as either :</p> <ul> <li>a single <code>python</code> file with everything inside</li> <li>a plugin module (a folder) containing multiple <code>python</code> files and a non mandatory <code>requirements.txt</code> file listing all the dependencies you need for you plugin.</li> </ul> <p>In the case of the module type plugin, at the root of the folder a file named <code>main.py</code> is strictly necessary, as it serves as the entrypoint of the plugin. In this <code>main.py</code> file, you can import what you need from other <code>python</code> files in the folder. The structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file): <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre></p> <p>The plugin you are going to upload has to contain a <code>class PluginHandler(PluginCore)</code> (in the case of the module type plugin it has to be inside <code>main.py</code>) that implements two methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted (a dictionary containing the fields of the GraphQL type Label)</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>You can add custom methods in your class as well.</p> <p>Moreover, some attributes are directly available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin (of <code>main.py</code> in the case of the module type plugin) should look like this:</p> <pre><code>from kili.plugins import PluginCore\nfrom kili.types import Label\nimport numpy as np\n\ndef custom_function():\n    # Do something...\n\nclass PluginHandler(PluginCore):\n\"\"\"Custom plugin\"\"\"\n\n    def custom_method(self):\n        # Do something...\n\n    def on_review(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Note</p> <p>The plugins run has some limitations, it can use a maximum of 512mb of ram and will timeout after 60sec of run</p>"},{"location":"sdk/plugins/#model-for-plugins","title":"Model for Plugins","text":"<p>Kili Plugin core class</p> <p>Parameters:</p> Name Type Description Default <code>kili</code> <code>Kili</code> <p>kili instance that plugins can make use of</p> required <code>project_id</code> <code>str</code> <p>the project on which plugin is ran</p> required <p>Implements:</p> <pre><code>on_submit(self, label: Label, asset_id: str)\non_review(self, label: Label, asset_id: str)\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore--warning-if-using-a-custom-init-be-sure-to-call-superinit","title":"Warning : if using a custom init, be sure to call super().init()","text":"Source code in <code>kili/services/plugins/model.py</code> <pre><code>class PluginCore:\n\"\"\"\n    Kili Plugin core class\n\n    Args:\n        kili: kili instance that plugins can make use of\n        project_id: the project on which plugin is ran\n\n    Implements:\n\n        on_submit(self, label: Label, asset_id: str)\n        on_review(self, label: Label, asset_id: str)\n\n    # Warning : if using a custom init, be sure to call super().__init__()\n    \"\"\"\n\n    logger: logging.Logger\n    kili: Kili\n    project_id: str\n\n    def __init__(\n        self, kili: Kili, project_id: str, logger: Optional[logging.Logger] = None\n    ) -&gt; None:\n        self.kili = kili\n        self.project_id = project_id\n        if logger:\n            self.logger = logger\n        else:\n            self.logger = get_logger()\n\n    def on_submit(\n        self,\n        label: Label,\n        asset_id: str,\n    ) -&gt; None:\n\"\"\"\n        Handler for the submit action, triggered when a default label is submitted into Kili.\n\n        Args:\n            label: label submitted to Kili\n            asset_id: id of the asset on which the label was submitted\n\n\n        Example use:\n\n            &gt;&gt;&gt; def on_submit(self, label: Label, asset_id: str):\n            &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n            &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n            &gt;&gt;&gt;         return\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n        pass  # pylint: disable=unnecessary-pass\n\n    def on_review(\n        self,\n        label: Label,\n        asset_id: str,\n    ) -&gt; None:\n\"\"\"\n        Handler for the review action, triggered when a default label is reviewed on Kili\n\n        Args:\n            label: label submitted to Kili\n            asset_id: id of the asset on which the label was submitted\n\n        Example use:\n\n            &gt;&gt;&gt; def on_review(self, label: Label, asset_id: str):\n            &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n            &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n            &gt;&gt;&gt;         return\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n        pass  # pylint: disable=unnecessary-pass\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_review","title":"<code>on_review(self, label, asset_id)</code>","text":"<p>Handler for the review action, triggered when a default label is reviewed on Kili</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Label</code> <p>label submitted to Kili</p> required <code>asset_id</code> <code>str</code> <p>id of the asset on which the label was submitted</p> required <p>Example use:</p> <pre><code>&gt;&gt;&gt; def on_review(self, label: Label, asset_id: str):\n&gt;&gt;&gt;     json_response = label.get('jsonResponse')\n&gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n&gt;&gt;&gt;         return\n&gt;&gt;&gt;     else:\n&gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_review(\n    self,\n    label: Label,\n    asset_id: str,\n) -&gt; None:\n\"\"\"\n    Handler for the review action, triggered when a default label is reviewed on Kili\n\n    Args:\n        label: label submitted to Kili\n        asset_id: id of the asset on which the label was submitted\n\n    Example use:\n\n        &gt;&gt;&gt; def on_review(self, label: Label, asset_id: str):\n        &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n        &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n        &gt;&gt;&gt;         return\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n    pass  # pylint: disable=unnecessary-pass\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_submit","title":"<code>on_submit(self, label, asset_id)</code>","text":"<p>Handler for the submit action, triggered when a default label is submitted into Kili.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Label</code> <p>label submitted to Kili</p> required <code>asset_id</code> <code>str</code> <p>id of the asset on which the label was submitted</p> required <p>Example use:</p> <pre><code>&gt;&gt;&gt; def on_submit(self, label: Label, asset_id: str):\n&gt;&gt;&gt;     json_response = label.get('jsonResponse')\n&gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n&gt;&gt;&gt;         return\n&gt;&gt;&gt;     else:\n&gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_submit(\n    self,\n    label: Label,\n    asset_id: str,\n) -&gt; None:\n\"\"\"\n    Handler for the submit action, triggered when a default label is submitted into Kili.\n\n    Args:\n        label: label submitted to Kili\n        asset_id: id of the asset on which the label was submitted\n\n\n    Example use:\n\n        &gt;&gt;&gt; def on_submit(self, label: Label, asset_id: str):\n        &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n        &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n        &gt;&gt;&gt;         return\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n    pass  # pylint: disable=unnecessary-pass\n</code></pre>"},{"location":"sdk/plugins/#queries","title":"Queries","text":"<p>Set of Plugins queries.</p> Source code in <code>kili/queries/plugins/__init__.py</code> <pre><code>class QueriesPlugins:\n\"\"\"Set of Plugins queries.\"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    def __init__(self, auth: KiliAuth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def get_plugin_logs(\n        self,\n        project_id: str,\n        plugin_name: str,\n        start_date: Optional[datetime] = None,\n        limit: Optional[int] = None,\n        skip: Optional[int] = None,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Get paginated logs of a plugin on a project.\n        Args:\n            project_id: Identifier of the project\n            plugin_name: Name of the plugin\n            start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n            limit: Limit for pagination, if not provided, it will be 100\n            skip: Skip for pagination, if not provided, it will be 0\n        Returns:\n            A result array which contains the logs of the plugin,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n        \"\"\"\n\n        where = PluginLogsWhere(\n            project_id=project_id, plugin_name=plugin_name, start_date=start_date\n        )\n        options = QueryOptions(\n            first=limit, skip=skip or 0, disable_tqdm=False\n        )  # disable tqm is not implemnted for this query\n        pretty_result = PluginQuery(self.auth.client).get_logs(where, options)\n        return json.dumps(pretty_result, sort_keys=True, indent=4)\n\n    @typechecked\n    def get_plugin_status(\n        self,\n        plugin_name: str,\n        verbose: bool = True,\n    ):\n\"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            The status of the plugin if query was successful or an error message otherwise.\n\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n        \"\"\"\n\n        result = PluginUploader(self.auth, \"\", plugin_name, verbose).get_plugin_runner_status()\n        return result\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def list_plugins(\n        self,\n        fields: List[str] = [\n            \"name\",\n            \"projectIds\",\n            \"id\",\n            \"createdAt\",\n            \"updatedAt\",\n        ],\n    ):\n        # pylint: disable=line-too-long\n\"\"\"List all plugins from your organization\n        Args:\n            fields: All the fields to request among the possible fields for the plugins\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields.\n\n        Returns:\n            A result array which contains all the plugins from your organization,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.list_plugins()\n            &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n        \"\"\"\n        return PluginQuery(self.auth.client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.get_plugin_logs","title":"<code>get_plugin_logs(self, project_id, plugin_name, start_date=None, limit=None, skip=None)</code>","text":"<p>Get paginated logs of a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Datetime used to get the logs from, if not provided, it will be the plugin's creation date</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Limit for pagination, if not provided, it will be 100</p> <code>None</code> <code>skip</code> <code>Optional[int]</code> <p>Skip for pagination, if not provided, it will be 0</p> <code>None</code> <p>Returns:</p> Type Description <p>A result array which contains the logs of the plugin,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n</code></pre> Source code in <code>kili/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef get_plugin_logs(\n    self,\n    project_id: str,\n    plugin_name: str,\n    start_date: Optional[datetime] = None,\n    limit: Optional[int] = None,\n    skip: Optional[int] = None,\n):\n    # pylint: disable=line-too-long\n\"\"\"Get paginated logs of a plugin on a project.\n    Args:\n        project_id: Identifier of the project\n        plugin_name: Name of the plugin\n        start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n        limit: Limit for pagination, if not provided, it will be 100\n        skip: Skip for pagination, if not provided, it will be 0\n    Returns:\n        A result array which contains the logs of the plugin,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n    \"\"\"\n\n    where = PluginLogsWhere(\n        project_id=project_id, plugin_name=plugin_name, start_date=start_date\n    )\n    options = QueryOptions(\n        first=limit, skip=skip or 0, disable_tqdm=False\n    )  # disable tqm is not implemnted for this query\n    pretty_result = PluginQuery(self.auth.client).get_logs(where, options)\n    return json.dumps(pretty_result, sort_keys=True, indent=4)\n</code></pre>"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.get_plugin_status","title":"<code>get_plugin_status(self, plugin_name, verbose=True)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>The status of the plugin if query was successful or an error message otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef get_plugin_status(\n    self,\n    plugin_name: str,\n    verbose: bool = True,\n):\n\"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        The status of the plugin if query was successful or an error message otherwise.\n\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n    \"\"\"\n\n    result = PluginUploader(self.auth, \"\", plugin_name, verbose).get_plugin_runner_status()\n    return result\n</code></pre>"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.list_plugins","title":"<code>list_plugins(self, fields=['name', 'projectIds', 'id', 'createdAt', 'updatedAt'])</code>","text":"<p>List all plugins from your organization</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the plugins See the documentation for all possible fields.</p> <code>['name', 'projectIds', 'id', 'createdAt', 'updatedAt']</code> <p>Returns:</p> Type Description <p>A result array which contains all the plugins from your organization,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.list_plugins()\n&gt;&gt;&gt; kili.list_plugins(fields=['name'])\n</code></pre> Source code in <code>kili/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef list_plugins(\n    self,\n    fields: List[str] = [\n        \"name\",\n        \"projectIds\",\n        \"id\",\n        \"createdAt\",\n        \"updatedAt\",\n    ],\n):\n    # pylint: disable=line-too-long\n\"\"\"List all plugins from your organization\n    Args:\n        fields: All the fields to request among the possible fields for the plugins\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields.\n\n    Returns:\n        A result array which contains all the plugins from your organization,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.list_plugins()\n        &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n    \"\"\"\n    return PluginQuery(self.auth.client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#mutations","title":"Mutations","text":"<p>Set of Plugins mutations.</p> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>class MutationsPlugins:\n\"\"\"Set of Plugins mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth: KiliAuth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def upload_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        **kwargs\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Uploads a plugin.\n\n        Args:\n            plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file\n            plugin_name: name of your plugin, if not provided, it will be the name from your file\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n        \"\"\"\n\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n                '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n                \" instead\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        return PluginUploader(self.auth, plugin_path, plugin_name, verbose).create_plugin()\n\n    @typechecked\n    def create_webhook(\n        self,\n        webhook_url: str,\n        plugin_name: str,\n        header: Optional[str] = None,\n        verbose: bool = True,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Create a webhook linked to Kili's events.\n\n        Args:\n            webhook_url: URL receiving post requests on events on Kili\n            plugin_name: name of your plugin\n            header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n\n        return WebhookUploader(\n            self.auth, webhook_url, plugin_name, header, verbose\n        ).create_webhook()\n\n    @typechecked\n    def update_webhook(\n        self,\n        new_webhook_url: str,\n        plugin_name: str,\n        new_header: Optional[str] = None,\n        verbose: bool = True,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Update a webhook linked to Kili's events.\n\n        Args:\n            new_webhook_url: New URL receiving post requests on events on Kili\n            plugin_name: name of your plugin\n            new_header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n\n        return WebhookUploader(\n            self.auth, new_webhook_url, plugin_name, new_header, verbose\n        ).update_webhook()\n\n    @typechecked\n    def activate_plugin_on_project(\n        self,\n        plugin_name: str,\n        project_id: str,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n\n        return activate_plugin(self.auth, plugin_name, project_id)\n\n    @typechecked\n    def deactivate_plugin_on_project(\n        self,\n        plugin_name: str,\n        project_id: str,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n\n        return deactivate_plugin(self.auth, plugin_name, project_id)\n\n    @typechecked\n    def delete_plugin(\n        self,\n        plugin_name: str,\n    ):\n        # pylint: disable=line-too-long\n\"\"\"Deletes a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n\n        return delete_plugin(self.auth, plugin_name)\n\n    @typechecked\n    def update_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        **kwargs\n    ):\n\"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_path : Path to your plugin. Either:\n             - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n             - a .py file\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n\"\"\" \"file_path\" has been deprecated for \"plugin_path\",\n                please use \"plugin_path\" instead\"\"\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        if not plugin_name:\n            raise TypeError('\"plugin_name is nullish, please provide a value')\n\n        return PluginUploader(self.auth, plugin_path, plugin_name, verbose).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.activate_plugin_on_project","title":"<code>activate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>verbose</code> <p>If false, minimal logs are displayed</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef activate_plugin_on_project(\n    self,\n    plugin_name: str,\n    project_id: str,\n):\n    # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n\n    return activate_plugin(self.auth, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.create_webhook","title":"<code>create_webhook(self, webhook_url, plugin_name, header=None, verbose=True)</code>","text":"<p>Create a webhook linked to Kili's events.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_url</code> <code>str</code> <p>URL receiving post requests on events on Kili</p> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef create_webhook(\n    self,\n    webhook_url: str,\n    plugin_name: str,\n    header: Optional[str] = None,\n    verbose: bool = True,\n):\n    # pylint: disable=line-too-long\n\"\"\"Create a webhook linked to Kili's events.\n\n    Args:\n        webhook_url: URL receiving post requests on events on Kili\n        plugin_name: name of your plugin\n        header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n\n    return WebhookUploader(\n        self.auth, webhook_url, plugin_name, header, verbose\n    ).create_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.deactivate_plugin_on_project","title":"<code>deactivate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>verbose</code> <p>If false, minimal logs are displayed</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef deactivate_plugin_on_project(\n    self,\n    plugin_name: str,\n    project_id: str,\n):\n    # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n\n    return deactivate_plugin(self.auth, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.delete_plugin","title":"<code>delete_plugin(self, plugin_name)</code>","text":"<p>Deletes a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>verbose</code> <p>If false, minimal logs are displayed</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef delete_plugin(\n    self,\n    plugin_name: str,\n):\n    # pylint: disable=line-too-long\n\"\"\"Deletes a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n\n    return delete_plugin(self.auth, plugin_name)\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.update_plugin","title":"<code>update_plugin(self, plugin_path=None, plugin_name=None, verbose=True, **kwargs)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <p>Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file</p> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>Name of the plugin</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef update_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    **kwargs\n):\n\"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_path : Path to your plugin. Either:\n         - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n         - a .py file\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n\"\"\" \"file_path\" has been deprecated for \"plugin_path\",\n            please use \"plugin_path\" instead\"\"\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    if not plugin_name:\n        raise TypeError('\"plugin_name is nullish, please provide a value')\n\n    return PluginUploader(self.auth, plugin_path, plugin_name, verbose).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.update_webhook","title":"<code>update_webhook(self, new_webhook_url, plugin_name, new_header=None, verbose=True)</code>","text":"<p>Update a webhook linked to Kili's events.</p> <p>Parameters:</p> Name Type Description Default <code>new_webhook_url</code> <code>str</code> <p>New URL receiving post requests on events on Kili</p> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>new_header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef update_webhook(\n    self,\n    new_webhook_url: str,\n    plugin_name: str,\n    new_header: Optional[str] = None,\n    verbose: bool = True,\n):\n    # pylint: disable=line-too-long\n\"\"\"Update a webhook linked to Kili's events.\n\n    Args:\n        new_webhook_url: New URL receiving post requests on events on Kili\n        plugin_name: name of your plugin\n        new_header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n\n    return WebhookUploader(\n        self.auth, new_webhook_url, plugin_name, new_header, verbose\n    ).update_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.upload_plugin","title":"<code>upload_plugin(self, plugin_path=None, plugin_name=None, verbose=True, **kwargs)</code>","text":"<p>Uploads a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <p>Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file</p> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>name of your plugin, if not provided, it will be the name from your file</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n</code></pre> Source code in <code>kili/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef upload_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    **kwargs\n):\n    # pylint: disable=line-too-long\n\"\"\"Uploads a plugin.\n\n    Args:\n        plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file\n        plugin_name: name of your plugin, if not provided, it will be the name from your file\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n    \"\"\"\n\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n            '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n            \" instead\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    return PluginUploader(self.auth, plugin_path, plugin_name, verbose).create_plugin()\n</code></pre>"},{"location":"sdk/project/","title":"Project module","text":""},{"location":"sdk/project/#queries","title":"Queries","text":"<p>Set of Project queries.</p> Source code in <code>kili/queries/project/__init__.py</code> <pre><code>class QueriesProject:\n\"\"\"Set of Project queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of projects that match a set of criteria.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings.\n            updated_at_gte: Returned projects should have a label whose update date is greater or equal\n                to this date.\n            updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n            skip: Number of projects to skip (they are ordered by their creation).\n            fields: All the fields to request among the possible fields for the projects.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n            first: Maximum number of projects to return.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the projects is returned.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; # List all my projects\n            &gt;&gt;&gt; kili.projects()\n        \"\"\"\n\n        where = ProjectWhere(\n            project_id=project_id,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        projects_gen = ProjectQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return projects_gen\n        return list(projects_gen)\n\n    @typechecked\n    def count_projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n\"\"\"\n        Counts the number of projects with a search_query\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot\n                or consensus settings\n            updated_at_gte: Returned projects should have a label\n                whose update date is greater\n                or equal to this date.\n            updated_at_lte: Returned projects should have a label\n                whose update date is lower or equal to this date.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of projects with the parameters provided\n        \"\"\"\n        where = ProjectWhere(\n            project_id=project_id,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n        )\n        return ProjectQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.count_projects","title":"<code>count_projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None)</code>","text":"<p>Counts the number of projects with a search_query</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of projects with the parameters provided</p> Source code in <code>kili/queries/project/__init__.py</code> <pre><code>@typechecked\ndef count_projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n\"\"\"\n    Counts the number of projects with a search_query\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot\n            or consensus settings\n        updated_at_gte: Returned projects should have a label\n            whose update date is greater\n            or equal to this date.\n        updated_at_lte: Returned projects should have a label\n            whose update date is lower or equal to this date.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of projects with the parameters provided\n    \"\"\"\n    where = ProjectWhere(\n        project_id=project_id,\n        search_query=search_query,\n        should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n    )\n    return ProjectQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.projects","title":"<code>projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, skip=0, fields=['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'], first=None, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of projects that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <p>Technical field, added to indicate changes in honeypot or consensus settings.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of projects to skip (they are ordered by their creation).</p> <code>0</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projects. See the documentation for all possible fields.</p> <code>['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of projects to return.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the projects is returned.</p> <code>False</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all my projects\n&gt;&gt;&gt; kili.projects()\n</code></pre> Source code in <code>kili/queries/project/__init__.py</code> <pre><code>@typechecked\ndef projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"consensusTotCoverage\",\n        \"id\",\n        \"inputType\",\n        \"jsonInterface\",\n        \"minConsensusSize\",\n        \"reviewCoverage\",\n        \"roles.id\",\n        \"roles.role\",\n        \"roles.user.email\",\n        \"roles.user.id\",\n        \"title\",\n    ],\n    first: Optional[int] = None,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of projects that match a set of criteria.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings.\n        updated_at_gte: Returned projects should have a label whose update date is greater or equal\n            to this date.\n        updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n        skip: Number of projects to skip (they are ordered by their creation).\n        fields: All the fields to request among the possible fields for the projects.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n        first: Maximum number of projects to return.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the projects is returned.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; # List all my projects\n        &gt;&gt;&gt; kili.projects()\n    \"\"\"\n\n    where = ProjectWhere(\n        project_id=project_id,\n        search_query=search_query,\n        should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    projects_gen = ProjectQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return projects_gen\n    return list(projects_gen)\n</code></pre>"},{"location":"sdk/project/#mutations","title":"Mutations","text":"<p>Set of Project mutations.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>class MutationsProject:\n\"\"\"Set of Project mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth: KiliAuth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def append_to_roles(\n        self, project_id: str, user_email: str, role: str = \"LABELER\"\n    ) -&gt; Dict[str, Union[str, dict, list, None]]:\n\"\"\"Add a user to a project.\n\n        !!! info\n            If the user does not exist in your organization, he/she is invited and added\n                both to your organization and project. This function can also be used to change\n                the role of the user in the project.\n\n        Args:\n            project_id: Identifier of the project\n            user_email: The email of the user.\n                This email is used as the unique identifier of the user.\n            role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n        \"\"\"\n        variables = {\n            \"data\": {\"role\": role, \"userEmail\": user_email},\n            \"where\": {\"id\": project_id},\n        }\n        result = self.auth.client.execute(GQL_APPEND_TO_ROLES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_properties_in_project(\n        self,\n        project_id: str,\n        can_navigate_between_assets: Optional[bool] = None,\n        can_skip_asset: Optional[bool] = None,\n        consensus_mark: Optional[float] = None,\n        consensus_tot_coverage: Optional[int] = None,\n        description: Optional[str] = None,\n        honeypot_mark: Optional[float] = None,\n        instructions: Optional[str] = None,\n        input_type: Optional[str] = None,\n        json_interface: Optional[dict] = None,\n        min_consensus_size: Optional[int] = None,\n        number_of_assets: Optional[int] = None,\n        number_of_skipped_assets: Optional[int] = None,\n        number_of_remaining_assets: Optional[int] = None,\n        number_of_reviewed_assets: Optional[int] = None,\n        review_coverage: Optional[int] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        title: Optional[str] = None,\n        use_honeypot: Optional[bool] = None,\n        metadata_types: Optional[dict] = None,\n    ) -&gt; Dict[str, Any]:\n\"\"\"Update properties of a project.\n\n        Args:\n            project_id: Identifier of the project.\n            can_navigate_between_assets:\n                Activate / Deactivate the use of next and previous buttons in labeling interface.\n            can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n            consensus_mark: Should be between 0 and 1.\n            consensus_tot_coverage: Should be between 0 and 100.\n                It is the percentage of the dataset that will be annotated several times.\n            description : Description of the project.\n            honeypot_mark : Should be between 0 and 1\n            instructions : Instructions of the project.\n            input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`,\n                `VIDEO`, `VIDEO_LEGACY`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            min_consensus_size: Should be between 1 and 10\n                Number of people that will annotate the same asset, for consensus computation.\n            number_of_assets: Defaults to 0\n            number_of_skipped_assets: Defaults to 0\n            number_of_remaining_assets: Defaults to 0\n            number_of_reviewed_assets: Defaults to 0\n            review_coverage: Allow to set the percentage of assets\n                that will be queued in the review interface.\n                Should be between 0 and 100\n            should_relaunch_kpi_computation: Technical field, added to indicate changes\n                in honeypot or consensus settings\n            title: Title of the project\n            use_honeypot: Activate / Deactivate the use of honeypot in the project\n            metadata_types: Types of the project metadata.\n                Should be a `dict` of metadata fields name as keys and metadata types as values.\n                Currently, possible types are: `string`, `number`\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n        !!! example \"Change Metadata Types\"\n            Metadata fields are by default interpreted as `string` types. To change the type\n            of a metadata field, you can use the `update_properties_in_project` function with the\n            metadata_types argument. `metadata_types` is given as a dict of metadata field names\n            as keys and metadata types as values.\n            Example:\n            ```\n            kili.update_properties_in_project(\n                project_id = project_id,\n                metadata_types = {\n                    'customConsensus': 'number',\n                    'sensitiveData': 'string',\n                    'uploadedFromCloud': 'string',\n                    'modelLabelErrorScore': 'number'\n                }\n            )\n            ```\n            Not providing a type for a metadata field or providing an unsupported one\n            will default to the `string` type.\n        \"\"\"\n        verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n        variables = {\n            \"canNavigateBetweenAssets\": can_navigate_between_assets,\n            \"canSkipAsset\": can_skip_asset,\n            \"consensusMark\": consensus_mark,\n            \"consensusTotCoverage\": consensus_tot_coverage,\n            \"description\": description,\n            \"honeypotMark\": honeypot_mark,\n            \"instructions\": instructions,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n            \"metadataTypes\": metadata_types,\n            \"minConsensusSize\": min_consensus_size,\n            \"numberOfAssets\": number_of_assets,\n            \"numberOfSkippedAssets\": number_of_skipped_assets,\n            \"numberOfRemainingAssets\": number_of_remaining_assets,\n            \"numberOfReviewedAssets\": number_of_reviewed_assets,\n            \"projectID\": project_id,\n            \"reviewCoverage\": review_coverage,\n            \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n            \"title\": title,\n            \"useHoneyPot\": use_honeypot,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        result = format_result(\"data\", result)\n\n        variables.pop(\"projectID\")\n        variables = {k: v for k, v in variables.items() if v is not None}\n\n        new_project_settings = services.get_project(self, project_id, list(variables.keys()))\n\n        result = {**result, **new_project_settings}\n        return result\n\n    @typechecked\n    def create_project(\n        self,\n        input_type: str,\n        json_interface: dict,\n        title: str,\n        description: str = \"\",\n        project_type: Optional[str] = None,\n    ) -&gt; Dict:\n        # pylint: disable=line-too-long\n\"\"\"Create a project.\n\n        Args:\n            input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}\n            json_interface: The json parameters of the project, see Edit your interface.\n            title: Title of the project\n            description: Description of the project\n            project_type:\n                Currently, one of {\n                    `IMAGE_CLASSIFICATION_SINGLE`,\n                    `IMAGE_CLASSIFICATION_MULTI`,\n                    `IMAGE_OBJECT_DETECTION_RECTANGLE`,\n                    `IMAGE_OBJECT_DETECTION_POLYGON`,\n                    `IMAGE_OBJECT_DETECTION_SEMANTIC`,\n                    `OCR, PDF_CLASSIFICATION_SINGLE`,\n                    `PDF_CLASSIFICATION_MULTI`,\n                    `TEXT_CLASSIFICATION_SINGLE`,\n                    `TEXT_CLASSIFICATION_MULTI`,\n                    `TEXT_TRANSCRIPTION, TEXT_NER`,\n                    `VIDEO_CLASSIFICATION_SINGLE`,\n                    `VIDEO_FRAME_CLASSIFICATION`,\n                    `VIDEO_FRAME_OBJECT_TRACKING`,\n                    `SPEECH_TO_TEXT`\n                }\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create projects,\n                see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"description\": description,\n                \"inputType\": input_type,\n                \"jsonInterface\": dumps(json_interface),\n                \"projectType\": project_type,\n                \"title\": title,\n            }\n        }\n        result = self.auth.client.execute(GQL_CREATE_PROJECT, variables)\n        result = format_result(\"data\", result)\n\n        # We check during 60s for the project to be created\n        for attempt in Retrying(\n            stop=stop_after_delay(60),\n            wait=wait_fixed(1),\n            retry=retry_if_exception_type(NotFound),\n            reraise=True,\n        ):\n            with attempt:\n                _ = services.get_project(self, project_id=result[\"id\"], fields=[\"id\"])\n\n        return result\n\n    @typechecked\n    def update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n\"\"\"Update properties of a role.\n\n        !!! info\n            To be able to change someone's role, you must be either of:\n\n            - an admin of the project\n            - a team manager of the project\n            - an admin of the organization\n\n        Args:\n            role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n            project_id: Identifier of the project\n            user_id: The email or identifier of the user with updated role\n            role: The new role.\n                Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"roleID\": role_id,\n            \"projectID\": project_id,\n            \"userID\": user_id,\n            \"role\": role,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_from_roles(self, role_id: str):\n\"\"\"Delete users by their role_id.\n\n        Args:\n            role_id: Identifier of the project user (not the ID of the user)\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": role_id}}\n        result = self.auth.client.execute(GQL_DELETE_FROM_ROLES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def internal_delete_project(self, project_id: str):\n\"\"\"Delete project permanently.\n        WARNING: This resolver is for internal use by Kili Technology only.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"projectID\": project_id}\n        result = self.auth.client.execute(GQL_DELETE_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_project(self, project_id: str) -&gt; str:\n\"\"\"\n        Delete a project permanently.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": project_id}}\n        result = self.auth.client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def archive_project(self, project_id: str):\n\"\"\"\n        Archive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": True,\n        }\n\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def unarchive_project(self, project_id: str):\n\"\"\"\n        Unarchive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": False,\n        }\n\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def copy_project(  # pylint: disable=too-many-arguments\n        self,\n        from_project_id: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        copy_json_interface: bool = True,\n        copy_quality_settings: bool = True,\n        copy_members: bool = True,\n        copy_assets: bool = False,\n        copy_labels: bool = False,\n        disable_tqdm: bool = False,\n    ) -&gt; str:\n\"\"\"Create new project from an existing project.\n\n        Args:\n            from_project_id: Project ID to copy from.\n            title: Title for the new project. Defaults to source project\n                title if `None` is provided.\n            description: Description for the new project. Defaults to empty string\n                if `None` is provided.\n            copy_json_interface: Include json interface in the copy.\n            copy_quality_settings: Include quality settings in the copy.\n            copy_members: Include members in the copy.\n            copy_assets: Include assets in the copy.\n            copy_labels: Include labels in the copy.\n            disable_tqdm: Disable tqdm progress bars.\n\n        Returns:\n            The created project ID.\n\n        Examples:\n            &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n        \"\"\"\n        return ProjectCopier(self).copy_project(\n            from_project_id,\n            title,\n            description,\n            copy_json_interface,\n            copy_quality_settings,\n            copy_members,\n            copy_assets,\n            copy_labels,\n            disable_tqdm,\n        )\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","title":"<code>append_to_roles(self, project_id, user_email, role='LABELER')</code>","text":"<p>Add a user to a project.</p> <p>Info</p> <p>If the user does not exist in your organization, he/she is invited and added     both to your organization and project. This function can also be used to change     the role of the user in the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_email</code> <code>str</code> <p>The email of the user. This email is used as the unique identifier of the user.</p> required <code>role</code> <code>str</code> <p>One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.</p> <code>'LABELER'</code> <p>Returns:</p> Type Description <code>Dict[str, Union[str, dict, list]]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n</code></pre> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef append_to_roles(\n    self, project_id: str, user_email: str, role: str = \"LABELER\"\n) -&gt; Dict[str, Union[str, dict, list, None]]:\n\"\"\"Add a user to a project.\n\n    !!! info\n        If the user does not exist in your organization, he/she is invited and added\n            both to your organization and project. This function can also be used to change\n            the role of the user in the project.\n\n    Args:\n        project_id: Identifier of the project\n        user_email: The email of the user.\n            This email is used as the unique identifier of the user.\n        role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n    \"\"\"\n    variables = {\n        \"data\": {\"role\": role, \"userEmail\": user_email},\n        \"where\": {\"id\": project_id},\n    }\n    result = self.auth.client.execute(GQL_APPEND_TO_ROLES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.archive_project","title":"<code>archive_project(self, project_id)</code>","text":"<p>Archive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef archive_project(self, project_id: str):\n\"\"\"\n    Archive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": True,\n    }\n\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.copy_project","title":"<code>copy_project(self, from_project_id, title=None, description=None, copy_json_interface=True, copy_quality_settings=True, copy_members=True, copy_assets=False, copy_labels=False, disable_tqdm=False)</code>","text":"<p>Create new project from an existing project.</p> <p>Parameters:</p> Name Type Description Default <code>from_project_id</code> <code>str</code> <p>Project ID to copy from.</p> required <code>title</code> <code>Optional[str]</code> <p>Title for the new project. Defaults to source project title if <code>None</code> is provided.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description for the new project. Defaults to empty string if <code>None</code> is provided.</p> <code>None</code> <code>copy_json_interface</code> <code>bool</code> <p>Include json interface in the copy.</p> <code>True</code> <code>copy_quality_settings</code> <code>bool</code> <p>Include quality settings in the copy.</p> <code>True</code> <code>copy_members</code> <code>bool</code> <p>Include members in the copy.</p> <code>True</code> <code>copy_assets</code> <code>bool</code> <p>Include assets in the copy.</p> <code>False</code> <code>copy_labels</code> <code>bool</code> <p>Include labels in the copy.</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable tqdm progress bars.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The created project ID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n</code></pre> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef copy_project(  # pylint: disable=too-many-arguments\n    self,\n    from_project_id: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    copy_json_interface: bool = True,\n    copy_quality_settings: bool = True,\n    copy_members: bool = True,\n    copy_assets: bool = False,\n    copy_labels: bool = False,\n    disable_tqdm: bool = False,\n) -&gt; str:\n\"\"\"Create new project from an existing project.\n\n    Args:\n        from_project_id: Project ID to copy from.\n        title: Title for the new project. Defaults to source project\n            title if `None` is provided.\n        description: Description for the new project. Defaults to empty string\n            if `None` is provided.\n        copy_json_interface: Include json interface in the copy.\n        copy_quality_settings: Include quality settings in the copy.\n        copy_members: Include members in the copy.\n        copy_assets: Include assets in the copy.\n        copy_labels: Include labels in the copy.\n        disable_tqdm: Disable tqdm progress bars.\n\n    Returns:\n        The created project ID.\n\n    Examples:\n        &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n    \"\"\"\n    return ProjectCopier(self).copy_project(\n        from_project_id,\n        title,\n        description,\n        copy_json_interface,\n        copy_quality_settings,\n        copy_members,\n        copy_assets,\n        copy_labels,\n        disable_tqdm,\n    )\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.create_project","title":"<code>create_project(self, input_type, json_interface, title, description='', project_type=None)</code>","text":"<p>Create a project.</p> <p>Parameters:</p> Name Type Description Default <code>input_type</code> <code>str</code> <p>Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}</p> required <code>json_interface</code> <code>dict</code> <p>The json parameters of the project, see Edit your interface.</p> required <code>title</code> <code>str</code> <p>Title of the project</p> required <code>description</code> <code>str</code> <p>Description of the project</p> <code>''</code> <code>project_type</code> <code>Optional[str]</code> <p>Currently, one of {     <code>IMAGE_CLASSIFICATION_SINGLE</code>,     <code>IMAGE_CLASSIFICATION_MULTI</code>,     <code>IMAGE_OBJECT_DETECTION_RECTANGLE</code>,     <code>IMAGE_OBJECT_DETECTION_POLYGON</code>,     <code>IMAGE_OBJECT_DETECTION_SEMANTIC</code>,     <code>OCR, PDF_CLASSIFICATION_SINGLE</code>,     <code>PDF_CLASSIFICATION_MULTI</code>,     <code>TEXT_CLASSIFICATION_SINGLE</code>,     <code>TEXT_CLASSIFICATION_MULTI</code>,     <code>TEXT_TRANSCRIPTION, TEXT_NER</code>,     <code>VIDEO_CLASSIFICATION_SINGLE</code>,     <code>VIDEO_FRAME_CLASSIFICATION</code>,     <code>VIDEO_FRAME_OBJECT_TRACKING</code>,     <code>SPEECH_TO_TEXT</code> }</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n</code></pre> <p>Recipe</p> <p>For more detailed examples on how to create projects,     see the recipe.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef create_project(\n    self,\n    input_type: str,\n    json_interface: dict,\n    title: str,\n    description: str = \"\",\n    project_type: Optional[str] = None,\n) -&gt; Dict:\n    # pylint: disable=line-too-long\n\"\"\"Create a project.\n\n    Args:\n        input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA}\n        json_interface: The json parameters of the project, see Edit your interface.\n        title: Title of the project\n        description: Description of the project\n        project_type:\n            Currently, one of {\n                `IMAGE_CLASSIFICATION_SINGLE`,\n                `IMAGE_CLASSIFICATION_MULTI`,\n                `IMAGE_OBJECT_DETECTION_RECTANGLE`,\n                `IMAGE_OBJECT_DETECTION_POLYGON`,\n                `IMAGE_OBJECT_DETECTION_SEMANTIC`,\n                `OCR, PDF_CLASSIFICATION_SINGLE`,\n                `PDF_CLASSIFICATION_MULTI`,\n                `TEXT_CLASSIFICATION_SINGLE`,\n                `TEXT_CLASSIFICATION_MULTI`,\n                `TEXT_TRANSCRIPTION, TEXT_NER`,\n                `VIDEO_CLASSIFICATION_SINGLE`,\n                `VIDEO_FRAME_CLASSIFICATION`,\n                `VIDEO_FRAME_OBJECT_TRACKING`,\n                `SPEECH_TO_TEXT`\n            }\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create projects,\n            see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"description\": description,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface),\n            \"projectType\": project_type,\n            \"title\": title,\n        }\n    }\n    result = self.auth.client.execute(GQL_CREATE_PROJECT, variables)\n    result = format_result(\"data\", result)\n\n    # We check during 60s for the project to be created\n    for attempt in Retrying(\n        stop=stop_after_delay(60),\n        wait=wait_fixed(1),\n        retry=retry_if_exception_type(NotFound),\n        reraise=True,\n    ):\n        with attempt:\n            _ = services.get_project(self, project_id=result[\"id\"], fields=[\"id\"])\n\n    return result\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","title":"<code>delete_from_roles(self, role_id)</code>","text":"<p>Delete users by their role_id.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Identifier of the project user (not the ID of the user)</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_from_roles(self, role_id: str):\n\"\"\"Delete users by their role_id.\n\n    Args:\n        role_id: Identifier of the project user (not the ID of the user)\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": role_id}}\n    result = self.auth.client.execute(GQL_DELETE_FROM_ROLES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_project","title":"<code>delete_project(self, project_id)</code>","text":"<p>Delete a project permanently.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>str</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_project(self, project_id: str) -&gt; str:\n\"\"\"\n    Delete a project permanently.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": project_id}}\n    result = self.auth.client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.unarchive_project","title":"<code>unarchive_project(self, project_id)</code>","text":"<p>Unarchive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef unarchive_project(self, project_id: str):\n\"\"\"\n    Unarchive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": False,\n    }\n\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","title":"<code>update_properties_in_project(self, project_id, can_navigate_between_assets=None, can_skip_asset=None, consensus_mark=None, consensus_tot_coverage=None, description=None, honeypot_mark=None, instructions=None, input_type=None, json_interface=None, min_consensus_size=None, number_of_assets=None, number_of_skipped_assets=None, number_of_remaining_assets=None, number_of_reviewed_assets=None, review_coverage=None, should_relaunch_kpi_computation=None, title=None, use_honeypot=None, metadata_types=None)</code>","text":"<p>Update properties of a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>can_navigate_between_assets</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of next and previous buttons in labeling interface.</p> <code>None</code> <code>can_skip_asset</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of skip button in labeling interface.</p> <code>None</code> <code>consensus_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>consensus_tot_coverage</code> <code>Optional[int]</code> <p>Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times.</p> <code>None</code> <code>description</code> <p>Description of the project.</p> <code>None</code> <code>honeypot_mark</code> <p>Should be between 0 and 1</p> <code>None</code> <code>instructions</code> <p>Instructions of the project.</p> <code>None</code> <code>input_type</code> <code>Optional[str]</code> <p>Currently, one of <code>AUDIO</code>, <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code>, <code>VIDEO</code>, <code>VIDEO_LEGACY</code>.</p> <code>None</code> <code>json_interface</code> <code>Optional[dict]</code> <p>The json parameters of the project, see Edit your interface.</p> <code>None</code> <code>min_consensus_size</code> <code>Optional[int]</code> <p>Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation.</p> <code>None</code> <code>number_of_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_skipped_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_remaining_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_reviewed_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>review_coverage</code> <code>Optional[int]</code> <p>Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title of the project</p> <code>None</code> <code>use_honeypot</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of honeypot in the project</p> <code>None</code> <code>metadata_types</code> <code>Optional[dict]</code> <p>Types of the project metadata. Should be a <code>dict</code> of metadata fields name as keys and metadata types as values. Currently, possible types are: <code>string</code>, <code>number</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n</code></pre> <p>Change Metadata Types</p> <p>Metadata fields are by default interpreted as <code>string</code> types. To change the type of a metadata field, you can use the <code>update_properties_in_project</code> function with the metadata_types argument. <code>metadata_types</code> is given as a dict of metadata field names as keys and metadata types as values. Example: <pre><code>kili.update_properties_in_project(\n    project_id = project_id,\n    metadata_types = {\n        'customConsensus': 'number',\n        'sensitiveData': 'string',\n        'uploadedFromCloud': 'string',\n        'modelLabelErrorScore': 'number'\n    }\n)\n</code></pre> Not providing a type for a metadata field or providing an unsupported one will default to the <code>string</code> type.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project(\n    self,\n    project_id: str,\n    can_navigate_between_assets: Optional[bool] = None,\n    can_skip_asset: Optional[bool] = None,\n    consensus_mark: Optional[float] = None,\n    consensus_tot_coverage: Optional[int] = None,\n    description: Optional[str] = None,\n    honeypot_mark: Optional[float] = None,\n    instructions: Optional[str] = None,\n    input_type: Optional[str] = None,\n    json_interface: Optional[dict] = None,\n    min_consensus_size: Optional[int] = None,\n    number_of_assets: Optional[int] = None,\n    number_of_skipped_assets: Optional[int] = None,\n    number_of_remaining_assets: Optional[int] = None,\n    number_of_reviewed_assets: Optional[int] = None,\n    review_coverage: Optional[int] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    title: Optional[str] = None,\n    use_honeypot: Optional[bool] = None,\n    metadata_types: Optional[dict] = None,\n) -&gt; Dict[str, Any]:\n\"\"\"Update properties of a project.\n\n    Args:\n        project_id: Identifier of the project.\n        can_navigate_between_assets:\n            Activate / Deactivate the use of next and previous buttons in labeling interface.\n        can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n        consensus_mark: Should be between 0 and 1.\n        consensus_tot_coverage: Should be between 0 and 100.\n            It is the percentage of the dataset that will be annotated several times.\n        description : Description of the project.\n        honeypot_mark : Should be between 0 and 1\n        instructions : Instructions of the project.\n        input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`,\n            `VIDEO`, `VIDEO_LEGACY`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        min_consensus_size: Should be between 1 and 10\n            Number of people that will annotate the same asset, for consensus computation.\n        number_of_assets: Defaults to 0\n        number_of_skipped_assets: Defaults to 0\n        number_of_remaining_assets: Defaults to 0\n        number_of_reviewed_assets: Defaults to 0\n        review_coverage: Allow to set the percentage of assets\n            that will be queued in the review interface.\n            Should be between 0 and 100\n        should_relaunch_kpi_computation: Technical field, added to indicate changes\n            in honeypot or consensus settings\n        title: Title of the project\n        use_honeypot: Activate / Deactivate the use of honeypot in the project\n        metadata_types: Types of the project metadata.\n            Should be a `dict` of metadata fields name as keys and metadata types as values.\n            Currently, possible types are: `string`, `number`\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n    !!! example \"Change Metadata Types\"\n        Metadata fields are by default interpreted as `string` types. To change the type\n        of a metadata field, you can use the `update_properties_in_project` function with the\n        metadata_types argument. `metadata_types` is given as a dict of metadata field names\n        as keys and metadata types as values.\n        Example:\n        ```\n        kili.update_properties_in_project(\n            project_id = project_id,\n            metadata_types = {\n                'customConsensus': 'number',\n                'sensitiveData': 'string',\n                'uploadedFromCloud': 'string',\n                'modelLabelErrorScore': 'number'\n            }\n        )\n        ```\n        Not providing a type for a metadata field or providing an unsupported one\n        will default to the `string` type.\n    \"\"\"\n    verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n    variables = {\n        \"canNavigateBetweenAssets\": can_navigate_between_assets,\n        \"canSkipAsset\": can_skip_asset,\n        \"consensusMark\": consensus_mark,\n        \"consensusTotCoverage\": consensus_tot_coverage,\n        \"description\": description,\n        \"honeypotMark\": honeypot_mark,\n        \"instructions\": instructions,\n        \"inputType\": input_type,\n        \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n        \"metadataTypes\": metadata_types,\n        \"minConsensusSize\": min_consensus_size,\n        \"numberOfAssets\": number_of_assets,\n        \"numberOfSkippedAssets\": number_of_skipped_assets,\n        \"numberOfRemainingAssets\": number_of_remaining_assets,\n        \"numberOfReviewedAssets\": number_of_reviewed_assets,\n        \"projectID\": project_id,\n        \"reviewCoverage\": review_coverage,\n        \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n        \"title\": title,\n        \"useHoneyPot\": use_honeypot,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    result = format_result(\"data\", result)\n\n    variables.pop(\"projectID\")\n    variables = {k: v for k, v in variables.items() if v is not None}\n\n    new_project_settings = services.get_project(self, project_id, list(variables.keys()))\n\n    result = {**result, **new_project_settings}\n    return result\n</code></pre>"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","title":"<code>update_properties_in_role(self, role_id, project_id, user_id, role)</code>","text":"<p>Update properties of a role.</p> <p>Info</p> <p>To be able to change someone's role, you must be either of:</p> <ul> <li>an admin of the project</li> <li>a team manager of the project</li> <li>an admin of the organization</li> </ul> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Role identifier of the user. E.g. : 'to-be-deactivated'</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_id</code> <code>str</code> <p>The email or identifier of the user with updated role</p> required <code>role</code> <code>str</code> <p>The new role. Possible choices are: <code>ADMIN</code>, <code>TEAM_MANAGER</code>, <code>REVIEWER</code>, <code>LABELER</code></p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n\"\"\"Update properties of a role.\n\n    !!! info\n        To be able to change someone's role, you must be either of:\n\n        - an admin of the project\n        - a team manager of the project\n        - an admin of the organization\n\n    Args:\n        role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n        project_id: Identifier of the project\n        user_id: The email or identifier of the user with updated role\n        role: The new role.\n            Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"roleID\": role_id,\n        \"projectID\": project_id,\n        \"userID\": user_id,\n        \"role\": role,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_user/","title":"Project User module","text":""},{"location":"sdk/project_user/#queries","title":"Queries","text":"<p>Set of ProjectUser queries.</p> Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>class QueriesProjectUser:\n\"\"\"Set of ProjectUser queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,redefined-builtin,dangerous-default-value,invalid-name\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Return project users (possibly with their KPIs) that match a set of criteria\n\n\n        Args:\n            project_id: Identifier of the project\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the projectUsers\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of project users to skip\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # Retrieve consensus marks of all users in project\n            &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n            ```\n        \"\"\"\n        where = ProjectUserWhere(\n            project_id=project_id, email=email, _id=id, organization_id=organization_id\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_users_gen = ProjectUserQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return project_users_gen\n        return list(project_users_gen)\n\n    @typechecked\n    def count_project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"\n        Counts the number of projects and their users that match a set of criteria\n\n        Args:\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            project_id: Identifier of the project\n\n        Returns:\n            The number of project users with the parameters provided\n        \"\"\"\n        where = ProjectUserWhere(\n            project_id=project_id, email=email, _id=id, organization_id=organization_id\n        )\n        return ProjectUserQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","title":"<code>count_project_users(self, project_id, email=None, id=None, organization_id=None)</code>","text":"<p>Counts the number of projects and their users that match a set of criteria</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of project users with the parameters provided</p> Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef count_project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n) -&gt; int:\n\"\"\"\n    Counts the number of projects and their users that match a set of criteria\n\n    Args:\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        project_id: Identifier of the project\n\n    Returns:\n        The number of project users with the parameters provided\n    \"\"\"\n    where = ProjectUserWhere(\n        project_id=project_id, email=email, _id=id, organization_id=organization_id\n    )\n    return ProjectUserQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","title":"<code>project_users(self, project_id, email=None, id=None, organization_id=None, fields=['activated', 'id', 'role', 'starred', 'user.email', 'user.id'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Return project users (possibly with their KPIs) that match a set of criteria</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields.</p> <code>['activated', 'id', 'role', 'starred', 'user.email', 'user.id']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project users to skip</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code># Retrieve consensus marks of all users in project\n&gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n</code></pre> Source code in <code>kili/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\n        \"activated\",\n        \"id\",\n        \"role\",\n        \"starred\",\n        \"user.email\",\n        \"user.id\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Return project users (possibly with their KPIs) that match a set of criteria\n\n\n    Args:\n        project_id: Identifier of the project\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the projectUsers\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of project users to skip\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # Retrieve consensus marks of all users in project\n        &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n        ```\n    \"\"\"\n    where = ProjectUserWhere(\n        project_id=project_id, email=email, _id=id, organization_id=organization_id\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_users_gen = ProjectUserQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return project_users_gen\n    return list(project_users_gen)\n</code></pre>"},{"location":"sdk/project_version/","title":"Project Version module","text":""},{"location":"sdk/project_version/#queries","title":"Queries","text":"<p>Set of ProjectVersion queries.</p> Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>class QueriesProjectVersion:\n\"\"\"Set of ProjectVersion queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n        Args:\n            project_id: Filter on Id of project\n            fields: All the fields to request among the possible fields for the project versions\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n            first: Number of project versions to query\n            skip: Number of project versions to skip (they are ordered by their date\n                of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project versions is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_versions_gen = ProjectVersionQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return project_versions_gen\n        return list(project_versions_gen)\n\n    @typechecked\n    def count_project_versions(self, project_id: str) -&gt; int:\n\"\"\"Count the number of project versions.\n\n        Args:\n            project_id: Filter on ID of project\n\n        Returns:\n            The number of project versions with the parameters provided\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        return ProjectVersionQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","title":"<code>count_project_versions(self, project_id)</code>","text":"<p>Count the number of project versions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on ID of project</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of project versions with the parameters provided</p> Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef count_project_versions(self, project_id: str) -&gt; int:\n\"\"\"Count the number of project versions.\n\n    Args:\n        project_id: Filter on ID of project\n\n    Returns:\n        The number of project versions with the parameters provided\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    return ProjectVersionQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","title":"<code>project_version(self, project_id, first=None, skip=0, fields=['createdAt', 'id', 'content', 'name', 'projectId'], disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of project versions respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on Id of project</p> required <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the project versions See the documentation for all possible fields.</p> <code>['createdAt', 'id', 'content', 'name', 'projectId']</code> <code>first</code> <code>Optional[int]</code> <p>Number of project versions to query</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project versions to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project versions is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef project_version(\n    self,\n    project_id: str,\n    first: Optional[int] = None,\n    skip: int = 0,\n    fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n    Args:\n        project_id: Filter on Id of project\n        fields: All the fields to request among the possible fields for the project versions\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n        first: Number of project versions to query\n        skip: Number of project versions to skip (they are ordered by their date\n            of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project versions is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_versions_gen = ProjectVersionQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return project_versions_gen\n    return list(project_versions_gen)\n</code></pre>"},{"location":"sdk/project_version/#mutations","title":"Mutations","text":"<p>Set of ProjectVersion mutations.</p> Source code in <code>kili/mutations/project_version/__init__.py</code> <pre><code>class MutationsProjectVersion:\n\"\"\"Set of ProjectVersion mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments,too-many-locals\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n\"\"\"Update properties of a project version.\n\n        Args:\n            project_version_id: Identifier of the project version\n            content: Link to download the project version\n\n        Returns:\n            A result object which indicates if the mutation was successful.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project_version(\n                    project_version_id=project_version_id,\n                    content='test')\n        \"\"\"\n        variables = {\n            \"content\": content,\n            \"id\": project_version_id,\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","title":"<code>update_properties_in_project_version(self, project_version_id, content)</code>","text":"<p>Update properties of a project version.</p> <p>Parameters:</p> Name Type Description Default <code>project_version_id</code> <code>str</code> <p>Identifier of the project version</p> required <code>content</code> <code>Optional[str]</code> <p>Link to download the project version</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project_version(\n        project_version_id=project_version_id,\n        content='test')\n</code></pre> Source code in <code>kili/mutations/project_version/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n\"\"\"Update properties of a project version.\n\n    Args:\n        project_version_id: Identifier of the project version\n        content: Link to download the project version\n\n    Returns:\n        A result object which indicates if the mutation was successful.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project_version(\n                project_version_id=project_version_id,\n                content='test')\n    \"\"\"\n    variables = {\n        \"content\": content,\n        \"id\": project_version_id,\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/","title":"User module","text":""},{"location":"sdk/user/#queries","title":"Queries","text":"<p>Set of User queries.</p> Source code in <code>kili/queries/user/__init__.py</code> <pre><code>class QueriesUser:\n\"\"\"Set of User queries.\"\"\"\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @overload\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of users given a set of criteria\n\n        Args:\n            api_key: Query an user by its API Key\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the users.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of skipped users (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # List all users in my organization\n            &gt;&gt;&gt; organization = kili.organizations()\n            &gt;&gt;&gt; organization_id = organizations[0]['id]\n            &gt;&gt;&gt; kili.users(organization_id=organization_id)\n            ```\n        \"\"\"\n\n        where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        users_gen = UserQuery(self.auth.client)(where, fields, options)\n\n        if as_generator:\n            return users_gen\n        return list(users_gen)\n\n    @typechecked\n    def count_users(\n        self,\n        organization_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Get user count based on a set of constraints.\n\n        Args:\n            organization_id: Identifier of the user's organization\n\n        Returns:\n            The number of organizations with the parameters provided\n        \"\"\"\n        where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n        return UserQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.count_users","title":"<code>count_users(self, organization_id=None, api_key=None, email=None)</code>","text":"<p>Get user count based on a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of organizations with the parameters provided</p> Source code in <code>kili/queries/user/__init__.py</code> <pre><code>@typechecked\ndef count_users(\n    self,\n    organization_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; int:\n\"\"\"Get user count based on a set of constraints.\n\n    Args:\n        organization_id: Identifier of the user's organization\n\n    Returns:\n        The number of organizations with the parameters provided\n    \"\"\"\n    where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n    return UserQuery(self.auth.client).count(where)\n</code></pre>"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.users","title":"<code>users(self, api_key=None, email=None, organization_id=None, fields=['email', 'id', 'firstname', 'lastname'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of users given a set of criteria</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Query an user by its API Key</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the users. See the documentation for all possible fields.</p> <code>['email', 'id', 'firstname', 'lastname']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped users (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code># List all users in my organization\n&gt;&gt;&gt; organization = kili.organizations()\n&gt;&gt;&gt; organization_id = organizations[0]['id]\n&gt;&gt;&gt; kili.users(organization_id=organization_id)\n</code></pre> Source code in <code>kili/queries/user/__init__.py</code> <pre><code>@typechecked\ndef users(\n    self,\n    api_key: Optional[str] = None,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of users given a set of criteria\n\n    Args:\n        api_key: Query an user by its API Key\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the users.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of skipped users (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # List all users in my organization\n        &gt;&gt;&gt; organization = kili.organizations()\n        &gt;&gt;&gt; organization_id = organizations[0]['id]\n        &gt;&gt;&gt; kili.users(organization_id=organization_id)\n        ```\n    \"\"\"\n\n    where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    users_gen = UserQuery(self.auth.client)(where, fields, options)\n\n    if as_generator:\n        return users_gen\n    return list(users_gen)\n</code></pre>"},{"location":"sdk/user/#mutations","title":"Mutations","text":"<p>Set of User mutations.</p> Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>class MutationsUser:\n\"\"\"Set of User mutations.\"\"\"\n\n    # pylint: disable=too-many-arguments\n\n    def __init__(self, auth):\n\"\"\"Initialize the subclass.\n\n        Args:\n            auth: KiliAuth object\n        \"\"\"\n        self.auth = auth\n\n    @typechecked\n    def create_user(\n        self,\n        email: str,\n        password: str,\n        organization_role: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n    ):\n\"\"\"Add a user to your organization.\n\n        Args:\n            email: Email of the new user, used as user's unique identifier.\n            password: On the first sign in, he will use this password and be able to change it.\n            organization_role: One of \"ADMIN\", \"USER\".\n            firstname: First name of the new user.\n            lastname: Last name of the new user.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"email\": email,\n                \"password\": password,\n                \"organizationRole\": organization_role,\n            }\n        }\n        if firstname is not None:\n            variables[\"data\"][\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"data\"][\"lastname\"] = lastname\n        result = self.auth.client.execute(GQL_CREATE_USER, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_password(\n        self, email: str, old_password: str, new_password_1: str, new_password_2: str\n    ):\n\"\"\"Allow to modify the password that you use to connect to Kili. \\\n        This resolver only works for on-premise installations without Auth0.\n\n        Args:\n            email : Email of the person whose password has to be updated.\n            old_password : The old password\n            new_password_1: The new password\n            new_password_2: A confirmation field for the new password\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"oldPassword\": old_password,\n                \"newPassword1\": new_password_1,\n                \"newPassword2\": new_password_2,\n            },\n            \"where\": {\"email\": email},\n        }\n        result = self.auth.client.execute(GQL_UPDATE_PASSWORD, variables)\n        return format_result(\"data\", result)\n\n    def reset_password(self, email: str):\n\"\"\"\n        Reset password.\n\n        !!! warning \"Method removed\"\n            This method is not available anymore.\n            Please use the Kili App instead to reset your password.\n        \"\"\"\n        raise RemovedMethodError(\n            \"reset_password() is not available anymore. Please use the Kili App instead to reset\"\n            \" your password.\"\n        )\n\n    @typechecked\n    def update_properties_in_user(\n        self,\n        email: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        organization_role: Optional[str] = None,\n        activated: Optional[bool] = None,\n    ):\n\"\"\"Update the properties of a user.\n\n        Args:\n            email: The email is the identifier of the user.\n            firstname:Change the first name of the user.\n            lastname: Change the last name of the user.\n            organization_id: Change the organization the user is related to.\n            organization_role: Change the role of the user.\n                One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n            activated: In case we want to deactivate a user, but keep it.\n\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables: Dict[str, Any] = {\n            \"email\": email,\n        }\n        if firstname is not None:\n            variables[\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"lastname\"] = lastname\n        if organization_id is not None:\n            variables[\"organizationId\"] = organization_id\n        if organization_role is not None:\n            variables[\"organizationRole\"] = organization_role\n        if activated is not None:\n            variables[\"activated\"] = activated\n        result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.create_user","title":"<code>create_user(self, email, password, organization_role, firstname=None, lastname=None)</code>","text":"<p>Add a user to your organization.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email of the new user, used as user's unique identifier.</p> required <code>password</code> <code>str</code> <p>On the first sign in, he will use this password and be able to change it.</p> required <code>organization_role</code> <code>str</code> <p>One of \"ADMIN\", \"USER\".</p> required <code>firstname</code> <code>Optional[str]</code> <p>First name of the new user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Last name of the new user.</p> <code>None</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef create_user(\n    self,\n    email: str,\n    password: str,\n    organization_role: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n):\n\"\"\"Add a user to your organization.\n\n    Args:\n        email: Email of the new user, used as user's unique identifier.\n        password: On the first sign in, he will use this password and be able to change it.\n        organization_role: One of \"ADMIN\", \"USER\".\n        firstname: First name of the new user.\n        lastname: Last name of the new user.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"email\": email,\n            \"password\": password,\n            \"organizationRole\": organization_role,\n        }\n    }\n    if firstname is not None:\n        variables[\"data\"][\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"data\"][\"lastname\"] = lastname\n    result = self.auth.client.execute(GQL_CREATE_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.reset_password","title":"<code>reset_password(self, email)</code>","text":"<p>Reset password.</p> <p>Method removed</p> <p>This method is not available anymore. Please use the Kili App instead to reset your password.</p> Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>def reset_password(self, email: str):\n\"\"\"\n    Reset password.\n\n    !!! warning \"Method removed\"\n        This method is not available anymore.\n        Please use the Kili App instead to reset your password.\n    \"\"\"\n    raise RemovedMethodError(\n        \"reset_password() is not available anymore. Please use the Kili App instead to reset\"\n        \" your password.\"\n    )\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_password","title":"<code>update_password(self, email, old_password, new_password_1, new_password_2)</code>","text":"<p>Allow to modify the password that you use to connect to Kili.         This resolver only works for on-premise installations without Auth0.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <p>Email of the person whose password has to be updated.</p> required <code>old_password</code> <p>The old password</p> required <code>new_password_1</code> <code>str</code> <p>The new password</p> required <code>new_password_2</code> <code>str</code> <p>A confirmation field for the new password</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_password(\n    self, email: str, old_password: str, new_password_1: str, new_password_2: str\n):\n\"\"\"Allow to modify the password that you use to connect to Kili. \\\n    This resolver only works for on-premise installations without Auth0.\n\n    Args:\n        email : Email of the person whose password has to be updated.\n        old_password : The old password\n        new_password_1: The new password\n        new_password_2: A confirmation field for the new password\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"oldPassword\": old_password,\n            \"newPassword1\": new_password_1,\n            \"newPassword2\": new_password_2,\n        },\n        \"where\": {\"email\": email},\n    }\n    result = self.auth.client.execute(GQL_UPDATE_PASSWORD, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","title":"<code>update_properties_in_user(self, email, firstname=None, lastname=None, organization_id=None, organization_role=None, activated=None)</code>","text":"<p>Update the properties of a user.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email is the identifier of the user.</p> required <code>firstname</code> <code>Optional[str]</code> <p>Change the first name of the user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Change the last name of the user.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Change the organization the user is related to.</p> <code>None</code> <code>organization_role</code> <code>Optional[str]</code> <p>Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".</p> <code>None</code> <code>activated</code> <code>Optional[bool]</code> <p>In case we want to deactivate a user, but keep it.</p> <code>None</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_user(\n    self,\n    email: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    organization_role: Optional[str] = None,\n    activated: Optional[bool] = None,\n):\n\"\"\"Update the properties of a user.\n\n    Args:\n        email: The email is the identifier of the user.\n        firstname:Change the first name of the user.\n        lastname: Change the last name of the user.\n        organization_id: Change the organization the user is related to.\n        organization_role: Change the role of the user.\n            One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n        activated: In case we want to deactivate a user, but keep it.\n\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables: Dict[str, Any] = {\n        \"email\": email,\n    }\n    if firstname is not None:\n        variables[\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"lastname\"] = lastname\n    if organization_id is not None:\n        variables[\"organizationId\"] = organization_id\n    if organization_role is not None:\n        variables[\"organizationRole\"] = organization_role\n    if activated is not None:\n        variables[\"activated\"] = activated\n    result = self.auth.client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/","title":"Basic project setup","text":""},{"location":"sdk/tutorials/basic_project_setup/#how-to-set-up-a-basic-kili-project","title":"How to set up a basic Kili project","text":"<p>In this tutorial, we will learn how to set up a basic Kili project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Installing and instantiating Kili</li> <li>Creating a basic Kili project</li> <li>Adding assets to project</li> <li>Adding users to project</li> </ol>"},{"location":"sdk/tutorials/basic_project_setup/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>!pip install kili\n</code></pre> <pre><code>from kili.client import Kili\nimport getpass\nimport os\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clcun99cn15wx0lq4c15a4dj7\n</code></pre> <p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p>"},{"location":"sdk/tutorials/basic_project_setup/#adding-assets-to-project","title":"Adding assets to project","text":"<pre><code># Image urls\nurl1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#adding-users-to-project","title":"Adding users to project","text":"<p>Now we need to add users to our project. Before we do that, we have to add them to our organization. Note that you have to be an org admin to be able to do that.</p> <p>For more info on roles in an organization, refer to https://docs.kili-technology.com/docs/user-roles-in-organization.</p> <pre><code>firstname = \"Jane\"\nlastname = \"Doe\"\nemail = \"no.such.email@no.such.domain.com\"\npassword = \"12345\"\norganization_role = \"USER\"\n\ntry:\n    kili.create_user(email, password, organization_role, firstname, lastname)\nexcept Exception as err:\n    print(str(err))\n</code></pre> <pre><code>error: \"[noOrganizationRights] You cannot use this function because it seems that you do not have access to this organization. Please contact you organization admin. -- This can be due to: User isn't admin from the organization | trace : false\"\n</code></pre> <p>If you already have users in your organization, here's how you can easily access their IDs:</p> <p>1) First, retrieve your organization ID:</p> <pre><code>org_id = kili.organizations()[0][\"id\"]\n</code></pre> <p>2) Then, based on your org ID, retrieve the full list of org users, with their e-mails:</p> <pre><code>all_org_users = kili.users(organization_id=org_id)\n\nall_emails = [i[\"email\"] for i in all_org_users]\n</code></pre> <p>3) We will use the e-mail of the new user to add our new user to our project:</p> <pre><code>roles = kili.append_to_roles(project_id, \"no.such.email@no.such.domain.com\", role=\"LABELER\")\nprint(roles[\"roles\"][-1])\n</code></pre> <pre><code>{'user': {'id': 'clcumy1fx15ci0lre0k21fnu7', 'email': 'no.such.email@no.such.domain.com'}, 'role': 'LABELER'}\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#cleanup","title":"Cleanup","text":"<p>To clean up, we need to simply remove the project that we created.</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, defined its interface, created a brand new user, and finally added our new user to the new project. Well done!</p>"},{"location":"sdk/tutorials/export_a_kili_project/","title":"Exporting project data","text":""},{"location":"sdk/tutorials/export_a_kili_project/#how-to-export-data-from-a-kili-project","title":"How to export data from a Kili project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#outline","title":"Outline","text":"<p>This tutorial explains the multiple ways to export a Kili project. It describes:</p> <ul> <li>Methods to export the labels one by one, after filtering</li> <li>The solutions for performing a full-project export</li> </ul> <p>The methods are illustrated with code snippets.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","title":"Export methods","text":"<p>With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it:</p> <ul> <li>Fetch the assets and/or the labels one by one using <code>.assets</code> or <code>.labels</code>, perform the data transformation yourself and then write the data to one or several output files.</li> <li>Export the whole project as a dataset. To do that, use the <code>.export_labels</code> method that creates an archive containing the labels in your chosen format.</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","title":"Preliminary steps","text":"<p>1) Fetch the project ID from the Kili UI (in Settings / Admin):</p> <p></p> <p>2) Ensure that your Kili API key has been set as an environment variable: <pre><code>export KILI_API_KEY=&lt;YOUR_API_KEY&gt;\n</code></pre></p> <p>3) If Kili has not been installed yet, install Kili.</p> <pre><code>!pip install  kili\n</code></pre> <p>4) Import packages and instantiate <code>Kili</code>:</p> <pre><code>from kili.client import Kili\nfrom pathlib import Path\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","title":"Exporting assets and labels one by one","text":"<p>To retrieve all assets of a project one by one, perform the following steps:</p>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","title":"Exporting the latest labels per asset","text":"<p>First, fetch the assets:</p> <pre><code>assets = kili.assets(your_project_id, fields=[\"externalId\", \"latestLabel.jsonResponse\"])\n</code></pre> <p>Now if you print an asset, you will see that you can access its <code>latestLabel</code>:</p> <pre><code>print(assets[0])\n</code></pre> <pre><code>{'latestLabel': {'jsonResponse': {'JOB_0': {'annotations': [{'categories': [{'name': 'OBJECT_A'}], 'mid': '20230111125258113-44528', 'type': 'rectangle', 'boundingPoly': [{'normalizedVertices': [{'x': 0.6101435505380516, 'y': 0.7689773770786136}, {'x': 0.6101435505380516, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.7689773770786136}]}], 'polyline': [], 'children': {}}]}}}, 'externalId': 'car_1'}\n</code></pre> <p>You can now get your label, and write the category name into a text file for example:</p> <pre><code>for asset in assets:\n    if asset[\"latestLabel\"]:  # check if asset has annotations\n        class_ = asset[\"latestLabel\"][\"jsonResponse\"][\"JOB_0\"][\"annotations\"][0][\"categories\"][0][\n            \"name\"\n        ]\n        with Path(asset[\"externalId\"] + \".txt\").open(\"w\", encoding=\"utf-8\") as f:\n            f.write(class_)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","title":"Filtering specific labels per asset through the method filters","text":"<p>You can specify label filters directly in the <code>.assets</code> and the <code>.labels</code> methods. The available filters are listed in the arguments list for each one of these methods.</p> <p>When done, you can write the conversion code to get the data in the format that you need.</p> <p>Get only the assets with a consensus mark above 0.5:</p> <pre><code>assets = kili.assets(\n    your_project_id, fields=[\"externalId\", \"id\", \"consensusMark\"], consensus_mark_gt=0.5\n)\nprint(assets)\n# + asset conversion code\n</code></pre> <pre><code>[{'externalId': 'car_1', 'id': 'clcyuykzd0000bgvze2z3wk81', 'consensusMark': 0.6504290982818591}]\n</code></pre> <p>Get all the labels with a honeypot mark above 0.1:</p> <pre><code>labels = kili.labels(\n    your_project_id,\n    fields=[\"labelOf.externalId\", \"honeypotMark\", \"author.email\", \"id\"],\n    honeypot_mark_gte=0.1,\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'honeypotMark': 0.16527040499137607, 'id': 'clcyuynri2fnl0krf0d7pgabo'}, {'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.smith@kili-technology.com'}, 'honeypotMark': 0.20754115450190522, 'id': 'clcyuynri2fnm0krfhx934jee'}]\n</code></pre> <p>Get all the labels added by a specific project member:</p> <pre><code>labels = kili.labels(\n    your_project_id, fields=[\"labelOf.externalId\", \"author.email\", \"id\"], user_id=john_doe_id\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'id': 'clcyuynri2fnl0krf0d7pgabo'}]\n</code></pre> <p>This code will return a list of labels authored by John Doe.</p> <p>You can also use the <code>author_in</code> parameter to filter by name directly.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","title":"Filtering specific labels per asset through the label properties","text":"<p>You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field <code>\"labels.isLatestReviewLabelForUser\"</code> to check if the label is the latest per user.</p> <pre><code>import json\n\nassets = kili.assets(\n    your_project_id,\n    fields=[\"externalId\", \"labels.jsonResponse\", \"labels.isLatestReviewLabelForUser\"],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:  # check if asset has annotations\n        for label in asset[\"labels\"]:\n            if label[\"isLatestReviewLabelForUser\"] and \"JOB_0\" in label[\"jsonResponse\"]:\n                annotation = label[\"jsonResponse\"][\"JOB_0\"]\n                with Path(asset[\"externalId\"] + \".json\").open(\"w\", encoding=\"utf-8\") as f:\n                    f.write(json.dumps(annotation))\n                break  # once we find a latest label done by a reviewer, we move on to the next asset.\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","title":"Filtering the latest label per annotator","text":"<p>When working on a project with consensus enabled, it can be useful to export the latest label made by each annotator:</p> <pre><code>from collections import defaultdict\n\nassets = kili.assets(\n    \"clb54wfkn01zb0kyadscgaf5j\",\n    fields=[\n        \"externalId\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.labelType\",\n        \"labels.jsonResponse\",\n    ],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:\n        latest_label_by_user = defaultdict(list)\n        for label in asset[\"labels\"]:\n            if label[\"labelType\"] == \"DEFAULT\":\n                latest_label_by_user[label[\"author\"][\"email\"]].append(label)\n        latest_label_per_user = {\n            email: max(labels, key=lambda x: x[\"createdAt\"])\n            for email, labels in latest_label_by_user.items()\n        }\n        with (Path(\"/tmp\") / (asset[\"externalId\"] + \".json\")).open(\"w\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(latest_label_per_user))\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","title":"Exporting a whole project","text":"<p>Kili has a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","title":"The <code>.export_labels</code> method","text":"<p>The <code>.export_labels</code> method enables the export of a full project. It does the following preprocessing:</p> <ul> <li>Only fetches the labels of types <code>\"DEFAULT\"</code> and <code>\"REVIEW\"</code> (see the label types explanations).</li> <li>If specified, selects a subset of asset ids.</li> <li>Exports labels to one of the standard formats (only available for a restricted set of ML tasks).</li> <li>Using various method arguments, you can decide:<ul> <li>Whether or not to include the assets in the export</li> <li>Whether to export just the latest label or all the labels</li> <li>Whether to create one folder for all the jobs or one folder per job</li> <li>Whether or not to export the label-related data into one single file</li> </ul> </li> </ul> <p>Note that some formats are by default single-file, while others use many files:</p> Format Single file Multiple files Kili \u2705 \u2705 Yolo \u274c \u2705 Pascal VOC \u274c \u2705 COCO \u2705 \u274c <p>For all the formats, in the output archive, a <code>README.kili.txt</code> file is also created. Here is an example of its contents: <pre><code>Exported Labels from KILI\n=========================\n\n- Project name: Awesome annotation project\n- Project identifier: abcdefghijklmnop\n- Project description: This project contains labels, most of which are awesome.\n- Export date: 20221125-093324\n- Exported format: kili\n- Exported labels: latest\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","title":"Kili format, one file per asset","text":"<p>The following code snippet exports the whole asset payload and the associated labels, with one json file per asset, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","title":"Kili format, one file for the whole project","text":"<p>This code snippet exports the whole asset payload and the associated labels as one file for the whole project, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n    single_file=True,\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","title":"YOLO formats","text":"<p>When you have at least one Object Detection job with bounding boxes, you can also export to one of the YOLO formats. You can choose <code>\"yolo_v4\"</code>, <code>\"yolo_v5\"</code> or <code>\"yolo_v7\"</code>. The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, one file per asset is produced, containing the last created <code>DEFAULT</code> or <code>REVIEW</code> label. Each YOLO label has the following shape: <pre><code>2        0.25 0.67 0.26 0.34\n^        ^    ^    ^    ^\nclass    x    y    w    h\n</code></pre> where:</p> <ul> <li><code>class</code> is the class index in the classes list contained in the YOLO metadata file.</li> <li><code>x</code> is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>y</code> is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>w</code> is the width relative to the image width (between 0.0 and 1.0) of the bounding box.</li> <li><code>h</code> is the height relative to the image height (between 0.0 and 1.0) of the bounding box.</li> </ul> <p>Here is an example of a YOLO annotation over an image:</p> <p></p> <p>Here is how to export to YOLO (in this example, YOLOv5):</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"yolo_v5\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre> <p>Note that a standard YOLO file format must also include:</p> <ul> <li>The path root to the assets</li> <li>The <code>train</code>, <code>val</code> and <code>test</code> subfolders</li> </ul> <p>Placing specific data in specific folders is the decision of an ML engineer or a Data scientist, so we are not providing a code snippet here.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","title":"COCO format","text":"<p>To export your data into the COCO format, run the following code:</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"coco\",\n)\n</code></pre> <pre><code>Fetching assets...\nConvert to coco format: 1it [00:00, 54.94it/s]\n/tmp/export.zip\n</code></pre> <p>This will create an archive containing both:</p> <ul> <li>The COCO annotation file</li> <li>The <code>data/</code> folder with all the assets</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#summary","title":"Summary","text":"<p>In this tutorial, we have seen several ways to export labels from a Kili project:</p> <ul> <li>Using <code>.assets</code> and <code>.labels</code> and their filtering arguments, a subset of assets or labels can be selected and then exported.</li> <li>Using <code>.export_labels</code>, the whole project can be exported into a standard output format.</li> </ul>"},{"location":"sdk/tutorials/importing_assets_and_labels/","title":"Importing assets and labels","text":""},{"location":"sdk/tutorials/importing_assets_and_labels/#how-to-import-assets-and-labels-to-a-kili-project","title":"How to import assets and labels to a Kili project","text":"<p>In this tutorial, we will learn how to import assets, add metadata to them, and then import labels to your project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing assets to Kili</li> <li>Adding metadata to assets</li> <li>Importing model-based pre-annotations into your project</li> <li>Importing pre-existing labels into your project</li> </ol>"},{"location":"sdk/tutorials/importing_assets_and_labels/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_assets_and_labels/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>!pip install  kili\n</code></pre> <pre><code>from kili.client import Kili\nimport getpass\nimport os\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_labels/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  cld90ffe80l8b0jn9d4vb44tn\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_labels/#importing-assets-to-kili","title":"Importing assets to Kili","text":"<p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],\n)\n</code></pre> <p>If you prefer to add your own images, you can use a local file. The code to do that would looks similar to this:</p> <pre><code># Path to local image\nproject_id = 'project_id'\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=['./image_1.jpeg'],\n    external_id_array=['image_1']\n)\n</code></pre> <p>The procedure looks the same for most of other data types, like PDFs or text. For more information on supported file formats, refer to our documentation.</p> <p>Because videos and Rich Text assets may be more complex to import, we've created separate tutorials devoted to them:</p> <ul> <li>For information on importing video assets, refer to this tutorial.</li> <li>For information on importing Rich Text assets, see here.</li> </ul> <p>For more information on importing assets, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_labels/#adding-metadata-to-assets","title":"Adding metadata to assets","text":"<p>In Kili, you can add extra information to an asset by using asset metadata. This can be information on document language, custom quality metrics, agreement metrics and so on that you can use, for example when using Kili's advanced filters or for Optical Character Recognition.</p> <p>Additionally, three specific metadata types can be used as information presented to labelers in Kili interface:</p> <ul> <li><code>imageUrl</code></li> <li><code>text</code></li> <li><code>url</code></li> </ul> <p>First, let's set data types for each type of our metadata. The default data type is <code>string</code>, so you can skip this step, but setting some of your metadata as numbers can really help when you want to filter your assets later.</p> <p>Note that we don't need to set data types for <code>imageUrl</code>, <code>text</code>, and <code>url</code>.</p> <pre><code>kili.update_properties_in_project(\n    project_id=project_id,\n    metadata_types={\n        \"customConsensus\": \"number\",\n        \"sensitiveData\": \"string\",\n        \"uploadedFromCloud\": \"string\",\n        \"modelLabelErrorScore\": \"number\",\n    },\n)\n</code></pre> <pre><code>{'id': 'cld90ffe80l8b0jn9d4vb44tn',\n 'metadataTypes': {'sensitiveData': 'string',\n  'customConsensus': 'number',\n  'uploadedFromCloud': 'string',\n  'modelLabelErrorScore': 'number'}}\n</code></pre> <p>Now we can add metadata to our assets:</p> <pre><code>external_ids = [\"image_1\", \"image_2\"]\n\nkili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=external_ids,\n    json_metadatas=[\n        {\n            \"customConsensus\": 10,\n            \"sensitiveData\": \"yes\",\n            \"uploadedFromCloud\": \"no\",\n            \"modelLabelErrorScore\": 50,\n        },\n        {\n            \"customConsensus\": 40,\n            \"sensitiveData\": \"no\",\n            \"uploadedFromCloud\": \"yes\",\n            \"modelLabelErrorScore\": 30,\n        },\n    ],\n)\n\n# Add metadata that will be visible to labelers in the labeling interface:\nkili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=external_ids,\n    json_metadatas=[\n        {\"imageUrl\": \"www.example.com/image.png\", \"text\": \"some text\", \"url\": \"www.example.com\"},\n        {\"imageUrl\": \"www.example.com/image.png\", \"text\": \"some text\", \"url\": \"www.example.com\"},\n    ],\n)\n</code></pre> <pre><code>[{'id': 'cld90fmg100009nvzbjvf73jx'}, {'id': 'cld90fmg100019nvzirlsutxz'}]\n</code></pre> <p>If you want to add metadata based on Optical Character Recognition, the process is slightly more complex. To help you with it, we've created a separate tutorial.</p> <p>For more information on adding asset metadata, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_labels/#importing-model-based-pre-annotations-into-your-project","title":"Importing model-based pre-annotations into your project","text":"<p>When you import pre-annotations, you can use two types of labels: <code>PREDICTION</code> and <code>INFERENCE</code>.</p> <p><code>PREDICTION</code>-type annotations will be displayed on the asset during the labeling process. Labelers will be able to confirm what model produced, edit, and/or add new annotations.</p> <p>Unlike with <code>PREDICTIONS</code>, <code>INFERENCE</code>-type annotations are not displayed on the asset during the labeling process. <code>INFERENCE</code>-type labels are used for IoU (intersection over union) calculation if you want to benchmark your model predictions, or labelers' work quality against ground truth.</p> <p>For more information on Kili label types, refer to our documentation.</p> <p>First, let's prepare some fake predictions:</p> <pre><code>json_response_array = [\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 95, \"name\": \"OBJECT_B\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 79, \"name\": \"OBJECT_A\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 83, \"name\": \"OBJECT_B\"}]}},\n]\n</code></pre> <p>Now, we'll upload them:</p> <pre><code>asset_external_id_array = [\"image_1\", \"image_2\", \"image_3\"]\n\nkili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"PREDICTION\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n\n\nkili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"INFERENCE\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n</code></pre> <pre><code>[{'id': 'cld90g9tu0l690joi5hnbc3rj'},\n {'id': 'cld90g9tu0l6a0joidtsk09q4'},\n {'id': 'cld90g9tu0l6b0joi1qp69ipz'}]\n</code></pre> <p>You can add prediction-type labels directly, using the <code>create_predictions</code> method. The <code>label_type</code> will be assigned automatically as <code>PREDICTION</code>:</p> <pre><code>external_id_array = [\"image_1\", \"image_2\", \"image_3\"]\n\nkili.create_predictions(\n    project_id=project_id,\n    external_id_array=external_id_array,\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n)\n</code></pre> <pre><code>{'id': 'cld90ffe80l8b0jn9d4vb44tn'}\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_labels/#importing-pre-existing-labels-into-your-project","title":"Importing pre-existing labels into your project","text":"<p>You can also use existing labels to add them to assets. Here, we'll use existing labels and add them to our assets only if their external IDs match.</p> <pre><code>external_id_array = [\"image_1\", \"image_2\", \"image_3\"]\n\nassets_list = kili.assets(project_id=project_id)\nfor asset in assets_list:\n    if asset[\"externalId\"] in external_id_array:\n        kili.append_labels(\n            json_response_array=[asset[\"labels\"][-1][\"jsonResponse\"]],\n            label_type=\"DEFAULT\",\n            project_id=project_id,\n            asset_external_id_array=[asset[\"externalId\"]],\n        )\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_labels/#cleanup","title":"Cleanup","text":"<p>To clean up, we need to simply remove the project that we created.</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_labels/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, imported assets to it, added metadata to our assets, and then imported various types of labels to our project. Well done!</p>"},{"location":"sdk/tutorials/importing_video_assets/","title":"Importing video assets","text":""},{"location":"sdk/tutorials/importing_video_assets/#how-to-import-video-assets-to-a-kili-project","title":"How to import video assets to a Kili project","text":"<p>In this tutorial, we will learn how to import video assets to Kili.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing video assets to Kili</li> <li>Uploading a video asset using a path to a local file</li> <li>Uploading a video asset using an URL</li> <li>Uploading a video asset to label each frame separately</li> <li>Uploading a list of local images as one video asset</li> <li>Uploading a list of image URLs as one video asset</li> <li>Uploading a video asset with a custom sampling rate</li> <li>Cleanup</li> </ol>"},{"location":"sdk/tutorials/importing_video_assets/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_video_assets/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>!pip install  kili\n</code></pre> <pre><code>from kili.client import Kili\nimport getpass\nimport os\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a video project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Object A\", \"id\": \"category3\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Object B\", \"id\": \"category4\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"mlTask\": \"CLASSIFICATION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"VIDEO\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  cld90h71d0ha50jptd28xfjg1\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#importing-video-assets-to-kili","title":"Importing video assets to Kili","text":"<p>Now, let's add some video assets to be labeled. You can videos using URLs or use your local assets.</p> <p>We will use a free off-the-shelf asset from the Internet.</p>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-a-path-to-a-local-file","title":"Uploading a video asset using a path to a local file","text":"<p>To show an example of how to upload a local video, we must first download it:</p> <pre><code>import urllib.request\n\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\",\n    \"test.mp4\",\n)\n</code></pre> <p>Now, we can easily upload the video to our project:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[\"./test.mp4\"], external_id_array=[\"video_1_from_local\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-an-url","title":"Uploading a video asset using an URL","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with the URL of the video that you want to upload.</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[url], external_id_array=[\"video_2_from_url\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-to-label-each-frame-separately","title":"Uploading a video asset to label each frame separately","text":"<p>To upload your video and be able to label frames separately, as individual images, refer to this code:</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url],\n    external_id_array=[\"video_2_from_url_split_frames\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-local-images-as-one-video-asset","title":"Uploading a list of local images as one video asset","text":"<p>We can create a video, by using local images as frames. Let's first download some images from the Internet:</p> <pre><code>urllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\",\n    \"image_1.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\",\n    \"image_2.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\",\n    \"image_3.jpg\",\n)\n</code></pre> <p>Now, let's put them together as one video:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[\"./image_1.jpg\", \"./image_2.jpg\", \"./image_3.jpg\"]],\n    external_id_array=[\"video_3_from_local_images\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-image-urls-as-one-video-asset","title":"Uploading a list of image URLs as one video asset","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with a set of URLs of images that you want to upload as a video.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[url1, url2, url3]],\n    external_id_array=[\"video_4_from_image_urls\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-with-a-custom-sampling-rate","title":"Uploading a video asset with a custom sampling rate","text":"<p>To upload a video with a custom sampling rate (let's say, 10 frames per second), use this code:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[\"./test.mp4\"],\n    external_id_array=[\"video_5_custom\"],\n    json_metadata_array=[{\"processingParameters\": {\"framesPlayedPerSecond\": 10}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#cleanup","title":"Cleanup","text":"<p>To clean up, we need to simply remove the project that we created.</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#summary","title":"Summary","text":"<p>Done. We've successfully set up a video project, defined its interface, and uploaded a bunch of assets to it, using various Kili's upload methods. Well done!</p>"},{"location":"sdk/tutorials/plugins_development/","title":"Developing plugins - overview","text":""},{"location":"sdk/tutorials/plugins_development/#how-to-develop-a-kili-plugin-overview","title":"How to develop a Kili plugin - overview","text":""},{"location":"sdk/tutorials/plugins_development/#preliminary","title":"Preliminary","text":"<p>This notebook will teach you how to build your first plugin.</p> <p>A plugin is an uploaded Python script triggered by an event that you define.</p> <p>For instance, you can trigger a plugin when a labeler clicks on Submit with the <code>on_submit</code> handler.</p> <p>The plugin should have different methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>Some attributes are available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin should look like this:</p> <pre><code>from kili.plugins import PluginCore\nfrom kili.types import Label\nimport numpy as np\n\nclass PluginHandler(PluginCore):\n\"\"\"Custom plugin\"\"\"\n\n    def on_review(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Do not hesitate to reach out to us if you need more.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_development/#instantiate-kili","title":"Instantiate Kili","text":"<pre><code>!pip install  kili\n</code></pre> <pre><code>%load_ext autoreload\n%autoreload 2\n\nfrom kili.client import Kili\nimport os\n\napi_endpoint = os.getenv(\"KILI_API_ENDPOINT\")\napi_key = os.getenv(\"KILI_API_KEY\")\n\n\nkili = Kili(api_endpoint=api_endpoint, api_key=api_key)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#develop-your-plugin","title":"Develop your plugin","text":"<p>The first step is to define the functions that will be called when the event is triggered. You will be able to iterate on these functions locally (more on that in the next section).</p> <p>The plugin can be defined in two ways: a single <code>.py</code> file with everything inside or a module (folder containing multiple <code>.py</code> files). In the case of the module type, a file named <code>main.py</code> needs to be at the root of the folder and will serve as the entrypoint.</p> <p>### 1. First option - Plugin defined in a single file</p> <p>This cell should be the contents of the <code>.py</code> file that you will upload as a plugin at the end.</p> <p>This file should define the <code>PluginHandler</code> class that will contain the proper methods.</p> <p>We recommend using a modern IDE like VScode to get type hints and autocompletion on the methods.</p> <pre><code>from kili.plugins import PluginCore\nfrom kili.types import Label\nimport numpy as np\n\n\ndef custom_function(label: Label):\n    label_id = label.get(\"id\")\n    print(f\"My custom function for review of label with id {label_id}\")\n\n\nclass PluginHandler(PluginCore):\n\"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def custom_method(self, project_id, label_id):\n        print(f\"custom_method called for label {label_id}\")\n        random_seed = np.random.random(1)[0]\n        if random_seed &gt; 0.5:\n            self.logger.warning(\"Generating issue\")\n            # Use kili for actions with self.kili\n            self.kili.append_to_issues(\n                label_id=label_id,\n                project_id=project_id,\n                text=\"Random issue generated for this label\",\n            )\n\n    def on_review(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Review action\n        \"\"\"\n        custom_function(label)\n\n    def on_submit(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        print(\"On submit called\")\n\n        project_id = self.project_id\n        label_id = label.get(\"id\")\n\n        self.custom_method(project_id, label_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#2-second-option-plugin-defined-in-a-folder","title":"2. Second option - Plugin defined in a folder","text":"<p>As said previously, the structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file): <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre></p> <p>You can notice that you can also include a <code>requirements.txt</code> file in the folder and the necessary packages will be installed with your plugin. Don't forget to add them, since the plugin could work on your machine if you have them installed, but it won't be possible to create the plugin if there are missing dependencies.</p> <p>Important: The main.py file need to have the same skeleton as the plugin defined in a single file (presence of the class <code>PluginHandler</code>), the difference being that it can import and call functions defined in other files</p> <p>Depending on where the folder is stored, there are two ways to import the plugin in order to test it: - The first way is to use a relative import (having the plugin folder and the notebook in the same folder). It is simpler and we recommend it as it will also allow the IDE to detect the correct methods and propose hints and autocompletion. - The second was is to use an absolute path to the plugin folder</p>"},{"location":"sdk/tutorials/plugins_development/#21-relative-import","title":"2.1 Relative import","text":"<pre><code># Here replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#22-absolute-path-import","title":"2.2 Absolute path import","text":"<pre><code>import os\nimport sys\nfrom pathlib import Path\n\n# Input the path to the plugin folder (it should include the folder), for example '/path/to/plugin_folder'\nplugin_path = \"&lt;INSERT PATH TO PLUGIN FOLDER&gt;\"\n\nmodule_path = str(Path(plugin_path).parent.absolute())\n\n# We are inserting the path in the system PATH to be able to import the module in the next line\nsys.path.insert(0, module_path)\n\n# In the next line replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#testing-the-plugin-locally","title":"Testing the plugin locally","text":"<p>In this we will show you how to test your plugin locally before uploading it.</p> <pre><code>project_id = \"&lt;PROJECT ID&gt;\"\n</code></pre> <p>Instantiate the plugin:</p> <pre><code>my_plugin_instance = PluginHandler(kili, project_id)\n\n\ndef get_label(label_id, project_id):\n\"\"\"\n    Function to get the object Label with the same keys as it will be in the plugin\n    \"\"\"\n    label = list(\n        kili.labels(\n            project_id=project_id,\n            label_id=label_id,\n            fields=[\"id\", \"jsonResponse\", \"author.id\", \"labelType\", \"createdAt\", \"secondsToLabel\"],\n        )\n    )[0]\n\n    label[\"authorId\"] = label[\"author\"][\"id\"]\n    del label[\"author\"]\n    return label\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run","title":"Test the plugin run","text":"<p>If you already have a test project with labels added, you can directly use the IDs of these labels (see the following cell). Otherwise, you can follow the plugins_example.ipynb notebook to create a new project and then upload an asset with an associated label.</p> <pre><code>asset_id = \"&lt;YOUR_ASSET_ID&gt;\"\nlabel_id = \"&lt;YOUR_LABEL_ID&gt;\"\n</code></pre> <pre><code>from kili.types import Label\n\nlabel = get_label(label_id=label_id, project_id=project_id)\n\nmy_plugin_instance.on_submit(label=Label(**label), asset_id=asset_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run-on-kili","title":"Test the plugin run on Kili","text":"<p>When you finish debugging the code, you may want to upload it directly into Kili.</p> <p>Note that you might get an error if the plugin name already exists in your Kili organization.</p> <pre><code>path_to_plugin = \"path/to/my/plugin.py\"\nplugin_name = \"My first kili plugin\"\n</code></pre> <pre><code>from kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(path_to_plugin, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <p>Plugins must be activated in the project that you want them to run in. Be careful with production projects: your custom workflows or rules will also be applied</p> <pre><code>kili.activate_plugin_on_project(plugin_name, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#monitoring-the-plugin","title":"Monitoring the plugin","text":"<p>Plugin creation takes some time (around 5 minutes). The plugin will begin to run only after it's been fully created (if labeling events are to be triggered on this project).</p> <p>Additionally, you can get the logs of the runs:</p> <pre><code>kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name)\n</code></pre> <p>You can set custom date rules for filtering your logs:</p> <pre><code>from datetime import date\nfrom datetime import datetime\n\ndt = date.today()  # You can change this date if needed\nstart_date = datetime.combine(dt, datetime.min.time())\n\nkili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#managing-your-plugin","title":"Managing your plugin","text":"<p>There are several other methods to manage your plugins and their lifecycle. To find out more, you can check the documentation in the section Reference -&gt; Plugins.</p>"},{"location":"sdk/tutorials/plugins_example/","title":"Developing plugins - example","text":""},{"location":"sdk/tutorials/plugins_example/#how-to-develop-a-kili-plugin-example","title":"How to develop a Kili plugin - example","text":""},{"location":"sdk/tutorials/plugins_example/#context","title":"Context","text":"<p>This notebook is an end-to-end example that you can follow to: create a project, upload a first plugin and activate it on this project, and finally start monitoring it.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_example/#step-1-instantiate-kili","title":"Step 1: Instantiate Kili","text":"<pre><code>!pip install kili\n</code></pre> <pre><code>from kili.client import Kili\nimport os\nimport time\nfrom pathlib import Path\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-2-create-the-project","title":"Step 2: Create the project","text":"<p>First, we need to create a new project. In our example, we will use an <code>IMAGE</code> type project with the following <code>jsonInterace</code>:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\n                        \"children\": [],\n                        \"name\": \"Object A\",\n                        \"color\": \"#733AFB\",\n                        \"id\": \"category1\",\n                    },\n                    \"OBJECT_B\": {\n                        \"children\": [],\n                        \"name\": \"Object B\",\n                        \"color\": \"#3CD876\",\n                        \"id\": \"category2\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n</code></pre> <pre><code>title = \"Plugins test project\"\ndescription = \"My first project with a plugin\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n\nprint(f\"Created project {project_id}\")\n</code></pre> <pre><code>Created project cldlyo2bq61if0jn9efvn3soo\n</code></pre> <p>Upload an asset:</p> <pre><code>content_array = [\"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"]\nnames_array = [\"landscape\"]\n\nkili.append_many_to_dataset(\n    project_id=project_id, content_array=content_array, external_id_array=names_array\n)\n\nasset_id = list(kili.assets(project_id=project_id, fields=[\"id\"], disable_tqdm=True))[0][\"id\"]\n</code></pre> <p>This project has one job of bounding box creation with two categories.</p> <p>With our plugin, we want to make sure that the labelers don't create more than one bounding box of category A.</p> <p>To iterate on the plugin code, you can refer to the plugins_development.ipynb notebook.</p>"},{"location":"sdk/tutorials/plugins_example/#step-3-write-the-plugin","title":"Step 3: Write the plugin","text":"<pre><code>from kili.plugins import PluginCore\nfrom kili.types import Label\n\ndef check_rules_on_label(label: Label):\n    #custom methods\n    print('Custom method - checking number of bboxes')\n\n    counter = 0\n    for annotation in label['jsonResponse'][\"JOB_0\"][\"annotations\"]:\n        if annotation[\"categories\"][0][\"name\"] == \"OBJECT_A\":\n            counter += 1\n\n    if counter == 0:\n        return []\n    return [f'There are too many BBox ({counter}) - Only 1 BBox of Object A accepted']\n\nclass PluginHandler(PluginCore):\n\"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def on_submit(self, label: Label, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        self.logger.info(\"On submit called\")\n\n        issues_array = check_rules_on_label(label)\n\n        project_id = self.project_id\n\n        if len(issues_array) &gt; 0:\n            print(\"Creating an issue...\")\n\n            for i, _ in enumerate(issues_array):\n\n                self.kili.append_to_issues(\n                    label_id=label['id'],\n                    project_id=project_id,\n                    text=issues_array[i],\n                )\n\n            print(\"Issue created!\")\n\n            self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> <pre><code>import urllib.request\n\n\nplugin_folder = \"plugin_folder\"\n\nPath(plugin_folder).mkdir(parents=True, exist_ok=True)\nurllib.request.urlretrieve(\n    \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/master/recipes/plugins_library/plugin_image.py\",\n    \"plugin_folder/main.py\",\n)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-upload-the-plugin-from-a-folder","title":"Step 4: Upload the plugin from a folder","text":"<p>With the plugin defined in a separate <code>Python</code> file, you can create a folder containing: - A <code>main.py</code> file which is the entrypoint of the plugin and must have a <code>PluginHandler</code> class which implements a <code>PluginCore</code> class - (optionally) a <code>requirements.txt</code> (if you need specific PyPi packages in your plugin)</p> <pre><code>folder/\n     main.py\n     requirements.txt\n</code></pre> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <p>Here is an example of a <code>requirements.txt</code> file: numpy scikit-learn pandas==1.5.1 git+https://github.com/yzhao062/pyod.git</p> <pre><code>requirements_path = Path(plugin_folder) / \"requirements.txt\"\n\npackages_list = [\n    \"numpy\\n\",\n    \"scikit-learn\\n\",\n    \"pandas==1.5.1\\n\",\n    \"git+https://github.com/yzhao062/pyod.git\\n\",\n]\n\nwith requirements_path.open(\"w\") as f:\n    f.writelines(packages_list)\n</code></pre> <pre><code>plugin_name = \"Plugin bbox count\"\n\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(plugin_folder, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin_folder\", plugin_name=\"Plugin bbox count\")\nerror: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"Plugin bbox count\" for field 'name' | trace : false\"\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name, project_id=project_id);\n</code></pre> <pre><code>Plugin with name \"Plugin bbox count\" activated on project \"cldlyo2bq61if0jn9efvn3soo\"\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-bis-upload-the-plugin-from-a-py-file","title":"Step 4 bis: Upload the plugin from a .py file","text":"<p>Alternatively, you can also create a plugin directly from a <code>.py</code> file.</p> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <pre><code>path_to_plugin = Path(plugin_folder) / \"main.py\"\nplugin_name = \"Plugin bbox count\"\n\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(str(path_to_plugin), plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin_folder/main.py\", plugin_name=\"Plugin bbox count\")\nerror: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"Plugin bbox count\" for field 'name' | trace : false\"\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name, project_id=project_id);\n</code></pre> <pre><code>Warning: A plugin with the name \"Plugin bbox count\" is already activated on the project with id \"cldlyo2bq61if0jn9efvn3soo\"\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-5-plugin-in-action","title":"Step 5: Plugin in action","text":"<p>Wait for the plugin to be successfully deployed.</p> <p>After that, you can test it by labelling in the Kili interface or just by uploading the following label.</p> <p>When you add the label that contains errors, you will see a new issue automatically created in the Kili app.</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.79, \"y\": 0.20},\n                            {\"x\": 0.79, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.20},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161456406-47055\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.87, \"y\": 0.36},\n                            {\"x\": 0.87, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.36},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161459298-45160\",\n                \"type\": \"rectangle\",\n            },\n        ]\n    }\n}\n</code></pre> <pre><code>kili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n</code></pre> <pre><code>[{'id': 'cldlyovj52lfr0joi831qfbao'}]\n</code></pre> <p>If you use the base plugin provided, the plugin should:</p> <ul> <li>Create an issue with information that three bboxes were found, instead of one</li> <li>Send the asset back to the labeling queue (status <code>ONGOING</code>)</li> </ul> <pre><code>print(\n    kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\", \"issues.comments.text\"])\n)\n\nprint(\n    \"Go to my project:\"\n    f' {kili.auth.api_endpoint.split(\"/api\")[0]}/label/projects/{project_id}/menu/queue'\n)\n</code></pre> <pre><code>[{'issues': [], 'status': 'LABELED'}]\nGo to my project: https://cloud.kili-technology.com/label/projects/cldlyo2bq61if0jn9efvn3soo/menu/queue\n</code></pre> <p>Woah! Amazing! Well done :) \ud83d\ude80</p> <p>Let's test now to post a proper label, this one for example:</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\nkili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n\nprint(kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\"]))\n\nprint(\n    \"Go to my project:\"\n    f' {kili.auth.api_endpoint.split(\"/api\")[0]}/label/projects/{project_id}/menu/queue'\n)\n</code></pre> <pre><code>[{'status': 'LABELED'}]\nGo to my project: https://cloud.kili-technology.com/label/projects/cldlyo2bq61if0jn9efvn3soo/menu/queue\n</code></pre> <p>The status of your asset should have now changed to <code>LABELED</code>. In this plugin, previous issues remain but you can solve them through the API as well.</p> <p>Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins_development.ipynb tutorial.</p>"},{"location":"sdk/tutorials/plugins_example/#step-6-monitor-the-plugin","title":"Step 6: Monitor the plugin","text":"<p>To monitor a certain plugin, you can get its logs by using the following command:</p> <pre><code>import json\nfrom datetime import date\nfrom datetime import datetime\n\ndt = (\n    date.today()\n)  # You can change this date if needed, or omit it to set it at the plugin creation date\nstart_date = datetime.combine(dt, datetime.min.time())\n\nlogs = kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n\nlogs_json = json.loads(logs)\nprint(json.dumps(logs_json, indent=4))\n</code></pre> <pre><code>[]\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-7-manage-the-plugin","title":"Step 7: Manage the plugin","text":"<p>You also have several other methods to manage your plugins.</p> <p>Get the list of all uploaded plugins in your organization:</p> <pre><code>plugins = kili.list_plugins()\n</code></pre> <p>Update a plugin with new source code:</p> <pre><code># Insert the path to the updated plugin\nnew_path_to_plugin = Path(plugin_folder) / \"main.py\"\n\n# Change to True if you want to update the plugin\nshould_update = False\n\nif should_update:\n    kili.update_plugin(plugin_name=plugin_name, plugin_path=str(new_path_to_plugin))\n</code></pre> <p>Deactivate the plugin on a certain project (the plugin can still be active for other projects):</p> <pre><code>kili.deactivate_plugin_on_project(plugin_name=plugin_name, project_id=project_id);\n</code></pre> <pre><code>Plugin Plugin bbox count deactivated on project cldlyo2bq61if0jn9efvn3soo\n</code></pre> <p>Delete the plugin completely (deactivates the plugin from all projects):</p> <pre><code>if delete_plugin_from_org:\n    kili.delete_plugin(plugin_name=plugin_name)\n</code></pre>"},{"location":"sdk/tutorials/plugins_library/","title":"Plugins library","text":""},{"location":"sdk/tutorials/plugins_library/#context","title":"Context","text":"<p>In this section you can find multiple examples of use-cases where our system of plugins can help you in the Kili projects.</p> <p>You can also refer to our tutorial to develop your plugin and iterate on it locally, before uploading the final version to Kili.</p> <p>For further information concerning the Kili plugins, refer to the Reference page</p>"},{"location":"sdk/tutorials/plugins_library/#library-of-pre-built-plugins","title":"Library of pre-built plugins","text":"<p>In the folder <code>plugins_library</code> you can find multiple examples of plugins that are ready to use in your projects. They can be split in various use-cases:</p>"},{"location":"sdk/tutorials/plugins_library/#1-programmatic-qa","title":"1. Programmatic QA","text":"<p>One application of plugins is to automate your quality checks: you can directly write your business rules in a Python script and upload them to Kili to have each new label automatically checked.</p>"},{"location":"sdk/tutorials/plugins_library/#11-image-object-detection-example","title":"1.1 Image Object Detection example","text":"<p>Let's imagine a project where we want to process images and detect some objects. One of the jobs is to detect an object and we are sure that in any image of the dataset we can have at most a single object of that type. In order to be sure that we will have only one object in all submitted labels, we can create a plugin that, in case a label has 2 BBoxes for that type of objects, will automatically create an issue with a clear instruction and will send the label back to the queue. z - Plugin file: <code>plugin_image.py</code> - End-to-end notebook showcasing this example: <code>plugins_example.ipynb</code></p>"},{"location":"sdk/tutorials/plugins_library/#12-document-processing-example","title":"1.2 Document processing example","text":"<p>Let's imagine another project where we process invoices. The project has two jobs and several transcription tasks associated with them. One of the jobs is about payment information and must contain a proper IBAN number as well as currency. The IBAN must start with FR, and the currency should be one of: EURO or DOLLAR. Kili's interface customization options are powerful and flexible, but won't help us in this specific situation so we have to turn to Kili plugins for help. We'll set up our Kili plugin to check these two rules when labelers click Submit. If the annotations don't match our predefined rules, our QA bot will add issues to the asset and send the asset back to the labeling queue. At the end, our script will calculate labeling accuracy and insert the accuracy metric in the json_metadata of the asset. All that with no need to engage a human reviewer.</p> <ul> <li>Plugin file: <code>plugin_document.py</code></li> <li>End-to-end notebook showcasing this example: <code>plugins_example_document.ipynb</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#2-consensus-resolution","title":"2. Consensus resolution","text":"<p>When working with consensus for object detection tasks, it is often handy for a reviewer to access the annotations of all the labelers involved, compare them and choose the best one. With Kili plugins, this task will be much simpler.</p> <p>For example: you can program your plugin to create an additional annotation that combines the annotations created by all the labelers. This way, you can instantaneously get a big-picture overview and only act when the situation calls for it. In large projects, this can save you a significant amount of time.</p> <ul> <li>Plugin file: <code>plugin_consensus.py</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#3-parallel-labeling","title":"3. Parallel labeling","text":"<p>For projects with specialized workforce, you can split your workforce in several groups, with each of them focused on a specific portion of your labeling tasks. For instance, group A (experts in the A domain) only does labeling for job A and group B (experts in the B domain) only does labeling for job B. With Kili Plugins, you could then combine these workflows by aggregating the annotations done by multiple labelers as one label. Your reviewers would then be presented with the combined results.</p> <ul> <li>Plugin file: <code>parallel_labeling_plugin.py</code></li> </ul>"},{"location":"sdk/tutorials/set_up_workflows/","title":"Managing workflows","text":""},{"location":"sdk/tutorials/set_up_workflows/#how-to-set-up-and-manage-workflows-with-kili","title":"How to set up and manage workflows with Kili","text":"<p>In this tutorial, we will learn how to set up basic Kili workflows:</p> <ol> <li>Managing reviews<ol> <li>Placing a specific percentage of project assets in the review queue</li> <li>Placing specific assets in the review queue</li> <li>Sending an asset back to the labeling queue</li> </ol> </li> <li>Setting up consensus<ol> <li>Setting consensus for a specific percentage of project assets</li> <li>Setting consensus for specific assets to compute consensus KPIs</li> </ol> </li> <li>Setting up honeypot</li> <li>Assigning labelers to assets</li> <li>Prioritizing assets in the labeling queue</li> </ol> <p>To work with this notebook, you will have to install and instantiate Kili.</p> <pre><code>!pip install kili\n</code></pre> <pre><code>from kili.client import Kili\nimport getpass\nimport os\n</code></pre> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # not needed if KILI_API_KEY is already in environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <pre><code>project_id = \"&lt;YOUR PROJECT ID&gt;\"\n</code></pre> <p>For information on how to set up a Kili project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#managing-reviews","title":"Managing reviews","text":""},{"location":"sdk/tutorials/set_up_workflows/#placing-a-specific-percentage-of-project-assets-in-the-review-queue","title":"Placing a specific percentage of project assets in the review queue","text":"<p>You can set up the percentage of assets that will automatically appear in the review queue (1-100%).</p> <pre><code>kili.update_properties_in_project(project_id=project_id, review_coverage=50)\n</code></pre> <pre><code>{'id': 'cld95dpne0n2y0joi6wuq3u6v', 'reviewCoverage': 50}\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-consensus","title":"Setting up consensus","text":"<p>Consensus works by having more than one labeler annotate the same asset. When the asset is labeled, a consensus score is calculated to measure the agreement level between the different annotations for a given asset. This is a key measure for controlling label production quality.</p> <p>To set up consensus, you will need to have at least two project members. For information on how to add users and assign them to your project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-a-specific-percentage-of-project-assets","title":"Setting consensus for a specific percentage of project assets","text":"<p>Let's set the percentage of the project dataset that will be annotated several times, to enable consensus calculations. We will also set the minimum number of labelers to label each one of these assets.</p> <pre><code>def set_consensus_coverage(project_id: str, consensus_tot_coverage: int, min_consensus_size: int):\n    kili.update_properties_in_project(\n        project_id=project_id,\n        consensus_tot_coverage=consensus_tot_coverage,\n        min_consensus_size=min_consensus_size,\n    )\n\n\nset_consensus_coverage(project_id=project_id, consensus_tot_coverage=50, min_consensus_size=3)\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-specific-assets-to-compute-consensus-kpis","title":"Setting consensus for specific assets to compute consensus KPIs","text":"<p>You can manually select specific project assets to be used for computing consensus KPIs.</p> <pre><code>def set_assets_for_consensus(project_id: str, external_ids: list):\n    kili.update_properties_in_assets(\n        project_id=project_id,\n        external_ids=external_ids,\n        is_used_for_consensus_array=[True] * len(external_ids),\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nset_assets_for_consensus(project_id=project_id, external_ids=external_ids)\n</code></pre> <p>For more information on consensus, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-honeypot","title":"Setting up honeypot","text":"<p>Honeypot (or gold standard) is a tool for auditing the work of labelers by measuring the accuracy of their annotations. Honeypot works by interspersing assets with defined ground truth label in the annotation queue. This way you can measure the agreement level between your ground truth and the annotations made by labelers.</p> <p>You can manually select specific project assets to be used as honeypots.</p> <pre><code>asset_external_id = \"1.jpg\"\njson_response = {\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}}\n\nkili.create_honeypot(\n    project_id=project_id, asset_external_id=asset_external_id, json_response=json_response\n);\n</code></pre> <p>For more information on honeypot, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#assigning-labelers-to-assets","title":"Assigning labelers to assets","text":"<p>You can assign specific labelers to specific assets in your project. You can do that by assigning users' emails to the selected asset IDs. Remember that you can assign more than one user to a specific asset.</p> <pre><code>def assign_labelers_to_assets(project_id: str, external_ids: list, to_be_labeled_by_array: list):\n    kili.update_properties_in_assets(\n        project_id=project_id,\n        external_ids=external_ids,\n        to_be_labeled_by_array=to_be_labeled_by_array,\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nto_be_labeled_by_array = [\n    [\"example1@example.com\"],\n    [\"example2@example.com\"],\n    [\"example3@example.com\"],\n]\n\nassign_labelers_to_assets(\n    project_id=project_id, external_ids=external_ids, to_be_labeled_by_array=to_be_labeled_by_array\n)\n</code></pre> <p>The <code>to_be_labeled_by_array</code> argument is a list of lists. Each of the sub-lists can contain several e-mails. This way you can assign several labelers to one asset.</p> <p>For example:</p> <p><code>to_be_labeled_by_array = [[\"example1@example.com\"], [\"example1@example.com\", \"example2@example.com\"], [\"example3@example.com\"]]</code></p> <p>For information on how to add users and assign them to your project, refer to the basic project setup tutorial. For information on assigning assets to users, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#prioritizing-assets-in-the-labeling-queue","title":"Prioritizing assets in the labeling queue","text":"<p>If you have certain assets that you need to have labeled earlier or later than the rest, you can use Kili's asset prioritization methods.</p> <pre><code>def set_priority_for_assets(project_id: str, external_ids: list, priorities: list):\n    kili.update_properties_in_assets(\n        project_id=project_id, external_ids=external_ids, priorities=priorities\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\npriorities = [1, 5, 10]\nset_priority_for_assets(project_id=project_id, external_ids=external_ids, priorities=priorities)\n</code></pre> <p>For information on setting asset priorities, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#placing-specific-assets-in-the-review-queue","title":"Placing specific assets in the review queue","text":"<p>When done with your basic workflow setup, you can place specific, labeled assets in the review queue. As this requires the assets to be labeled, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs.</p> <pre><code>json_response_array = [\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}} for i in range(3)\n]\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    json_response_array=json_response_array,\n    label_type=\"DEFAULT\",\n)\n</code></pre> <pre><code>[{'id': 'cld95duf80o3k0jpa5f8bdolk'},\n {'id': 'cld95duf80o3l0jpa6tkv947s'},\n {'id': 'cld95duf90o3m0jpaccwo0awt'}]\n</code></pre> <p>Now, let's place some assets in the review queue. The method will return a project ID and a list of asset IDs placed in the review queue.</p> <pre><code>external_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nkili.add_to_review(project_id=project_id, external_ids=external_ids)\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#sending-an-asset-back-to-the-labeling-queue","title":"Sending an asset back to the labeling queue","text":"<p>You can also send specific labeled assets back to the labeling queue. asset_names, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs.</p> <pre><code>json_response_array = [{\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}}] * 3\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    json_response_array=json_response_array,\n    label_type=\"DEFAULT\",\n)\n</code></pre> <pre><code>[{'id': 'cld95dy130iss0ko864g7c7hr'},\n {'id': 'cld95dy130ist0ko8fgokak6h'},\n {'id': 'cld95dy130isu0ko8gb0s1ckc'}]\n</code></pre> <p>Now, we will send some of our assets back to the labeling queue. The method will return a project ID and a list of asset IDs that were sent back to the labeling queue.</p> <pre><code>external_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nkili.send_back_to_queue(project_id=project_id, external_ids=external_ids)\n</code></pre> <pre><code>{'id': 'cld95dpne0n2y0joi6wuq3u6v',\n 'asset_ids': ['cld95dq340006wvszexj8u1uh',\n  'cld95dq340007wvszoxdhet57',\n  'cld95dq340008wvszveinxcy2']}\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#summary","title":"Summary","text":"<p>Done!</p> <p>We have learned how to handle the review workflow, set up consensus and honeypot in a project, assign specific labelers to specific assets, and how to prioritize assets in the labeling queue.</p>"}]}