{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with the Kili Python SDK","text":""},{"location":"#what-is-kili","title":"What is Kili?","text":"<p>Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here.</p> <p>If you are looking for the Kili product documentation, it is located here.</p>"},{"location":"#the-kili-python-sdk","title":"The Kili Python SDK","text":"<p>Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>You only need Python 3.7 or higher.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the Kili client with pip:</p> <pre><code>pip install kili\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <ul> <li>Instantiate the Kili client:</li> </ul> <pre><code>from kili.client import Kili\nkili = Kili()\n</code></pre> <p>Info</p> <p>You can also pass the API key as an argument during <code>Kili</code> initialization:</p> <pre><code>kili = Kili(api_key='&lt;you api key value here&gt;')\n</code></pre> <p>Great!</p> <p>You can now begin to use the Kili Python SDK! \ud83c\udf89</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Kili Tutorials Homepage!</p> <p>We understand that getting started with a new product can sometimes be challenging. That's why we have created this page to provide you with easy-to-follow tutorials that will help you understand how to use the Kili Python SDK in no time.</p> <p>Here is a brief overview of our tutorials:</p>"},{"location":"tutorials/#basic-project-setup","title":"Basic project setup","text":"<p>In this tutorial you will learn how to set up a new project in Kili, configure its settings, and add assets and users to it.</p>"},{"location":"tutorials/#importing-assets","title":"Importing assets","text":"<p>This tutorial will show you how to import assets into your Kili project and add asset metadata.</p> <p>Because videos and Rich Text assets may be more complex to import, we\u2019ve created separate tutorials devoted to them:</p> <ul> <li>For information on importing video assets, refer to this tutorial.</li> <li>For information on importing rich text assets, see here.</li> </ul>"},{"location":"tutorials/#importing-labels","title":"Importing labels","text":"<p>In this tutorial you will learn how to import different types of label formats supported by Kili, including model-based pre-annotations and pre-existing labels from other projects.</p> <p>This tutorial explains how to use a powerful OpenAI Large Language Model (LLM) to generate pre-annotations, which will then be imported into a Named Entity Recognition (NER) Kili project.</p> <p>For other specific use cases, see these tutorials:</p> <ul> <li>Importing OCR pre-annotations</li> <li>Importing segmentation pre-annotations</li> <li>Importing DINOv2 classification pre-annotations</li> </ul> <p>Additionally, we\u2019ve devoted one tutorial to explaining the most common use cases for importing and using model-generated labels: actively monitoring the quality of a model currently deployed to production to detect issues like data drift, and using a model to speed up the process of label creation.</p>"},{"location":"tutorials/#working-with-labels","title":"Working with labels","text":"<p>In this section, you\u2019ll learn the various ways you can process labels with Kili.</p> <p>This tutorial shows you how to upload medical images to Kili using pydicom, upload dicom tags as metadata to your assets, download segmentation labels from Kili, and finally convert them to Numpy masks for visualization with matplotlib.</p> <p>The Tagtog to Kili tutorial will show you how to convert and import your tagtog assets and labels into Kili.</p> <p>The label parsing tutorial will show you how you can read and write label data more efficiently.</p>"},{"location":"tutorials/#managing-workflows","title":"Managing workflows","text":"<p>In this tutorial you will learn how to manage your review queue, set up quality assurance measures, assign specific labelers to assets, and prioritize assets to be annotated.</p>"},{"location":"tutorials/#exporting-project-data","title":"Exporting Project Data","text":"<p>This tutorial will show you how to export your project\u2019s assets and labels to different formats supported by Kili.</p>"},{"location":"tutorials/#plugins","title":"Plugins","text":"<p>A plugin is a custom Python script uploaded to Kili and triggered by an event that you define. For instance, you can trigger a specific action when a labeler clicks on Submit.</p> <p>In this tutorial you will learn how to create your own custom plugins.</p> <p>Here, you\u2019ll find example use cases for using Kili plugins.</p> <p>For a more specific use case, follow this tutorial on how to set up and use Kili plugins to monitor the quality of labels added to your project in real-time, without having to involve human reviewers.</p> <p>Webhooks are really similar to plugins, except they are self-hosted, and require a web service deployed at your end, callable by Kili. To learn how to use webhooks, follow this tutorial.</p>"},{"location":"tutorials/#more","title":"More","text":"<p>For more tutorials and recipes, see our Github repository.</p>"},{"location":"cli/","title":"Getting started with the Kili CLI","text":""},{"location":"cli/#what-is-kili-cli","title":"What is Kili CLI","text":"<p>Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.</p>"},{"location":"cli/#authentication","title":"Authentication","text":"<ul> <li>Create and copy a Kili API key</li> <li>Add the <code>KILI_API_KEY</code> variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier:</li> </ul> <pre><code>export KILI_API_KEY='&lt;you api key value here&gt;'\n</code></pre> <p>Info</p> <p>While launching commands, you can also provide you API key through the <code>--api-key</code> option. If you set your api key in the <code>KILI_API_KEY</code> environment variable and provide it once again through the <code>--api-key</code> option, Kili CLI will use the api key value provided in command options.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>The main command is <code>kili</code>. It currently has only one subcommand <code>project</code> that entails all the commands for project management :</p> <pre><code>kili project [COMMAND]\n</code></pre>"},{"location":"cli/#workflow-example","title":"Workflow example","text":"<p>Let's take an example where you want to start a project from scratch  You can download ressources to run this example here. Once in the current directory where all files are stored, you can run the following commands:</p>"},{"location":"cli/#create-a-project","title":"Create a project","text":"<p>To create an IMAGE project:</p> <pre><code>kili project create \\\n            json_interface.json \\\n            --title \"Quality inspection\" \\\n            --input-type IMAGE \\\n            --description \"Steel defects on production line\"\n</code></pre> <p>Ouput:</p> <pre><code>ID                         URL\n&lt;project_id&gt;               https://cloud.kili-technology.com/label/projects/&lt;project_id&gt;/\n</code></pre>"},{"location":"cli/#list-your-projects","title":"List your projects","text":"<pre><code>kili project list --max 10\n</code></pre> <p>Ouput:</p> <pre><code>TITLE                                ID                      PROGRESS  DESCRIPTION\nQuality inspection                   &lt;project_id&gt;                0.0%  Steel defects on production line...\n</code></pre>"},{"location":"cli/#recover-your-project-id","title":"Recover your project ID","text":"<pre><code>export project_id=$(kili project list \\\n              | grep -m1 \"Quality inspection\" \\\n              | awk '{print $3}')\n</code></pre>"},{"location":"cli/#add-a-member-to-your-project","title":"Add a member to your project","text":"<pre><code>kili project member add \\\n                &lt;email_adress&gt; \\\n                --project-id $project_id \\\n                --role REVIEWER\n</code></pre> <p>Ouput:</p> <pre><code>1 member(s) have been successfully added to project: &lt;project_id&gt;\n</code></pre>"},{"location":"cli/#list-the-projects-members","title":"List the project's members","text":"<pre><code>kili project member list --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>ROLE      NAME            EMAIL                ID                         ORGANIZATION\nADMIN     &lt;your_name&gt;     &lt;your_email&gt;         &lt;your_member_id&gt;           &lt;your_organization&gt;\nREVIEWER  &lt;reviewer_name&gt; &lt;email_adress&gt;       &lt;member_id&gt;                &lt;your_organization&gt;\n</code></pre>"},{"location":"cli/#import-data-to-your-project","title":"Import data to your project","text":"<p>To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths)</p> <pre><code>kili project import \\\n    assets \\\n    --project-id $project_id\n</code></pre> <p>Ouput:</p> <pre><code>40 files have been successfully imported\n</code></pre>"},{"location":"cli/#import-labels-to-your-project","title":"Import labels to your project","text":"<p>To import labels, provide a list of files or folders.</p> <p>You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example).  File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre> <p>If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface.</p> <pre><code>kili project label \\\n    ground_truths \\\n    --project-id $project_id \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> <p>Outputs:</p> <pre><code>40 labels have been successfully imported\n</code></pre>"},{"location":"cli/#get-metrics-of-your-project","title":"Get metrics of your project","text":"<pre><code>kili project describe $project_id\n</code></pre> <p>Ouput:</p> <pre><code>Title        Quality inspection\nDescription  Steel defects on production line\n\nDataset KPIs\n------------\nTotal number of assets      40\nNumber of remaining assets  10\nSkipped assets              0\nProgress                    25.0%\n\nQuality KPIs\n------------\nProject consensus           N/A\nProject honeypot            N/A\nNumber of reviewed assets   0\nNumber of open issues       0\nNumber of solved issues     0\nNumber of open questions    0\nNumber of solved questions  0\n</code></pre>"},{"location":"cli/reference/","title":"kili","text":"<p>Kili Command line Interface.</p> <p>To get all the available commands, please type: <code>kili project --help</code>.</p> <p>Usage:</p> <pre><code>kili [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#project","title":"project","text":"<p>Commands to interact with a Kili project.</p> <p>Usage:</p> <pre><code>kili project [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#copy","title":"copy","text":"<p>Copy an existing Kili project.</p> <p>The copy can include or not the json interface, quality settings, members, assets and labels of the source project.</p> <p>By default, only the json interface, quality settings and project members are copied.</p> <p>If no <code>title</code> is provided, the source project title will be used. If no description is provided, the description will be set to an empty string.</p> <p>Returns the new project id and title once the copy is finished.</p> <p>Examples</p> <p>Copy a project and set a new title and new description: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --title \"New project title\" \\\n    --description \"New project description\"\n</code></pre> Copy the json interface but not the members: <pre><code>kili project copy clbqn56b331234567890l41c0 \\\n    --with-json-interface \\\n    --without-members\n</code></pre></p> <p>Usage:</p> <pre><code>kili project copy [OPTIONS] FROM_PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--title</code> text New project title. None <code>--description</code> text New project description. None <code>--with-json-interface</code> / <code>--without-json-interface</code> boolean Copy json interface. <code>True</code> <code>--with-quality-settings</code> / <code>--without-quality-settings</code> boolean Copy quality settings. <code>True</code> <code>--with-members</code> / <code>--without-members</code> boolean Copy members. <code>True</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Copy assets. <code>False</code> <code>--with-labels</code> / <code>--without-labels</code> boolean Copy labels. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#create","title":"create","text":"<p>Create a Kili project.</p> <p>interface must be a path pointing to your json interface file</p> <p>If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied).</p> <p>Examples</p> <p><pre><code>kili project create \\\n     path/to/interface.json \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre> <pre><code>kili project create \\\n    --from-project &lt;project_id_src&gt; \\\n    --input-type TEXT \\\n    --title \"Invoice annotation project\"\n</code></pre></p> <p>To build a Kili project interface, please visit: </p> <p>https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings</p> <p>Usage:</p> <pre><code>kili project create [OPTIONS] [INTERFACE]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--from-project</code> text project_id of another Kili project None <code>--title</code> text Project Title. _required <code>--input-type</code> choice (<code>AUDIO</code> | <code>IMAGE</code> | <code>PDF</code> | <code>TEXT</code> | <code>TIME_SERIES</code> | <code>VIDEO</code> | <code>VIDEO_LEGACY</code>) Project input data type. Please check your license to see which ones you have access to. _required <code>--description</code> text Project description. `` <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#describe","title":"describe","text":"<p>Show project description and analytics.</p> <p>Examples</p> <pre><code>kili project describe --project-id &lt;project_id&gt;\n</code></pre> <p>Usage:</p> <pre><code>kili project describe [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#export","title":"export","text":"<p>Export the Kili labels of a project to a given format.</p> <p>Info</p> <p>The supported formats are:</p> <ul> <li>Yolo V4, V5, V7 for object detection tasks (bounding box).</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (bounding box and semantic segmentation).</li> <li>Pascal VOC for object detection tasks (bounding box).</li> </ul> <p>Cloud storage</p> <p>Export with asset download (<code>--with-assets</code>) is not allowed for projects connected to a cloud storage.</p> <p>Examples</p> <p><pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format coco \\\n    --output-file /tmp/export.zip\n</code></pre> <pre><code>kili project export \\\n    --project-id &lt;project_id&gt; \\\n    --output-format yolo_v5 \\\n    --output-file /tmp/export_split.zip \\\n    --layout split\n</code></pre></p> <p>Usage:</p> <pre><code>kili project export [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--output-format</code> choice (<code>raw</code> | <code>kili</code> | <code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>coco</code> | <code>pascal_voc</code>) Format into which the label data will be converted _required <code>--output-file</code> text File into which the labels are saved. _required <code>--layout</code> choice (<code>split</code> | <code>merged</code>) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. <code>merged</code> <code>--single-file</code> boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). <code>False</code> <code>--with-assets</code> / <code>--without-assets</code> boolean Download assets in the export. <code>True</code> <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--verbose</code> boolean Show more logs <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#import","title":"import","text":"<p>Add assets into a project.</p> <p>Files can be paths to files or to folders. You can provide several paths separated by spaces.</p> <p>If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns:</p> <ul> <li><code>external_id</code>: external id of the asset.</li> <li><code>content</code>: paths to the asset file or a url hosting the asset.</li> </ul> <p>Examples</p> <p><pre><code>kili project import \\\n    dir1/dir2/ dir1/dir3/test1.png \\\n    --project-id &lt;project_id&gt;\n</code></pre> <pre><code>kili project import \\\n    dir1/dir3/video.mp4 \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre> <pre><code>kili project import \\\n    --from-csv assets_list.csv \\\n    --project-id &lt;project_id&gt; \\\n    --frames \\\n    --fps 24\n</code></pre></p> <p>Unsupported imports</p> <p>Currently, this command does not support:</p> <ul> <li>the import of videos from local frames, rich text and time series assets</li> <li>the import of assets with metadata or with a custom external_id</li> </ul> <p>For such imports, please use the <code>append_many_to_dataset</code> method in the Kili SDK.</p> <p>Usage:</p> <pre><code>kili project import [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:external_id, content required columns: None <code>--frames</code> boolean Only for a frame project, import videos as frames. The import time is longer with this option. <code>False</code> <code>--fps</code> integer Only for a frame project, import videos with a specific frame rate None <code>--verbose</code> boolean Show more logs <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#label","title":"label","text":"<p>Import labels or predictions.</p> <p>Files can be paths to files or to folders.  You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id.</p> <p>Examples</p> <p>To import default labels: <pre><code>kili project label \\\n    dir/labels/ dir/ground-truth/image1.json \\\n    --project-id &lt;project_id&gt;\n</code></pre> To import labels as predictions: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-run-3\n</code></pre> To import labels as predictions in the Yolo v5 format into a target job: <pre><code>kili project label \\\n    dir/predictions/ \\\n    --project-id &lt;project_id&gt; \\\n    --prediction \\\n    --model-name YOLO-v5 \\\n    --metadata-file classes.yml \\\n    --target-job IMAGE_DETECTION_JOB \\\n    --input-format yolo_v5\n</code></pre></p> <p>Usage:</p> <pre><code>kili project label [OPTIONS] [FILES]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--prediction</code> boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface <code>False</code> <code>--model-name</code> text Name of the model that generated predictions, if labels are sent as predictions None <code>--verbose</code> boolean Show more logs <code>False</code> <code>--input-format</code> choice (<code>yolo_v4</code> | <code>yolo_v5</code> | <code>yolo_v7</code> | <code>kili</code> | <code>raw</code>) Format in which the labels are encoded <code>kili</code> <code>--metadata-file</code> text File containing format metadata (if relevant to the input format) None <code>--target-job</code> text Job name in the project where to upload the labels (if relevant to the input format) None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list","title":"list","text":"<p>List your projects.</p> <p>Examples</p> <pre><code>kili project list --max 10 --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--max</code> integer Maximum number of project to display. <code>100</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#member","title":"member","text":"<p>Commands to interact with Kili project members.</p> <p>Usage:</p> <pre><code>kili project member [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#add","title":"add","text":"<p>Add members to a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com jane.doe@test.com\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member add \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member add [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#list_1","title":"list","text":"<p>List the members of the project.</p> <p>Examples</p> <pre><code>kili project member list &lt;project_id&gt; --stdout-format pretty\n</code></pre> <p>Usage:</p> <pre><code>kili project member list [OPTIONS] PROJECT_ID\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--stdout-format</code> text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). <code>plain</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#rm","title":"rm","text":"<p>Remove members from a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member rm \\\n    --project-id &lt;project_id&gt; \\\n    --all\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member rm [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--all</code> boolean Remove all users from project <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/reference/#update","title":"update","text":"<p>Update member's role of a Kili project.</p> <p>Emails can be passed directly as arguments. You can provide several emails separated by spaces.</p> <p>Examples</p> <p><pre><code>kili project member update\\\n    --project-id &lt;project_id&gt; \\\n    --role REVIEWER \\\n    john.doe@test.com\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-csv path/to/members.csv\n</code></pre> <pre><code>kili project member update \\\n    --project-id &lt;project_id&gt; \\\n    --from-project &lt;project_id_scr&gt;\n</code></pre></p> <p>Usage:</p> <pre><code>kili project member update [OPTIONS] [EMAILS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--api-key</code> text Your Kili API key. None <code>--endpoint</code> text Kili API Endpoint. None <code>--project-id</code> text Id of the project _required <code>--role</code> choice (<code>ADMIN</code> | <code>TEAM_MANAGER</code> | <code>REVIEWER</code> | <code>LABELER</code>) Project role of the added user(s). None <code>--from-csv</code> path path to a csv file with required columns:email required columns: role None <code>--from-project</code> text project_id of another Kili project None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"sdk/asset/","title":"Asset module","text":""},{"location":"sdk/asset/#queries","title":"Queries","text":"<p>Set of Asset queries.</p> Source code in <code>kili/entrypoints/queries/asset/__init__.py</code> <pre><code>class QueriesAsset:\n\"\"\"Set of Asset queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,too-many-locals,dangerous-default-value,redefined-builtin\n\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_reviewer_in: Optional[List[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_reviewer_in: Optional[List[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"content\",\n            \"createdAt\",\n            \"externalId\",\n            \"id\",\n            \"isHoneypot\",\n            \"jsonMetadata\",\n            \"labels.author.id\",\n            \"labels.author.email\",\n            \"labels.createdAt\",\n            \"labels.id\",\n            \"labels.jsonResponse\",\n            \"skipped\",\n            \"status\",\n        ],\n        asset_id_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        disable_tqdm: bool = False,\n        external_id_contains: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        format: Optional[str] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        skipped: Optional[bool] = None,\n        status_in: Optional[List[str]] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        download_media: bool = False,\n        local_media_dir: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_reviewer_in: Optional[List[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n        label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        *,\n        as_generator: bool = False,\n    ) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n        # pylint: disable=line-too-long\n\"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset to retrieve.\n            asset_id_in: A list of the IDs of the assets to retrieve.\n            skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n            fields: All the fields to request among the possible fields for the assets.\n                    See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n            first: Maximum number of assets to return.\n            consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n            consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n            external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n            metadata_where: Filters by the values of the metadata of the asset.\n            honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n            honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n            status_in: Returned assets should have a status that belongs to that list, if given.\n                Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n            label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n            label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n            label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n            label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n            label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n            skipped: Returned assets should be skipped\n            updated_at_gte: Returned assets should have a label whose update date is greater or equal to this date.\n            updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n            format: If equal to 'pandas', returns a pandas DataFrame\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the assets is returned.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            download_media: Tell is the media have to be downloaded or not.\n            local_media_dir: Directory where the media are downloaded if `download_media` is True.\n            created_at_gte: Returned assets should have their import date greater or equal to this date.\n            created_at_lte: Returned assets should have their import date lower or equal to this date.\n            honeypot_mark_lte: Maximum amount of honeypot for the asset.\n            honeypot_mark_gte: Minimum amount of honeypot for the asset.\n            consensus_mark_lte: Maximum amount of consensus for the asset.\n            consensus_mark_gte: Minimum amount of consensus for the asset.\n            inference_mark_gte: Minimum amount of human/model IoU for the asset.\n            inference_mark_lte: Maximum amount of human/model IoU for the asset.\n            label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n            label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n            label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n            label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n            label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n            label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n            label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n            issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n            issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n            external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n            external_id_in: Returned assets should have external ids that partially match the ones in the list.\n                For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n            label_output_format: If `parsed_label`, the labels in the assets will be parsed. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            An asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n        Example:\n            ```\n            # returns the assets list of the project\n            &gt;&gt;&gt; kili.assets(project_id)\n            &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n            # returns a generator of the project assets\n            &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n            ```\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n        if format == \"pandas\" and as_generator:\n            raise ValueError(\n                'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n            )\n\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        if external_id_contains is not None:\n            warnings.warn(\n                \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        for arg_name, arg_value in zip(\n            (\n                \"consensus_mark_gt\",\n                \"consensus_mark_lt\",\n                \"honeypot_mark_gt\",\n                \"honeypot_mark_lt\",\n                \"label_consensus_mark_gt\",\n                \"label_consensus_mark_lt\",\n                \"label_created_at_gt\",\n                \"label_created_at_lt\",\n                \"label_honeypot_mark_gt\",\n                \"label_honeypot_mark_lt\",\n            ),\n            (\n                consensus_mark_gt,\n                consensus_mark_lt,\n                honeypot_mark_gt,\n                honeypot_mark_lt,\n                label_consensus_mark_gt,\n                label_consensus_mark_lt,\n                label_created_at_gt,\n                label_created_at_lt,\n                label_honeypot_mark_gt,\n                label_honeypot_mark_lt,\n            ),\n        ):\n            if arg_value:\n                warnings.warn(\n                    (\n                        f\"'{arg_name}' is deprecated, please use\"\n                        f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\"\n                    ),\n                    DeprecationWarning,\n                    stacklevel=1,\n                )\n\n        where = AssetWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n            consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n            external_id_strictly_in=external_id_strictly_in or external_id_contains,\n            external_id_in=external_id_in,\n            honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n            inference_mark_gte=inference_mark_gte,\n            inference_mark_lte=inference_mark_lte,\n            label_author_in=label_author_in,\n            label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n            label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n            label_created_at=label_created_at,\n            label_created_at_gte=label_created_at_gt or label_created_at_gte,\n            label_created_at_lte=label_created_at_lt or label_created_at_lte,\n            label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n            label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            label_reviewer_in=label_reviewer_in,\n            issue_status=issue_status,\n            issue_type=issue_type,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        post_call_function, fields = get_download_assets_function(\n            self, download_media, fields, project_id, local_media_dir\n        )\n\n        assets_gen = AssetQuery(self.graphql_client)(where, fields, options, post_call_function)\n\n        if label_output_format == \"parsed_label\":\n            project = get_project(self, project_id, [\"jsonInterface\", \"inputType\"])\n\n            def parse_labels_of_asset(asset: Dict) -&gt; Dict:\n                if \"labels.jsonResponse\" in fields:\n                    asset[\"labels\"] = parse_labels(\n                        asset[\"labels\"], project[\"jsonInterface\"], project[\"inputType\"]\n                    )\n                if \"latestLabel.jsonResponse\" in fields and asset[\"latestLabel\"] is not None:\n                    asset[\"latestLabel\"] = ParsedLabel(\n                        label=asset[\"latestLabel\"],\n                        json_interface=project[\"jsonInterface\"],\n                        input_type=project[\"inputType\"],\n                    )\n                return asset\n\n            assets_gen = (parse_labels_of_asset(asset) for asset in assets_gen)\n\n        if format == \"pandas\":\n            return pd.DataFrame(list(assets_gen))\n        if as_generator:\n            return assets_gen\n        return list(assets_gen)\n\n    @typechecked\n    def count_assets(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        external_id_contains: Optional[List[str]] = None,\n        metadata_where: Optional[dict] = None,\n        status_in: Optional[List[str]] = None,\n        consensus_mark_gt: Optional[float] = None,\n        consensus_mark_lt: Optional[float] = None,\n        honeypot_mark_gt: Optional[float] = None,\n        honeypot_mark_lt: Optional[float] = None,\n        label_type_in: Optional[List[str]] = None,\n        label_author_in: Optional[List[str]] = None,\n        label_consensus_mark_gt: Optional[float] = None,\n        label_consensus_mark_lt: Optional[float] = None,\n        label_created_at: Optional[str] = None,\n        label_created_at_gt: Optional[str] = None,\n        label_created_at_lt: Optional[str] = None,\n        label_honeypot_mark_gt: Optional[float] = None,\n        label_honeypot_mark_lt: Optional[float] = None,\n        skipped: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        label_category_search: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        consensus_mark_gte: Optional[float] = None,\n        consensus_mark_lte: Optional[float] = None,\n        inference_mark_gte: Optional[float] = None,\n        inference_mark_lte: Optional[float] = None,\n        label_reviewer_in: Optional[List[str]] = None,\n        label_consensus_mark_gte: Optional[float] = None,\n        label_consensus_mark_lte: Optional[float] = None,\n        label_created_at_gte: Optional[str] = None,\n        label_created_at_lte: Optional[str] = None,\n        label_honeypot_mark_gte: Optional[float] = None,\n        label_honeypot_mark_lte: Optional[float] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        external_id_strictly_in: Optional[List[str]] = None,\n        external_id_in: Optional[List[str]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n\"\"\"Count and return the number of assets with the given constraints.\n\n        Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n        Args:\n            project_id: Identifier of the project\n            asset_id: The unique id of the asset to retrieve.\n            asset_id_in: A list of the ids of the assets to retrieve.\n            external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n            metadata_where: Filters by the values of the metadata of the asset.\n            status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n            consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n            consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n            honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n            honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n            label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n            label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n            label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n            label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n            label_created_at: Returned assets should have a label whose creation date is equal to this date.\n            label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n            label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n            label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n            label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n            skipped: Returned assets should be skipped.\n            updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n            updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n            label_category_search: Returned assets should have a label that follows this category search query.\n            created_at_gte: Returned assets should have their import date greater or equal to this date.\n            created_at_lte: Returned assets should have their import date lower or equal to this date.\n            honeypot_mark_lte: Maximum amount of honeypot for the asset.\n            honeypot_mark_gte: Minimum amount of honeypot for the asset.\n            consensus_mark_lte: Maximum amount of consensus for the asset.\n            consensus_mark_gte: Minimum amount of consensus for the asset.\n            inference_mark_gte: Minimum amount of human/model IoU for the asset.\n            inference_mark_lte: Maximum amount of human/model IoU for the asset.\n            label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n            label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n            label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n            label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n            label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n            label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n            label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n            issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n            issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n            external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n            external_id_in: Returned assets should have external ids that partially match the ones in the list.\n                For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n            250\n            &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n            1\n\n        !!! example \"How to filter based on Metadata\"\n            - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\"\n            - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n                have key \"key1\" with value \"value1\" or value \"value2\n            - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n                have key \"key2\" with a value between 2 and 10.\n        \"\"\"\n        if label_category_search:\n            validate_category_search_query(label_category_search)\n\n        if external_id_contains is not None:\n            warnings.warn(\n                \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        for arg_name, arg_value in zip(\n            (\n                \"consensus_mark_gt\",\n                \"consensus_mark_lt\",\n                \"honeypot_mark_gt\",\n                \"honeypot_mark_lt\",\n                \"label_consensus_mark_gt\",\n                \"label_consensus_mark_lt\",\n                \"label_created_at_gt\",\n                \"label_created_at_lt\",\n                \"label_honeypot_mark_gt\",\n                \"label_honeypot_mark_lt\",\n            ),\n            (\n                consensus_mark_gt,\n                consensus_mark_lt,\n                honeypot_mark_gt,\n                honeypot_mark_lt,\n                label_consensus_mark_gt,\n                label_consensus_mark_lt,\n                label_created_at_gt,\n                label_created_at_lt,\n                label_honeypot_mark_gt,\n                label_honeypot_mark_lt,\n            ),\n        ):\n            if arg_value:\n                warnings.warn(\n                    (\n                        f\"'{arg_name}' is deprecated, please use\"\n                        f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\"\n                    ),\n                    DeprecationWarning,\n                    stacklevel=1,\n                )\n\n        where = AssetWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n            consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n            external_id_strictly_in=external_id_strictly_in or external_id_contains,\n            external_id_in=external_id_in,\n            honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n            inference_mark_gte=inference_mark_gte,\n            inference_mark_lte=inference_mark_lte,\n            label_author_in=label_author_in,\n            label_reviewer_in=label_reviewer_in,\n            label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n            label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n            label_created_at=label_created_at,\n            label_created_at_gte=label_created_at_gt or label_created_at_gte,\n            label_created_at_lte=label_created_at_lt or label_created_at_lte,\n            label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n            label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n            label_type_in=label_type_in,\n            metadata_where=metadata_where,\n            skipped=skipped,\n            status_in=status_in,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            label_category_search=label_category_search,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            issue_status=issue_status,\n            issue_type=issue_type,\n        )\n        return AssetQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.queries.asset.__init__.QueriesAsset.assets","title":"<code>assets(self, project_id, asset_id=None, skip=0, fields=['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'], asset_id_in=None, consensus_mark_gt=None, consensus_mark_lt=None, disable_tqdm=False, external_id_contains=None, first=None, format=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, label_type_in=None, metadata_where=None, skipped=None, status_in=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None, download_media=False, local_media_dir=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, consensus_mark_gte=None, consensus_mark_lte=None, inference_mark_gte=None, inference_mark_lte=None, label_reviewer_in=None, label_consensus_mark_gte=None, label_consensus_mark_lte=None, label_created_at_gte=None, label_created_at_lte=None, label_honeypot_mark_gte=None, label_honeypot_mark_lte=None, issue_type=None, issue_status=None, external_id_strictly_in=None, external_id_in=None, label_output_format='dict', *, as_generator=False)</code>","text":"<p>Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the IDs of the assets to retrieve.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of assets to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets.     See the documentation for all possible fields.</p> <code>['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of assets to return.</p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_gte</code> instead.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_lte</code> instead.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Deprecated. Use <code>external_id_strictly_in</code> instead.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_gte</code> instead.</p> <code>None</code> <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_lte</code> instead.</p> <code>None</code> <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_gte</code> instead.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_lte</code> instead.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_gte</code> instead.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_lte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_gte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_lte</code> instead.</p> <code>None</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>format</code> <code>Optional[str]</code> <p>If equal to 'pandas', returns a pandas DataFrame</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the assets is returned.</p> <code>False</code> <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code> <code>download_media</code> <code>bool</code> <p>Tell is the media have to be downloaded or not.</p> <code>False</code> <code>local_media_dir</code> <code>Optional[str]</code> <p>Directory where the media are downloaded if <code>download_media</code> is True.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have their import date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have their import date lower or equal to this date.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>consensus_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>inference_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of human/model IoU for the asset.</p> <code>None</code> <code>inference_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of human/model IoU for the asset.</p> <code>None</code> <code>label_reviewer_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose reviewer belongs to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater or equal to this number.</p> <code>None</code> <code>label_consensus_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower or equal to this number.</p> <code>None</code> <code>label_created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower or equal to this date.</p> <code>None</code> <code>label_created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater or equal to this date.</p> <code>None</code> <code>label_honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater or equal to this number.</p> <code>None</code> <code>label_honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower or equal to this number.</p> <code>None</code> <code>issue_type</code> <code>Optional[typing_extensions.Literal['QUESTION', 'ISSUE']]</code> <p>Returned assets should have issues of type <code>QUESTION</code> or <code>ISSUE</code>.</p> <code>None</code> <code>issue_status</code> <code>Optional[typing_extensions.Literal['OPEN', 'SOLVED']]</code> <p>Returned assets should have issues of status <code>OPEN</code> or <code>SOLVED</code>.</p> <code>None</code> <code>external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that match exactly the ones in the list.</p> <code>None</code> <code>external_id_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that partially match the ones in the list. For example, with <code>external_id_in=['abc']</code>, any asset with an external id containing <code>'abc'</code> will be returned.</p> <code>None</code> <code>label_output_format</code> <code>typing_extensions.Literal['dict', 'parsed_label']</code> <p>If <code>parsed_label</code>, the labels in the assets will be parsed. More information on parsed labels in the documentation.</p> <code>'dict'</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Union[Iterable[Dict], pandas.core.frame.DataFrame]</code> <p>An asset list, an asset generator or a pandas DataFrame that match a set of constraints.</p> <p>Examples:</p> <pre><code># returns the assets list of the project\n&gt;&gt;&gt; kili.assets(project_id)\n&gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n# returns a generator of the project assets\n&gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\nlabel_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\nlabel_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre> Source code in <code>kili/entrypoints/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"content\",\n        \"createdAt\",\n        \"externalId\",\n        \"id\",\n        \"isHoneypot\",\n        \"jsonMetadata\",\n        \"labels.author.id\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.id\",\n        \"labels.jsonResponse\",\n        \"skipped\",\n        \"status\",\n    ],\n    asset_id_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    disable_tqdm: bool = False,\n    external_id_contains: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    format: Optional[str] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    skipped: Optional[bool] = None,\n    status_in: Optional[List[str]] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n    download_media: bool = False,\n    local_media_dir: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    consensus_mark_gte: Optional[float] = None,\n    consensus_mark_lte: Optional[float] = None,\n    inference_mark_gte: Optional[float] = None,\n    inference_mark_lte: Optional[float] = None,\n    label_reviewer_in: Optional[List[str]] = None,\n    label_consensus_mark_gte: Optional[float] = None,\n    label_consensus_mark_lte: Optional[float] = None,\n    label_created_at_gte: Optional[str] = None,\n    label_created_at_lte: Optional[str] = None,\n    label_honeypot_mark_gte: Optional[float] = None,\n    label_honeypot_mark_lte: Optional[float] = None,\n    issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n    issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n    external_id_strictly_in: Optional[List[str]] = None,\n    external_id_in: Optional[List[str]] = None,\n    label_output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n    *,\n    as_generator: bool = False,\n) -&gt; Union[Iterable[Dict], pd.DataFrame]:\n    # pylint: disable=line-too-long\n\"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset to retrieve.\n        asset_id_in: A list of the IDs of the assets to retrieve.\n        skip: Number of assets to skip (they are ordered by their date of creation, first to last).\n        fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n        first: Maximum number of assets to return.\n        consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n        consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n        external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n        metadata_where: Filters by the values of the metadata of the asset.\n        honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n        honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n        status_in: Returned assets should have a status that belongs to that list, if given.\n            Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n        label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n        label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n        label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n        label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n        label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n        skipped: Returned assets should be skipped\n        updated_at_gte: Returned assets should have a label whose update date is greater or equal to this date.\n        updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n        format: If equal to 'pandas', returns a pandas DataFrame\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the assets is returned.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        download_media: Tell is the media have to be downloaded or not.\n        local_media_dir: Directory where the media are downloaded if `download_media` is True.\n        created_at_gte: Returned assets should have their import date greater or equal to this date.\n        created_at_lte: Returned assets should have their import date lower or equal to this date.\n        honeypot_mark_lte: Maximum amount of honeypot for the asset.\n        honeypot_mark_gte: Minimum amount of honeypot for the asset.\n        consensus_mark_lte: Maximum amount of consensus for the asset.\n        consensus_mark_gte: Minimum amount of consensus for the asset.\n        inference_mark_gte: Minimum amount of human/model IoU for the asset.\n        inference_mark_lte: Maximum amount of human/model IoU for the asset.\n        label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n        label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n        label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n        label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n        label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n        label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n        label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n        issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n        issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n        external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n        external_id_in: Returned assets should have external ids that partially match the ones in the list.\n            For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n        label_output_format: If `parsed_label`, the labels in the assets will be parsed. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        An asset list, an asset generator or a pandas DataFrame that match a set of constraints.\n\n    Example:\n        ```\n        # returns the assets list of the project\n        &gt;&gt;&gt; kili.assets(project_id)\n        &gt;&gt;&gt; kili.assets(project_id, asset_id=asset_id)\n        # returns a generator of the project assets\n        &gt;&gt;&gt; kili.assets(project_id, as_generator=True)\n        ```\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            label_category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n    if format == \"pandas\" and as_generator:\n        raise ValueError(\n            'Argument values as_generator==True and format==\"pandas\" are not compatible.'\n        )\n\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    if external_id_contains is not None:\n        warnings.warn(\n            \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    for arg_name, arg_value in zip(\n        (\n            \"consensus_mark_gt\",\n            \"consensus_mark_lt\",\n            \"honeypot_mark_gt\",\n            \"honeypot_mark_lt\",\n            \"label_consensus_mark_gt\",\n            \"label_consensus_mark_lt\",\n            \"label_created_at_gt\",\n            \"label_created_at_lt\",\n            \"label_honeypot_mark_gt\",\n            \"label_honeypot_mark_lt\",\n        ),\n        (\n            consensus_mark_gt,\n            consensus_mark_lt,\n            honeypot_mark_gt,\n            honeypot_mark_lt,\n            label_consensus_mark_gt,\n            label_consensus_mark_lt,\n            label_created_at_gt,\n            label_created_at_lt,\n            label_honeypot_mark_gt,\n            label_honeypot_mark_lt,\n        ),\n    ):\n        if arg_value:\n            warnings.warn(\n                (\n                    f\"'{arg_name}' is deprecated, please use\"\n                    f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n    where = AssetWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n        consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n        external_id_strictly_in=external_id_strictly_in or external_id_contains,\n        external_id_in=external_id_in,\n        honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n        inference_mark_gte=inference_mark_gte,\n        inference_mark_lte=inference_mark_lte,\n        label_author_in=label_author_in,\n        label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n        label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n        label_created_at=label_created_at,\n        label_created_at_gte=label_created_at_gt or label_created_at_gte,\n        label_created_at_lte=label_created_at_lt or label_created_at_lte,\n        label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n        label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        label_reviewer_in=label_reviewer_in,\n        issue_status=issue_status,\n        issue_type=issue_type,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    post_call_function, fields = get_download_assets_function(\n        self, download_media, fields, project_id, local_media_dir\n    )\n\n    assets_gen = AssetQuery(self.graphql_client)(where, fields, options, post_call_function)\n\n    if label_output_format == \"parsed_label\":\n        project = get_project(self, project_id, [\"jsonInterface\", \"inputType\"])\n\n        def parse_labels_of_asset(asset: Dict) -&gt; Dict:\n            if \"labels.jsonResponse\" in fields:\n                asset[\"labels\"] = parse_labels(\n                    asset[\"labels\"], project[\"jsonInterface\"], project[\"inputType\"]\n                )\n            if \"latestLabel.jsonResponse\" in fields and asset[\"latestLabel\"] is not None:\n                asset[\"latestLabel\"] = ParsedLabel(\n                    label=asset[\"latestLabel\"],\n                    json_interface=project[\"jsonInterface\"],\n                    input_type=project[\"inputType\"],\n                )\n            return asset\n\n        assets_gen = (parse_labels_of_asset(asset) for asset in assets_gen)\n\n    if format == \"pandas\":\n        return pd.DataFrame(list(assets_gen))\n    if as_generator:\n        return assets_gen\n    return list(assets_gen)\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.queries.asset.__init__.QueriesAsset.count_assets","title":"<code>count_assets(self, project_id, asset_id=None, asset_id_in=None, external_id_contains=None, metadata_where=None, status_in=None, consensus_mark_gt=None, consensus_mark_lt=None, honeypot_mark_gt=None, honeypot_mark_lt=None, label_type_in=None, label_author_in=None, label_consensus_mark_gt=None, label_consensus_mark_lt=None, label_created_at=None, label_created_at_gt=None, label_created_at_lt=None, label_honeypot_mark_gt=None, label_honeypot_mark_lt=None, skipped=None, updated_at_gte=None, updated_at_lte=None, label_category_search=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, consensus_mark_gte=None, consensus_mark_lte=None, inference_mark_gte=None, inference_mark_lte=None, label_reviewer_in=None, label_consensus_mark_gte=None, label_consensus_mark_lte=None, label_created_at_gte=None, label_created_at_lte=None, label_honeypot_mark_gte=None, label_honeypot_mark_lte=None, issue_type=None, issue_status=None, external_id_strictly_in=None, external_id_in=None)</code>","text":"<p>Count and return the number of assets with the given constraints.</p> <p>Parameters beginning with 'label_' apply to labels, others apply to assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>asset_id</code> <code>Optional[str]</code> <p>The unique id of the asset to retrieve.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>A list of the ids of the assets to retrieve.</p> <code>None</code> <code>external_id_contains</code> <code>Optional[List[str]]</code> <p>Deprecated. Use <code>external_id_strictly_in</code> instead.</p> <code>None</code> <code>metadata_where</code> <code>Optional[dict]</code> <p>Filters by the values of the metadata of the asset.</p> <code>None</code> <code>status_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a status that belongs to that list, if given. Possible choices: <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_gte</code> instead.</p> <code>None</code> <code>consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>consensus_mark_lte</code> instead.</p> <code>None</code> <code>honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_gte</code> instead.</p> <code>None</code> <code>honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>honeypot_mark_lte</code> instead.</p> <code>None</code> <code>label_type_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>label_author_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>label_consensus_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_gte</code> instead.</p> <code>None</code> <code>label_consensus_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_consensus_mark_lte</code> instead.</p> <code>None</code> <code>label_created_at</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is equal to this date.</p> <code>None</code> <code>label_created_at_gt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_gte</code> instead.</p> <code>None</code> <code>label_created_at_lt</code> <code>Optional[str]</code> <p>Deprecated. Use <code>label_created_at_lte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_gt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_gte</code> instead.</p> <code>None</code> <code>label_honeypot_mark_lt</code> <code>Optional[float]</code> <p>Deprecated. Use <code>label_honeypot_mark_lte</code> instead.</p> <code>None</code> <code>skipped</code> <code>Optional[bool]</code> <p>Returned assets should be skipped.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is greated or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>label_category_search</code> <code>Optional[str]</code> <p>Returned assets should have a label that follows this category search query.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have their import date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have their import date lower or equal to this date.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of honeypot for the asset.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of honeypot for the asset.</p> <code>None</code> <code>consensus_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of consensus for the asset.</p> <code>None</code> <code>consensus_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of consensus for the asset.</p> <code>None</code> <code>inference_mark_gte</code> <code>Optional[float]</code> <p>Minimum amount of human/model IoU for the asset.</p> <code>None</code> <code>inference_mark_lte</code> <code>Optional[float]</code> <p>Maximum amount of human/model IoU for the asset.</p> <code>None</code> <code>label_reviewer_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have a label whose reviewer belongs to that list, if given.</p> <code>None</code> <code>label_consensus_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is greater or equal to this number.</p> <code>None</code> <code>label_consensus_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose consensus is lower or equal to this number.</p> <code>None</code> <code>label_created_at_lte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is lower or equal to this date.</p> <code>None</code> <code>label_created_at_gte</code> <code>Optional[str]</code> <p>Returned assets should have a label whose creation date is greater or equal to this date.</p> <code>None</code> <code>label_honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is greater or equal to this number.</p> <code>None</code> <code>label_honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned assets should have a label whose honeypot is lower or equal to this number.</p> <code>None</code> <code>issue_type</code> <code>Optional[typing_extensions.Literal['QUESTION', 'ISSUE']]</code> <p>Returned assets should have issues of type <code>QUESTION</code> or <code>ISSUE</code>.</p> <code>None</code> <code>issue_status</code> <code>Optional[typing_extensions.Literal['OPEN', 'SOLVED']]</code> <p>Returned assets should have issues of status <code>OPEN</code> or <code>SOLVED</code>.</p> <code>None</code> <code>external_id_strictly_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that match exactly the ones in the list.</p> <code>None</code> <code>external_id_in</code> <code>Optional[List[str]]</code> <p>Returned assets should have external ids that partially match the ones in the list. For example, with <code>external_id_in=['abc']</code>, any asset with an external id containing <code>'abc'</code> will be returned.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.count_assets(project_id=project_id)\n250\n&gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n1\n</code></pre> <p>How to filter based on Metadata</p> <ul> <li><code>metadata_where = {key1: \"value1\"}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\"</li> <li><code>metadata_where = {key1: [\"value1\", \"value2\"]}</code> to filter on assets whose metadata     have key \"key1\" with value \"value1\" or value \"value2</li> <li><code>metadata_where = {key2: [2, 10]}</code> to filter on assets whose metadata     have key \"key2\" with a value between 2 and 10.</li> </ul> Source code in <code>kili/entrypoints/queries/asset/__init__.py</code> <pre><code>@typechecked\ndef count_assets(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    external_id_contains: Optional[List[str]] = None,\n    metadata_where: Optional[dict] = None,\n    status_in: Optional[List[str]] = None,\n    consensus_mark_gt: Optional[float] = None,\n    consensus_mark_lt: Optional[float] = None,\n    honeypot_mark_gt: Optional[float] = None,\n    honeypot_mark_lt: Optional[float] = None,\n    label_type_in: Optional[List[str]] = None,\n    label_author_in: Optional[List[str]] = None,\n    label_consensus_mark_gt: Optional[float] = None,\n    label_consensus_mark_lt: Optional[float] = None,\n    label_created_at: Optional[str] = None,\n    label_created_at_gt: Optional[str] = None,\n    label_created_at_lt: Optional[str] = None,\n    label_honeypot_mark_gt: Optional[float] = None,\n    label_honeypot_mark_lt: Optional[float] = None,\n    skipped: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    label_category_search: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    consensus_mark_gte: Optional[float] = None,\n    consensus_mark_lte: Optional[float] = None,\n    inference_mark_gte: Optional[float] = None,\n    inference_mark_lte: Optional[float] = None,\n    label_reviewer_in: Optional[List[str]] = None,\n    label_consensus_mark_gte: Optional[float] = None,\n    label_consensus_mark_lte: Optional[float] = None,\n    label_created_at_gte: Optional[str] = None,\n    label_created_at_lte: Optional[str] = None,\n    label_honeypot_mark_gte: Optional[float] = None,\n    label_honeypot_mark_lte: Optional[float] = None,\n    issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n    issue_status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n    external_id_strictly_in: Optional[List[str]] = None,\n    external_id_in: Optional[List[str]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n\"\"\"Count and return the number of assets with the given constraints.\n\n    Parameters beginning with 'label_' apply to labels, others apply to assets.\n\n    Args:\n        project_id: Identifier of the project\n        asset_id: The unique id of the asset to retrieve.\n        asset_id_in: A list of the ids of the assets to retrieve.\n        external_id_contains: Deprecated. Use `external_id_strictly_in` instead.\n        metadata_where: Filters by the values of the metadata of the asset.\n        status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED`.\n        consensus_mark_gt: Deprecated. Use `consensus_mark_gte` instead.\n        consensus_mark_lt: Deprecated. Use `consensus_mark_lte` instead.\n        honeypot_mark_gt: Deprecated. Use `honeypot_mark_gte` instead.\n        honeypot_mark_lt: Deprecated. Use `honeypot_mark_lte` instead.\n        label_type_in: Returned assets should have a label whose type belongs to that list, if given.\n        label_author_in: Returned assets should have a label whose author belongs to that list, if given. An author can be designated by the first name, the last name, or the first name + last name.\n        label_consensus_mark_gt: Deprecated. Use `label_consensus_mark_gte` instead.\n        label_consensus_mark_lt: Deprecated. Use `label_consensus_mark_lte` instead.\n        label_created_at: Returned assets should have a label whose creation date is equal to this date.\n        label_created_at_gt: Deprecated. Use `label_created_at_gte` instead.\n        label_created_at_lt: Deprecated. Use `label_created_at_lte` instead.\n        label_honeypot_mark_gt: Deprecated. Use `label_honeypot_mark_gte` instead.\n        label_honeypot_mark_lt: Deprecated. Use `label_honeypot_mark_lte` instead.\n        skipped: Returned assets should be skipped.\n        updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date.\n        updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date.\n        label_category_search: Returned assets should have a label that follows this category search query.\n        created_at_gte: Returned assets should have their import date greater or equal to this date.\n        created_at_lte: Returned assets should have their import date lower or equal to this date.\n        honeypot_mark_lte: Maximum amount of honeypot for the asset.\n        honeypot_mark_gte: Minimum amount of honeypot for the asset.\n        consensus_mark_lte: Maximum amount of consensus for the asset.\n        consensus_mark_gte: Minimum amount of consensus for the asset.\n        inference_mark_gte: Minimum amount of human/model IoU for the asset.\n        inference_mark_lte: Maximum amount of human/model IoU for the asset.\n        label_reviewer_in: Returned assets should have a label whose reviewer belongs to that list, if given.\n        label_consensus_mark_gte: Returned assets should have a label whose consensus is greater or equal to this number.\n        label_consensus_mark_lte: Returned assets should have a label whose consensus is lower or equal to this number.\n        label_created_at_lte: Returned assets should have a label whose creation date is lower or equal to this date.\n        label_created_at_gte: Returned assets should have a label whose creation date is greater or equal to this date.\n        label_honeypot_mark_gte: Returned assets should have a label whose honeypot is greater or equal to this number.\n        label_honeypot_mark_lte: Returned assets should have a label whose honeypot is lower or equal to this number.\n        issue_type: Returned assets should have issues of type `QUESTION` or `ISSUE`.\n        issue_status: Returned assets should have issues of status `OPEN` or `SOLVED`.\n        external_id_strictly_in: Returned assets should have external ids that match exactly the ones in the list.\n        external_id_in: Returned assets should have external ids that partially match the ones in the list.\n            For example, with `external_id_in=['abc']`, any asset with an external id containing `'abc'` will be returned.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.count_assets(project_id=project_id)\n        250\n        &gt;&gt;&gt; kili.count_assets(asset_id=asset_id)\n        1\n\n    !!! example \"How to filter based on Metadata\"\n        - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\"\n        - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata\n            have key \"key1\" with value \"value1\" or value \"value2\n        - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata\n            have key \"key2\" with a value between 2 and 10.\n    \"\"\"\n    if label_category_search:\n        validate_category_search_query(label_category_search)\n\n    if external_id_contains is not None:\n        warnings.warn(\n            \"external_id_contains is deprecated, use external_id_strictly_in instead\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    for arg_name, arg_value in zip(\n        (\n            \"consensus_mark_gt\",\n            \"consensus_mark_lt\",\n            \"honeypot_mark_gt\",\n            \"honeypot_mark_lt\",\n            \"label_consensus_mark_gt\",\n            \"label_consensus_mark_lt\",\n            \"label_created_at_gt\",\n            \"label_created_at_lt\",\n            \"label_honeypot_mark_gt\",\n            \"label_honeypot_mark_lt\",\n        ),\n        (\n            consensus_mark_gt,\n            consensus_mark_lt,\n            honeypot_mark_gt,\n            honeypot_mark_lt,\n            label_consensus_mark_gt,\n            label_consensus_mark_lt,\n            label_created_at_gt,\n            label_created_at_lt,\n            label_honeypot_mark_gt,\n            label_honeypot_mark_lt,\n        ),\n    ):\n        if arg_value:\n            warnings.warn(\n                (\n                    f\"'{arg_name}' is deprecated, please use\"\n                    f\" '{arg_name.replace('_gt', '_gte').replace('_lt', '_lte')}' instead.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n    where = AssetWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        consensus_mark_gte=consensus_mark_gt or consensus_mark_gte,\n        consensus_mark_lte=consensus_mark_lt or consensus_mark_lte,\n        external_id_strictly_in=external_id_strictly_in or external_id_contains,\n        external_id_in=external_id_in,\n        honeypot_mark_gte=honeypot_mark_gt or honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lt or honeypot_mark_lte,\n        inference_mark_gte=inference_mark_gte,\n        inference_mark_lte=inference_mark_lte,\n        label_author_in=label_author_in,\n        label_reviewer_in=label_reviewer_in,\n        label_consensus_mark_gte=label_consensus_mark_gt or label_consensus_mark_gte,\n        label_consensus_mark_lte=label_consensus_mark_lt or label_consensus_mark_lte,\n        label_created_at=label_created_at,\n        label_created_at_gte=label_created_at_gt or label_created_at_gte,\n        label_created_at_lte=label_created_at_lt or label_created_at_lte,\n        label_honeypot_mark_gte=label_honeypot_mark_gt or label_honeypot_mark_gte,\n        label_honeypot_mark_lte=label_honeypot_mark_lt or label_honeypot_mark_lte,\n        label_type_in=label_type_in,\n        metadata_where=metadata_where,\n        skipped=skipped,\n        status_in=status_in,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        label_category_search=label_category_search,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        issue_status=issue_status,\n        issue_type=issue_type,\n    )\n    return AssetQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/asset/#mutations","title":"Mutations","text":"<p>Set of Asset mutations.</p> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>class MutationsAsset:\n\"\"\"Set of Asset mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,too-many-locals\n    @typechecked\n    def append_many_to_dataset(\n        self,\n        project_id: str,\n        content_array: Optional[List[str]] = None,\n        external_id_array: Optional[List[str]] = None,\n        id_array: Optional[List[str]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        status_array: Optional[List[str]] = None,\n        json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n        json_metadata_array: Optional[List[dict]] = None,\n        disable_tqdm: bool = False,\n        wait_until_availability: bool = True,\n    ) -&gt; Optional[Dict[str, str]]:\n        # pylint: disable=line-too-long\n\"\"\"Append assets to a project.\n\n        Args:\n            project_id: Identifier of the project\n            content_array: List of elements added to the assets of the project\n                Must not be None except if you provide json_content_array.\n\n                - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n                - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                    images/pdf on your computer.\n                - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n                existing video files on your computer. If you want to import video from frames, look at the json_content\n                section below.\n                - For an `VIDEO_LEGACY` project, the content can be only be URLs\n            external_id_array: List of external ids given to identify the assets.\n                If None, random identifiers are created.\n            id_array: Disabled parameter. Do not use.\n            is_honeypot_array:  Whether to use the asset for honeypot\n            status_array: By default, all imported assets are set to `TODO`. Other options:\n                `ONGOING`, `LABELED`, `REVIEWED`.\n            json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n                - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                    list of URLs to images or a list of paths to images.\n                - For `TEXT` projects, each element is a json_content dict,\n                    formatted according to documentation [on how to import\n                rich-text assets](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n            json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n                - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                    Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n                - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                    Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n                If `False`, the function will return faster but the assets might not be fully processed by the server.\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_many_to_dataset(\n                    project_id=project_id,\n                    content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n        !!! example \"Recipe\"\n            - For more detailed examples on how to import assets,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n            - For more detailed examples on how to import text assets,\n                see [the recipe](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"append_many_to_dataset\", \"content_array\", content_array\n        ) or is_empty_list_with_warning(\n            \"append_many_to_dataset\", \"json_content_array\", json_content_array\n        ):\n            return None\n\n        if status_array is not None:\n            warnings.warn(\n                (\n                    \"status_array is deprecated, asset status is automatically computed based on\"\n                    \" its labels and cannot be overwritten.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        if content_array is None and json_content_array is None:\n            raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n\n        nb_data = (\n            len(content_array)\n            if content_array is not None\n            else len(json_content_array)  # type:ignore\n        )\n\n        field_mapping = {\n            \"content\": content_array,\n            \"json_content\": json_content_array,\n            \"external_id\": external_id_array,\n            \"id\": id_array,\n            \"status\": status_array,\n            \"json_metadata\": json_metadata_array,\n            \"is_honeypot\": is_honeypot_array,\n        }\n        assets = [{}] * nb_data\n        for key, value in field_mapping.items():\n            if value is not None:\n                assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n        result = import_assets(\n            self,\n            project_id=project_id,\n            assets=assets,\n            disable_tqdm=disable_tqdm,\n            verify=wait_until_availability,\n        )\n        return result\n\n    @typechecked\n    # pylint: disable=unused-argument\n    def update_properties_in_assets(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        priorities: Optional[List[int]] = None,\n        json_metadatas: Optional[List[Union[dict, str]]] = None,\n        consensus_marks: Optional[List[float]] = None,\n        honeypot_marks: Optional[List[float]] = None,\n        to_be_labeled_by_array: Optional[List[List[str]]] = None,\n        contents: Optional[List[str]] = None,\n        json_contents: Optional[List[str]] = None,\n        status_array: Optional[List[str]] = None,\n        is_used_for_consensus_array: Optional[List[bool]] = None,\n        is_honeypot_array: Optional[List[bool]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n\"\"\"Update the properties of one or more assets.\n\n        Args:\n            asset_ids: The internal asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            priorities: You can change the priority of the assets.\n                By default, all assets have a priority of 0.\n            json_metadatas: The metadata given to an asset should be stored\n                in a json like dict with keys `imageUrl`, `text`, `url`:\n                `json_metadata = {'imageUrl': '','text': '','url': ''}`\n            consensus_marks: Should be between 0 and 1.\n            honeypot_marks: Should be between 0 and 1.\n            to_be_labeled_by_array: If given, each element of the list should contain the emails of\n                the labelers authorized to label the asset.\n            contents: - For a NLP project, the content can be directly in text format.\n                - For an Image / Video / Pdf project, the content must be hosted on a web server,\n                and you point Kili to your data by giving the URLs.\n            json_contents: - For a NLP project, the `json_content`\n                is a text formatted using RichText.\n                - For a Video project, the`json_content` is a json containg urls pointing\n                    to each frame of the video.\n            status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n                `TO_REVIEW`, `REVIEWED`.\n            is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n            is_honeypot_array: Whether to use the asset for honeypot.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_assets(\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                    consensus_marks=[1, 0.7],\n                    contents=[None, 'https://to/second/asset.png'],\n                    honeypot_marks=[0.8, 0.5],\n                    is_honeypot_array=[True, True],\n                    is_used_for_consensus_array=[True, False],\n                    priorities=[None, 2],\n                    status_array=['LABELED', 'REVIEWED'],\n                    to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"update_properties_in_assets\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\n            \"update_properties_in_assets\", \"external_ids\", external_ids\n        ):\n            return []\n\n        if status_array is not None:\n            warnings.warn(\n                (\n                    \"status_array is deprecated, asset status is automatically computed based on\"\n                    \" its labels and cannot be overwritten.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n\n        if asset_ids is not None and external_ids is not None:\n            warnings.warn(\n                (\n                    \"The use of `external_ids` argument has changed. It is now used to identify\"\n                    \" which properties of which assets to update. Please use\"\n                    \" `kili.change_asset_external_ids()` method instead to change asset external\"\n                    \" IDs.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        saved_args = locals()\n        parameters = {\n            k: v\n            for (k, v) in saved_args.items()\n            if k\n            in [\n                \"asset_ids\",\n                \"priorities\",\n                \"json_metadatas\",\n                \"consensus_marks\",\n                \"honeypot_marks\",\n                \"to_be_labeled_by_array\",\n                \"contents\",\n                \"json_contents\",\n                \"status_array\",\n                \"is_used_for_consensus_array\",\n                \"is_honeypot_array\",\n            ]\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"priority\": batch[\"priorities\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"consensusMark\": batch[\"consensus_marks\"],\n                \"honeypotMark\": batch[\"honeypot_marks\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n                \"content\": batch[\"contents\"],\n                \"jsonContent\": batch[\"json_contents\"],\n                \"status\": batch[\"status_array\"],\n                \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n                \"isHoneypot\": batch[\"is_honeypot_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]  # type: ignore\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def change_asset_external_ids(\n        self,\n        new_external_ids: List[str],\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; List[Dict]:\n\"\"\"Update the external IDs of one or more assets.\n\n        Args:\n            new_external_ids: The new external IDs of the assets.\n            asset_ids: The asset IDs to modify.\n            external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.change_asset_external_ids(\n                    new_external_ids=[\"asset1\", \"asset2\"],\n                    asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"change_asset_external_ids\", \"new_external_ids\", new_external_ids\n        ):\n            return []\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        parameters = {\n            \"asset_ids\": asset_ids,\n            \"new_external_ids\": new_external_ids,\n            \"json_metadatas\": None,\n            \"to_be_labeled_by_array\": None,\n        }\n        properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n        def generate_variables(batch: Dict) -&gt; Dict:\n            data = {\n                \"externalId\": batch[\"new_external_ids\"],\n                \"jsonMetadata\": batch[\"json_metadatas\"],\n                \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n                \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            }\n            data_array = [dict(zip(data, t)) for t in zip(*data.values())]  # type: ignore\n            return {\n                \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n                \"dataArray\": data_array,\n            }\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_UPDATE_PROPERTIES_IN_ASSETS,\n        )\n        formated_results = [format_result(\"data\", result, Asset) for result in results]\n        return [item for batch_list in formated_results for item in batch_list]\n\n    @typechecked\n    def delete_many_from_dataset(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Asset:\n\"\"\"Delete assets from a project.\n\n        Args:\n            asset_ids: The list of asset internal IDs to delete.\n            external_ids: The list of asset external IDs to delete.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"delete_many_from_dataset\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"delete_many_from_dataset\", \"external_ids\", external_ids):\n            return Asset()\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_kili = AssetQuery(self.graphql_client).count(\n                AssetWhere(\n                    project_id=results[0][\"data\"][\"id\"],\n                    asset_id_in=asset_ids,\n                )\n            )\n            if nb_assets_in_kili &gt; 0:\n                raise MutationError(\"Failed to delete some assets.\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_DELETE_MANY_FROM_DATASET,\n            last_batch_callback=verify_last_batch,\n        )\n        return format_result(\"data\", results[0], Asset)\n\n    @typechecked\n    def add_to_review(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Add assets to review.\n\n        !!! warning\n            Assets without any label will be ignored.\n\n        Args:\n            asset_ids: The asset internal IDs to add to review.\n            external_ids: The asset external IDs to add to review.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to review.\n            `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.add_to_review(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"add_to_review\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"add_to_review\", \"external_ids\", external_ids):\n            return None\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n            try:\n                project_id = results[0][\"data\"][\"id\"]\n            except TypeError:\n                return  # No assets have changed status\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_review = AssetQuery(self.graphql_client).count(\n                AssetWhere(\n                    project_id=project_id,\n                    asset_id_in=asset_ids,\n                    status_in=[\"TO_REVIEW\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_review:\n                raise MutationError(\"Failed to send some assets to review\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n            last_batch_callback=verify_last_batch,\n        )\n        result = format_result(\"data\", results[0])\n        # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n        # it happens when no assets have been sent to review\n        if isinstance(result, dict) and \"id\" in result:\n            assets_in_review = AssetQuery(self.graphql_client)(\n                AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"TO_REVIEW\"]),\n                [\"id\"],\n                QueryOptions(disable_tqdm=True),\n            )\n            result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n            return result\n        return result\n\n    @typechecked\n    def send_back_to_queue(\n        self,\n        asset_ids: Optional[List[str]] = None,\n        external_ids: Optional[List[str]] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Send assets back to queue.\n\n        Args:\n            asset_ids: List of internal IDs of assets to send back to queue.\n            external_ids: List of external IDs of assets to send back to queue.\n            project_id: The project ID. Only required if `external_ids` argument is provided.\n\n        Returns:\n            A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n            An error message if mutation failed.\n\n        Examples:\n            &gt;&gt;&gt; kili.send_back_to_queue(\n                    asset_ids=[\n                        \"ckg22d81r0jrg0885unmuswj8\",\n                        \"ckg22d81s0jrh0885pdxfd03n\",\n                        ],\n                )\n        \"\"\"\n        if is_empty_list_with_warning(\n            \"send_back_to_queue\", \"asset_ids\", asset_ids\n        ) or is_empty_list_with_warning(\"send_back_to_queue\", \"external_ids\", external_ids):\n            return None\n\n        asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n        properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n        def generate_variables(batch):\n            return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n        @retry(\n            wait=wait_exponential(multiplier=1, min=1, max=8),\n            retry=retry_if_exception_type(MutationError),\n            reraise=True,\n        )\n        def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n            asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n            nb_assets_in_queue = AssetQuery(self.graphql_client).count(\n                AssetWhere(\n                    project_id=results[0][\"data\"][\"id\"],\n                    asset_id_in=asset_ids,\n                    status_in=[\"ONGOING\"],\n                )\n            )\n            if len(asset_ids) != nb_assets_in_queue:\n                raise MutationError(\"Failed to send some assets back to queue\")\n\n        results = _mutate_from_paginated_call(\n            self,\n            properties_to_batch,\n            generate_variables,\n            GQL_SEND_BACK_ASSETS_TO_QUEUE,\n            last_batch_callback=verify_last_batch,\n        )\n        result = format_result(\"data\", results[0])\n        assets_in_queue = AssetQuery(self.graphql_client)(\n            AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"ONGOING\"]),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n        return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.add_to_review","title":"<code>add_to_review(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Add assets to review.</p> <p>Warning</p> <p>Assets without any label will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset internal IDs to add to review.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The asset external IDs to add to review.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to review. <code>None</code> if no assets have changed status (already had <code>TO_REVIEW</code> status for example). An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.add_to_review(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n        ],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef add_to_review(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Add assets to review.\n\n    !!! warning\n        Assets without any label will be ignored.\n\n    Args:\n        asset_ids: The asset internal IDs to add to review.\n        external_ids: The asset external IDs to add to review.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to review.\n        `None` if no assets have changed status (already had `TO_REVIEW` status for example).\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.add_to_review(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                ],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"add_to_review\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"add_to_review\", \"external_ids\", external_ids):\n        return None\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent to review.\"\"\"\n        try:\n            project_id = results[0][\"data\"][\"id\"]\n        except TypeError:\n            return  # No assets have changed status\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_review = AssetQuery(self.graphql_client).count(\n            AssetWhere(\n                project_id=project_id,\n                asset_id_in=asset_ids,\n                status_in=[\"TO_REVIEW\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_review:\n            raise MutationError(\"Failed to send some assets to review\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW,\n        last_batch_callback=verify_last_batch,\n    )\n    result = format_result(\"data\", results[0])\n    # unlike send_back_to_queue, the add_to_review mutation doesn't always return the project ID\n    # it happens when no assets have been sent to review\n    if isinstance(result, dict) and \"id\" in result:\n        assets_in_review = AssetQuery(self.graphql_client)(\n            AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"TO_REVIEW\"]),\n            [\"id\"],\n            QueryOptions(disable_tqdm=True),\n        )\n        result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_review]\n        return result\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","title":"<code>append_many_to_dataset(self, project_id, content_array=None, external_id_array=None, id_array=None, is_honeypot_array=None, status_array=None, json_content_array=None, json_metadata_array=None, disable_tqdm=False, wait_until_availability=True)</code>","text":"<p>Append assets to a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>content_array</code> <code>Optional[List[str]]</code> <p>List of elements added to the assets of the project Must not be None except if you provide json_content_array.</p> <ul> <li>For a <code>TEXT</code> project, the content can be either raw text, or URLs to TEXT assets.</li> <li>For an <code>IMAGE</code> / <code>PDF</code> project, the content can be either URLs or paths to existing     images/pdf on your computer.</li> <li>For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below.</li> <li>For an <code>VIDEO_LEGACY</code> project, the content can be only be URLs</li> </ul> <code>None</code> <code>external_id_array</code> <code>Optional[List[str]]</code> <p>List of external ids given to identify the assets. If None, random identifiers are created.</p> <code>None</code> <code>id_array</code> <code>Optional[List[str]]</code> <p>Disabled parameter. Do not use.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot</p> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>By default, all imported assets are set to <code>TODO</code>. Other options: <code>ONGOING</code>, <code>LABELED</code>, <code>REVIEWED</code>.</p> <code>None</code> <code>json_content_array</code> <code>Optional[List[List[Union[dict, str]]]]</code> <p>Useful for <code>VIDEO</code> or <code>TEXT</code> projects only.</p> <ul> <li>For <code>VIDEO</code> projects, each element is a sequence of frames, i.e. a     list of URLs to images or a list of paths to images.</li> <li>For <code>TEXT</code> projects, each element is a json_content dict,     formatted according to documentation on how to import rich-text assets.</li> </ul> <code>None</code> <code>json_metadata_array</code> <code>Optional[List[dict]]</code> <p>The metadata given to each asset should be stored in a json like dict with keys.</p> <ul> <li>Add metadata visible on the asset with the following keys: <code>imageUrl</code>, <code>text</code>, <code>url</code>.     Example for one asset: <code>json_metadata_array = [{'imageUrl': '','text': '','url': ''}]</code>.</li> <li>For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).     Example for one asset: <code>json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]</code>.</li> </ul> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>wait_until_availability</code> <code>bool</code> <p>If <code>True</code>, the function will return once the assets are fully imported in Kili. If <code>False</code>, the function will return faster but the assets might not be fully processed by the server.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, str]]</code> <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_many_to_dataset(\n        project_id=project_id,\n        content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n</code></pre> <p>Recipe</p> <ul> <li>For more detailed examples on how to import assets,     see the recipe.</li> <li>For more detailed examples on how to import text assets,     see the recipe.</li> </ul> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef append_many_to_dataset(\n    self,\n    project_id: str,\n    content_array: Optional[List[str]] = None,\n    external_id_array: Optional[List[str]] = None,\n    id_array: Optional[List[str]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    status_array: Optional[List[str]] = None,\n    json_content_array: Optional[List[List[Union[dict, str]]]] = None,\n    json_metadata_array: Optional[List[dict]] = None,\n    disable_tqdm: bool = False,\n    wait_until_availability: bool = True,\n) -&gt; Optional[Dict[str, str]]:\n    # pylint: disable=line-too-long\n\"\"\"Append assets to a project.\n\n    Args:\n        project_id: Identifier of the project\n        content_array: List of elements added to the assets of the project\n            Must not be None except if you provide json_content_array.\n\n            - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets.\n            - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing\n                images/pdf on your computer.\n            - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to\n            existing video files on your computer. If you want to import video from frames, look at the json_content\n            section below.\n            - For an `VIDEO_LEGACY` project, the content can be only be URLs\n        external_id_array: List of external ids given to identify the assets.\n            If None, random identifiers are created.\n        id_array: Disabled parameter. Do not use.\n        is_honeypot_array:  Whether to use the asset for honeypot\n        status_array: By default, all imported assets are set to `TODO`. Other options:\n            `ONGOING`, `LABELED`, `REVIEWED`.\n        json_content_array: Useful for `VIDEO` or `TEXT` projects only.\n\n            - For `VIDEO` projects, each element is a sequence of frames, i.e. a\n                list of URLs to images or a list of paths to images.\n            - For `TEXT` projects, each element is a json_content dict,\n                formatted according to documentation [on how to import\n            rich-text assets](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n        json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys.\n\n            - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`.\n                Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`.\n            - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30).\n                Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        wait_until_availability: If `True`, the function will return once the assets are fully imported in Kili.\n            If `False`, the function will return faster but the assets might not be fully processed by the server.\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_many_to_dataset(\n                project_id=project_id,\n                content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png'])\n\n    !!! example \"Recipe\"\n        - For more detailed examples on how to import assets,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-data).\n        - For more detailed examples on how to import text assets,\n            see [the recipe](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/import_text_assets/).\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"append_many_to_dataset\", \"content_array\", content_array\n    ) or is_empty_list_with_warning(\n        \"append_many_to_dataset\", \"json_content_array\", json_content_array\n    ):\n        return None\n\n    if status_array is not None:\n        warnings.warn(\n            (\n                \"status_array is deprecated, asset status is automatically computed based on\"\n                \" its labels and cannot be overwritten.\"\n            ),\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    if content_array is None and json_content_array is None:\n        raise ValueError(\"Variables content_array and json_content_array cannot be both None.\")\n\n    nb_data = (\n        len(content_array)\n        if content_array is not None\n        else len(json_content_array)  # type:ignore\n    )\n\n    field_mapping = {\n        \"content\": content_array,\n        \"json_content\": json_content_array,\n        \"external_id\": external_id_array,\n        \"id\": id_array,\n        \"status\": status_array,\n        \"json_metadata\": json_metadata_array,\n        \"is_honeypot\": is_honeypot_array,\n    }\n    assets = [{}] * nb_data\n    for key, value in field_mapping.items():\n        if value is not None:\n            assets = [{**assets[i], key: value[i]} for i in range(nb_data)]\n    result = import_assets(\n        self,\n        project_id=project_id,\n        assets=assets,\n        disable_tqdm=disable_tqdm,\n        verify=wait_until_availability,\n    )\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.change_asset_external_ids","title":"<code>change_asset_external_ids(self, new_external_ids, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Update the external IDs of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>new_external_ids</code> <code>List[str]</code> <p>The new external IDs of the assets.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.change_asset_external_ids(\n        new_external_ids=[\"asset1\", \"asset2\"],\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef change_asset_external_ids(\n    self,\n    new_external_ids: List[str],\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n\"\"\"Update the external IDs of one or more assets.\n\n    Args:\n        new_external_ids: The new external IDs of the assets.\n        asset_ids: The asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.change_asset_external_ids(\n                new_external_ids=[\"asset1\", \"asset2\"],\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"change_asset_external_ids\", \"new_external_ids\", new_external_ids\n    ):\n        return []\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    parameters = {\n        \"asset_ids\": asset_ids,\n        \"new_external_ids\": new_external_ids,\n        \"json_metadatas\": None,\n        \"to_be_labeled_by_array\": None,\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"externalId\": batch[\"new_external_ids\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]  # type: ignore\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","title":"<code>delete_many_from_dataset(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Delete assets from a project.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The list of asset internal IDs to delete.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The list of asset external IDs to delete.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Asset</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef delete_many_from_dataset(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Asset:\n\"\"\"Delete assets from a project.\n\n    Args:\n        asset_ids: The list of asset internal IDs to delete.\n        external_ids: The list of asset external IDs to delete.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"delete_many_from_dataset\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"delete_many_from_dataset\", \"external_ids\", external_ids):\n        return Asset()\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been deleted.\"\"\"\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_kili = AssetQuery(self.graphql_client).count(\n            AssetWhere(\n                project_id=results[0][\"data\"][\"id\"],\n                asset_id_in=asset_ids,\n            )\n        )\n        if nb_assets_in_kili &gt; 0:\n            raise MutationError(\"Failed to delete some assets.\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_DELETE_MANY_FROM_DATASET,\n        last_batch_callback=verify_last_batch,\n    )\n    return format_result(\"data\", results[0], Asset)\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.send_back_to_queue","title":"<code>send_back_to_queue(self, asset_ids=None, external_ids=None, project_id=None)</code>","text":"<p>Send assets back to queue.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>List of internal IDs of assets to send back to queue.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>List of external IDs of assets to send back to queue.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>A dict object with the project <code>id</code> and the <code>asset_ids</code> of assets moved to queue. An error message if mutation failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.send_back_to_queue(\n        asset_ids=[\n            \"ckg22d81r0jrg0885unmuswj8\",\n            \"ckg22d81s0jrh0885pdxfd03n\",\n            ],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\ndef send_back_to_queue(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    project_id: Optional[str] = None,\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Send assets back to queue.\n\n    Args:\n        asset_ids: List of internal IDs of assets to send back to queue.\n        external_ids: List of external IDs of assets to send back to queue.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A dict object with the project `id` and the `asset_ids` of assets moved to queue.\n        An error message if mutation failed.\n\n    Examples:\n        &gt;&gt;&gt; kili.send_back_to_queue(\n                asset_ids=[\n                    \"ckg22d81r0jrg0885unmuswj8\",\n                    \"ckg22d81s0jrh0885pdxfd03n\",\n                    ],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"send_back_to_queue\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\"send_back_to_queue\", \"external_ids\", external_ids):\n        return None\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    properties_to_batch: Dict[str, Optional[List[Any]]] = {\"asset_ids\": asset_ids}\n\n    def generate_variables(batch):\n        return {\"where\": {\"idIn\": batch[\"asset_ids\"]}}\n\n    @retry(\n        wait=wait_exponential(multiplier=1, min=1, max=8),\n        retry=retry_if_exception_type(MutationError),\n        reraise=True,\n    )\n    def verify_last_batch(last_batch: Dict, results: List):\n\"\"\"Check that all assets in the last batch have been sent back to queue.\"\"\"\n        asset_ids = last_batch[\"asset_ids\"][-1:]  # check last asset of the batch only\n        nb_assets_in_queue = AssetQuery(self.graphql_client).count(\n            AssetWhere(\n                project_id=results[0][\"data\"][\"id\"],\n                asset_id_in=asset_ids,\n                status_in=[\"ONGOING\"],\n            )\n        )\n        if len(asset_ids) != nb_assets_in_queue:\n            raise MutationError(\"Failed to send some assets back to queue\")\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_SEND_BACK_ASSETS_TO_QUEUE,\n        last_batch_callback=verify_last_batch,\n    )\n    result = format_result(\"data\", results[0])\n    assets_in_queue = AssetQuery(self.graphql_client)(\n        AssetWhere(project_id=result[\"id\"], asset_id_in=asset_ids, status_in=[\"ONGOING\"]),\n        [\"id\"],\n        QueryOptions(disable_tqdm=True),\n    )\n    result[\"asset_ids\"] = [asset[\"id\"] for asset in assets_in_queue]\n    return result\n</code></pre>"},{"location":"sdk/asset/#kili.entrypoints.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","title":"<code>update_properties_in_assets(self, asset_ids=None, external_ids=None, priorities=None, json_metadatas=None, consensus_marks=None, honeypot_marks=None, to_be_labeled_by_array=None, contents=None, json_contents=None, status_array=None, is_used_for_consensus_array=None, is_honeypot_array=None, project_id=None)</code>","text":"<p>Update the properties of one or more assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_ids</code> <code>Optional[List[str]]</code> <p>The internal asset IDs to modify.</p> <code>None</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>The external asset IDs to modify (if <code>asset_ids</code> is not already provided).</p> <code>None</code> <code>priorities</code> <code>Optional[List[int]]</code> <p>You can change the priority of the assets. By default, all assets have a priority of 0.</p> <code>None</code> <code>json_metadatas</code> <code>Optional[List[Union[dict, str]]]</code> <p>The metadata given to an asset should be stored in a json like dict with keys <code>imageUrl</code>, <code>text</code>, <code>url</code>: <code>json_metadata = {'imageUrl': '','text': '','url': ''}</code></p> <code>None</code> <code>consensus_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>honeypot_marks</code> <code>Optional[List[float]]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>to_be_labeled_by_array</code> <code>Optional[List[List[str]]]</code> <p>If given, each element of the list should contain the emails of the labelers authorized to label the asset.</p> <code>None</code> <code>contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the content can be directly in text format.</li> <li>For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs.</li> </ul> <code>None</code> <code>json_contents</code> <code>Optional[List[str]]</code> <ul> <li>For a NLP project, the <code>json_content</code> is a text formatted using RichText.</li> <li>For a Video project, the<code>json_content</code> is a json containg urls pointing     to each frame of the video.</li> </ul> <code>None</code> <code>status_array</code> <code>Optional[List[str]]</code> <p>Each element should be in <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO_REVIEW</code>, <code>REVIEWED</code>.</p> <code>None</code> <code>is_used_for_consensus_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset to compute consensus kpis or not.</p> <code>None</code> <code>is_honeypot_array</code> <code>Optional[List[bool]]</code> <p>Whether to use the asset for honeypot.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>The project ID. Only required if <code>external_ids</code> argument is provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_assets(\n        asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n        consensus_marks=[1, 0.7],\n        contents=[None, 'https://to/second/asset.png'],\n        honeypot_marks=[0.8, 0.5],\n        is_honeypot_array=[True, True],\n        is_used_for_consensus_array=[True, False],\n        priorities=[None, 2],\n        status_array=['LABELED', 'REVIEWED'],\n        to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/asset/__init__.py</code> <pre><code>@typechecked\n# pylint: disable=unused-argument\ndef update_properties_in_assets(\n    self,\n    asset_ids: Optional[List[str]] = None,\n    external_ids: Optional[List[str]] = None,\n    priorities: Optional[List[int]] = None,\n    json_metadatas: Optional[List[Union[dict, str]]] = None,\n    consensus_marks: Optional[List[float]] = None,\n    honeypot_marks: Optional[List[float]] = None,\n    to_be_labeled_by_array: Optional[List[List[str]]] = None,\n    contents: Optional[List[str]] = None,\n    json_contents: Optional[List[str]] = None,\n    status_array: Optional[List[str]] = None,\n    is_used_for_consensus_array: Optional[List[bool]] = None,\n    is_honeypot_array: Optional[List[bool]] = None,\n    project_id: Optional[str] = None,\n) -&gt; List[Dict]:\n\"\"\"Update the properties of one or more assets.\n\n    Args:\n        asset_ids: The internal asset IDs to modify.\n        external_ids: The external asset IDs to modify (if `asset_ids` is not already provided).\n        priorities: You can change the priority of the assets.\n            By default, all assets have a priority of 0.\n        json_metadatas: The metadata given to an asset should be stored\n            in a json like dict with keys `imageUrl`, `text`, `url`:\n            `json_metadata = {'imageUrl': '','text': '','url': ''}`\n        consensus_marks: Should be between 0 and 1.\n        honeypot_marks: Should be between 0 and 1.\n        to_be_labeled_by_array: If given, each element of the list should contain the emails of\n            the labelers authorized to label the asset.\n        contents: - For a NLP project, the content can be directly in text format.\n            - For an Image / Video / Pdf project, the content must be hosted on a web server,\n            and you point Kili to your data by giving the URLs.\n        json_contents: - For a NLP project, the `json_content`\n            is a text formatted using RichText.\n            - For a Video project, the`json_content` is a json containg urls pointing\n                to each frame of the video.\n        status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`,\n            `TO_REVIEW`, `REVIEWED`.\n        is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not.\n        is_honeypot_array: Whether to use the asset for honeypot.\n        project_id: The project ID. Only required if `external_ids` argument is provided.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_assets(\n                asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"],\n                consensus_marks=[1, 0.7],\n                contents=[None, 'https://to/second/asset.png'],\n                honeypot_marks=[0.8, 0.5],\n                is_honeypot_array=[True, True],\n                is_used_for_consensus_array=[True, False],\n                priorities=[None, 2],\n                status_array=['LABELED', 'REVIEWED'],\n                to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None],\n            )\n    \"\"\"\n    if is_empty_list_with_warning(\n        \"update_properties_in_assets\", \"asset_ids\", asset_ids\n    ) or is_empty_list_with_warning(\n        \"update_properties_in_assets\", \"external_ids\", external_ids\n    ):\n        return []\n\n    if status_array is not None:\n        warnings.warn(\n            (\n                \"status_array is deprecated, asset status is automatically computed based on\"\n                \" its labels and cannot be overwritten.\"\n            ),\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n    if asset_ids is not None and external_ids is not None:\n        warnings.warn(\n            (\n                \"The use of `external_ids` argument has changed. It is now used to identify\"\n                \" which properties of which assets to update. Please use\"\n                \" `kili.change_asset_external_ids()` method instead to change asset external\"\n                \" IDs.\"\n            ),\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        raise MissingArgumentError(\"Please provide either `asset_ids` or `external_ids`.\")\n\n    asset_ids = get_asset_ids_or_throw_error(self, asset_ids, external_ids, project_id)\n\n    saved_args = locals()\n    parameters = {\n        k: v\n        for (k, v) in saved_args.items()\n        if k\n        in [\n            \"asset_ids\",\n            \"priorities\",\n            \"json_metadatas\",\n            \"consensus_marks\",\n            \"honeypot_marks\",\n            \"to_be_labeled_by_array\",\n            \"contents\",\n            \"json_contents\",\n            \"status_array\",\n            \"is_used_for_consensus_array\",\n            \"is_honeypot_array\",\n        ]\n    }\n    properties_to_batch = process_update_properties_in_assets_parameters(parameters)\n\n    def generate_variables(batch: Dict) -&gt; Dict:\n        data = {\n            \"priority\": batch[\"priorities\"],\n            \"jsonMetadata\": batch[\"json_metadatas\"],\n            \"consensusMark\": batch[\"consensus_marks\"],\n            \"honeypotMark\": batch[\"honeypot_marks\"],\n            \"toBeLabeledBy\": batch[\"to_be_labeled_by_array\"],\n            \"shouldResetToBeLabeledBy\": batch[\"should_reset_to_be_labeled_by_array\"],\n            \"content\": batch[\"contents\"],\n            \"jsonContent\": batch[\"json_contents\"],\n            \"status\": batch[\"status_array\"],\n            \"isUsedForConsensus\": batch[\"is_used_for_consensus_array\"],\n            \"isHoneypot\": batch[\"is_honeypot_array\"],\n        }\n        data_array = [dict(zip(data, t)) for t in zip(*data.values())]  # type: ignore\n        return {\n            \"whereArray\": [{\"id\": asset_id} for asset_id in batch[\"asset_ids\"]],\n            \"dataArray\": data_array,\n        }\n\n    results = _mutate_from_paginated_call(\n        self,\n        properties_to_batch,\n        generate_variables,\n        GQL_UPDATE_PROPERTIES_IN_ASSETS,\n    )\n    formated_results = [format_result(\"data\", result, Asset) for result in results]\n    return [item for batch_list in formated_results for item in batch_list]\n</code></pre>"},{"location":"sdk/cloud_storage/","title":"Cloud storage module","text":"<p>Alpha feature</p> <p>The cloud storage feature is currently in alpha. It is still under active development: methods and behaviors can still evolve until the feature is complete.</p> <p>Cloud Storage Integration and Connection</p> <p>A cloud storage integration is a connection between a Kili organization and a cloud storage (AWS, GCP or Azure). Once a cloud storage integration is created, it can be used in any project of the organization. Adding a cloud storage integration from the SDK is currently not supported. More information about how to create a cloud storage integration can be found here.</p> <p>A cloud storage connection is a cloud storage integration used in a Kili project. It is used to import data from a cloud storage to a project. More information about how to use a cloud storage integration in a project can be found here.</p> <p>Azure</p> <p>It is recommended to install the Azure dependencies to use the Azure cloud storage integration and connection. <pre><code>pip install kili[azure]\n</code></pre></p>"},{"location":"sdk/cloud_storage/#queries","title":"Queries","text":"<p>Set of cloud storage integration queries.</p> Source code in <code>kili/entrypoints/queries/data_integration/__init__.py</code> <pre><code>class QueriesDataIntegration:\n\"\"\"Set of cloud storage integration queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n        status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"name\", \"id\", \"platform\", \"status\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n        status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"name\", \"id\", \"platform\", \"status\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n        status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"name\", \"id\", \"platform\", \"status\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of cloud storage integrations that match a set of criteria.\n\n        Args:\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            status: Status of the cloud storage integration.\n            organization_id: ID of the organization.\n            fields: All the fields to request among the possible fields for the cloud storage integrations.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#dataintegration) for all possible fields.\n            first: Maximum number of cloud storage integrations to return.\n            skip: Number of skipped cloud storage integrations.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the cloud storage integrations is returned.\n\n        Returns:\n            A list or a generator of the cloud storage integrations that match the criteria.\n\n        Examples:\n            &gt;&gt;&gt; kili.cloud_storage_integrations()\n            [{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n        \"\"\"\n        where = DataIntegrationWhere(\n            data_integration_id=cloud_storage_integration_id,\n            name=name,\n            platform=platform,\n            status=status,\n            organization_id=organization_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        data_integrations_gen = DataIntegrationsQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return data_integrations_gen\n        return list(data_integrations_gen)\n\n    @typechecked\n    def count_cloud_storage_integrations(\n        self,\n        cloud_storage_integration_id: Optional[str] = None,\n        name: Optional[str] = None,\n        platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n        status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n        organization_id: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Count and return the number of cloud storage integrations that match a set of criteria.\n\n        Args:\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            name: Name of the cloud storage integration.\n            platform: Platform of the cloud storage integration.\n            status: Status of the cloud storage integration.\n            organization_id: ID of the organization.\n\n        Returns:\n            The number of cloud storage integrations that match the criteria.\n        \"\"\"\n        where = DataIntegrationWhere(\n            data_integration_id=cloud_storage_integration_id,\n            name=name,\n            platform=platform,\n            status=status,\n            organization_id=organization_id,\n        )\n        return DataIntegrationsQuery(self.graphql_client).count(where)\n</code></pre> <p>Set of cloud storage connection queries.</p> Source code in <code>kili/entrypoints/queries/data_connection/__init__.py</code> <pre><code>class QueriesDataConnection:\n\"\"\"Set of cloud storage connection queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: List[str] = [\n            \"id\",\n            \"lastChecked\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: List[str] = [\n            \"id\",\n            \"lastChecked\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def cloud_storage_connections(\n        self,\n        cloud_storage_connection_id: Optional[str] = None,\n        cloud_storage_integration_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n        fields: List[str] = [\n            \"id\",\n            \"lastChecked\",\n            \"numberOfAssets\",\n            \"selectedFolders\",\n            \"projectId\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of cloud storage connections that match a set of criteria.\n\n        Args:\n            cloud_storage_connection_id: ID of the cloud storage connection.\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            project_id: ID of the project.\n            fields: All the fields to request among the possible fields for the cloud storage connections.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#dataconnection) for all possible fields.\n            first: Maximum number of cloud storage connections to return.\n            skip: Number of skipped cloud storage connections.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the cloud storage connections is returned.\n\n        Returns:\n            A list or a generator of the cloud storage connections that match the criteria.\n\n        Examples:\n            &gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n            [{'id': '123456789', 'lastChecked': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n        \"\"\"\n        if (\n            cloud_storage_connection_id is None\n            and cloud_storage_integration_id is None\n            and project_id is None\n        ):\n            raise ValueError(\n                \"At least one of cloud_storage_connection_id, cloud_storage_integration_id or\"\n                \" project_id must be specified\"\n            )\n\n        # call dataConnection resolver\n        if cloud_storage_connection_id is not None:\n            data_connection = services.get_data_connection(\n                self, cloud_storage_connection_id, fields\n            )\n            data_connection_list = [data_connection]\n            if as_generator:\n                return iter(data_connection_list)\n            return data_connection_list\n\n        # call dataConnections resolver\n        where = DataConnectionsWhere(\n            project_id=project_id, data_integration_id=cloud_storage_integration_id\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        data_connections_gen = DataConnectionsQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return data_connections_gen\n        return list(data_connections_gen)\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.entrypoints.queries.data_integration.__init__.QueriesDataIntegration.cloud_storage_integrations","title":"<code>cloud_storage_integrations(self, cloud_storage_integration_id=None, name=None, platform=None, status=None, organization_id=None, fields=['name', 'id', 'platform', 'status'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of cloud storage integrations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name of the cloud storage integration.</p> <code>None</code> <code>platform</code> <code>Optional[typing_extensions.Literal['AWS', 'Azure', 'GCP']]</code> <p>Platform of the cloud storage integration.</p> <code>None</code> <code>status</code> <code>Optional[typing_extensions.Literal['CONNECTED', 'DISCONNECTED', 'CHECKING']]</code> <p>Status of the cloud storage integration.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>ID of the organization.</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the cloud storage integrations. See the documentation for all possible fields.</p> <code>['name', 'id', 'platform', 'status']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of cloud storage integrations to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped cloud storage integrations.</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the cloud storage integrations is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list or a generator of the cloud storage integrations that match the criteria.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.cloud_storage_integrations()\n[{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n</code></pre> Source code in <code>kili/entrypoints/queries/data_integration/__init__.py</code> <pre><code>@typechecked\ndef cloud_storage_integrations(\n    self,\n    cloud_storage_integration_id: Optional[str] = None,\n    name: Optional[str] = None,\n    platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n    status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"name\", \"id\", \"platform\", \"status\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of cloud storage integrations that match a set of criteria.\n\n    Args:\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        status: Status of the cloud storage integration.\n        organization_id: ID of the organization.\n        fields: All the fields to request among the possible fields for the cloud storage integrations.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#dataintegration) for all possible fields.\n        first: Maximum number of cloud storage integrations to return.\n        skip: Number of skipped cloud storage integrations.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the cloud storage integrations is returned.\n\n    Returns:\n        A list or a generator of the cloud storage integrations that match the criteria.\n\n    Examples:\n        &gt;&gt;&gt; kili.cloud_storage_integrations()\n        [{'name': 'My bucket', 'id': '123456789', 'platform': 'AWS', 'status': 'CONNECTED'}]\n    \"\"\"\n    where = DataIntegrationWhere(\n        data_integration_id=cloud_storage_integration_id,\n        name=name,\n        platform=platform,\n        status=status,\n        organization_id=organization_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    data_integrations_gen = DataIntegrationsQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return data_integrations_gen\n    return list(data_integrations_gen)\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.entrypoints.queries.data_integration.__init__.QueriesDataIntegration.count_cloud_storage_integrations","title":"<code>count_cloud_storage_integrations(self, cloud_storage_integration_id=None, name=None, platform=None, status=None, organization_id=None)</code>","text":"<p>Count and return the number of cloud storage integrations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Name of the cloud storage integration.</p> <code>None</code> <code>platform</code> <code>Optional[typing_extensions.Literal['AWS', 'Azure', 'GCP']]</code> <p>Platform of the cloud storage integration.</p> <code>None</code> <code>status</code> <code>Optional[typing_extensions.Literal['CONNECTED', 'DISCONNECTED', 'CHECKING']]</code> <p>Status of the cloud storage integration.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>ID of the organization.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of cloud storage integrations that match the criteria.</p> Source code in <code>kili/entrypoints/queries/data_integration/__init__.py</code> <pre><code>@typechecked\ndef count_cloud_storage_integrations(\n    self,\n    cloud_storage_integration_id: Optional[str] = None,\n    name: Optional[str] = None,\n    platform: Optional[Literal[\"AWS\", \"Azure\", \"GCP\"]] = None,\n    status: Optional[Literal[\"CONNECTED\", \"DISCONNECTED\", \"CHECKING\"]] = None,\n    organization_id: Optional[str] = None,\n) -&gt; int:\n\"\"\"Count and return the number of cloud storage integrations that match a set of criteria.\n\n    Args:\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        name: Name of the cloud storage integration.\n        platform: Platform of the cloud storage integration.\n        status: Status of the cloud storage integration.\n        organization_id: ID of the organization.\n\n    Returns:\n        The number of cloud storage integrations that match the criteria.\n    \"\"\"\n    where = DataIntegrationWhere(\n        data_integration_id=cloud_storage_integration_id,\n        name=name,\n        platform=platform,\n        status=status,\n        organization_id=organization_id,\n    )\n    return DataIntegrationsQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.entrypoints.queries.data_connection.__init__.QueriesDataConnection.cloud_storage_connections","title":"<code>cloud_storage_connections(self, cloud_storage_connection_id=None, cloud_storage_integration_id=None, project_id=None, fields=['id', 'lastChecked', 'numberOfAssets', 'selectedFolders', 'projectId'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of cloud storage connections that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_connection_id</code> <code>Optional[str]</code> <p>ID of the cloud storage connection.</p> <code>None</code> <code>cloud_storage_integration_id</code> <code>Optional[str]</code> <p>ID of the cloud storage integration.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>ID of the project.</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the cloud storage connections. See the documentation for all possible fields.</p> <code>['id', 'lastChecked', 'numberOfAssets', 'selectedFolders', 'projectId']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of cloud storage connections to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped cloud storage connections.</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the cloud storage connections is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list or a generator of the cloud storage connections that match the criteria.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n[{'id': '123456789', 'lastChecked': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n</code></pre> Source code in <code>kili/entrypoints/queries/data_connection/__init__.py</code> <pre><code>@typechecked\ndef cloud_storage_connections(\n    self,\n    cloud_storage_connection_id: Optional[str] = None,\n    cloud_storage_integration_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n    fields: List[str] = [\n        \"id\",\n        \"lastChecked\",\n        \"numberOfAssets\",\n        \"selectedFolders\",\n        \"projectId\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of cloud storage connections that match a set of criteria.\n\n    Args:\n        cloud_storage_connection_id: ID of the cloud storage connection.\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        project_id: ID of the project.\n        fields: All the fields to request among the possible fields for the cloud storage connections.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#dataconnection) for all possible fields.\n        first: Maximum number of cloud storage connections to return.\n        skip: Number of skipped cloud storage connections.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the cloud storage connections is returned.\n\n    Returns:\n        A list or a generator of the cloud storage connections that match the criteria.\n\n    Examples:\n        &gt;&gt;&gt; kili.cloud_storage_connections(project_id=\"789465123\")\n        [{'id': '123456789', 'lastChecked': '2023-02-21T14:49:35.606Z', 'numberOfAssets': 42, 'selectedFolders': ['folder1', 'folder2'], 'projectId': '789465123'}]\n    \"\"\"\n    if (\n        cloud_storage_connection_id is None\n        and cloud_storage_integration_id is None\n        and project_id is None\n    ):\n        raise ValueError(\n            \"At least one of cloud_storage_connection_id, cloud_storage_integration_id or\"\n            \" project_id must be specified\"\n        )\n\n    # call dataConnection resolver\n    if cloud_storage_connection_id is not None:\n        data_connection = services.get_data_connection(\n            self, cloud_storage_connection_id, fields\n        )\n        data_connection_list = [data_connection]\n        if as_generator:\n            return iter(data_connection_list)\n        return data_connection_list\n\n    # call dataConnections resolver\n    where = DataConnectionsWhere(\n        project_id=project_id, data_integration_id=cloud_storage_integration_id\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    data_connections_gen = DataConnectionsQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return data_connections_gen\n    return list(data_connections_gen)\n</code></pre>"},{"location":"sdk/cloud_storage/#mutations","title":"Mutations","text":"<p>Set of DataConnection mutations.</p> Source code in <code>kili/entrypoints/mutations/data_connection/__init__.py</code> <pre><code>class MutationsDataConnection:\n\"\"\"Set of DataConnection mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def add_cloud_storage_connection(\n        self,\n        project_id: str,\n        cloud_storage_integration_id: str,\n        selected_folders: Optional[List[str]] = None,\n    ) -&gt; Dict:\n\"\"\"Connect a cloud storage to a project.\n\n        Args:\n            project_id: ID of the project.\n            cloud_storage_integration_id: ID of the cloud storage integration.\n            selected_folders: List of folders of the data integration to connect to the project.\n                If not provided, all folders of the data integration will be connected.\n\n        Returns:\n            A dict with the DataConnection ID.\n        \"\"\"\n        data_integrations = list(\n            DataIntegrationsQuery(self.graphql_client)(\n                where=DataIntegrationWhere(data_integration_id=cloud_storage_integration_id),\n                fields=[\"id\"],\n                options=QueryOptions(disable_tqdm=True, first=1, skip=0),\n            )\n        )\n        if len(data_integrations) == 0:\n            raise ValueError(\n                f\"Cloud storage integration with id {cloud_storage_integration_id} not found.\"\n            )\n\n        variables = {\n            \"data\": {\n                \"projectId\": project_id,\n                \"integrationId\": cloud_storage_integration_id,\n                \"isChecking\": False,\n                \"lastChecked\": datetime.now().isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n                \"selectedFolders\": selected_folders,\n            }\n        }\n        result = self.graphql_client.execute(GQL_ADD_PROJECT_DATA_CONNECTION, variables)\n        result = format_result(\"data\", result)\n\n        # We trigger data difference computation (same behavior as in the frontend)\n        services.compute_differences(self, result[\"id\"])\n\n        return result\n\n    @typechecked\n    def synchronize_cloud_storage_connection(\n        self,\n        cloud_storage_connection_id: str,\n        delete_extraneous_files: bool = False,\n        dry_run: bool = False,\n    ) -&gt; Dict:\n\"\"\"Synchronize a cloud storage connection.\n\n        This method will compute differences between the cloud storage connection and the project,\n            and then validate the differences.\n\n        If `delete_extraneous_files` is True, it will also delete files that are not in the\n            cloud storage integration anymore but that are still in the project.\n\n        Args:\n            cloud_storage_connection_id: ID of the cloud storage connection.\n            delete_extraneous_files: If True, delete extraneous files.\n            dry_run: If True, will not synchronize the data connection but only print the\n                differences. This is useful to check the differences before applying them to the\n                project.\n\n        Returns:\n            A dict with the cloud storage connection ID.\n        \"\"\"\n        return services.synchronize_data_connection(\n            self, cloud_storage_connection_id, delete_extraneous_files, dry_run\n        )\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.entrypoints.mutations.data_connection.__init__.MutationsDataConnection.add_cloud_storage_connection","title":"<code>add_cloud_storage_connection(self, project_id, cloud_storage_integration_id, selected_folders=None)</code>","text":"<p>Connect a cloud storage to a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>ID of the project.</p> required <code>cloud_storage_integration_id</code> <code>str</code> <p>ID of the cloud storage integration.</p> required <code>selected_folders</code> <code>Optional[List[str]]</code> <p>List of folders of the data integration to connect to the project. If not provided, all folders of the data integration will be connected.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dict with the DataConnection ID.</p> Source code in <code>kili/entrypoints/mutations/data_connection/__init__.py</code> <pre><code>@typechecked\ndef add_cloud_storage_connection(\n    self,\n    project_id: str,\n    cloud_storage_integration_id: str,\n    selected_folders: Optional[List[str]] = None,\n) -&gt; Dict:\n\"\"\"Connect a cloud storage to a project.\n\n    Args:\n        project_id: ID of the project.\n        cloud_storage_integration_id: ID of the cloud storage integration.\n        selected_folders: List of folders of the data integration to connect to the project.\n            If not provided, all folders of the data integration will be connected.\n\n    Returns:\n        A dict with the DataConnection ID.\n    \"\"\"\n    data_integrations = list(\n        DataIntegrationsQuery(self.graphql_client)(\n            where=DataIntegrationWhere(data_integration_id=cloud_storage_integration_id),\n            fields=[\"id\"],\n            options=QueryOptions(disable_tqdm=True, first=1, skip=0),\n        )\n    )\n    if len(data_integrations) == 0:\n        raise ValueError(\n            f\"Cloud storage integration with id {cloud_storage_integration_id} not found.\"\n        )\n\n    variables = {\n        \"data\": {\n            \"projectId\": project_id,\n            \"integrationId\": cloud_storage_integration_id,\n            \"isChecking\": False,\n            \"lastChecked\": datetime.now().isoformat(sep=\"T\", timespec=\"milliseconds\") + \"Z\",\n            \"selectedFolders\": selected_folders,\n        }\n    }\n    result = self.graphql_client.execute(GQL_ADD_PROJECT_DATA_CONNECTION, variables)\n    result = format_result(\"data\", result)\n\n    # We trigger data difference computation (same behavior as in the frontend)\n    services.compute_differences(self, result[\"id\"])\n\n    return result\n</code></pre>"},{"location":"sdk/cloud_storage/#kili.entrypoints.mutations.data_connection.__init__.MutationsDataConnection.synchronize_cloud_storage_connection","title":"<code>synchronize_cloud_storage_connection(self, cloud_storage_connection_id, delete_extraneous_files=False, dry_run=False)</code>","text":"<p>Synchronize a cloud storage connection.</p> <p>This method will compute differences between the cloud storage connection and the project,     and then validate the differences.</p> <p>If <code>delete_extraneous_files</code> is True, it will also delete files that are not in the     cloud storage integration anymore but that are still in the project.</p> <p>Parameters:</p> Name Type Description Default <code>cloud_storage_connection_id</code> <code>str</code> <p>ID of the cloud storage connection.</p> required <code>delete_extraneous_files</code> <code>bool</code> <p>If True, delete extraneous files.</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>If True, will not synchronize the data connection but only print the differences. This is useful to check the differences before applying them to the project.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dict with the cloud storage connection ID.</p> Source code in <code>kili/entrypoints/mutations/data_connection/__init__.py</code> <pre><code>@typechecked\ndef synchronize_cloud_storage_connection(\n    self,\n    cloud_storage_connection_id: str,\n    delete_extraneous_files: bool = False,\n    dry_run: bool = False,\n) -&gt; Dict:\n\"\"\"Synchronize a cloud storage connection.\n\n    This method will compute differences between the cloud storage connection and the project,\n        and then validate the differences.\n\n    If `delete_extraneous_files` is True, it will also delete files that are not in the\n        cloud storage integration anymore but that are still in the project.\n\n    Args:\n        cloud_storage_connection_id: ID of the cloud storage connection.\n        delete_extraneous_files: If True, delete extraneous files.\n        dry_run: If True, will not synchronize the data connection but only print the\n            differences. This is useful to check the differences before applying them to the\n            project.\n\n    Returns:\n        A dict with the cloud storage connection ID.\n    \"\"\"\n    return services.synchronize_data_connection(\n        self, cloud_storage_connection_id, delete_extraneous_files, dry_run\n    )\n</code></pre>"},{"location":"sdk/issue/","title":"Issue module","text":""},{"location":"sdk/issue/#queries","title":"Queries","text":"<p>Set of Issue queries.</p> Source code in <code>kili/entrypoints/queries/issue/__init__.py</code> <pre><code>class QueriesIssue:\n\"\"\"Set of Issue queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def issues(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"id\",\n            \"createdAt\",\n            \"issueNumber\",\n            \"status\",\n            \"type\",\n            \"assetId\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of issues that match a set of criteria.\n\n        !!! Info \"Issues or Questions\"\n            An `Issue` object both represent an issue and a question in the app.\n            To create them, two different methods are provided: `create_issues` and `create_questions`.\n            However to query issues and questions, we currently provide this unique method that retrieves both of them.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            asset_id: Id of the asset whose returned issues are associated to.\n            asset_id_in: List of Ids of assets whose returned issues are associated to.\n            issue_type: Type of the issue to return. An issue object both represents issues and questions in the app.\n            status: Status of the issues to return.\n            fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n            first: Maximum number of issues to return.\n            skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the issues is returned.\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n        \"\"\"\n\n        if asset_id and asset_id_in:\n            raise ValueError(\n                \"You cannot provide both `asset_id` and `asset_id_in` at the same time\"\n            )\n        where = IssueWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            issue_type=issue_type,\n            status=status,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        issues_gen = IssueQuery(self.graphql_client)(where, fields, options)\n        if as_generator:\n            return issues_gen\n        return list(issues_gen)\n\n    @typechecked\n    def count_issues(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_id_in: Optional[List[str]] = None,\n        issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n        status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n    ) -&gt; int:\n\"\"\"Count and return the number of issues with the given constraints.\n\n        Args:\n            project_id: Project ID the issue belongs to.\n            asset_id: Asset id whose returned issues are associated to.\n            asset_id_in: List of asset ids whose returned issues are associated to.\n            issue_type: Type of the issue to return. An issue object both\n                represents issues and questions in the app\n            status: Status of the issues to return.\n        Returns:\n            The number of issues with the parameters provided\n        \"\"\"\n        if asset_id and asset_id_in:\n            raise ValueError(\n                \"You cannot provide both `asset_id` and `asset_id_in` at the same time\"\n            )\n        where = IssueWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_id_in=asset_id_in,\n            issue_type=issue_type,\n            status=status,\n        )\n        return IssueQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/issue/#kili.entrypoints.queries.issue.__init__.QueriesIssue.count_issues","title":"<code>count_issues(self, project_id, asset_id=None, asset_id_in=None, issue_type=None, status=None)</code>","text":"<p>Count and return the number of issues with the given constraints.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Asset id whose returned issues are associated to.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>List of asset ids whose returned issues are associated to.</p> <code>None</code> <code>issue_type</code> <code>Optional[typing_extensions.Literal['QUESTION', 'ISSUE']]</code> <p>Type of the issue to return. An issue object both represents issues and questions in the app</p> <code>None</code> <code>status</code> <code>Optional[typing_extensions.Literal['OPEN', 'SOLVED']]</code> <p>Status of the issues to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of issues with the parameters provided</p> Source code in <code>kili/entrypoints/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef count_issues(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n    status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n) -&gt; int:\n\"\"\"Count and return the number of issues with the given constraints.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        asset_id: Asset id whose returned issues are associated to.\n        asset_id_in: List of asset ids whose returned issues are associated to.\n        issue_type: Type of the issue to return. An issue object both\n            represents issues and questions in the app\n        status: Status of the issues to return.\n    Returns:\n        The number of issues with the parameters provided\n    \"\"\"\n    if asset_id and asset_id_in:\n        raise ValueError(\n            \"You cannot provide both `asset_id` and `asset_id_in` at the same time\"\n        )\n    where = IssueWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        issue_type=issue_type,\n        status=status,\n    )\n    return IssueQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/issue/#kili.entrypoints.queries.issue.__init__.QueriesIssue.issues","title":"<code>issues(self, project_id, fields=['id', 'createdAt', 'issueNumber', 'status', 'type', 'assetId'], first=None, skip=0, disable_tqdm=False, asset_id=None, asset_id_in=None, issue_type=None, status=None, *, as_generator=False)</code>","text":"<p>Get a generator or a list of issues that match a set of criteria.</p> <p>Issues or Questions</p> <p>An <code>Issue</code> object both represent an issue and a question in the app. To create them, two different methods are provided: <code>create_issues</code> and <code>create_questions</code>. However to query issues and questions, we currently provide this unique method that retrieves both of them.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Project ID the issue belongs to.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Id of the asset whose returned issues are associated to.</p> <code>None</code> <code>asset_id_in</code> <code>Optional[List[str]]</code> <p>List of Ids of assets whose returned issues are associated to.</p> <code>None</code> <code>issue_type</code> <code>Optional[typing_extensions.Literal['QUESTION', 'ISSUE']]</code> <p>Type of the issue to return. An issue object both represents issues and questions in the app.</p> <code>None</code> <code>status</code> <code>Optional[typing_extensions.Literal['OPEN', 'SOLVED']]</code> <p>Status of the issues to return.</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['id', 'createdAt', 'issueNumber', 'status', 'type', 'assetId']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of issues to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of issues to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the issues is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n</code></pre> Source code in <code>kili/entrypoints/queries/issue/__init__.py</code> <pre><code>@typechecked\ndef issues(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"id\",\n        \"createdAt\",\n        \"issueNumber\",\n        \"status\",\n        \"type\",\n        \"assetId\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    asset_id: Optional[str] = None,\n    asset_id_in: Optional[List[str]] = None,\n    issue_type: Optional[Literal[\"QUESTION\", \"ISSUE\"]] = None,\n    status: Optional[Literal[\"OPEN\", \"SOLVED\"]] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of issues that match a set of criteria.\n\n    !!! Info \"Issues or Questions\"\n        An `Issue` object both represent an issue and a question in the app.\n        To create them, two different methods are provided: `create_issues` and `create_questions`.\n        However to query issues and questions, we currently provide this unique method that retrieves both of them.\n\n    Args:\n        project_id: Project ID the issue belongs to.\n        asset_id: Id of the asset whose returned issues are associated to.\n        asset_id_in: List of Ids of assets whose returned issues are associated to.\n        issue_type: Type of the issue to return. An issue object both represents issues and questions in the app.\n        status: Status of the issues to return.\n        fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields.\n        first: Maximum number of issues to return.\n        skip: Number of issues to skip (they are ordered by their date of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the issues is returned.\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors\n    \"\"\"\n\n    if asset_id and asset_id_in:\n        raise ValueError(\n            \"You cannot provide both `asset_id` and `asset_id_in` at the same time\"\n        )\n    where = IssueWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_id_in=asset_id_in,\n        issue_type=issue_type,\n        status=status,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    issues_gen = IssueQuery(self.graphql_client)(where, fields, options)\n    if as_generator:\n        return issues_gen\n    return list(issues_gen)\n</code></pre>"},{"location":"sdk/issue/#mutations","title":"Mutations","text":"<p>Set of Issue mutations.</p> Source code in <code>kili/entrypoints/mutations/issue/__init__.py</code> <pre><code>class MutationsIssue:\n\"\"\"Set of Issue mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments\n    @deprecate(\n        msg=(\n            \"append_to_issues is deprecated. Please use `create_issues` or `create_questions`\"\n            \" instead. These new methods allow to import several issues or questions at the same\"\n            \" time and provide better performances.\"\n        )\n    )\n    @typechecked\n    def append_to_issues(\n        self,\n        label_id: str,\n        project_id: str,\n        object_mid: Optional[str] = None,\n        text: Optional[str] = None,\n        type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n    ) -&gt; Dict:\n\"\"\"Create an issue.\n\n        !!! danger \"Deprecated\"\n            append_to_issues is deprecated.\n            Please use `create_issues` or `create_questions` instead.\n            These new methods allow to import several issues or questions at the same time\n            and provide better performances.\n\n        Args:\n            label_id: Id of the label to add an issue to\n            object_mid: Mid of the object in the label to associate the issue to\n            type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n            text: If given, write a comment related to the issue\n            project_id: Id of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        issue_number = get_issue_numbers(self, project_id, type_, 1)[0]\n        try:\n            options = QueryOptions(disable_tqdm=True)\n            where = LabelWhere(\n                project_id=project_id,\n                label_id=label_id,\n            )\n            asset_id: str = list(\n                LabelQuery(self.graphql_client)(where=where, fields=[\"labelOf.id\"], options=options)\n            )[0][\"labelOf\"][\"id\"]\n        except:\n            # pylint: disable=raise-missing-from\n            raise ValueError(\n                f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n            )\n        variables = {\n            \"issues\": [\n                {\n                    \"issueNumber\": issue_number,\n                    \"labelID\": label_id,\n                    \"objectMid\": object_mid,\n                    \"type\": type_,\n                    \"assetId\": asset_id,\n                    \"text\": text,\n                }\n            ],\n            \"where\": {\"id\": asset_id},\n        }\n\n        result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n        return format_result(\"data\", result)[0]\n\n    @typechecked\n    def create_issues(\n        self,\n        project_id: str,\n        label_id_array: List[str],\n        object_mid_array: Optional[List[Optional[str]]] = None,\n        text_array: Optional[List[Optional[str]]] = None,\n    ) -&gt; List[Dict]:\n\"\"\"Create an issue.\n\n        Args:\n            project_id: Id of the project.\n            label_id_array: List of Ids of the labels to add an issue to.\n            object_mid_array: List of mids of the objects in the labels to associate the issues to.\n            text_array: List of texts to associate to the issues.\n\n        Returns:\n            A list of dictionary with the `id` key of the created issues.\n        \"\"\"\n        assert_all_arrays_have_same_size([label_id_array, object_mid_array, text_array])\n        issue_number_array = get_issue_numbers(self, project_id, \"ISSUE\", len(label_id_array))\n        label_asset_ids_map = get_labels_asset_ids_map(self, project_id, label_id_array)\n        variables = {\n            \"issues\": [\n                {\n                    \"issueNumber\": issue_number,\n                    \"labelID\": label_id,\n                    \"objectMid\": object_mid,\n                    \"type\": \"ISSUE\",\n                    \"assetId\": label_asset_ids_map[label_id],\n                    \"text\": text,\n                }\n                for (issue_number, label_id, object_mid, text) in zip(\n                    issue_number_array,\n                    label_id_array,\n                    object_mid_array or repeat(None),\n                    text_array or repeat(None),\n                )\n            ],\n            \"where\": {\"idIn\": list(label_asset_ids_map.values())},\n        }\n\n        result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def create_questions(\n        self,\n        project_id: str,\n        text_array: List[Optional[str]],\n        asset_id_array: Optional[List[str]] = None,\n        asset_external_id_array: Optional[List[str]] = None,\n    ) -&gt; List[Dict]:\n        # pylint:disable=line-too-long\n\"\"\"Create questions.\n\n        Args:\n            project_id: Id of the project.\n            text_array: List of question strings.\n            asset_id_array: List of the assets to add the questions to.\n            asset_external_id_array: List of the assets to add the questions to. Used if `asset_id_array` is not given.\n\n        Returns:\n            A list of dictionary with the `id` key of the created questions.\n        \"\"\"\n        assert_all_arrays_have_same_size([text_array, asset_id_array])\n        issue_number_array = get_issue_numbers(self, project_id, \"QUESTION\", len(text_array))\n        asset_id_array = get_asset_ids_or_throw_error(\n            self, asset_id_array, asset_external_id_array, project_id\n        )\n        variables = {\n            \"issues\": [\n                {\"issueNumber\": issue_number, \"type\": \"QUESTION\", \"assetId\": asset_id, \"text\": text}\n                for (asset_id, text, issue_number) in zip(\n                    asset_id_array, text_array, issue_number_array\n                )\n            ],\n            \"where\": {\"idIn\": asset_id_array},\n        }\n\n        result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/issue/#kili.entrypoints.mutations.issue.__init__.MutationsIssue.append_to_issues","title":"<code>append_to_issues(self, label_id, project_id, object_mid=None, text=None, type_='ISSUE')</code>","text":"<p>Create an issue.</p> <p>Deprecated</p> <p>append_to_issues is deprecated. Please use <code>create_issues</code> or <code>create_questions</code> instead. These new methods allow to import several issues or questions at the same time and provide better performances.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>Id of the label to add an issue to</p> required <code>object_mid</code> <code>Optional[str]</code> <p>Mid of the object in the label to associate the issue to</p> <code>None</code> <code>type_</code> <code>typing_extensions.Literal['ISSUE', 'QUESTION']</code> <p>type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"</p> <code>'ISSUE'</code> <code>text</code> <code>Optional[str]</code> <p>If given, write a comment related to the issue</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Id of the project</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/issue/__init__.py</code> <pre><code>@deprecate(\n    msg=(\n        \"append_to_issues is deprecated. Please use `create_issues` or `create_questions`\"\n        \" instead. These new methods allow to import several issues or questions at the same\"\n        \" time and provide better performances.\"\n    )\n)\n@typechecked\ndef append_to_issues(\n    self,\n    label_id: str,\n    project_id: str,\n    object_mid: Optional[str] = None,\n    text: Optional[str] = None,\n    type_: Literal[\"ISSUE\", \"QUESTION\"] = \"ISSUE\",\n) -&gt; Dict:\n\"\"\"Create an issue.\n\n    !!! danger \"Deprecated\"\n        append_to_issues is deprecated.\n        Please use `create_issues` or `create_questions` instead.\n        These new methods allow to import several issues or questions at the same time\n        and provide better performances.\n\n    Args:\n        label_id: Id of the label to add an issue to\n        object_mid: Mid of the object in the label to associate the issue to\n        type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\"\n        text: If given, write a comment related to the issue\n        project_id: Id of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    issue_number = get_issue_numbers(self, project_id, type_, 1)[0]\n    try:\n        options = QueryOptions(disable_tqdm=True)\n        where = LabelWhere(\n            project_id=project_id,\n            label_id=label_id,\n        )\n        asset_id: str = list(\n            LabelQuery(self.graphql_client)(where=where, fields=[\"labelOf.id\"], options=options)\n        )[0][\"labelOf\"][\"id\"]\n    except:\n        # pylint: disable=raise-missing-from\n        raise ValueError(\n            f\"Label ID {label_id} does not exist in the project of ID {project_id}\"\n        )\n    variables = {\n        \"issues\": [\n            {\n                \"issueNumber\": issue_number,\n                \"labelID\": label_id,\n                \"objectMid\": object_mid,\n                \"type\": type_,\n                \"assetId\": asset_id,\n                \"text\": text,\n            }\n        ],\n        \"where\": {\"id\": asset_id},\n    }\n\n    result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n    return format_result(\"data\", result)[0]\n</code></pre>"},{"location":"sdk/issue/#kili.entrypoints.mutations.issue.__init__.MutationsIssue.create_issues","title":"<code>create_issues(self, project_id, label_id_array, object_mid_array=None, text_array=None)</code>","text":"<p>Create an issue.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>label_id_array</code> <code>List[str]</code> <p>List of Ids of the labels to add an issue to.</p> required <code>object_mid_array</code> <code>Optional[List[Union[str, NoneType]]]</code> <p>List of mids of the objects in the labels to associate the issues to.</p> <code>None</code> <code>text_array</code> <code>Optional[List[Union[str, NoneType]]]</code> <p>List of texts to associate to the issues.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of dictionary with the <code>id</code> key of the created issues.</p> Source code in <code>kili/entrypoints/mutations/issue/__init__.py</code> <pre><code>@typechecked\ndef create_issues(\n    self,\n    project_id: str,\n    label_id_array: List[str],\n    object_mid_array: Optional[List[Optional[str]]] = None,\n    text_array: Optional[List[Optional[str]]] = None,\n) -&gt; List[Dict]:\n\"\"\"Create an issue.\n\n    Args:\n        project_id: Id of the project.\n        label_id_array: List of Ids of the labels to add an issue to.\n        object_mid_array: List of mids of the objects in the labels to associate the issues to.\n        text_array: List of texts to associate to the issues.\n\n    Returns:\n        A list of dictionary with the `id` key of the created issues.\n    \"\"\"\n    assert_all_arrays_have_same_size([label_id_array, object_mid_array, text_array])\n    issue_number_array = get_issue_numbers(self, project_id, \"ISSUE\", len(label_id_array))\n    label_asset_ids_map = get_labels_asset_ids_map(self, project_id, label_id_array)\n    variables = {\n        \"issues\": [\n            {\n                \"issueNumber\": issue_number,\n                \"labelID\": label_id,\n                \"objectMid\": object_mid,\n                \"type\": \"ISSUE\",\n                \"assetId\": label_asset_ids_map[label_id],\n                \"text\": text,\n            }\n            for (issue_number, label_id, object_mid, text) in zip(\n                issue_number_array,\n                label_id_array,\n                object_mid_array or repeat(None),\n                text_array or repeat(None),\n            )\n        ],\n        \"where\": {\"idIn\": list(label_asset_ids_map.values())},\n    }\n\n    result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/issue/#kili.entrypoints.mutations.issue.__init__.MutationsIssue.create_questions","title":"<code>create_questions(self, project_id, text_array, asset_id_array=None, asset_external_id_array=None)</code>","text":"<p>Create questions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Id of the project.</p> required <code>text_array</code> <code>List[Optional[str]]</code> <p>List of question strings.</p> required <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>List of the assets to add the questions to.</p> <code>None</code> <code>asset_external_id_array</code> <code>Optional[List[str]]</code> <p>List of the assets to add the questions to. Used if <code>asset_id_array</code> is not given.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of dictionary with the <code>id</code> key of the created questions.</p> Source code in <code>kili/entrypoints/mutations/issue/__init__.py</code> <pre><code>@typechecked\ndef create_questions(\n    self,\n    project_id: str,\n    text_array: List[Optional[str]],\n    asset_id_array: Optional[List[str]] = None,\n    asset_external_id_array: Optional[List[str]] = None,\n) -&gt; List[Dict]:\n    # pylint:disable=line-too-long\n\"\"\"Create questions.\n\n    Args:\n        project_id: Id of the project.\n        text_array: List of question strings.\n        asset_id_array: List of the assets to add the questions to.\n        asset_external_id_array: List of the assets to add the questions to. Used if `asset_id_array` is not given.\n\n    Returns:\n        A list of dictionary with the `id` key of the created questions.\n    \"\"\"\n    assert_all_arrays_have_same_size([text_array, asset_id_array])\n    issue_number_array = get_issue_numbers(self, project_id, \"QUESTION\", len(text_array))\n    asset_id_array = get_asset_ids_or_throw_error(\n        self, asset_id_array, asset_external_id_array, project_id\n    )\n    variables = {\n        \"issues\": [\n            {\"issueNumber\": issue_number, \"type\": \"QUESTION\", \"assetId\": asset_id, \"text\": text}\n            for (asset_id, text, issue_number) in zip(\n                asset_id_array, text_array, issue_number_array\n            )\n        ],\n        \"where\": {\"idIn\": asset_id_array},\n    }\n\n    result = self.graphql_client.execute(GQL_CREATE_ISSUES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/label/","title":"Label module","text":""},{"location":"sdk/label/#queries","title":"Queries","text":"<p>Set of Label queries.</p> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>class QueriesLabel:\n\"\"\"Set of Label queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,too-many-locals,dangerous-default-value\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\"] = \"dict\",\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\"] = \"dict\",\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"parsed_label\"] = \"parsed_label\",\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[ParsedLabel]:\n        ...\n\n    @overload\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"parsed_label\"] = \"parsed_label\",\n        *,\n        as_generator: Literal[True] = True,\n    ) -&gt; Generator[ParsedLabel, None, None]:\n        ...\n\n    @typechecked\n    def labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"secondsToLabel\",\n            \"isLatestLabelForUser\",\n        ],\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Union[Dict, ParsedLabel]]:\n        # pylint: disable=line-too-long\n\"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`.\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have their creation date equal to this date.\n            created_at_gte: Returned labels should have their creation date greater or equal to this date.\n            created_at_lte: Returned labels should have their creation date lower or equal to this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled.\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse.\n            output_format: If `dict`, the output is an iterable of Python dictionaries.\n                If `parsed_label`, the output is an iterable of parsed labels objects. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n            &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n        !!! example \"How to filter based on label categories\"\n            The search query is composed of logical expressions following this format:\n\n                [job_name].[category_name].count [comparaison_operator] [value]\n            where:\n\n            - `[job_name]` is the name of the job in the interface\n            - `[category_name]` is the name of the category in the interface for this job\n            - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n            - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n            These operations can be separated by OR and AND operators\n\n            Example:\n\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n                category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n                category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n        \"\"\"\n        if category_search:\n            validate_category_search_query(category_search)\n\n        where = LabelWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            type_in=type_in,\n            user_id=user_id,\n            category_search=category_search,\n        )\n\n        post_call_function = None\n        if output_format == \"parsed_label\":\n            if \"jsonResponse\" not in fields:\n                raise ValueError(\n                    \"The field 'jsonResponse' is required to parse labels. Please add it to the\"\n                    \" 'fields' argument.\"\n                )\n\n            project = get_project(self, project_id, [\"jsonInterface\", \"inputType\"])\n\n            post_call_function = partial(\n                parse_labels,\n                json_interface=project[\"jsonInterface\"],\n                input_type=project[\"inputType\"],\n            )\n\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        labels_gen = LabelQuery(self.graphql_client)(where, fields, options, post_call_function)\n\n        if as_generator:\n            return labels_gen\n        return list(labels_gen)\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def predictions(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get prediction labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n        \"\"\"\n        if fields is None:\n            fields = [\n                \"author.email\",\n                \"author.id\",\n                \"id\",\n                \"jsonResponse\",\n                \"labelType\",\n                \"modelName\",\n            ]\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"PREDICTION\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # type: ignore\n        )\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def inferences(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n        first: Optional[int] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        id_contains: Optional[List[str]] = None,\n        label_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        category_search: Optional[str] = None,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get inference labels from a project based on a set of criteria.\n\n        This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            first: Maximum number of labels to return.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n            label_id: Identifier of the label.\n            skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n            user_id: Identifier of the user.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the labels is returned.\n            category_search: Query to filter labels based on the content of their jsonResponse\n\n        Returns:\n            A result object which contains the query if it was successful, else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n        \"\"\"\n        if fields is None:\n            fields = [\n                \"author.email\",\n                \"author.id\",\n                \"id\",\n                \"jsonResponse\",\n                \"labelType\",\n                \"modelName\",\n            ]\n        return self.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            fields=fields,\n            first=first,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            skip=skip,\n            type_in=[\"INFERENCE\"],\n            user_id=user_id,\n            disable_tqdm=disable_tqdm,\n            category_search=category_search,\n            as_generator=as_generator,  # type: ignore\n        )\n\n    @typechecked\n    def export_labels_as_df(\n        self,\n        project_id: str,\n        fields: List[str] = [\n            \"author.email\",\n            \"author.id\",\n            \"createdAt\",\n            \"id\",\n            \"labelType\",\n        ],\n        asset_fields: List[str] = [\"externalId\"],\n    ) -&gt; pd.DataFrame:\n        # pylint: disable=line-too-long\n\"\"\"Get the labels of a project as a pandas DataFrame.\n\n        Args:\n            project_id: Identifier of the project\n            fields: All the fields to request among the possible fields for the labels.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n            asset_fields: All the fields to request among the possible fields for the assets.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n        Returns:\n            A pandas DataFrame containing the labels.\n        \"\"\"\n        services.get_project(self, project_id, [\"id\"])\n        assets_gen = AssetQuery(self.graphql_client)(\n            AssetWhere(project_id=project_id),\n            asset_fields + [\"labels.\" + field for field in fields],\n            QueryOptions(disable_tqdm=False),\n        )\n        labels = [\n            dict(\n                label,\n                **{f\"asset_{key}\": asset[key] for key in asset if key != \"labels\"},\n            )\n            for asset in assets_gen\n            for label in asset[\"labels\"]\n        ]\n        labels_df = pd.DataFrame(labels)\n        return labels_df\n\n    @typechecked\n    def count_labels(\n        self,\n        project_id: str,\n        asset_id: Optional[str] = None,\n        asset_status_in: Optional[List[str]] = None,\n        asset_external_id_in: Optional[List[str]] = None,\n        author_in: Optional[List[str]] = None,\n        created_at: Optional[str] = None,\n        created_at_gte: Optional[str] = None,\n        created_at_lte: Optional[str] = None,\n        honeypot_mark_gte: Optional[float] = None,\n        honeypot_mark_lte: Optional[float] = None,\n        label_id: Optional[str] = None,\n        type_in: Optional[List[str]] = None,\n        user_id: Optional[str] = None,\n        category_search: Optional[str] = None,\n        id_contains: Optional[List[str]] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n\"\"\"Get the number of labels for the given parameters.\n\n        Args:\n            project_id: Identifier of the project.\n            asset_id: Identifier of the asset.\n            asset_status_in: Returned labels should have a status that belongs to that list, if given.\n                Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n            asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n            author_in: Returned labels should have been made by authors in that list, if given.\n                An author can be designated by the first name, the last name, or the first name + last name.\n            created_at: Returned labels should have a label whose creation date is equal to this date.\n            created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n            created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n            honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n            honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n            label_id: Identifier of the label.\n            type_in: Returned labels should have a label whose type belongs to that list, if given.\n            user_id: Identifier of the user.\n            category_search: Query to filter labels based on the content of their jsonResponse\n            id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of labels with the parameters provided\n        \"\"\"\n        if category_search:\n            validate_category_search_query(category_search)\n\n        where = LabelWhere(\n            project_id=project_id,\n            asset_id=asset_id,\n            asset_status_in=asset_status_in,\n            asset_external_id_in=asset_external_id_in,\n            author_in=author_in,\n            created_at=created_at,\n            created_at_gte=created_at_gte,\n            created_at_lte=created_at_lte,\n            honeypot_mark_gte=honeypot_mark_gte,\n            honeypot_mark_lte=honeypot_mark_lte,\n            id_contains=id_contains,\n            label_id=label_id,\n            type_in=type_in,\n            user_id=user_id,\n            category_search=category_search,\n        )\n        return LabelQuery(self.graphql_client).count(where)\n\n    def export_labels(\n        self,\n        project_id: str,\n        filename: str,\n        fmt: LabelFormat,\n        asset_ids: Optional[List[str]] = None,\n        layout: SplitOption = \"split\",\n        single_file: bool = False,\n        disable_tqdm: bool = False,\n        with_assets: bool = True,\n        external_ids: Optional[List[str]] = None,\n        annotation_modifier: Optional[CocoAnnotationModifier] = None,\n        asset_filter_kwargs: Optional[Dict[str, object]] = None,\n    ) -&gt; None:\n        # pylint: disable=line-too-long\n\"\"\"Export the project labels with the requested format into the requested output path.\n\n        Args:\n            project_id: Identifier of the project.\n            filename: Relative or full path of the archive that will contain\n                the exported data.\n            fmt: Format of the exported labels.\n            asset_ids: Optional list of the assets internal IDs from which to export the labels.\n            layout: Layout of the exported files. \"split\" means there is one folder\n                per job, \"merged\" that there is one folder with every labels.\n            single_file: Layout of the exported labels. Single file mode is\n                only available for some specific formats (COCO and Kili).\n            disable_tqdm: Disable the progress bar if True.\n            with_assets: Download the assets in the export.\n            external_ids: Optional list of the assets external IDs from which to export the labels.\n            annotation_modifier: (For COCO export only) function that takes the COCO annotation, the\n                COCO image, and the Kili annotation, and should return an updated COCO annotation.\n                This can be used if you want to add a new attribute to the COCO annotation. For\n                example, you can add a method that computes if the annotation is a rectangle or not\n                and add it to the COCO annotation (see example).\n            asset_filter_kwargs: Optional dictionary of arguments to pass to `kili.assets()` in order to filter the assets the labels are exported from. The supported arguments are:\n\n                - `consensus_mark_gte`\n                - `consensus_mark_lte`\n                - `external_id_strictly_in`\n                - `external_id_in`\n                - `honeypot_mark_gte`\n                - `honeypot_mark_lte`\n                - `label_author_in`\n                - `label_reviewer_in`\n                - `skipped`\n                - `status_in`\n                - `label_category_search`\n                - `created_at_gte`\n                - `created_at_lte`\n                - `issue_type`\n                - `issue_status`\n                - `inference_mark_gte`\n                - `inference_mark_lte`\n                - `metadata_where`\n\n                See the documentation of [`kili.assets()`](https://python-sdk-docs.kili-technology.com/latest/sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets) for more information.\n\n        !!! Info\n            The supported formats are:\n\n            - Yolo V4, V5, V7 for object detection tasks (bounding box).\n            - Kili (a.k.a raw) for all tasks.\n            - COCO for object detection tasks (bounding box and semantic segmentation).\n            - Pascal VOC for object detection tasks (bounding box).\n\n        !!! warning \"Cloud storage\"\n            Export with asset download (`with_assets=True`) is not allowed for projects connected to a cloud storage.\n            As they require an access to the assets to read their dimension, the COCO and Pascal VOC formats are not\n            allowed in this case.\n\n        !!! Example\n            ```python\n            kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n            ```\n\n        !!! Example\n            ```python\n            def is_rectangle(coco_annotation, coco_image, kili_annotation):\n                is_rectangle = ...\n                return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\n            kili.export_labels(\n                \"your_project_id\",\n                \"export.zip\",\n                \"coco\",\n                annotation_modifier=add_is_rectangle\n            )\n            ```\n        \"\"\"\n        if external_ids is not None and asset_ids is None:\n            id_map = infer_ids_from_external_ids(\n                kili=self, asset_external_ids=external_ids, project_id=project_id\n            )\n            asset_ids = [id_map[id] for id in external_ids]\n\n        try:\n            services.export_labels(\n                self,\n                asset_ids=asset_ids,\n                project_id=cast(ProjectId, project_id),\n                export_type=\"latest\",\n                label_format=fmt,\n                split_option=layout,\n                single_file=single_file,\n                output_file=filename,\n                disable_tqdm=disable_tqdm,\n                log_level=\"WARNING\",\n                with_assets=with_assets,\n                annotation_modifier=annotation_modifier,\n                asset_filter_kwargs=asset_filter_kwargs,\n            )\n        except NoCompatibleJobError as excp:\n            print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.count_labels","title":"<code>count_labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, honeypot_mark_gte=None, honeypot_mark_lte=None, label_id=None, type_in=None, user_id=None, category_search=None, id_contains=None)</code>","text":"<p>Get the number of labels for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of labels with the parameters provided</p> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>@typechecked\ndef count_labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    label_id: Optional[str] = None,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    category_search: Optional[str] = None,\n    id_contains: Optional[List[str]] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n\"\"\"Get the number of labels for the given parameters.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        label_id: Identifier of the label.\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        category_search: Query to filter labels based on the content of their jsonResponse\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of labels with the parameters provided\n    \"\"\"\n    if category_search:\n        validate_category_search_query(category_search)\n\n    where = LabelWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        type_in=type_in,\n        user_id=user_id,\n        category_search=category_search,\n    )\n    return LabelQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.export_labels","title":"<code>export_labels(self, project_id, filename, fmt, asset_ids=None, layout='split', single_file=False, disable_tqdm=False, with_assets=True, external_ids=None, annotation_modifier=None, asset_filter_kwargs=None)</code>","text":"<p>Export the project labels with the requested format into the requested output path.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>filename</code> <code>str</code> <p>Relative or full path of the archive that will contain the exported data.</p> required <code>fmt</code> <code>typing_extensions.Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc']</code> <p>Format of the exported labels.</p> required <code>asset_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets internal IDs from which to export the labels.</p> <code>None</code> <code>layout</code> <code>typing_extensions.Literal['split', 'merged']</code> <p>Layout of the exported files. \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels.</p> <code>'split'</code> <code>single_file</code> <code>bool</code> <p>Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili).</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable the progress bar if True.</p> <code>False</code> <code>with_assets</code> <code>bool</code> <p>Download the assets in the export.</p> <code>True</code> <code>external_ids</code> <code>Optional[List[str]]</code> <p>Optional list of the assets external IDs from which to export the labels.</p> <code>None</code> <code>annotation_modifier</code> <code>Optional[Callable[[Dict, Dict, Dict], Dict]]</code> <p>(For COCO export only) function that takes the COCO annotation, the COCO image, and the Kili annotation, and should return an updated COCO annotation. This can be used if you want to add a new attribute to the COCO annotation. For example, you can add a method that computes if the annotation is a rectangle or not and add it to the COCO annotation (see example).</p> <code>None</code> <code>asset_filter_kwargs</code> <code>Optional[Dict[str, object]]</code> <p>Optional dictionary of arguments to pass to <code>kili.assets()</code> in order to filter the assets the labels are exported from. The supported arguments are:</p> <ul> <li><code>consensus_mark_gte</code></li> <li><code>consensus_mark_lte</code></li> <li><code>external_id_strictly_in</code></li> <li><code>external_id_in</code></li> <li><code>honeypot_mark_gte</code></li> <li><code>honeypot_mark_lte</code></li> <li><code>label_author_in</code></li> <li><code>label_reviewer_in</code></li> <li><code>skipped</code></li> <li><code>status_in</code></li> <li><code>label_category_search</code></li> <li><code>created_at_gte</code></li> <li><code>created_at_lte</code></li> <li><code>issue_type</code></li> <li><code>issue_status</code></li> <li><code>inference_mark_gte</code></li> <li><code>inference_mark_lte</code></li> <li><code>metadata_where</code></li> </ul> <p>See the documentation of <code>kili.assets()</code> for more information.</p> <code>None</code> <p>Info</p> <p>The supported formats are:</p> <ul> <li>Yolo V4, V5, V7 for object detection tasks (bounding box).</li> <li>Kili (a.k.a raw) for all tasks.</li> <li>COCO for object detection tasks (bounding box and semantic segmentation).</li> <li>Pascal VOC for object detection tasks (bounding box).</li> </ul> <p>Cloud storage</p> <p>Export with asset download (<code>with_assets=True</code>) is not allowed for projects connected to a cloud storage. As they require an access to the assets to read their dimension, the COCO and Pascal VOC formats are not allowed in this case.</p> <p>Example</p> <pre><code>kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n</code></pre> <p>Example</p> <pre><code>def is_rectangle(coco_annotation, coco_image, kili_annotation):\n    is_rectangle = ...\n    return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\nkili.export_labels(\n    \"your_project_id\",\n    \"export.zip\",\n    \"coco\",\n    annotation_modifier=add_is_rectangle\n)\n</code></pre> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>def export_labels(\n    self,\n    project_id: str,\n    filename: str,\n    fmt: LabelFormat,\n    asset_ids: Optional[List[str]] = None,\n    layout: SplitOption = \"split\",\n    single_file: bool = False,\n    disable_tqdm: bool = False,\n    with_assets: bool = True,\n    external_ids: Optional[List[str]] = None,\n    annotation_modifier: Optional[CocoAnnotationModifier] = None,\n    asset_filter_kwargs: Optional[Dict[str, object]] = None,\n) -&gt; None:\n    # pylint: disable=line-too-long\n\"\"\"Export the project labels with the requested format into the requested output path.\n\n    Args:\n        project_id: Identifier of the project.\n        filename: Relative or full path of the archive that will contain\n            the exported data.\n        fmt: Format of the exported labels.\n        asset_ids: Optional list of the assets internal IDs from which to export the labels.\n        layout: Layout of the exported files. \"split\" means there is one folder\n            per job, \"merged\" that there is one folder with every labels.\n        single_file: Layout of the exported labels. Single file mode is\n            only available for some specific formats (COCO and Kili).\n        disable_tqdm: Disable the progress bar if True.\n        with_assets: Download the assets in the export.\n        external_ids: Optional list of the assets external IDs from which to export the labels.\n        annotation_modifier: (For COCO export only) function that takes the COCO annotation, the\n            COCO image, and the Kili annotation, and should return an updated COCO annotation.\n            This can be used if you want to add a new attribute to the COCO annotation. For\n            example, you can add a method that computes if the annotation is a rectangle or not\n            and add it to the COCO annotation (see example).\n        asset_filter_kwargs: Optional dictionary of arguments to pass to `kili.assets()` in order to filter the assets the labels are exported from. The supported arguments are:\n\n            - `consensus_mark_gte`\n            - `consensus_mark_lte`\n            - `external_id_strictly_in`\n            - `external_id_in`\n            - `honeypot_mark_gte`\n            - `honeypot_mark_lte`\n            - `label_author_in`\n            - `label_reviewer_in`\n            - `skipped`\n            - `status_in`\n            - `label_category_search`\n            - `created_at_gte`\n            - `created_at_lte`\n            - `issue_type`\n            - `issue_status`\n            - `inference_mark_gte`\n            - `inference_mark_lte`\n            - `metadata_where`\n\n            See the documentation of [`kili.assets()`](https://python-sdk-docs.kili-technology.com/latest/sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets) for more information.\n\n    !!! Info\n        The supported formats are:\n\n        - Yolo V4, V5, V7 for object detection tasks (bounding box).\n        - Kili (a.k.a raw) for all tasks.\n        - COCO for object detection tasks (bounding box and semantic segmentation).\n        - Pascal VOC for object detection tasks (bounding box).\n\n    !!! warning \"Cloud storage\"\n        Export with asset download (`with_assets=True`) is not allowed for projects connected to a cloud storage.\n        As they require an access to the assets to read their dimension, the COCO and Pascal VOC formats are not\n        allowed in this case.\n\n    !!! Example\n        ```python\n        kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\")\n        ```\n\n    !!! Example\n        ```python\n        def is_rectangle(coco_annotation, coco_image, kili_annotation):\n            is_rectangle = ...\n            return {**coco_annotation, \"attributes\": {\"is_rectangle\": is_rectangle}}\n\n        kili.export_labels(\n            \"your_project_id\",\n            \"export.zip\",\n            \"coco\",\n            annotation_modifier=add_is_rectangle\n        )\n        ```\n    \"\"\"\n    if external_ids is not None and asset_ids is None:\n        id_map = infer_ids_from_external_ids(\n            kili=self, asset_external_ids=external_ids, project_id=project_id\n        )\n        asset_ids = [id_map[id] for id in external_ids]\n\n    try:\n        services.export_labels(\n            self,\n            asset_ids=asset_ids,\n            project_id=cast(ProjectId, project_id),\n            export_type=\"latest\",\n            label_format=fmt,\n            split_option=layout,\n            single_file=single_file,\n            output_file=filename,\n            disable_tqdm=disable_tqdm,\n            log_level=\"WARNING\",\n            with_assets=with_assets,\n            annotation_modifier=annotation_modifier,\n            asset_filter_kwargs=asset_filter_kwargs,\n        )\n    except NoCompatibleJobError as excp:\n        print(str(excp))\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.export_labels_as_df","title":"<code>export_labels_as_df(self, project_id, fields=['author.email', 'author.id', 'createdAt', 'id', 'labelType'], asset_fields=['externalId'])</code>","text":"<p>Get the labels of a project as a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'createdAt', 'id', 'labelType']</code> <code>asset_fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the assets. See the documentation for all possible fields.</p> <code>['externalId']</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame containing the labels.</p> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>@typechecked\ndef export_labels_as_df(\n    self,\n    project_id: str,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"createdAt\",\n        \"id\",\n        \"labelType\",\n    ],\n    asset_fields: List[str] = [\"externalId\"],\n) -&gt; pd.DataFrame:\n    # pylint: disable=line-too-long\n\"\"\"Get the labels of a project as a pandas DataFrame.\n\n    Args:\n        project_id: Identifier of the project\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        asset_fields: All the fields to request among the possible fields for the assets.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields.\n\n    Returns:\n        A pandas DataFrame containing the labels.\n    \"\"\"\n    services.get_project(self, project_id, [\"id\"])\n    assets_gen = AssetQuery(self.graphql_client)(\n        AssetWhere(project_id=project_id),\n        asset_fields + [\"labels.\" + field for field in fields],\n        QueryOptions(disable_tqdm=False),\n    )\n    labels = [\n        dict(\n            label,\n            **{f\"asset_{key}\": asset[key] for key in asset if key != \"labels\"},\n        )\n        for asset in assets_gen\n        for label in asset[\"labels\"]\n    ]\n    labels_df = pd.DataFrame(labels)\n    return labels_df\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.inferences","title":"<code>inferences(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=None, first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=False, category_search=None, *, as_generator=False)</code>","text":"<p>Get inference labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"INFERENCE\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>None</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n</code></pre> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>@typechecked\ndef inferences(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get inference labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"INFERENCE\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.inferences(project_id=project_id) # returns a list of inference labels of a project\n    \"\"\"\n    if fields is None:\n        fields = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ]\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"INFERENCE\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # type: ignore\n    )\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.labels","title":"<code>labels(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'isLatestLabelForUser'], first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, type_in=None, user_id=None, disable_tqdm=False, category_search=None, output_format='dict', *, as_generator=False)</code>","text":"<p>Get a label list or a label generator from a project based on a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code>.</p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have their creation date equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have their creation date greater or equal to this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have their creation date lower or equal to this date.</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'isLatestLabelForUser']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>type_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a label whose type belongs to that list, if given.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled.</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse.</p> <code>None</code> <code>output_format</code> <code>typing_extensions.Literal['dict', 'parsed_label']</code> <p>If <code>dict</code>, the output is an iterable of Python dictionaries. If <code>parsed_label</code>, the output is an iterable of parsed labels objects. More information on parsed labels in the documentation.</p> <code>'dict'</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Union[Dict, kili.utils.labels.parsing.ParsedLabel]]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n&gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n</code></pre> <p>How to filter based on label categories</p> <p>The search query is composed of logical expressions following this format:</p> <pre><code>[job_name].[category_name].count [comparaison_operator] [value]\n</code></pre> <p>where:</p> <ul> <li><code>[job_name]</code> is the name of the job in the interface</li> <li><code>[category_name]</code> is the name of the category in the interface for this job</li> <li><code>[comparaison_operator]</code> can be one of: [<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>]</li> <li><code>[value]</code> is an integer that represents the count of such objects of the given category in the label</li> </ul> <p>These operations can be separated by OR and AND operators</p> <p>Example:</p> <pre><code>category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\ncategory_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\ncategory_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n</code></pre> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>@typechecked\ndef labels(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: List[str] = [\n        \"author.email\",\n        \"author.id\",\n        \"id\",\n        \"jsonResponse\",\n        \"labelType\",\n        \"secondsToLabel\",\n        \"isLatestLabelForUser\",\n    ],\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    type_in: Optional[List[str]] = None,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    output_format: Literal[\"dict\", \"parsed_label\"] = \"dict\",\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Union[Dict, ParsedLabel]]:\n    # pylint: disable=line-too-long\n\"\"\"Get a label list or a label generator from a project based on a set of criteria.\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`.\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have their creation date equal to this date.\n        created_at_gte: Returned labels should have their creation date greater or equal to this date.\n        created_at_lte: Returned labels should have their creation date lower or equal to this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        type_in: Returned labels should have a label whose type belongs to that list, if given.\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled.\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse.\n        output_format: If `dict`, the output is an iterable of Python dictionaries.\n            If `parsed_label`, the output is an iterable of parsed labels objects. More information on parsed labels in the [documentation](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID\n        &gt;&gt;&gt; kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project\n\n    !!! example \"How to filter based on label categories\"\n        The search query is composed of logical expressions following this format:\n\n            [job_name].[category_name].count [comparaison_operator] [value]\n        where:\n\n        - `[job_name]` is the name of the job in the interface\n        - `[category_name]` is the name of the category in the interface for this job\n        - `[comparaison_operator]` can be one of: [`==`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`]\n        - `[value]` is an integer that represents the count of such objects of the given category in the label\n\n        These operations can be separated by OR and AND operators\n\n        Example:\n\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0`\n            category_search = `JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0`\n            category_search = `(JOB_CLASSIF.CATEGORY_A.count &gt; 0 OR JOB_NER.CATEGORY_B.count &gt; 0) AND JOB_BBOX.CATEGORY_C.count &gt; 10`\n    \"\"\"\n    if category_search:\n        validate_category_search_query(category_search)\n\n    where = LabelWhere(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        type_in=type_in,\n        user_id=user_id,\n        category_search=category_search,\n    )\n\n    post_call_function = None\n    if output_format == \"parsed_label\":\n        if \"jsonResponse\" not in fields:\n            raise ValueError(\n                \"The field 'jsonResponse' is required to parse labels. Please add it to the\"\n                \" 'fields' argument.\"\n            )\n\n        project = get_project(self, project_id, [\"jsonInterface\", \"inputType\"])\n\n        post_call_function = partial(\n            parse_labels,\n            json_interface=project[\"jsonInterface\"],\n            input_type=project[\"inputType\"],\n        )\n\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    labels_gen = LabelQuery(self.graphql_client)(where, fields, options, post_call_function)\n\n    if as_generator:\n        return labels_gen\n    return list(labels_gen)\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.queries.label.__init__.QueriesLabel.predictions","title":"<code>predictions(self, project_id, asset_id=None, asset_status_in=None, asset_external_id_in=None, author_in=None, created_at=None, created_at_gte=None, created_at_lte=None, fields=None, first=None, honeypot_mark_gte=None, honeypot_mark_lte=None, id_contains=None, label_id=None, skip=0, user_id=None, disable_tqdm=False, category_search=None, *, as_generator=False)</code>","text":"<p>Get prediction labels from a project based on a set of criteria.</p> <p>This method is equivalent to the <code>kili.labels()</code> method, but it only returns label of type \"PREDICTION\".</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>asset_status_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have a status that belongs to that list, if given. Possible choices : <code>TODO</code>, <code>ONGOING</code>, <code>LABELED</code>, <code>TO REVIEW</code> or <code>REVIEWED</code></p> <code>None</code> <code>asset_external_id_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have an external id that belongs to that list, if given.</p> <code>None</code> <code>author_in</code> <code>Optional[List[str]]</code> <p>Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name.</p> <code>None</code> <code>created_at</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is equal to this date.</p> <code>None</code> <code>created_at_gte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is greater than this date.</p> <code>None</code> <code>created_at_lte</code> <code>Optional[str]</code> <p>Returned labels should have a label whose creation date is lower than this date.</p> <code>None</code> <code>fields</code> <code>Optional[List[str]]</code> <p>All the fields to request among the possible fields for the labels. See the documentation for all possible fields.</p> <code>None</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of labels to return.</p> <code>None</code> <code>honeypot_mark_gte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is greater than this number.</p> <code>None</code> <code>honeypot_mark_lte</code> <code>Optional[float]</code> <p>Returned labels should have a label whose honeypot is lower than this number.</p> <code>None</code> <code>id_contains</code> <code>Optional[List[str]]</code> <p>Filters out labels not belonging to that list. If empty, no filtering is applied.</p> <code>None</code> <code>label_id</code> <code>Optional[str]</code> <p>Identifier of the label.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of labels to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>Identifier of the user.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the labels is returned.</p> <code>False</code> <code>category_search</code> <code>Optional[str]</code> <p>Query to filter labels based on the content of their jsonResponse</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful, else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n</code></pre> Source code in <code>kili/entrypoints/queries/label/__init__.py</code> <pre><code>@typechecked\ndef predictions(\n    self,\n    project_id: str,\n    asset_id: Optional[str] = None,\n    asset_status_in: Optional[List[str]] = None,\n    asset_external_id_in: Optional[List[str]] = None,\n    author_in: Optional[List[str]] = None,\n    created_at: Optional[str] = None,\n    created_at_gte: Optional[str] = None,\n    created_at_lte: Optional[str] = None,\n    fields: Optional[List[str]] = None,\n    first: Optional[int] = None,\n    honeypot_mark_gte: Optional[float] = None,\n    honeypot_mark_lte: Optional[float] = None,\n    id_contains: Optional[List[str]] = None,\n    label_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    category_search: Optional[str] = None,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get prediction labels from a project based on a set of criteria.\n\n    This method is equivalent to the `kili.labels()` method, but it only returns label of type \"PREDICTION\".\n\n    Args:\n        project_id: Identifier of the project.\n        asset_id: Identifier of the asset.\n        asset_status_in: Returned labels should have a status that belongs to that list, if given.\n            Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED`\n        asset_external_id_in: Returned labels should have an external id that belongs to that list, if given.\n        author_in: Returned labels should have been made by authors in that list, if given.\n            An author can be designated by the first name, the last name, or the first name + last name.\n        created_at: Returned labels should have a label whose creation date is equal to this date.\n        created_at_gte: Returned labels should have a label whose creation date is greater than this date.\n        created_at_lte: Returned labels should have a label whose creation date is lower than this date.\n        fields: All the fields to request among the possible fields for the labels.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields.\n        first: Maximum number of labels to return.\n        honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number.\n        honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number.\n        id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied.\n        label_id: Identifier of the label.\n        skip: Number of labels to skip (they are ordered by their date of creation, first to last).\n        user_id: Identifier of the user.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the labels is returned.\n        category_search: Query to filter labels based on the content of their jsonResponse\n\n    Returns:\n        A result object which contains the query if it was successful, else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.predictions(project_id=project_id) # returns a list of prediction labels of a project\n    \"\"\"\n    if fields is None:\n        fields = [\n            \"author.email\",\n            \"author.id\",\n            \"id\",\n            \"jsonResponse\",\n            \"labelType\",\n            \"modelName\",\n        ]\n    return self.labels(\n        project_id=project_id,\n        asset_id=asset_id,\n        asset_status_in=asset_status_in,\n        asset_external_id_in=asset_external_id_in,\n        author_in=author_in,\n        created_at=created_at,\n        created_at_gte=created_at_gte,\n        created_at_lte=created_at_lte,\n        fields=fields,\n        first=first,\n        honeypot_mark_gte=honeypot_mark_gte,\n        honeypot_mark_lte=honeypot_mark_lte,\n        id_contains=id_contains,\n        label_id=label_id,\n        skip=skip,\n        type_in=[\"PREDICTION\"],\n        user_id=user_id,\n        disable_tqdm=disable_tqdm,\n        category_search=category_search,\n        as_generator=as_generator,  # type: ignore\n    )\n</code></pre>"},{"location":"sdk/label/#mutations","title":"Mutations","text":"<p>Set of Label mutations.</p> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>class MutationsLabel:\n\"\"\"Set of Label mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments\n    @typechecked\n    def create_predictions(\n        self,\n        project_id: str,\n        external_id_array: Optional[List[str]] = None,\n        model_name_array: Optional[List[str]] = None,\n        json_response_array: Optional[List[dict]] = None,\n        model_name: Optional[str] = None,\n        asset_id_array: Optional[List[str]] = None,\n        disable_tqdm: bool = False,\n    ) -&gt; Dict:\n        # pylint: disable=line-too-long\n\"\"\"Create predictions for specific assets.\n\n        Args:\n            project_id: Identifier of the project.\n            external_id_array: The external IDs of the assets for which we want to add predictions.\n            model_name_array: Deprecated, use `model_name` instead.\n            json_response_array: The predictions are given here. For examples,\n                see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n            model_name: The name of the model that generated the predictions\n            asset_id_array: The internal IDs of the assets for which we want to add predictions.\n            disable_tqdm: Disable tqdm progress bar.\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n        !!! warning \"model name\"\n            The use of `model_name_array` is deprecated. Creating predictions from different\n            models is not supported anymore. Please use `model_name` argument instead to\n            provide the predictions model name.\n        \"\"\"\n        if json_response_array is None or len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one prediction to upload\"\n            )\n        assert_all_arrays_have_same_size(\n            [external_id_array, json_response_array, model_name_array, asset_id_array]\n        )\n        if model_name is None:\n            if model_name_array is None:\n                raise ValueError(\"You must provide a model name with the model_name argument \")\n            if len(set(model_name_array)) &gt; 1:\n                raise ValueError(\n                    \"Creating predictions from different models is not supported anymore. Separate\"\n                    \" your calls by models.\"\n                )\n            warnings.warn(\n                (\n                    \"The use of `model_name_array` is deprecated. Creating predictions from\"\n                    \" different models is not supported anymore. Please use `model_name` argument\"\n                    \" instead to provide the predictions model name.\"\n                ),\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            model_name = model_name_array[0]\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n            }\n            for (asset_id, asset_external_id, json_response) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                )\n            )\n        ]\n        services.import_labels_from_dict(\n            self, project_id, labels, \"PREDICTION\", model_name, disable_tqdm\n        )\n        return {\"id\": project_id}\n\n    @deprecate(\n        msg=(\n            \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n            \" function allows to import several labels 10 times faster.\"\n        )\n    )\n    @typechecked\n    def append_to_labels(\n        self,\n        json_response: dict,\n        author_id: Optional[str] = None,\n        label_asset_external_id: Optional[str] = None,\n        label_asset_id: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        seconds_to_label: Optional[int] = 0,\n    ):\n\"\"\"!!! danger \"[DEPRECATED]\"\n            append_to_labels method is deprecated. Please use append_labels instead.\n            This new function allows to import several labels 10 times faster.\n\n        Append a label to an asset.\n\n        Args:\n            json_response: Label is given here.\n            author_id: ID of the author of the label.\n            label_asset_external_id: External identifier of the asset.\n            label_asset_id: Identifier of the asset.\n            project_id: Identifier of the project.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            seconds_to_label: Time to create the label.\n\n        !!! warning\n            Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n        \"\"\"\n        if author_id is None:\n            user = self.get_user()  # type: ignore  # pylint: disable=no-member\n            author_id = user[\"id\"]\n\n        check_asset_identifier_arguments(\n            project_id,\n            [label_asset_id] if label_asset_id else None,\n            [label_asset_external_id] if label_asset_external_id else None,\n        )\n        if label_asset_id is None:\n            assert label_asset_external_id and project_id\n            label_asset_id = infer_ids_from_external_ids(\n                self, [label_asset_external_id], project_id\n            )[label_asset_external_id]\n        variables = {\n            \"data\": {\n                \"authorID\": author_id,\n                \"jsonResponse\": dumps(json_response),\n                \"labelType\": label_type,\n                \"secondsToLabel\": seconds_to_label,\n            },\n            \"where\": {\"id\": label_asset_id},\n        }\n        result = self.graphql_client.execute(GQL_APPEND_TO_LABELS, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def append_labels(  # pylint: disable=dangerous-default-value\n        self,\n        asset_id_array: Optional[List[str]] = None,\n        json_response_array: List[Dict] = [],\n        author_id_array: Optional[List[str]] = None,\n        seconds_to_label_array: Optional[List[int]] = None,\n        model_name: Optional[str] = None,\n        label_type: LabelType = \"DEFAULT\",\n        project_id: Optional[str] = None,\n        asset_external_id_array: Optional[List[str]] = None,\n        disable_tqdm: bool = False,\n    ) -&gt; List:\n\"\"\"Append labels to assets.\n\n        Args:\n            asset_id_array: list of asset internal ids to append labels on.\n            json_response_array: list of labels to append.\n            author_id_array: list of the author id of the labels.\n            seconds_to_label_array: list of times taken to produce the label, in seconds.\n            model_name: Name of the model that generated the labels.\n                Only useful when uploading PREDICTION or INFERENCE labels.\n            label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n            project_id: Identifier of the project.\n            asset_external_id_array: list of asset external ids to append labels on.\n            disable_tqdm: Disable tqdm progress bar.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.append_labels(\n                    asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                    json_response_array=[{...}, {...}]\n                )\n        \"\"\"\n        if len(json_response_array) == 0:\n            raise ValueError(\n                \"json_response_array is empty, you must provide at least one label to upload\"\n            )\n        check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n        assert_all_arrays_have_same_size(\n            [\n                seconds_to_label_array,\n                author_id_array,\n                json_response_array,\n                asset_external_id_array,\n                asset_id_array,\n            ]\n        )\n\n        labels = [\n            {\n                \"asset_id\": asset_id,\n                \"asset_external_id\": asset_external_id,\n                \"json_response\": json_response,\n                \"seconds_to_label\": seconds_to_label,\n                \"author_id\": author_id,\n            }\n            for (asset_id, asset_external_id, json_response, seconds_to_label, author_id) in list(\n                zip(\n                    asset_id_array or [None] * len(json_response_array),\n                    asset_external_id_array or [None] * len(json_response_array),\n                    json_response_array,\n                    seconds_to_label_array or [None] * len(json_response_array),\n                    author_id_array or [None] * len(json_response_array),\n                )\n            )\n        ]\n        return services.import_labels_from_dict(\n            self, project_id, labels, label_type, model_name, disable_tqdm\n        )\n\n    @typechecked\n    def update_properties_in_label(\n        self,\n        label_id: str,\n        seconds_to_label: Optional[int] = None,\n        model_name: Optional[str] = None,\n        json_response: Optional[dict] = None,\n    ) -&gt; Label:\n\"\"\"Update properties of a label.\n\n        Args:\n            label_id: Identifier of the label\n            seconds_to_label: Time to create the label\n            model_name: Name of the model\n            json_response: The label is given here\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n        \"\"\"\n        formatted_json_response = None if json_response is None else dumps(json_response)\n        variables = {\n            \"labelID\": label_id,\n            \"secondsToLabel\": seconds_to_label,\n            \"modelName\": model_name,\n            \"jsonResponse\": formatted_json_response,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n        return format_result(\"data\", result, Label)\n\n    @typechecked\n    def create_honeypot(\n        self,\n        json_response: dict,\n        asset_external_id: Optional[str] = None,\n        asset_id: Optional[str] = None,\n        project_id: Optional[str] = None,\n    ) -&gt; Label:\n\"\"\"Create honeypot for an asset.\n\n        !!! info\n            Uses the given `json_response` to create a `REVIEW` label.\n            This enables Kili to compute a`honeypotMark`,\n            which measures the similarity between this label and other labels.\n\n        Args:\n            json_response: The JSON response of the honeypot label of the asset.\n            asset_id: Identifier of the asset.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n            asset_external_id: External identifier of the asset.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n            project_id: Identifier of the project.\n                Either provide `asset_id` or `asset_external_id` and `project_id`.\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        if asset_id is None:\n            if asset_external_id is None or project_id is None:\n                raise ValueError(\n                    \"Either provide `asset_id` or `asset_external_id` and `project_id`.\"\n                )\n            asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n                asset_external_id\n            ]\n\n        variables = {\n            \"data\": {\"jsonResponse\": dumps(json_response)},\n            \"where\": {\"id\": asset_id},\n        }\n        result = self.graphql_client.execute(GQL_CREATE_HONEYPOT, variables)\n        return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.mutations.label.__init__.MutationsLabel.append_labels","title":"<code>append_labels(self, asset_id_array=None, json_response_array=[], author_id_array=None, seconds_to_label_array=None, model_name=None, label_type='DEFAULT', project_id=None, asset_external_id_array=None, disable_tqdm=False)</code>","text":"<p>Append labels to assets.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>list of asset internal ids to append labels on.</p> <code>None</code> <code>json_response_array</code> <code>List[Dict]</code> <p>list of labels to append.</p> <code>[]</code> <code>author_id_array</code> <code>Optional[List[str]]</code> <p>list of the author id of the labels.</p> <code>None</code> <code>seconds_to_label_array</code> <code>Optional[List[int]]</code> <p>list of times taken to produce the label, in seconds.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model that generated the labels. Only useful when uploading PREDICTION or INFERENCE labels.</p> <code>None</code> <code>label_type</code> <code>typing_extensions.Literal['AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW', 'INFERENCE']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project.</p> <code>None</code> <code>asset_external_id_array</code> <code>Optional[List[str]]</code> <p>list of asset external ids to append labels on.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable tqdm progress bar.</p> <code>False</code> <p>Returns:</p> Type Description <code>List</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_labels(\n        asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n        json_response_array=[{...}, {...}]\n    )\n</code></pre> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef append_labels(  # pylint: disable=dangerous-default-value\n    self,\n    asset_id_array: Optional[List[str]] = None,\n    json_response_array: List[Dict] = [],\n    author_id_array: Optional[List[str]] = None,\n    seconds_to_label_array: Optional[List[int]] = None,\n    model_name: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    asset_external_id_array: Optional[List[str]] = None,\n    disable_tqdm: bool = False,\n) -&gt; List:\n\"\"\"Append labels to assets.\n\n    Args:\n        asset_id_array: list of asset internal ids to append labels on.\n        json_response_array: list of labels to append.\n        author_id_array: list of the author id of the labels.\n        seconds_to_label_array: list of times taken to produce the label, in seconds.\n        model_name: Name of the model that generated the labels.\n            Only useful when uploading PREDICTION or INFERENCE labels.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        project_id: Identifier of the project.\n        asset_external_id_array: list of asset external ids to append labels on.\n        disable_tqdm: Disable tqdm progress bar.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_labels(\n                asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'],\n                json_response_array=[{...}, {...}]\n            )\n    \"\"\"\n    if len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one label to upload\"\n        )\n    check_asset_identifier_arguments(project_id, asset_id_array, asset_external_id_array)\n    assert_all_arrays_have_same_size(\n        [\n            seconds_to_label_array,\n            author_id_array,\n            json_response_array,\n            asset_external_id_array,\n            asset_id_array,\n        ]\n    )\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n            \"seconds_to_label\": seconds_to_label,\n            \"author_id\": author_id,\n        }\n        for (asset_id, asset_external_id, json_response, seconds_to_label, author_id) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                asset_external_id_array or [None] * len(json_response_array),\n                json_response_array,\n                seconds_to_label_array or [None] * len(json_response_array),\n                author_id_array or [None] * len(json_response_array),\n            )\n        )\n    ]\n    return services.import_labels_from_dict(\n        self, project_id, labels, label_type, model_name, disable_tqdm\n    )\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.mutations.label.__init__.MutationsLabel.append_to_labels","title":"<code>append_to_labels(self, json_response, author_id=None, label_asset_external_id=None, label_asset_id=None, label_type='DEFAULT', project_id=None, seconds_to_label=0)</code>","text":"<p>[DEPRECATED]</p> <p>append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster.</p> <p>Append a label to an asset.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>Label is given here.</p> required <code>author_id</code> <code>Optional[str]</code> <p>ID of the author of the label.</p> <code>None</code> <code>label_asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset.</p> <code>None</code> <code>label_asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project.</p> <code>None</code> <code>label_type</code> <code>typing_extensions.Literal['AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW', 'INFERENCE']</code> <p>Can be one of <code>AUTOSAVE</code>, <code>DEFAULT</code>, <code>PREDICTION</code>, <code>REVIEW</code> or <code>INFERENCE</code>.</p> <code>'DEFAULT'</code> <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label.</p> <code>0</code> <p>Warning</p> <p>Either provide <code>label_asset_id</code> or <code>label_asset_external_id</code> and <code>project_id</code></p> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n</code></pre> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>@deprecate(\n    msg=(\n        \"append_to_labels method is deprecated. Please use append_labels instead. This new\"\n        \" function allows to import several labels 10 times faster.\"\n    )\n)\n@typechecked\ndef append_to_labels(\n    self,\n    json_response: dict,\n    author_id: Optional[str] = None,\n    label_asset_external_id: Optional[str] = None,\n    label_asset_id: Optional[str] = None,\n    label_type: LabelType = \"DEFAULT\",\n    project_id: Optional[str] = None,\n    seconds_to_label: Optional[int] = 0,\n):\n\"\"\"!!! danger \"[DEPRECATED]\"\n        append_to_labels method is deprecated. Please use append_labels instead.\n        This new function allows to import several labels 10 times faster.\n\n    Append a label to an asset.\n\n    Args:\n        json_response: Label is given here.\n        author_id: ID of the author of the label.\n        label_asset_external_id: External identifier of the asset.\n        label_asset_id: Identifier of the asset.\n        project_id: Identifier of the project.\n        label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE`.\n        seconds_to_label: Time to create the label.\n\n    !!! warning\n        Either provide `label_asset_id` or `label_asset_external_id` and `project_id`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_labels(label_asset_id=asset_id, json_response={...})\n    \"\"\"\n    if author_id is None:\n        user = self.get_user()  # type: ignore  # pylint: disable=no-member\n        author_id = user[\"id\"]\n\n    check_asset_identifier_arguments(\n        project_id,\n        [label_asset_id] if label_asset_id else None,\n        [label_asset_external_id] if label_asset_external_id else None,\n    )\n    if label_asset_id is None:\n        assert label_asset_external_id and project_id\n        label_asset_id = infer_ids_from_external_ids(\n            self, [label_asset_external_id], project_id\n        )[label_asset_external_id]\n    variables = {\n        \"data\": {\n            \"authorID\": author_id,\n            \"jsonResponse\": dumps(json_response),\n            \"labelType\": label_type,\n            \"secondsToLabel\": seconds_to_label,\n        },\n        \"where\": {\"id\": label_asset_id},\n    }\n    result = self.graphql_client.execute(GQL_APPEND_TO_LABELS, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.mutations.label.__init__.MutationsLabel.create_honeypot","title":"<code>create_honeypot(self, json_response, asset_external_id=None, asset_id=None, project_id=None)</code>","text":"<p>Create honeypot for an asset.</p> <p>Info</p> <p>Uses the given <code>json_response</code> to create a <code>REVIEW</code> label. This enables Kili to compute a<code>honeypotMark</code>, which measures the similarity between this label and other labels.</p> <p>Parameters:</p> Name Type Description Default <code>json_response</code> <code>dict</code> <p>The JSON response of the honeypot label of the asset.</p> required <code>asset_id</code> <code>Optional[str]</code> <p>Identifier of the asset. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <code>asset_external_id</code> <code>Optional[str]</code> <p>External identifier of the asset. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Identifier of the project. Either provide <code>asset_id</code> or <code>asset_external_id</code> and <code>project_id</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_honeypot(\n    self,\n    json_response: dict,\n    asset_external_id: Optional[str] = None,\n    asset_id: Optional[str] = None,\n    project_id: Optional[str] = None,\n) -&gt; Label:\n\"\"\"Create honeypot for an asset.\n\n    !!! info\n        Uses the given `json_response` to create a `REVIEW` label.\n        This enables Kili to compute a`honeypotMark`,\n        which measures the similarity between this label and other labels.\n\n    Args:\n        json_response: The JSON response of the honeypot label of the asset.\n        asset_id: Identifier of the asset.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n        asset_external_id: External identifier of the asset.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n        project_id: Identifier of the project.\n            Either provide `asset_id` or `asset_external_id` and `project_id`.\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    if asset_id is None:\n        if asset_external_id is None or project_id is None:\n            raise ValueError(\n                \"Either provide `asset_id` or `asset_external_id` and `project_id`.\"\n            )\n        asset_id = infer_ids_from_external_ids(self, [asset_external_id], project_id)[\n            asset_external_id\n        ]\n\n    variables = {\n        \"data\": {\"jsonResponse\": dumps(json_response)},\n        \"where\": {\"id\": asset_id},\n    }\n    result = self.graphql_client.execute(GQL_CREATE_HONEYPOT, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.mutations.label.__init__.MutationsLabel.create_predictions","title":"<code>create_predictions(self, project_id, external_id_array=None, model_name_array=None, json_response_array=None, model_name=None, asset_id_array=None, disable_tqdm=False)</code>","text":"<p>Create predictions for specific assets.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>external_id_array</code> <code>Optional[List[str]]</code> <p>The external IDs of the assets for which we want to add predictions.</p> <code>None</code> <code>model_name_array</code> <code>Optional[List[str]]</code> <p>Deprecated, use <code>model_name</code> instead.</p> <code>None</code> <code>json_response_array</code> <code>Optional[List[dict]]</code> <p>The predictions are given here. For examples, see the recipe.</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>The name of the model that generated the predictions</p> <code>None</code> <code>asset_id_array</code> <code>Optional[List[str]]</code> <p>The internal IDs of the assets for which we want to add predictions.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable tqdm progress bar.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Recipe</p> <p>For more detailed examples on how to create predictions, see the recipe.</p> <p>model name</p> <p>The use of <code>model_name_array</code> is deprecated. Creating predictions from different models is not supported anymore. Please use <code>model_name</code> argument instead to provide the predictions model name.</p> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef create_predictions(\n    self,\n    project_id: str,\n    external_id_array: Optional[List[str]] = None,\n    model_name_array: Optional[List[str]] = None,\n    json_response_array: Optional[List[dict]] = None,\n    model_name: Optional[str] = None,\n    asset_id_array: Optional[List[str]] = None,\n    disable_tqdm: bool = False,\n) -&gt; Dict:\n    # pylint: disable=line-too-long\n\"\"\"Create predictions for specific assets.\n\n    Args:\n        project_id: Identifier of the project.\n        external_id_array: The external IDs of the assets for which we want to add predictions.\n        model_name_array: Deprecated, use `model_name` instead.\n        json_response_array: The predictions are given here. For examples,\n            see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n        model_name: The name of the model that generated the predictions\n        asset_id_array: The internal IDs of the assets for which we want to add predictions.\n        disable_tqdm: Disable tqdm progress bar.\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions).\n\n    !!! warning \"model name\"\n        The use of `model_name_array` is deprecated. Creating predictions from different\n        models is not supported anymore. Please use `model_name` argument instead to\n        provide the predictions model name.\n    \"\"\"\n    if json_response_array is None or len(json_response_array) == 0:\n        raise ValueError(\n            \"json_response_array is empty, you must provide at least one prediction to upload\"\n        )\n    assert_all_arrays_have_same_size(\n        [external_id_array, json_response_array, model_name_array, asset_id_array]\n    )\n    if model_name is None:\n        if model_name_array is None:\n            raise ValueError(\"You must provide a model name with the model_name argument \")\n        if len(set(model_name_array)) &gt; 1:\n            raise ValueError(\n                \"Creating predictions from different models is not supported anymore. Separate\"\n                \" your calls by models.\"\n            )\n        warnings.warn(\n            (\n                \"The use of `model_name_array` is deprecated. Creating predictions from\"\n                \" different models is not supported anymore. Please use `model_name` argument\"\n                \" instead to provide the predictions model name.\"\n            ),\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        model_name = model_name_array[0]\n\n    labels = [\n        {\n            \"asset_id\": asset_id,\n            \"asset_external_id\": asset_external_id,\n            \"json_response\": json_response,\n        }\n        for (asset_id, asset_external_id, json_response) in list(\n            zip(\n                asset_id_array or [None] * len(json_response_array),\n                external_id_array or [None] * len(json_response_array),\n                json_response_array,\n            )\n        )\n    ]\n    services.import_labels_from_dict(\n        self, project_id, labels, \"PREDICTION\", model_name, disable_tqdm\n    )\n    return {\"id\": project_id}\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.mutations.label.__init__.MutationsLabel.update_properties_in_label","title":"<code>update_properties_in_label(self, label_id, seconds_to_label=None, model_name=None, json_response=None)</code>","text":"<p>Update properties of a label.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>Identifier of the label</p> required <code>seconds_to_label</code> <code>Optional[int]</code> <p>Time to create the label</p> <code>None</code> <code>model_name</code> <code>Optional[str]</code> <p>Name of the model</p> <code>None</code> <code>json_response</code> <code>Optional[dict]</code> <p>The label is given here</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n</code></pre> Source code in <code>kili/entrypoints/mutations/label/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_label(\n    self,\n    label_id: str,\n    seconds_to_label: Optional[int] = None,\n    model_name: Optional[str] = None,\n    json_response: Optional[dict] = None,\n) -&gt; Label:\n\"\"\"Update properties of a label.\n\n    Args:\n        label_id: Identifier of the label\n        seconds_to_label: Time to create the label\n        model_name: Name of the model\n        json_response: The label is given here\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_label(label_id=label_id, json_response={...})\n    \"\"\"\n    formatted_json_response = None if json_response is None else dumps(json_response)\n    variables = {\n        \"labelID\": label_id,\n        \"secondsToLabel\": seconds_to_label,\n        \"modelName\": model_name,\n        \"jsonResponse\": formatted_json_response,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_LABEL, variables)\n    return format_result(\"data\", result, Label)\n</code></pre>"},{"location":"sdk/label/#subscriptions","title":"Subscriptions","text":"<p>Set of Label subscriptions.</p> Source code in <code>kili/entrypoints/subscriptions/label/__init__.py</code> <pre><code>class SubscriptionsLabel:\n\"\"\"Set of Label subscriptions.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def label_created_or_updated(\n        self, project_id: str, callback: Callable[[str, str], None]\n    ) -&gt; SubscriptionGraphQLClient:\n        # pylint: disable=line-too-long\n\"\"\"Subscribe a callback to a project, which is executed when a label is created or updated.\n\n        Args:\n            project_id: Identifier of the project\n            callback: This function takes as input the id of the asset and its content.\n\n        Returns:\n            A subscription client.\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to use Webhooks,\n            See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/webhooks.ipynb)\n        \"\"\"\n        ws_endpoint = self.graphql_client.endpoint.replace(\"http\", \"ws\")\n        websocket = SubscriptionGraphQLClient(ws_endpoint)\n        headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n        authorization = f\"X-API-Key: {self.api_key}\"  # type: ignore  # pylint: disable=no-member\n        headers[\"Authorization\"] = authorization\n        variables = {\"projectID\": project_id}\n        websocket.subscribe(\n            GQL_LABEL_CREATED_OR_UPDATED,\n            variables=variables,\n            callback=callback,\n            headers=headers,\n            authorization=authorization,\n        )\n        return websocket\n</code></pre>"},{"location":"sdk/label/#kili.entrypoints.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","title":"<code>label_created_or_updated(self, project_id, callback)</code>","text":"<p>Subscribe a callback to a project, which is executed when a label is created or updated.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>callback</code> <code>Callable[[str, str], NoneType]</code> <p>This function takes as input the id of the asset and its content.</p> required <p>Returns:</p> Type Description <code>SubscriptionGraphQLClient</code> <p>A subscription client.</p> <p>Recipe</p> <p>For more detailed examples on how to use Webhooks, See the related recipe</p> Source code in <code>kili/entrypoints/subscriptions/label/__init__.py</code> <pre><code>@typechecked\ndef label_created_or_updated(\n    self, project_id: str, callback: Callable[[str, str], None]\n) -&gt; SubscriptionGraphQLClient:\n    # pylint: disable=line-too-long\n\"\"\"Subscribe a callback to a project, which is executed when a label is created or updated.\n\n    Args:\n        project_id: Identifier of the project\n        callback: This function takes as input the id of the asset and its content.\n\n    Returns:\n        A subscription client.\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to use Webhooks,\n        See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/webhooks.ipynb)\n    \"\"\"\n    ws_endpoint = self.graphql_client.endpoint.replace(\"http\", \"ws\")\n    websocket = SubscriptionGraphQLClient(ws_endpoint)\n    headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n    authorization = f\"X-API-Key: {self.api_key}\"  # type: ignore  # pylint: disable=no-member\n    headers[\"Authorization\"] = authorization\n    variables = {\"projectID\": project_id}\n    websocket.subscribe(\n        GQL_LABEL_CREATED_OR_UPDATED,\n        variables=variables,\n        callback=callback,\n        headers=headers,\n        authorization=authorization,\n    )\n    return websocket\n</code></pre>"},{"location":"sdk/label_parsing/","title":"Label parsing module","text":"<p>The module <code>kili.utils.labels.parsing</code> provides a <code>ParsedLabel</code> class that is used to parse labels.</p> <p>Using labels as <code>ParsedLabel</code> instances is recommended when manipulating the label data, as it will provide autocompletion to access the meaningful fields of the label. If you prefer not to use it, you can still access the labeling data through the label dictionaries.</p> <p>Read more about this feature in the label parsing tutorial.</p> <p>Warning</p> <p>This feature is currently in beta. The classes and methods can still change marginally.</p>"},{"location":"sdk/label_parsing/#parsedlabel","title":"ParsedLabel","text":"<p>Class that represents a parsed label.</p> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>class ParsedLabel(Dict):\n\"\"\"Class that represents a parsed label.\"\"\"\n\n    def __init__(self, label: Dict, json_interface: Dict, input_type: InputType) -&gt; None:\n        # pylint: disable=line-too-long\n\"\"\"Class that represents a parsed label.\n\n        The class behaves like a dict but adds the attribute `.jobs`.\n\n        The original input label passed to this class is not modified.\n\n        Args:\n            label: Label to parse.\n            json_interface: Json interface of the project.\n            input_type: Type of assets of the project.\n\n        !!! Example\n            ```python\n            from kili.utils.labels.parsing import ParsedLabel\n\n            my_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\n            my_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n            # Access the job \"JOB_0\" data through the attribute \".jobs\":\n            print(my_parsed_label.jobs[\"JOB_0\"])\n            ```\n\n        !!! info\n            More information about the label parsing can be found in this [tutorial](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n        \"\"\"\n        label_copy = deepcopy(label)\n        json_response = label_copy.pop(\"jsonResponse\", {})\n\n        super().__init__(label_copy)\n\n        project_info = Project(inputType=input_type, jsonInterface=json_interface[\"jobs\"])\n\n        self.jobs = json_response_module.ParsedJobs(\n            project_info=project_info, json_response=json_response\n        )\n\n    def to_dict(self) -&gt; Dict:\n\"\"\"Returns a copy of the parsed label as a dict.\n\n        !!! Example\n            ```python\n            my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n            # Convert back to native Python dictionary\n            my_label_as_dict = label.to_dict()\n\n            assert isinstance(my_label_as_dict, dict)  # True\n            ```\n        \"\"\"\n        ret = {k: deepcopy(v) for k, v in self.items() if k != \"jsonResponse\"}\n        ret[\"jsonResponse\"] = self.json_response\n        return ret\n\n    def __repr__(self) -&gt; str:\n\"\"\"Returns the representation of the object.\"\"\"\n        return repr(self.to_dict())\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the object.\"\"\"\n        return str(self.to_dict())\n\n    @property\n    def json_response(self) -&gt; Dict:\n\"\"\"Returns a copy of the json response of the parsed label.\"\"\"\n        return self.jobs.to_dict()\n</code></pre>"},{"location":"sdk/label_parsing/#kili.utils.labels.parsing.ParsedLabel.__init__","title":"<code>__init__(self, label, json_interface, input_type)</code>  <code>special</code>","text":"<p>Class that represents a parsed label.</p> <p>The class behaves like a dict but adds the attribute <code>.jobs</code>.</p> <p>The original input label passed to this class is not modified.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label to parse.</p> required <code>json_interface</code> <code>Dict</code> <p>Json interface of the project.</p> required <code>input_type</code> <code>typing_extensions.Literal['AUDIO', 'IMAGE', 'PDF', 'TEXT', 'TIME_SERIES', 'VIDEO', 'VIDEO_LEGACY']</code> <p>Type of assets of the project.</p> required <p>Example</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n\nmy_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\nmy_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n# Access the job \"JOB_0\" data through the attribute \".jobs\":\nprint(my_parsed_label.jobs[\"JOB_0\"])\n</code></pre> <p>Info</p> <p>More information about the label parsing can be found in this tutorial.</p> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>def __init__(self, label: Dict, json_interface: Dict, input_type: InputType) -&gt; None:\n    # pylint: disable=line-too-long\n\"\"\"Class that represents a parsed label.\n\n    The class behaves like a dict but adds the attribute `.jobs`.\n\n    The original input label passed to this class is not modified.\n\n    Args:\n        label: Label to parse.\n        json_interface: Json interface of the project.\n        input_type: Type of assets of the project.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.parsing import ParsedLabel\n\n        my_label = kili.labels(\"project_id\")[0]  # my_label is a dict\n\n        my_parsed_label = ParsedLabel(my_label, json_interface, input_type)  # ParsedLabel object\n\n        # Access the job \"JOB_0\" data through the attribute \".jobs\":\n        print(my_parsed_label.jobs[\"JOB_0\"])\n        ```\n\n    !!! info\n        More information about the label parsing can be found in this [tutorial](https://python-sdk-docs.kili-technology.com/latest/sdk/tutorials/label_parsing/).\n    \"\"\"\n    label_copy = deepcopy(label)\n    json_response = label_copy.pop(\"jsonResponse\", {})\n\n    super().__init__(label_copy)\n\n    project_info = Project(inputType=input_type, jsonInterface=json_interface[\"jobs\"])\n\n    self.jobs = json_response_module.ParsedJobs(\n        project_info=project_info, json_response=json_response\n    )\n</code></pre>"},{"location":"sdk/label_parsing/#kili.utils.labels.parsing.ParsedLabel.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Returns a copy of the parsed label as a dict.</p> <p>Example</p> <pre><code>my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n# Convert back to native Python dictionary\nmy_label_as_dict = label.to_dict()\n\nassert isinstance(my_label_as_dict, dict)  # True\n</code></pre> Source code in <code>kili/utils/labels/parsing.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n\"\"\"Returns a copy of the parsed label as a dict.\n\n    !!! Example\n        ```python\n        my_parsed_label = ParsedLabel(my_dict_label, json_interface, input_type)\n\n        # Convert back to native Python dictionary\n        my_label_as_dict = label.to_dict()\n\n        assert isinstance(my_label_as_dict, dict)  # True\n        ```\n    \"\"\"\n    ret = {k: deepcopy(v) for k, v in self.items() if k != \"jsonResponse\"}\n    ret[\"jsonResponse\"] = self.json_response\n    return ret\n</code></pre>"},{"location":"sdk/label_parsing/#task-specific-attributes-and-methods","title":"Task specific attributes and methods","text":""},{"location":"sdk/label_parsing/#classification-tasks","title":"Classification tasks","text":"<p>For classification tasks, the following attributes are available:</p>"},{"location":"sdk/label_parsing/#categories","title":"<code>.categories</code>","text":"<p>Returns a <code>CategoryList</code> object that contains the categories of an asset.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].categories\n</code></pre>"},{"location":"sdk/label_parsing/#category","title":"<code>.category</code>","text":"<p>Returns a <code>Category</code> object that contains the category of an asset.</p> <p>Only available if the classification job is a one-class classification job.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category\n# Same as:\nlabel.jobs[\"CLASSIF_JOB\"].categories[0]\n</code></pre>"},{"location":"sdk/label_parsing/#name","title":"<code>.name</code>","text":"<p>Retrieves the category name.</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category.name\n</code></pre>"},{"location":"sdk/label_parsing/#confidence","title":"<code>.confidence</code>","text":"<p>Retrieves the confidence (when available).</p> <pre><code>label.jobs[\"CLASSIF_JOB\"].category.confidence\n</code></pre>"},{"location":"sdk/label_parsing/#transcription-tasks","title":"Transcription tasks","text":""},{"location":"sdk/label_parsing/#text","title":"<code>.text</code>","text":"<p>Retrieves the transcription text.</p> <pre><code>label.jobs[\"TRANSCRIPTION_JOB\"].text\n</code></pre>"},{"location":"sdk/label_parsing/#object-detection-tasks","title":"Object detection tasks","text":"<p>For more information about the different object detection tasks and their label formats, please refer to the Kili documentation.</p>"},{"location":"sdk/label_parsing/#standard-object-detection","title":"Standard object detection","text":""},{"location":"sdk/label_parsing/#bounding_poly","title":"<code>.bounding_poly</code>","text":"<p>Returns a list of bounding polygons for an annotation.</p> <pre><code>label.jobs[\"DETECTION_JOB\"].annotations[0].bounding_poly\n</code></pre>"},{"location":"sdk/label_parsing/#normalized_vertices","title":"<code>.normalized_vertices</code>","text":"<p>Returns a list of normalized vertices for a bounding polygon.</p> <pre><code>label.jobs[\"DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n</code></pre>"},{"location":"sdk/label_parsing/#bounding_poly_annotations","title":"<code>.bounding_poly_annotations</code>","text":"<p>This attribute is an alias for <code>.annotations</code>.</p> <p>The benefit of using this attribute is that it will only show in your IDE autocompletions the attributes that are relevant for the object detection task.</p> <pre><code># the .content attribute is not relevant for object detection tasks!\n\n# IDE autocompletion will accept this attribute, but will crash at runtime\nlabel.jobs[\"BBOX_JOB\"].annotations.content\n\n# IDE autocompletion will not display this attribute and Python linter will raise an error\nlabel.jobs[\"BBOX_JOB\"].bounding_poly_annotations.content\n</code></pre>"},{"location":"sdk/label_parsing/#point-detection","title":"Point detection","text":""},{"location":"sdk/label_parsing/#point","title":"<code>.point</code>","text":"<p>Returns the <code>x</code> and <code>y</code> coordinates of the point.</p> <pre><code>label.jobs[\"POINT_JOB\"].annotations[0].point\n</code></pre>"},{"location":"sdk/label_parsing/#line-detection","title":"Line detection","text":""},{"location":"sdk/label_parsing/#polyline","title":"<code>.polyline</code>","text":"<p>Returns the list of points for a line annotation.</p> <pre><code>label.jobs[\"LINE_JOB\"].annotations[0].polyline\n</code></pre>"},{"location":"sdk/label_parsing/#pose-estimation","title":"Pose estimation","text":""},{"location":"sdk/label_parsing/#points","title":"<code>.points</code>","text":"<p>Returns the list of points for an annotation.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points\n</code></pre>"},{"location":"sdk/label_parsing/#point_1","title":"<code>.point</code>","text":"<p>Returns the point data.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point\n</code></pre>"},{"location":"sdk/label_parsing/#pointpoint","title":"<code>.point.point</code>","text":"<p>Returns a dictionary with the coordinates of the point.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.point\n</code></pre>"},{"location":"sdk/label_parsing/#code","title":"<code>.code</code>","text":"<p>Returns the point identifier (unique for each point in an object).</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.code\n</code></pre>"},{"location":"sdk/label_parsing/#name_1","title":"<code>.name</code>","text":"<p>Returns the point name.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.name\n</code></pre>"},{"location":"sdk/label_parsing/#job_name","title":"<code>.job_name</code>","text":"<p>Returns the job which annotated point belongs to.</p> <pre><code>label.jobs[\"POSE_JOB\"].annotations[0].points[0].point.job_name\n</code></pre>"},{"location":"sdk/label_parsing/#video-tasks","title":"Video tasks","text":""},{"location":"sdk/label_parsing/#frames","title":"<code>.frames</code>","text":"<p>Returns a list of parsed label data for a each frame.</p> <pre><code>label.jobs[\"FRAME_CLASSIF_JOB\"].frames\nlabel.jobs[\"FRAME_CLASSIF_JOB\"].frames[5]  # 6th frame\n\n# get category name of the 6th frame (for a frame classification job only)\nlabel.jobs[\"FRAME_CLASSIF_JOB\"].frames[5].category.name\n</code></pre>"},{"location":"sdk/label_parsing/#named-entities-recognition-tasks","title":"Named entities recognition tasks","text":""},{"location":"sdk/label_parsing/#content","title":"<code>.content</code>","text":"<p>Returns the content of the mention.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].content\n</code></pre>"},{"location":"sdk/label_parsing/#begin_offset","title":"<code>.begin_offset</code>","text":"<p>Returns the position of the first character of the mention in the text.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].begin_offset\n</code></pre>"},{"location":"sdk/label_parsing/#end_offet","title":"<code>.end_offet</code>","text":"<p>When available, returns the position of the last character of the mention in the text.</p> <pre><code>label.jobs[\"NER_JOB\"].annotations[0].end_offset\n</code></pre>"},{"location":"sdk/label_parsing/#entity_annotations","title":"<code>.entity_annotations</code>","text":"<p>This attribute is an alias for <code>.annotations</code>.</p> <p>The benefit of using this attribute is that it will only show in your IDE autocompletions the attributes that are relevant for the NER task.</p> <pre><code># the .points attribute is not relevant for NER tasks, it is only used for pose estimation tasks!\n\n# IDE autocompletion will accept this attribute, but will crash at runtime\nlabel.jobs[\"NER_JOB\"].annotations.points\n\n# IDE autocompletion will not display this attribute and Python linter will raise an error\nlabel.jobs[\"NER_JOB\"].entity_annotations.points\n</code></pre>"},{"location":"sdk/label_parsing/#named-entities-recognition-in-pdfs-tasks","title":"Named entities recognition in PDFs tasks","text":""},{"location":"sdk/label_parsing/#content_1","title":"<code>.content</code>","text":"<p>Returns the content of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].content\n</code></pre>"},{"location":"sdk/label_parsing/#annotations","title":"<code>.annotations</code>","text":"<p>NER in PDFs annotations have an additional layer of annotations. See the documentation for more information.</p>"},{"location":"sdk/label_parsing/#polys","title":"<code>.polys</code>","text":"<p>Returns a list of dictionaries containing the normalized vertices of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].polys\n</code></pre>"},{"location":"sdk/label_parsing/#page_number_array","title":"<code>.page_number_array</code>","text":"<pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].page_number_array\n</code></pre>"},{"location":"sdk/label_parsing/#bounding_poly_1","title":"<code>.bounding_poly</code>","text":"<p>Returns a list of dictionaries containing the normalized vertices of the mention.</p> <pre><code>label.jobs[\"NER_PDF_JOB\"].annotations[0].annotations[0].bounding_poly\n</code></pre>"},{"location":"sdk/label_parsing/#relation-tasks","title":"Relation tasks","text":""},{"location":"sdk/label_parsing/#named-entities-relation","title":"Named entities relation","text":""},{"location":"sdk/label_parsing/#start_entities","title":"<code>.start_entities</code>","text":"<p>Returns a list of dictionaries containing the start entities Ids of the relation.</p> <pre><code>label.jobs[\"NER_RELATION_JOB\"].annotations[0].start_entities\n</code></pre>"},{"location":"sdk/label_parsing/#end_entities","title":"<code>.end_entities</code>","text":"<p>Returns a list of dictionaries containing the end entities Ids of the relation.</p> <pre><code>label.jobs[\"NER_RELATION_JOB\"].annotations[0].end_entities\n</code></pre>"},{"location":"sdk/label_parsing/#object-detection-relation","title":"Object detection relation","text":""},{"location":"sdk/label_parsing/#start_objects","title":"<code>.start_objects</code>","text":"<p>Returns a list of dictionaries containing the start objects Ids of the relation.</p> <pre><code>label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].start_objects\n</code></pre>"},{"location":"sdk/label_parsing/#end_objects","title":"<code>.end_objects</code>","text":"<p>Returns a list of dictionaries containing the end objects Ids of the relation.</p> <pre><code>label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].end_objects\n</code></pre>"},{"location":"sdk/label_parsing/#children-tasks","title":"Children tasks","text":""},{"location":"sdk/label_parsing/#children","title":"<code>.children</code>","text":"<p>Depending on the task, the <code>.children</code> attribute can be found in different places:</p> <pre><code># For cassification task\nlabel.jobs[\"CLASSIF_JOB\"].category.children\n\n# For several kinds of tasks: object detection, NER, pose estimation, etc.\nlabel.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].children\n</code></pre> <p>You can find more information about the children jobs in the Kili documentation.</p>"},{"location":"sdk/label_parsing/#migrating-from-jsonreponse-format","title":"Migrating from jsonReponse format","text":"<p>In most cases, the attributes of a parsed label are the snake case version of the keys present in the json response.</p> <p>For example, with a NER (named entities recognition) label, you can access the <code>beginOffset</code> data of an annotation with <code>parsed_label.jobs[\"NER_JOB\"].annotations[0].begin_offset</code>.</p> <p>The different json response keys are listed in the Kili documentation:</p> <ul> <li>for classification tasks</li> <li>for exported object/entity detection and relation tasks</li> <li>for exported transcription tasks.</li> </ul>"},{"location":"sdk/label_utils/","title":"Label utils module","text":"<p>The module <code>kili.utils.labels</code> provides a set of helpers to convert point, bounding box, polygon and segmentation labels.</p> <p>Info</p> <p>In Kili json response format, a normalized vertex is a dictionary with keys <code>x</code> and <code>y</code> and values between <code>0</code> and <code>1</code>. The origin is always the top left corner of the image. The x-axis is horizontal and the y-axis is vertical with the y-axis pointing down. You can find more information about the Kili data format here.</p>"},{"location":"sdk/label_utils/#points","title":"Points","text":"<p><code>kili.utils.labels.point</code></p> <p>Helpers to create point annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.point.normalized_point_to_point","title":"<code>normalized_point_to_point(point, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Convert a Kili normalized vertex to a 2D point.</p> <p>It is the inverse of the method <code>point_to_normalized_point</code>.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input point:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>Conventions for the output point:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>If the image width and height are provided, the output point coordinates will be scaled to the image size. If not, the method will return a point with normalized coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, float]</code> <p>Point to convert.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the point is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the point is defined in.</p> <code>None</code> <code>origin_location</code> <code>typing_extensions.Literal['top_left', 'bottom_left']</code> <p>Location of the origin of output point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['x', 'y'], float]</code> <p>A dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels.</p> Source code in <code>kili/utils/labels/point.py</code> <pre><code>def normalized_point_to_point(\n    point: Dict[str, float],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[Literal[\"x\", \"y\"], float]:\n    # pylint: disable=line-too-long\n\"\"\"Convert a Kili normalized vertex to a 2D point.\n\n    It is the inverse of the method `point_to_normalized_point`.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input point:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    Conventions for the output point:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    If the image width and height are provided, the output point coordinates will be scaled to the image size.\n    If not, the method will return a point with normalized coordinates.\n\n    Args:\n        point: Point to convert.\n        img_width: Width of the image the point is defined in.\n        img_height: Height of the image the point is defined in.\n        origin_location: Location of the origin of output point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels.\n    \"\"\"\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    if origin_location == \"bottom_left\":\n        point = {\"x\": point[\"x\"], \"y\": 1 - point[\"y\"]}\n\n    img_height = img_height or 1\n    img_width = img_width or 1\n\n    return {\"x\": point[\"x\"] * img_width, \"y\": point[\"y\"] * img_height}\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.point.point_to_normalized_point","title":"<code>point_to_normalized_point(point, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a 2D point to a Kili normalized vertex.</p> <p>The output can be used to create object detection annotations. See the documentation for more details.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input point:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>Conventions for the output point:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>If the image width and height are provided, the input point coordinates will be normalized to <code>[0, 1]</code>. If not, the method expects the input point coordinates to be already normalized.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Dict[str, Union[int, float]]</code> <p>Point to convert.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the point is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the point is defined in.</p> <code>None</code> <code>origin_location</code> <code>typing_extensions.Literal['top_left', 'bottom_left']</code> <p>Location of the origin of input point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['x', 'y'], float]</code> <p>A dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding normalized values.</p> <p>Example</p> <pre><code>from kili.utils.labels.point import point_to_normalized_point\n\nnormalized_point = point_to_normalized_point({\"x\": 5, \"y\": 40}, img_width=100, img_height=100)\n\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"point\": normalized_point,\n                \"categories\": [{\"name\": \"CLASS_A\"}],\n                \"type\": \"marker\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/point.py</code> <pre><code>def point_to_normalized_point(\n    point: Dict[str, Union[int, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[Literal[\"x\", \"y\"], float]:\n    # pylint: disable=line-too-long\n\"\"\"Converts a 2D point to a Kili normalized vertex.\n\n    The output can be used to create object detection annotations. See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation) for more details.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input point:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    Conventions for the output point:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    If the image width and height are provided, the input point coordinates will be normalized to `[0, 1]`.\n    If not, the method expects the input point coordinates to be already normalized.\n\n    Args:\n        point: Point to convert.\n        img_width: Width of the image the point is defined in.\n        img_height: Height of the image the point is defined in.\n        origin_location: Location of the origin of input point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"x\"` and `\"y\"`, and corresponding normalized values.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.point import point_to_normalized_point\n\n        normalized_point = point_to_normalized_point({\"x\": 5, \"y\": 40}, img_width=100, img_height=100)\n\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"point\": normalized_point,\n                        \"categories\": [{\"name\": \"CLASS_A\"}],\n                        \"type\": \"marker\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    if img_width is not None and img_height is not None:\n        point = {\n            \"x\": point[\"x\"] / img_width,\n            \"y\": point[\"y\"] / img_height,\n        }\n\n    if origin_location == \"bottom_left\":\n        point = {\"x\": point[\"x\"], \"y\": 1 - point[\"y\"]}\n\n    assert 0 &lt;= point[\"x\"] &lt;= 1, f\"Point x coordinate {point['x']} should be in [0, 1].\"\n    assert 0 &lt;= point[\"y\"] &lt;= 1, f\"Point y coordinate {point['y']} should be in [0, 1].\"\n\n    return {\"x\": point[\"x\"], \"y\": point[\"y\"]}\n</code></pre>"},{"location":"sdk/label_utils/#bounding-boxes","title":"Bounding boxes","text":"<p><code>kili.utils.labels.bbox</code></p> <p>Helpers to create boundingPoly rectangle annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.bbox.bbox_points_to_normalized_vertices","title":"<code>bbox_points_to_normalized_vertices(*, bottom_left, bottom_right, top_right, top_left, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a bounding box defined by its 4 points to normalized vertices.</p> <p>The output can be used to create a boundingPoly rectangle annotation. See the documentation for more details.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input points:</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>Conventions for the output vertices:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>If the image width and height are provided, the input point coordinates will be normalized to <code>[0, 1]</code>. If not, the method expects the input points' coordinates to be already normalized.</p> <p>Parameters:</p> Name Type Description Default <code>bottom_left</code> <code>Dict[str, Union[int, float]]</code> <p>Bottom left point of the bounding box.</p> required <code>bottom_right</code> <code>Dict[str, Union[int, float]]</code> <p>Bottom right point of the bounding box.</p> required <code>top_right</code> <code>Dict[str, Union[int, float]]</code> <p>Top right point of the bounding box.</p> required <code>top_left</code> <code>Dict[str, Union[int, float]]</code> <p>Top left point of the bounding box.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the bounding box is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the bounding box is defined in.</p> <code>None</code> <code>origin_location</code> <code>typing_extensions.Literal['top_left', 'bottom_left']</code> <p>Location of the origin of input point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>List[Dict[typing_extensions.Literal['x', 'y'], float]]</code> <p>A list of normalized vertices.</p> <p>Example</p> <pre><code>from kili.utils.labels.bbox import bbox_points_to_normalized_vertices\n\ninputs = {\n    bottom_left = {\"x\": 0, \"y\": 0},\n    bottom_right = {\"x\": 10, \"y\": 0},\n    top_right = {\"x\": 10, \"y\": 10},\n    top_left = {\"x\": 0, \"y\": 10},\n    img_width = 100,\n    img_height = 100,\n}\nnormalized_vertices = bbox_points_to_normalized_vertices(**inputs)\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [{\"normalizedVertices\": normalized_vertices}],\n                \"categories\": [{\"name\": \"CLASS_A\"}],\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/bbox.py</code> <pre><code>def bbox_points_to_normalized_vertices(\n    *,\n    bottom_left: Dict[str, Union[int, float]],\n    bottom_right: Dict[str, Union[int, float]],\n    top_right: Dict[str, Union[int, float]],\n    top_left: Dict[str, Union[int, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; List[Dict[Literal[\"x\", \"y\"], float]]:\n    # pylint: disable=line-too-long\n\"\"\"Converts a bounding box defined by its 4 points to normalized vertices.\n\n    The output can be used to create a boundingPoly rectangle annotation. See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation#standard-object-detection) for more details.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input points:\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    Conventions for the output vertices:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    If the image width and height are provided, the input point coordinates will be normalized to `[0, 1]`.\n    If not, the method expects the input points' coordinates to be already normalized.\n\n    Args:\n        bottom_left: Bottom left point of the bounding box.\n        bottom_right: Bottom right point of the bounding box.\n        top_right: Top right point of the bounding box.\n        top_left: Top left point of the bounding box.\n        img_width: Width of the image the bounding box is defined in.\n        img_height: Height of the image the bounding box is defined in.\n        origin_location: Location of the origin of input point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A list of normalized vertices.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.bbox import bbox_points_to_normalized_vertices\n\n        inputs = {\n            bottom_left = {\"x\": 0, \"y\": 0},\n            bottom_right = {\"x\": 10, \"y\": 0},\n            top_right = {\"x\": 10, \"y\": 10},\n            top_left = {\"x\": 0, \"y\": 10},\n            img_width = 100,\n            img_height = 100,\n        }\n        normalized_vertices = bbox_points_to_normalized_vertices(**inputs)\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"boundingPoly\": [{\"normalizedVertices\": normalized_vertices}],\n                        \"categories\": [{\"name\": \"CLASS_A\"}],\n                        \"type\": \"rectangle\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    assert bottom_left[\"x\"] &lt;= bottom_right[\"x\"], \"bottom_left.x must be &lt;= bottom_right.x\"\n    assert top_left[\"x\"] &lt;= top_right[\"x\"], \"top_left.x must be &lt;= top_right.x\"\n    if origin_location == \"bottom_left\":\n        assert bottom_left[\"y\"] &lt;= top_left[\"y\"], \"bottom_left.y must be &lt;= top_left.y\"\n        assert bottom_right[\"y\"] &lt;= top_right[\"y\"], \"bottom_right.y must be &lt;= top_right.y\"\n    elif origin_location == \"top_left\":\n        assert bottom_left[\"y\"] &gt;= top_left[\"y\"], \"bottom_left.y must be &gt;= top_left.y\"\n        assert bottom_right[\"y\"] &gt;= top_right[\"y\"], \"bottom_right.y must be &gt;= top_right.y\"\n\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    vertices = [\n        point_to_normalized_point(\n            point, img_width=img_width, img_height=img_height, origin_location=origin_location\n        )\n        for point in (bottom_left, top_left, top_right, bottom_right)\n    ]\n\n    return vertices\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.bbox.normalized_vertices_to_bbox_points","title":"<code>normalized_vertices_to_bbox_points(normalized_vertices, img_width=None, img_height=None, origin_location='bottom_left')</code>","text":"<p>Converts a rectangle normalizedVertices annotation to a bounding box defined by 4 points.</p> <p>It is the inverse of the method <code>bbox_points_to_normalized_vertices</code>.</p> <p>A point is a dict with keys <code>\"x\"</code> and <code>\"y\"</code>, and corresponding values in pixels (<code>int</code> or <code>float</code>).</p> <p>Conventions for the input vertices:</p> <ul> <li>The origin is the top left corner of the image.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical and goes from top to bottom.</li> </ul> <p>Conventions for the output points (<code>top_left</code>, <code>bottom_left</code>, <code>bottom_right</code>, <code>top_right</code>):</p> <ul> <li>The origin is defined by the <code>origin_location</code> argument.</li> <li>x-axis is horizontal and goes from left to right.</li> <li>y-axis is vertical. If <code>origin_location</code> is <code>\"top_left\"</code>, it goes from top to bottom. If <code>origin_location</code> is <code>\"bottom_left\"</code>, it goes from bottom to top.</li> </ul> <p>If the image width and height are provided, the output point coordinates will be scaled to the image size. If not, the method will return the output points' coordinates normalized to <code>[0, 1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>normalized_vertices</code> <code>List[Dict[str, float]]</code> <p>A list of normalized vertices.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the bounding box is defined in.</p> <code>None</code> <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the bounding box is defined in.</p> <code>None</code> <code>origin_location</code> <code>typing_extensions.Literal['top_left', 'bottom_left']</code> <p>Location of the origin of output point coordinate system. Can be either <code>top_left</code> or <code>bottom_left</code>.</p> <code>'bottom_left'</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['top_left', 'bottom_left', 'bottom_right', 'top_right'], Dict[typing_extensions.Literal['x', 'y'], float]]</code> <p>A dict with keys <code>\"top_left\"</code>, <code>\"bottom_left\"</code>, <code>\"bottom_right\"</code>, <code>\"top_right\"</code>, and corresponding points.</p> <p>Example</p> <pre><code>from kili.utils.labels.bbox import normalized_vertices_to_bbox_points\n\n# if using raw dict label:\nnormalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n# if using parsed label:\nnormalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\nimg_height, img_width = 1080, 1920\nbbox_points = normalized_vertices_to_bbox_points(normalized_vertices, img_width, img_height)\n</code></pre> Source code in <code>kili/utils/labels/bbox.py</code> <pre><code>def normalized_vertices_to_bbox_points(\n    normalized_vertices: List[Dict[str, float]],\n    img_width: Optional[Union[int, float]] = None,\n    img_height: Optional[Union[int, float]] = None,\n    origin_location: Literal[\"top_left\", \"bottom_left\"] = \"bottom_left\",\n) -&gt; Dict[\n    Literal[\"top_left\", \"bottom_left\", \"bottom_right\", \"top_right\"], Dict[Literal[\"x\", \"y\"], float]\n]:\n    # pylint: disable=line-too-long\n\"\"\"Converts a rectangle normalizedVertices annotation to a bounding box defined by 4 points.\n\n    It is the inverse of the method `bbox_points_to_normalized_vertices`.\n\n    A point is a dict with keys `\"x\"` and `\"y\"`, and corresponding values in pixels (`int` or `float`).\n\n    Conventions for the input vertices:\n\n    - The origin is the top left corner of the image.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical and goes from top to bottom.\n\n    Conventions for the output points (`top_left`, `bottom_left`, `bottom_right`, `top_right`):\n\n    - The origin is defined by the `origin_location` argument.\n    - x-axis is horizontal and goes from left to right.\n    - y-axis is vertical. If `origin_location` is `\"top_left\"`, it goes from top to bottom. If `origin_location` is `\"bottom_left\"`, it goes from bottom to top.\n\n    If the image width and height are provided, the output point coordinates will be scaled to the image size.\n    If not, the method will return the output points' coordinates normalized to `[0, 1]`.\n\n    Args:\n        normalized_vertices: A list of normalized vertices.\n        img_width: Width of the image the bounding box is defined in.\n        img_height: Height of the image the bounding box is defined in.\n        origin_location: Location of the origin of output point coordinate system. Can be either `top_left` or `bottom_left`.\n\n    Returns:\n        A dict with keys `\"top_left\"`, `\"bottom_left\"`, `\"bottom_right\"`, `\"top_right\"`, and corresponding points.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.bbox import normalized_vertices_to_bbox_points\n\n        # if using raw dict label:\n        normalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n        # if using parsed label:\n        normalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\n        img_height, img_width = 1080, 1920\n        bbox_points = normalized_vertices_to_bbox_points(normalized_vertices, img_width, img_height)\n        ```\n    \"\"\"\n    if len(normalized_vertices) != 4:\n        raise ValueError(f\"normalized_vertices must have length 4. Got {len(normalized_vertices)}.\")\n\n    if (img_width is None) != (img_height is None):\n        raise ValueError(\"img_width and img_height must be both None or both not None.\")\n\n    img_height = img_height or 1\n    img_width = img_width or 1\n\n    ret = {}\n\n    for vertex, point_name in zip(\n        normalized_vertices, (\"bottom_left\", \"top_left\", \"top_right\", \"bottom_right\")\n    ):\n        ret[point_name] = normalized_point_to_point(\n            vertex, img_width=img_width, img_height=img_height, origin_location=origin_location\n        )\n\n    return ret\n</code></pre>"},{"location":"sdk/label_utils/#polygon-and-segmentation-masks","title":"Polygon and segmentation masks","text":"<p><code>kili.utils.labels.image</code></p> <p>OpenCV</p> <p>It is recommended to install the image dependencies to use the image helpers. <pre><code>pip install kili[image-utils]\n</code></pre></p> <p>Helpers to create boundingPoly polygon and semantic annotations.</p>"},{"location":"sdk/label_utils/#kili.utils.labels.image.mask_to_normalized_vertices","title":"<code>mask_to_normalized_vertices(image)</code>","text":"<p>Converts a binary mask to a list of normalized vertices using OpenCV cv2.findContours.</p> <p>The output can be used to create \"boundingPoly\" polygon or semantic annotations. See the documentation for more details.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Binary mask. Should be an array of shape (height, width) with values in {0, 255}.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>A tuple containing a list of normalized vertices and the hierarchy of the contours (see OpenCV documentation).</p> <p>Example</p> <pre><code>import urllib.request\nimport cv2\nfrom kili.utils.labels.image import mask_to_normalized_vertices\n\nmask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\nurllib.request.urlretrieve(mask_url, \"mask.png\")\n\nimg = cv2.imread(\"mask.png\")[:, :, 0]  # keep only height and width\nimg[200:220, 200:220] = 0  # add a hole in the mask to test the hierarchy\n\ncontours, hierarchy = mask_to_normalized_vertices(img)\n# hierarchy tells us that the first contour is the outer contour\n# and the second one is the inner contour\n\njson_response = {\n    \"OBJECT_DETECTION_JOB\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\"normalizedVertices\": contours[0]},  # outer contour\n                    {\"normalizedVertices\": contours[1]},  # inner contour\n                ],\n                \"categories\": [{\"name\": \"A\"}],\n                \"type\": \"semantic\",\n            }\n        ]\n    }\n}\n</code></pre> Source code in <code>kili/utils/labels/image.py</code> <pre><code>def mask_to_normalized_vertices(\n    image: np.ndarray,\n) -&gt; Tuple[List[List[Dict[str, float]]], np.ndarray]:\n    # pylint: disable=line-too-long\n\"\"\"Converts a binary mask to a list of normalized vertices using OpenCV [cv2.findContours](https://docs.opencv.org/4.7.0/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0).\n\n    The output can be used to create \"boundingPoly\" polygon or semantic annotations.\n    See the [documentation](https://docs.kili-technology.com/reference/export-object-entity-detection-and-relation#standard-object-detection) for more details.\n\n    Args:\n        image: Binary mask. Should be an array of shape (height, width) with values in {0, 255}.\n\n    Returns:\n        Tuple: A tuple containing a list of normalized vertices and the hierarchy of the contours (see [OpenCV documentation](https://docs.opencv.org/4.7.0/d9/d8b/tutorial_py_contours_hierarchy.html)).\n\n    !!! Example\n        ```python\n        import urllib.request\n        import cv2\n        from kili.utils.labels.image import mask_to_normalized_vertices\n\n        mask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\n        urllib.request.urlretrieve(mask_url, \"mask.png\")\n\n        img = cv2.imread(\"mask.png\")[:, :, 0]  # keep only height and width\n        img[200:220, 200:220] = 0  # add a hole in the mask to test the hierarchy\n\n        contours, hierarchy = mask_to_normalized_vertices(img)\n        # hierarchy tells us that the first contour is the outer contour\n        # and the second one is the inner contour\n\n        json_response = {\n            \"OBJECT_DETECTION_JOB\": {\n                \"annotations\": [\n                    {\n                        \"boundingPoly\": [\n                            {\"normalizedVertices\": contours[0]},  # outer contour\n                            {\"normalizedVertices\": contours[1]},  # inner contour\n                        ],\n                        \"categories\": [{\"name\": \"A\"}],\n                        \"type\": \"semantic\",\n                    }\n                ]\n            }\n        }\n        ```\n    \"\"\"\n    if image.ndim &gt; 2:\n        raise ValueError(f\"Image should be a 2D array, got {image.ndim}D array\")\n\n    unique_values = np.unique(image).tolist()\n    if not all(value in [0, 255] for value in unique_values):\n        raise ValueError(f\"Image should be binary with values in {{0, 255}}, got {unique_values}\")\n\n    img_height, img_width = image.shape\n    # pylint:disable=no-member\n    contours, hierarchy = cv2.findContours(image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)  # type: ignore\n\n    contours = [\n        _opencv_contour_to_normalized_vertices(contour, img_width, img_height)\n        for contour in contours\n    ]\n    hierarchy = hierarchy[0]\n\n    return contours, hierarchy\n</code></pre>"},{"location":"sdk/label_utils/#kili.utils.labels.image.normalized_vertices_to_mask","title":"<code>normalized_vertices_to_mask(normalized_vertices, img_width, img_height)</code>","text":"<p>Converts a Kili label with normalized vertices to a binary mask.</p> <p>It is the inverse of the method <code>mask_to_normalized_vertices</code>.</p> <p>Parameters:</p> Name Type Description Default <code>normalized_vertices</code> <code>List[Dict[str, float]]</code> <p>A list of normalized vertices.</p> required <code>img_width</code> <code>Union[int, float]</code> <p>Width of the image the segmentation is defined in.</p> required <code>img_height</code> <code>Union[int, float]</code> <p>Height of the image the segmentation is defined in.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array of shape (height, width) with values in {0, 255}.</p> <p>Example</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n\n# if using raw dict label:\nnormalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n# if using parsed label:\nnormalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\nimg_height, img_width = 1080, 1920\nmask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\nplt.imshow(mask)\nplt.show()\n</code></pre> Source code in <code>kili/utils/labels/image.py</code> <pre><code>def normalized_vertices_to_mask(\n    normalized_vertices: List[Dict[str, float]],\n    img_width: Union[int, float],\n    img_height: Union[int, float],\n) -&gt; np.ndarray:\n    # pylint: disable=line-too-long\n\"\"\"Converts a Kili label with normalized vertices to a binary mask.\n\n    It is the inverse of the method `mask_to_normalized_vertices`.\n\n    Args:\n        normalized_vertices: A list of normalized vertices.\n        img_width: Width of the image the segmentation is defined in.\n        img_height: Height of the image the segmentation is defined in.\n\n    Returns:\n        A numpy array of shape (height, width) with values in {0, 255}.\n\n    !!! Example\n        ```python\n        from kili.utils.labels.image import normalized_vertices_to_mask\n\n        # if using raw dict label:\n        normalized_vertices = label[\"jsonResponse\"][\"OBJECT_DETECTION_JOB\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"]\n\n        # if using parsed label:\n        normalized_vertices = label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices\n\n        img_height, img_width = 1080, 1920\n        mask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\n        plt.imshow(mask)\n        plt.show()\n        ```\n    \"\"\"\n    mask = np.zeros((img_height, img_width), dtype=np.uint8)\n    polygon = [\n        [\n            int(round(vertice[\"x\"] * img_width)),\n            int(round(vertice[\"y\"] * img_height)),\n        ]\n        for vertice in normalized_vertices\n    ]\n    polygon = np.array([polygon])\n    cv2.fillPoly(img=mask, pts=polygon, color=255)  # type: ignore  # pylint:disable=no-member\n    return mask\n</code></pre>"},{"location":"sdk/notification/","title":"Notification module","text":""},{"location":"sdk/notification/#queries","title":"Queries","text":"<p>Set of Notification queries.</p> Source code in <code>kili/entrypoints/queries/notification/__init__.py</code> <pre><code>class QueriesNotification:\n\"\"\"Set of Notification queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def notifications(\n        self,\n        fields: List[str] = [\n            \"createdAt\",\n            \"hasBeenSeen\",\n            \"id\",\n            \"message\",\n            \"status\",\n            \"userID\",\n        ],\n        first: Optional[int] = None,\n        has_been_seen: Optional[bool] = None,\n        notification_id: Optional[str] = None,\n        skip: int = 0,\n        user_id: Optional[str] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n        Args:\n            fields: All the fields to request among the possible fields for the notifications\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n            first: Number of notifications to query\n            has_been_seen: If the notifications returned should have been seen.\n            notification_id: If given, will return the notification which has this id\n            skip: Number of notifications to skip (they are ordered by their date of creation,\n                first to last).\n            user_id: If given, returns the notifications of a specific user\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the notifications is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n\n        where = NotificationWhere(\n            has_been_seen=has_been_seen,\n            notification_id=notification_id,\n            user_id=user_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        notifications_gen = NotificationQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return notifications_gen\n        return list(notifications_gen)\n\n    @typechecked\n    def count_notifications(\n        self,\n        has_been_seen: Optional[bool] = None,\n        user_id: Optional[str] = None,\n        notification_id: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Count the number of notifications.\n\n        Args:\n            has_been_seen: Filter on notifications that have been seen.\n            user_id: Filter on the notifications of a specific user.\n            notification_id: Filter on a specific notification.\n\n        Returns:\n            The number of notifications with the parameters provided\n        \"\"\"\n        where = NotificationWhere(\n            has_been_seen=has_been_seen,\n            notification_id=notification_id,\n            user_id=user_id,\n        )\n        return NotificationQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/notification/#kili.entrypoints.queries.notification.__init__.QueriesNotification.count_notifications","title":"<code>count_notifications(self, has_been_seen=None, user_id=None, notification_id=None)</code>","text":"<p>Count the number of notifications.</p> <p>Parameters:</p> Name Type Description Default <code>has_been_seen</code> <code>Optional[bool]</code> <p>Filter on notifications that have been seen.</p> <code>None</code> <code>user_id</code> <code>Optional[str]</code> <p>Filter on the notifications of a specific user.</p> <code>None</code> <code>notification_id</code> <code>Optional[str]</code> <p>Filter on a specific notification.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of notifications with the parameters provided</p> Source code in <code>kili/entrypoints/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef count_notifications(\n    self,\n    has_been_seen: Optional[bool] = None,\n    user_id: Optional[str] = None,\n    notification_id: Optional[str] = None,\n) -&gt; int:\n\"\"\"Count the number of notifications.\n\n    Args:\n        has_been_seen: Filter on notifications that have been seen.\n        user_id: Filter on the notifications of a specific user.\n        notification_id: Filter on a specific notification.\n\n    Returns:\n        The number of notifications with the parameters provided\n    \"\"\"\n    where = NotificationWhere(\n        has_been_seen=has_been_seen,\n        notification_id=notification_id,\n        user_id=user_id,\n    )\n    return NotificationQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/notification/#kili.entrypoints.queries.notification.__init__.QueriesNotification.notifications","title":"<code>notifications(self, fields=['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'], first=None, has_been_seen=None, notification_id=None, skip=0, user_id=None, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of notifications respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the notifications See the documentation for all possible fields.</p> <code>['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID']</code> <code>first</code> <code>Optional[int]</code> <p>Number of notifications to query</p> <code>None</code> <code>has_been_seen</code> <code>Optional[bool]</code> <p>If the notifications returned should have been seen.</p> <code>None</code> <code>notification_id</code> <code>Optional[str]</code> <p>If given, will return the notification which has this id</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of notifications to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>user_id</code> <code>Optional[str]</code> <p>If given, returns the notifications of a specific user</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the notifications is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/entrypoints/queries/notification/__init__.py</code> <pre><code>@typechecked\ndef notifications(\n    self,\n    fields: List[str] = [\n        \"createdAt\",\n        \"hasBeenSeen\",\n        \"id\",\n        \"message\",\n        \"status\",\n        \"userID\",\n    ],\n    first: Optional[int] = None,\n    has_been_seen: Optional[bool] = None,\n    notification_id: Optional[str] = None,\n    skip: int = 0,\n    user_id: Optional[str] = None,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of notifications respecting a set of criteria.\n\n    Args:\n        fields: All the fields to request among the possible fields for the notifications\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields.\n        first: Number of notifications to query\n        has_been_seen: If the notifications returned should have been seen.\n        notification_id: If given, will return the notification which has this id\n        skip: Number of notifications to skip (they are ordered by their date of creation,\n            first to last).\n        user_id: If given, returns the notifications of a specific user\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the notifications is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n\n    where = NotificationWhere(\n        has_been_seen=has_been_seen,\n        notification_id=notification_id,\n        user_id=user_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    notifications_gen = NotificationQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return notifications_gen\n    return list(notifications_gen)\n</code></pre>"},{"location":"sdk/organization/","title":"Organization module","text":""},{"location":"sdk/organization/#queries","title":"Queries","text":"<p>Set of Organization queries.</p> Source code in <code>kili/entrypoints/queries/organization/__init__.py</code> <pre><code>class QueriesOrganization:\n\"\"\"Set of Organization queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def organizations(\n        self,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"id\", \"name\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n            fields: All the fields to request among the possible fields for the organizations.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n            first: Maximum number of organizations to return.\n            skip: Number of skipped organizations (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the organizations is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n            [{'users': [{'email': 'john@doe.com'}]}]\n        \"\"\"\n        where = OrganizationWhere(\n            email=email,\n            organization_id=organization_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        organizations_gen = OrganizationQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return organizations_gen\n        return list(organizations_gen)\n\n    @typechecked\n    def count_organizations(\n        self, email: Optional[str] = None, organization_id: Optional[str] = None\n    ) -&gt; int:\n\"\"\"Count organizations that match a set of criteria.\n\n        Args:\n            email: Email of a user of the organization\n            organization_id: Identifier of the organization\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        where = OrganizationWhere(\n            email=email,\n            organization_id=organization_id,\n        )\n        return OrganizationQuery(self.graphql_client).count(where)\n\n    @typechecked\n    def organization_metrics(\n        self,\n        organization_id: str,\n        start_date: Optional[datetime] = None,\n        end_date: Optional[datetime] = None,\n    ) -&gt; Dict:\n\"\"\"Get organization metrics.\n\n        Args:\n            organization_id: Identifier of the organization\n            start_date: Start date of the metrics computation\n            end_date: End date of the metrics computation\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        if start_date is None:\n            start_date = datetime.now()\n        if end_date is None:\n            end_date = datetime.now()\n        where = OrganizationMetricsWhere(\n            organization_id=organization_id, start_date=start_date, end_date=end_date\n        )\n        return OrganizationQuery(self.graphql_client).metrics(where)\n</code></pre>"},{"location":"sdk/organization/#kili.entrypoints.queries.organization.__init__.QueriesOrganization.count_organizations","title":"<code>count_organizations(self, email=None, organization_id=None)</code>","text":"<p>Count organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/entrypoints/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef count_organizations(\n    self, email: Optional[str] = None, organization_id: Optional[str] = None\n) -&gt; int:\n\"\"\"Count organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    where = OrganizationWhere(\n        email=email,\n        organization_id=organization_id,\n    )\n    return OrganizationQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/organization/#kili.entrypoints.queries.organization.__init__.QueriesOrganization.organization_metrics","title":"<code>organization_metrics(self, organization_id, start_date=None, end_date=None)</code>","text":"<p>Get organization metrics.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>str</code> <p>Identifier of the organization</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Start date of the metrics computation</p> <code>None</code> <code>end_date</code> <code>Optional[datetime.datetime]</code> <p>End date of the metrics computation</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/entrypoints/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organization_metrics(\n    self,\n    organization_id: str,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n) -&gt; Dict:\n\"\"\"Get organization metrics.\n\n    Args:\n        organization_id: Identifier of the organization\n        start_date: Start date of the metrics computation\n        end_date: End date of the metrics computation\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    if start_date is None:\n        start_date = datetime.now()\n    if end_date is None:\n        end_date = datetime.now()\n    where = OrganizationMetricsWhere(\n        organization_id=organization_id, start_date=start_date, end_date=end_date\n    )\n    return OrganizationQuery(self.graphql_client).metrics(where)\n</code></pre>"},{"location":"sdk/organization/#kili.entrypoints.queries.organization.__init__.QueriesOrganization.organizations","title":"<code>organizations(self, email=None, organization_id=None, fields=['id', 'name'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of organizations that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of a user of the organization</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the organizations. See the documentation for all possible fields.</p> <code>['id', 'name']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of organizations to return.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped organizations (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the organizations is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n[{'users': [{'email': 'john@doe.com'}]}]\n</code></pre> Source code in <code>kili/entrypoints/queries/organization/__init__.py</code> <pre><code>@typechecked\ndef organizations(\n    self,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"id\", \"name\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of organizations that match a set of criteria.\n\n    Args:\n        email: Email of a user of the organization\n        organization_id: Identifier of the organization\n        fields: All the fields to request among the possible fields for the organizations.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields.\n        first: Maximum number of organizations to return.\n        skip: Number of skipped organizations (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the organizations is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.organizations(organization_id=organization_id, fields=['users.email'])\n        [{'users': [{'email': 'john@doe.com'}]}]\n    \"\"\"\n    where = OrganizationWhere(\n        email=email,\n        organization_id=organization_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    organizations_gen = OrganizationQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return organizations_gen\n    return list(organizations_gen)\n</code></pre>"},{"location":"sdk/plugins/","title":"Plugin module","text":""},{"location":"sdk/plugins/#plugins-structure","title":"Plugins structure","text":"<p>A plugin is an uploaded Python script triggered by an event. It can be defined as either :</p> <ul> <li>a single <code>python</code> file with everything inside</li> <li>a plugin module (a folder) containing multiple <code>python</code> files and a non mandatory <code>requirements.txt</code> file listing all the dependencies you need for you plugin.</li> </ul> <p>In the case of the module type plugin, at the root of the folder a file named <code>main.py</code> is strictly necessary, as it serves as the entrypoint of the plugin. In this <code>main.py</code> file, you can import what you need from other <code>python</code> files in the folder. The structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file):</p> <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre> <p>The plugin you are going to upload has to contain a <code>class PluginHandler(PluginCore)</code> (in the case of the module type plugin it has to be inside <code>main.py</code>) that implements two methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted (a dictionary containing the fields of the GraphQL type Label)</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>You can add custom methods in your class as well.</p> <p>Moreover, some attributes are directly available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin (of <code>main.py</code> in the case of the module type plugin) should look like this:</p> <pre><code>from typing import Dict\nimport numpy as np\n\nfrom kili.plugins import PluginCore\n\ndef custom_function():\n    # Do something...\n\nclass PluginHandler(PluginCore):\n\"\"\"Custom plugin\"\"\"\n\n    def custom_method(self):\n        # Do something...\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Note</p> <p>The plugins run has some limitations, it can use a maximum of 512 MB of ram and will timeout after 60 sec of run.</p>"},{"location":"sdk/plugins/#model-for-plugins","title":"Model for Plugins","text":"<p>Kili Plugin core class.</p> <p>Parameters:</p> Name Type Description Default <code>kili</code> <code>Kili</code> <p>kili instance that plugins can make use of</p> required <code>project_id</code> <code>str</code> <p>the project on which plugin is ran</p> required <p>Implements:</p> <pre><code>on_submit(self, label: Dict, asset_id: str)\non_review(self, label: Dict, asset_id: str)\non_custom_interface_click(self, label: Dict, asset_id: str):\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore--warning-if-using-a-custom-init-be-sure-to-call-superinit","title":"Warning : if using a custom init, be sure to call super().init()","text":"Source code in <code>kili/services/plugins/model.py</code> <pre><code>class PluginCore:\n\"\"\"Kili Plugin core class.\n\n    Args:\n        kili: kili instance that plugins can make use of\n        project_id: the project on which plugin is ran\n\n    Implements:\n\n        on_submit(self, label: Dict, asset_id: str)\n        on_review(self, label: Dict, asset_id: str)\n        on_custom_interface_click(self, label: Dict, asset_id: str):\n\n    # Warning : if using a custom init, be sure to call super().__init__()\n    \"\"\"\n\n    logger: logging.Logger\n    kili: Kili\n    project_id: str\n\n    def __init__(\n        self, kili: Kili, project_id: str, logger: Optional[logging.Logger] = None\n    ) -&gt; None:\n        self.kili = kili\n        self.project_id = project_id\n        if logger:\n            self.logger = logger\n        else:\n            self.logger = get_logger()\n\n    def on_submit(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n\"\"\"Handler for the submit action, triggered when a default label is submitted into Kili.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n                `secondsToLabel`, `isSentBackToQueue`, `search` and some technical fields:\n                `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n                `isLatestLabelForUser`, `isLatestDefaultLabelForUser`, `readPermissionsFromProject`.\n            asset_id: Id of the asset on which the label was submitted\n\n        Example use:\n\n            &gt;&gt;&gt; def on_submit(self, label: Dict, asset_id: str):\n            &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n            &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n            &gt;&gt;&gt;         return\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n        pass  # pylint: disable=unnecessary-pass\n\n    def on_review(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n\"\"\"Handler for the review action, triggered when a default label is reviewed on Kili.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n                `secondsToLabel`, `isSentBackToQueue`, `search` and `reviewedLabel` (dictionary\n                that has a field `id` representing the id of the original label that was reviewed).\n                It also contains some technical fields: `createdAt`, `updatedAt`, `version`,\n                `isLatestReviewLabelForUser`, `isLatestLabelForUser`, `isLatestDefaultLabelForUser`,\n                `readPermissionsFromProject`.\n            asset_id: Id of the asset on which the label was submitted\n\n        Example use:\n\n            &gt;&gt;&gt; def on_review(self, label: Dict, asset_id: str):\n            &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n            &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n            &gt;&gt;&gt;         return\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n        pass  # pylint: disable=unnecessary-pass\n\n    def on_custom_interface_click(\n        self,\n        label: Dict,\n        asset_id: str,\n    ) -&gt; None:\n\"\"\"Handler for the custom interface click action.\n\n        **Warning**: This handler is in beta and is still in active development,\n        it should be used with caution.\n\n        Args:\n            label: Label submitted to Kili: a dictionary containing the following fields:\n                `id`, `jsonResponse`.\n            asset_id: id of the asset on which the action is called\n\n        Example use:\n\n            &gt;&gt;&gt; def on_custom_interface_click(self, label: Dict, asset_id: str):\n            &gt;&gt;&gt;     json_response = label.get('jsonResponse')`\n            &gt;&gt;&gt;     label_id = label.get('id')\n            &gt;&gt;&gt;     issue = label_is_respecting_business_rule(json_response)\n            &gt;&gt;&gt;     if !issue:\n            &gt;&gt;&gt;         return\n            &gt;&gt;&gt;     else:\n            &gt;&gt;&gt;         self.kili.create_issues(\n                            project_id=self.project_id,\n                            label_id_array=[label_id],\n                            text_array=[issue]\n                        )\n        \"\"\"\n        # pylint: disable=unused-argument\n        self.logger.warning(\"Handler is in active development.\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_custom_interface_click","title":"<code>on_custom_interface_click(self, label, asset_id)</code>","text":"<p>Handler for the custom interface click action.</p> <p>Warning: This handler is in beta and is still in active development, it should be used with caution.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>jsonResponse</code>.</p> required <code>asset_id</code> <code>str</code> <p>id of the asset on which the action is called</p> required <p>Example use:</p> <pre><code>&gt;&gt;&gt; def on_custom_interface_click(self, label: Dict, asset_id: str):\n&gt;&gt;&gt;     json_response = label.get('jsonResponse')`\n&gt;&gt;&gt;     label_id = label.get('id')\n&gt;&gt;&gt;     issue = label_is_respecting_business_rule(json_response)\n&gt;&gt;&gt;     if !issue:\n&gt;&gt;&gt;         return\n&gt;&gt;&gt;     else:\n&gt;&gt;&gt;         self.kili.create_issues(\n                project_id=self.project_id,\n                label_id_array=[label_id],\n                text_array=[issue]\n            )\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_custom_interface_click(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n\"\"\"Handler for the custom interface click action.\n\n    **Warning**: This handler is in beta and is still in active development,\n    it should be used with caution.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `jsonResponse`.\n        asset_id: id of the asset on which the action is called\n\n    Example use:\n\n        &gt;&gt;&gt; def on_custom_interface_click(self, label: Dict, asset_id: str):\n        &gt;&gt;&gt;     json_response = label.get('jsonResponse')`\n        &gt;&gt;&gt;     label_id = label.get('id')\n        &gt;&gt;&gt;     issue = label_is_respecting_business_rule(json_response)\n        &gt;&gt;&gt;     if !issue:\n        &gt;&gt;&gt;         return\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         self.kili.create_issues(\n                        project_id=self.project_id,\n                        label_id_array=[label_id],\n                        text_array=[issue]\n                    )\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Handler is in active development.\")\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_review","title":"<code>on_review(self, label, asset_id)</code>","text":"<p>Handler for the review action, triggered when a default label is reviewed on Kili.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>labelType</code>, <code>numberOfAnnotations</code>, <code>authorId</code>, <code>modelName</code>, <code>jsonResponse</code>, <code>secondsToLabel</code>, <code>isSentBackToQueue</code>, <code>search</code> and <code>reviewedLabel</code> (dictionary that has a field <code>id</code> representing the id of the original label that was reviewed). It also contains some technical fields: <code>createdAt</code>, <code>updatedAt</code>, <code>version</code>, <code>isLatestReviewLabelForUser</code>, <code>isLatestLabelForUser</code>, <code>isLatestDefaultLabelForUser</code>, <code>readPermissionsFromProject</code>.</p> required <code>asset_id</code> <code>str</code> <p>Id of the asset on which the label was submitted</p> required <p>Example use:</p> <pre><code>&gt;&gt;&gt; def on_review(self, label: Dict, asset_id: str):\n&gt;&gt;&gt;     json_response = label.get('jsonResponse')\n&gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n&gt;&gt;&gt;         return\n&gt;&gt;&gt;     else:\n&gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_review(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n\"\"\"Handler for the review action, triggered when a default label is reviewed on Kili.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n            `secondsToLabel`, `isSentBackToQueue`, `search` and `reviewedLabel` (dictionary\n            that has a field `id` representing the id of the original label that was reviewed).\n            It also contains some technical fields: `createdAt`, `updatedAt`, `version`,\n            `isLatestReviewLabelForUser`, `isLatestLabelForUser`, `isLatestDefaultLabelForUser`,\n            `readPermissionsFromProject`.\n        asset_id: Id of the asset on which the label was submitted\n\n    Example use:\n\n        &gt;&gt;&gt; def on_review(self, label: Dict, asset_id: str):\n        &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n        &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n        &gt;&gt;&gt;         return\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_review on your plugin\")\n    pass  # pylint: disable=unnecessary-pass\n</code></pre>"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_submit","title":"<code>on_submit(self, label, asset_id)</code>","text":"<p>Handler for the submit action, triggered when a default label is submitted into Kili.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Dict</code> <p>Label submitted to Kili: a dictionary containing the following fields: <code>id</code>, <code>labelType</code>, <code>numberOfAnnotations</code>, <code>authorId</code>, <code>modelName</code>, <code>jsonResponse</code>, <code>secondsToLabel</code>, <code>isSentBackToQueue</code>, <code>search</code> and some technical fields: <code>createdAt</code>, <code>updatedAt</code>, <code>version</code>, <code>isLatestReviewLabelForUser</code>, <code>isLatestLabelForUser</code>, <code>isLatestDefaultLabelForUser</code>, <code>readPermissionsFromProject</code>.</p> required <code>asset_id</code> <code>str</code> <p>Id of the asset on which the label was submitted</p> required <p>Example use:</p> <pre><code>&gt;&gt;&gt; def on_submit(self, label: Dict, asset_id: str):\n&gt;&gt;&gt;     json_response = label.get('jsonResponse')\n&gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n&gt;&gt;&gt;         return\n&gt;&gt;&gt;     else:\n&gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> Source code in <code>kili/services/plugins/model.py</code> <pre><code>def on_submit(\n    self,\n    label: Dict,\n    asset_id: str,\n) -&gt; None:\n\"\"\"Handler for the submit action, triggered when a default label is submitted into Kili.\n\n    Args:\n        label: Label submitted to Kili: a dictionary containing the following fields:\n            `id`, `labelType`, `numberOfAnnotations`, `authorId`, `modelName`, `jsonResponse`,\n            `secondsToLabel`, `isSentBackToQueue`, `search` and some technical fields:\n            `createdAt`, `updatedAt`, `version`, `isLatestReviewLabelForUser`,\n            `isLatestLabelForUser`, `isLatestDefaultLabelForUser`, `readPermissionsFromProject`.\n        asset_id: Id of the asset on which the label was submitted\n\n    Example use:\n\n        &gt;&gt;&gt; def on_submit(self, label: Dict, asset_id: str):\n        &gt;&gt;&gt;     json_response = label.get('jsonResponse')\n        &gt;&gt;&gt;     if label_is_respecting_business_rule(json_response):\n        &gt;&gt;&gt;         return\n        &gt;&gt;&gt;     else:\n        &gt;&gt;&gt;         self.kili.send_back_to_queue(asset_ids=[asset_id])\n    \"\"\"\n    # pylint: disable=unused-argument\n    self.logger.warning(\"Method not implemented. Define a custom on_submit on your plugin\")\n    pass  # pylint: disable=unnecessary-pass\n</code></pre>"},{"location":"sdk/plugins/#queries","title":"Queries","text":"<p>Set of Plugins queries.</p> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>class QueriesPlugins:\n\"\"\"Set of Plugins queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments\n\n    @typechecked\n    def get_plugin_build_errors(\n        self,\n        plugin_name: str,\n        start_date: Optional[datetime] = None,\n        limit: int = 100,\n        skip: int = 0,\n    ) -&gt; str:\n        # pylint: disable=line-too-long\n\"\"\"Get paginated build errors of a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n            start_date: Datetime used to get the build errors from, if not provided, it will be the plugin's creation date\n            limit: Limit for pagination, if not provided, it will be 100\n            skip: Skip for pagination, if not provided, it will be 0\n        Returns:\n            A result array which contains the build errors of the plugin,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n        \"\"\"\n\n        where = PluginBuildErrorsWhere(plugin_name=plugin_name, start_date=start_date)\n        options = QueryOptions(\n            first=limit, skip=skip, disable_tqdm=False\n        )  # disable tqm is not implemented for this query\n        pretty_result = PluginQuery(self.graphql_client).get_build_errors(where, options)\n        return json.dumps(pretty_result, sort_keys=True, indent=4)\n\n    @typechecked\n    def get_plugin_logs(\n        self,\n        project_id: str,\n        plugin_name: str,\n        start_date: Optional[datetime] = None,\n        limit: int = 100,\n        skip: int = 0,\n    ) -&gt; str:\n        # pylint: disable=line-too-long\n\"\"\"Get paginated logs of a plugin on a project.\n\n        Args:\n            project_id: Identifier of the project\n            plugin_name: Name of the plugin\n            start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n            limit: Limit for pagination, if not provided, it will be 100\n            skip: Skip for pagination, if not provided, it will be 0\n        Returns:\n            A result array which contains the logs of the plugin,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n        \"\"\"\n\n        where = PluginLogsWhere(\n            project_id=project_id, plugin_name=plugin_name, start_date=start_date\n        )\n        options = QueryOptions(\n            first=limit, skip=skip, disable_tqdm=False\n        )  # disable tqm is not implemented for this query\n        pretty_result = PluginQuery(self.graphql_client).get_logs(where, options)\n        return json.dumps(pretty_result, sort_keys=True, indent=4)\n\n    @typechecked\n    def get_plugin_status(\n        self,\n        plugin_name: str,\n        verbose: bool = True,\n    ):\n\"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            The status of the plugin if query was successful or an error message otherwise.\n\n        Examples:\n            &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n        \"\"\"\n\n        result = PluginUploader(self, \"\", plugin_name, verbose).get_plugin_runner_status()\n        return result\n\n    # pylint: disable=dangerous-default-value\n    @typechecked\n    def list_plugins(\n        self,\n        fields: List[str] = [\n            \"name\",\n            \"projectIds\",\n            \"id\",\n            \"createdAt\",\n            \"updatedAt\",\n        ],\n    ):\n        # pylint: disable=line-too-long\n\"\"\"List all plugins from your organization\n        Args:\n            fields: All the fields to request among the possible fields for the plugins\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields.\n\n        Returns:\n            A result array which contains all the plugins from your organization,\n                or an error message.\n        Examples:\n            &gt;&gt;&gt; kili.list_plugins()\n            &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n        \"\"\"\n        return PluginQuery(self.graphql_client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_build_errors","title":"<code>get_plugin_build_errors(self, plugin_name, start_date=None, limit=100, skip=0)</code>","text":"<p>Get paginated build errors of a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Datetime used to get the build errors from, if not provided, it will be the plugin's creation date</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit for pagination, if not provided, it will be 100</p> <code>100</code> <code>skip</code> <code>int</code> <p>Skip for pagination, if not provided, it will be 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>A result array which contains the build errors of the plugin,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef get_plugin_build_errors(\n    self,\n    plugin_name: str,\n    start_date: Optional[datetime] = None,\n    limit: int = 100,\n    skip: int = 0,\n) -&gt; str:\n    # pylint: disable=line-too-long\n\"\"\"Get paginated build errors of a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n        start_date: Datetime used to get the build errors from, if not provided, it will be the plugin's creation date\n        limit: Limit for pagination, if not provided, it will be 100\n        skip: Skip for pagination, if not provided, it will be 0\n    Returns:\n        A result array which contains the build errors of the plugin,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_build_errors(plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n    \"\"\"\n\n    where = PluginBuildErrorsWhere(plugin_name=plugin_name, start_date=start_date)\n    options = QueryOptions(\n        first=limit, skip=skip, disable_tqdm=False\n    )  # disable tqm is not implemented for this query\n    pretty_result = PluginQuery(self.graphql_client).get_build_errors(where, options)\n    return json.dumps(pretty_result, sort_keys=True, indent=4)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_logs","title":"<code>get_plugin_logs(self, project_id, plugin_name, start_date=None, limit=100, skip=0)</code>","text":"<p>Get paginated logs of a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>start_date</code> <code>Optional[datetime.datetime]</code> <p>Datetime used to get the logs from, if not provided, it will be the plugin's creation date</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit for pagination, if not provided, it will be 100</p> <code>100</code> <code>skip</code> <code>int</code> <p>Skip for pagination, if not provided, it will be 0</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>A result array which contains the logs of the plugin,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef get_plugin_logs(\n    self,\n    project_id: str,\n    plugin_name: str,\n    start_date: Optional[datetime] = None,\n    limit: int = 100,\n    skip: int = 0,\n) -&gt; str:\n    # pylint: disable=line-too-long\n\"\"\"Get paginated logs of a plugin on a project.\n\n    Args:\n        project_id: Identifier of the project\n        plugin_name: Name of the plugin\n        start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date\n        limit: Limit for pagination, if not provided, it will be 100\n        skip: Skip for pagination, if not provided, it will be 0\n    Returns:\n        A result array which contains the logs of the plugin,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\")\n    \"\"\"\n\n    where = PluginLogsWhere(\n        project_id=project_id, plugin_name=plugin_name, start_date=start_date\n    )\n    options = QueryOptions(\n        first=limit, skip=skip, disable_tqdm=False\n    )  # disable tqm is not implemented for this query\n    pretty_result = PluginQuery(self.graphql_client).get_logs(where, options)\n    return json.dumps(pretty_result, sort_keys=True, indent=4)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.get_plugin_status","title":"<code>get_plugin_status(self, plugin_name, verbose=True)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>The status of the plugin if query was successful or an error message otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef get_plugin_status(\n    self,\n    plugin_name: str,\n    verbose: bool = True,\n):\n\"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        The status of the plugin if query was successful or an error message otherwise.\n\n    Examples:\n        &gt;&gt;&gt; kili.get_plugin_status(plugin_name=\"my_plugin_name\")\n    \"\"\"\n\n    result = PluginUploader(self, \"\", plugin_name, verbose).get_plugin_runner_status()\n    return result\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.queries.plugins.__init__.QueriesPlugins.list_plugins","title":"<code>list_plugins(self, fields=['name', 'projectIds', 'id', 'createdAt', 'updatedAt'])</code>","text":"<p>List all plugins from your organization</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the plugins See the documentation for all possible fields.</p> <code>['name', 'projectIds', 'id', 'createdAt', 'updatedAt']</code> <p>Returns:</p> Type Description <p>A result array which contains all the plugins from your organization,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.list_plugins()\n&gt;&gt;&gt; kili.list_plugins(fields=['name'])\n</code></pre> Source code in <code>kili/entrypoints/queries/plugins/__init__.py</code> <pre><code>@typechecked\ndef list_plugins(\n    self,\n    fields: List[str] = [\n        \"name\",\n        \"projectIds\",\n        \"id\",\n        \"createdAt\",\n        \"updatedAt\",\n    ],\n):\n    # pylint: disable=line-too-long\n\"\"\"List all plugins from your organization\n    Args:\n        fields: All the fields to request among the possible fields for the plugins\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields.\n\n    Returns:\n        A result array which contains all the plugins from your organization,\n            or an error message.\n    Examples:\n        &gt;&gt;&gt; kili.list_plugins()\n        &gt;&gt;&gt; kili.list_plugins(fields=['name'])\n    \"\"\"\n    return PluginQuery(self.graphql_client).list(fields=fields)\n</code></pre>"},{"location":"sdk/plugins/#mutations","title":"Mutations","text":"<p>Set of Plugins mutations.</p> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>class MutationsPlugins:\n\"\"\"Set of Plugins mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def upload_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        **kwargs  # pylint: disable=missing-param-doc\n    ):\n\"\"\"Uploads a plugin.\n\n        Args:\n            plugin_path: Path to your plugin. Either:\n\n                - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n                - a .py file\n            plugin_name: name of your plugin, if not provided, it will be the name from your file\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n            &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n        \"\"\"\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n                '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n                \" instead\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        return PluginUploader(self, plugin_path, plugin_name, verbose).create_plugin()\n\n    @typechecked\n    def create_webhook(\n        self,\n        webhook_url: str,\n        plugin_name: str,\n        header: Optional[str] = None,\n        verbose: bool = True,\n        handler_types: Optional[List[str]] = None,\n    ):\n        # pylint: disable=line-too-long,too-many-arguments\n\"\"\"Create a webhook linked to Kili's events.\n        For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n        Args:\n            webhook_url: URL receiving post requests on events on Kili. The payload will be the following:\n\n                - eventType: the type of event called\n                - logPayload:\n                    - runId: a unique identifier of the run for observability\n                    - projectId: the Kili project the webhook is called on\n                - payload: the event produced, for example for `onSubmit` event:\n                    - label: the label produced\n                    - asset_id: the asset on which the label is produced\n            plugin_name: name of your plugin\n            header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n            handler_types: List of actions for which the webhook should be called.\n                Possible variants: `onSubmit`, `onReview`.\n                By default, is [`onSubmit`, `onReview`].\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n\n        return WebhookUploader(\n            self, webhook_url, plugin_name, header, verbose, handler_types\n        ).create_webhook()\n\n    @typechecked\n    def update_webhook(\n        self,\n        new_webhook_url: str,\n        plugin_name: str,\n        new_header: Optional[str] = None,\n        verbose: bool = True,\n        handler_types: Optional[List[str]] = None,\n    ):\n        # pylint: disable=line-too-long,too-many-arguments\n\"\"\"Update a webhook linked to Kili's events.\n\n        For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n        Args:\n            new_webhook_url: New URL receiving post requests on events on Kili. See `create_webhook` for the payload description\n            plugin_name: name of your plugin\n            new_header: Authorization header to access the routes\n            verbose: If false, minimal logs are displayed\n            handler_types: List of actions for which the webhook should be called.\n                Possible variants: `onSubmit`, `onReview`.\n                By default, is [`onSubmit`, `onReview`]\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n        \"\"\"\n\n        return WebhookUploader(\n            self, new_webhook_url, plugin_name, new_header, verbose, handler_types\n        ).update_webhook()\n\n    @typechecked\n    def activate_plugin_on_project(self, plugin_name: str, project_id: str):\n        # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n        return activate_plugin(self, plugin_name, project_id)\n\n    @typechecked\n    def deactivate_plugin_on_project(self, plugin_name: str, project_id: str):\n        # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n        Args:\n            plugin_name: Name of the plugin\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n        \"\"\"\n        return deactivate_plugin(self, plugin_name, project_id)\n\n    @typechecked\n    def delete_plugin(self, plugin_name: str):\n\"\"\"Deletes a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n        return delete_plugin(self, plugin_name)\n\n    @typechecked\n    def update_plugin(\n        self,\n        plugin_path: Optional[str] = None,\n        plugin_name: Optional[str] = None,\n        verbose: bool = True,\n        **kwargs  # pylint: disable=missing-param-doc\n    ):\n\"\"\"Update a plugin with new code.\n\n        Args:\n            plugin_path: Path to your plugin. Either:\n\n                - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n                - a .py file\n            plugin_name: Name of the plugin\n            verbose: If false, minimal logs are displayed\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n        \"\"\"\n        if kwargs.get(\"file_path\"):\n            raise TypeError(\n                '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n                \" instead\"\n            )\n\n        if not plugin_path:\n            raise TypeError('\"plugin_path is nullish, please provide a value')\n\n        if not plugin_name:\n            raise TypeError('\"plugin_name is nullish, please provide a value')\n\n        return PluginUploader(self, plugin_path, plugin_name, verbose).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.activate_plugin_on_project","title":"<code>activate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef activate_plugin_on_project(self, plugin_name: str, project_id: str):\n    # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n    return activate_plugin(self, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.create_webhook","title":"<code>create_webhook(self, webhook_url, plugin_name, header=None, verbose=True, handler_types=None)</code>","text":"<p>Create a webhook linked to Kili's events. For a complete example, refer to the notebook <code>webhooks_example</code> on kili repo.</p> <p>Parameters:</p> Name Type Description Default <code>webhook_url</code> <code>str</code> <p>URL receiving post requests on events on Kili. The payload will be the following:</p> <ul> <li>eventType: the type of event called</li> <li>logPayload:<ul> <li>runId: a unique identifier of the run for observability</li> <li>projectId: the Kili project the webhook is called on</li> </ul> </li> <li>payload: the event produced, for example for <code>onSubmit</code> event:<ul> <li>label: the label produced</li> <li>asset_id: the asset on which the label is produced</li> </ul> </li> </ul> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <code>handler_types</code> <code>Optional[List[str]]</code> <p>List of actions for which the webhook should be called. Possible variants: <code>onSubmit</code>, <code>onReview</code>. By default, is [<code>onSubmit</code>, <code>onReview</code>].</p> <code>None</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef create_webhook(\n    self,\n    webhook_url: str,\n    plugin_name: str,\n    header: Optional[str] = None,\n    verbose: bool = True,\n    handler_types: Optional[List[str]] = None,\n):\n    # pylint: disable=line-too-long,too-many-arguments\n\"\"\"Create a webhook linked to Kili's events.\n    For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n    Args:\n        webhook_url: URL receiving post requests on events on Kili. The payload will be the following:\n\n            - eventType: the type of event called\n            - logPayload:\n                - runId: a unique identifier of the run for observability\n                - projectId: the Kili project the webhook is called on\n            - payload: the event produced, for example for `onSubmit` event:\n                - label: the label produced\n                - asset_id: the asset on which the label is produced\n        plugin_name: name of your plugin\n        header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n        handler_types: List of actions for which the webhook should be called.\n            Possible variants: `onSubmit`, `onReview`.\n            By default, is [`onSubmit`, `onReview`].\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n\n    return WebhookUploader(\n        self, webhook_url, plugin_name, header, verbose, handler_types\n    ).create_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.deactivate_plugin_on_project","title":"<code>deactivate_plugin_on_project(self, plugin_name, project_id)</code>","text":"<p>Activates a plugin on a project.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef deactivate_plugin_on_project(self, plugin_name: str, project_id: str):\n    # pylint: disable=line-too-long\n\"\"\"Activates a plugin on a project.\n\n    Args:\n        plugin_name: Name of the plugin\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\")\n    \"\"\"\n    return deactivate_plugin(self, plugin_name, project_id)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.delete_plugin","title":"<code>delete_plugin(self, plugin_name)</code>","text":"<p>Deletes a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef delete_plugin(self, plugin_name: str):\n\"\"\"Deletes a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.delete_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n    return delete_plugin(self, plugin_name)\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.update_plugin","title":"<code>update_plugin(self, plugin_path=None, plugin_name=None, verbose=True, **kwargs)</code>","text":"<p>Update a plugin with new code.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <code>Optional[str]</code> <p>Path to your plugin. Either:</p> <ul> <li>a folder containing a main.py (mandatory) and a requirements.txt (optional)</li> <li>a .py file</li> </ul> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>Name of the plugin</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef update_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    **kwargs  # pylint: disable=missing-param-doc\n):\n\"\"\"Update a plugin with new code.\n\n    Args:\n        plugin_path: Path to your plugin. Either:\n\n            - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n            - a .py file\n        plugin_name: Name of the plugin\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_plugin(plugin_name=\"my_plugin_name\")\n    \"\"\"\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n            '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n            \" instead\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    if not plugin_name:\n        raise TypeError('\"plugin_name is nullish, please provide a value')\n\n    return PluginUploader(self, plugin_path, plugin_name, verbose).update_plugin()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.update_webhook","title":"<code>update_webhook(self, new_webhook_url, plugin_name, new_header=None, verbose=True, handler_types=None)</code>","text":"<p>Update a webhook linked to Kili's events.</p> <p>For a complete example, refer to the notebook <code>webhooks_example</code> on kili repo.</p> <p>Parameters:</p> Name Type Description Default <code>new_webhook_url</code> <code>str</code> <p>New URL receiving post requests on events on Kili. See <code>create_webhook</code> for the payload description</p> required <code>plugin_name</code> <code>str</code> <p>name of your plugin</p> required <code>new_header</code> <code>Optional[str]</code> <p>Authorization header to access the routes</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <code>handler_types</code> <code>Optional[List[str]]</code> <p>List of actions for which the webhook should be called. Possible variants: <code>onSubmit</code>, <code>onReview</code>. By default, is [<code>onSubmit</code>, <code>onReview</code>]</p> <code>None</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef update_webhook(\n    self,\n    new_webhook_url: str,\n    plugin_name: str,\n    new_header: Optional[str] = None,\n    verbose: bool = True,\n    handler_types: Optional[List[str]] = None,\n):\n    # pylint: disable=line-too-long,too-many-arguments\n\"\"\"Update a webhook linked to Kili's events.\n\n    For a complete example, refer to the notebook `webhooks_example` on kili repo.\n\n    Args:\n        new_webhook_url: New URL receiving post requests on events on Kili. See `create_webhook` for the payload description\n        plugin_name: name of your plugin\n        new_header: Authorization header to access the routes\n        verbose: If false, minimal logs are displayed\n        handler_types: List of actions for which the webhook should be called.\n            Possible variants: `onSubmit`, `onReview`.\n            By default, is [`onSubmit`, `onReview`]\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...')\n    \"\"\"\n\n    return WebhookUploader(\n        self, new_webhook_url, plugin_name, new_header, verbose, handler_types\n    ).update_webhook()\n</code></pre>"},{"location":"sdk/plugins/#kili.entrypoints.mutations.plugins.__init__.MutationsPlugins.upload_plugin","title":"<code>upload_plugin(self, plugin_path=None, plugin_name=None, verbose=True, **kwargs)</code>","text":"<p>Uploads a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_path</code> <code>Optional[str]</code> <p>Path to your plugin. Either:</p> <ul> <li>a folder containing a main.py (mandatory) and a requirements.txt (optional)</li> <li>a .py file</li> </ul> <code>None</code> <code>plugin_name</code> <code>Optional[str]</code> <p>name of your plugin, if not provided, it will be the name from your file</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If false, minimal logs are displayed</p> <code>True</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful, or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n&gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/plugins/__init__.py</code> <pre><code>@typechecked\ndef upload_plugin(\n    self,\n    plugin_path: Optional[str] = None,\n    plugin_name: Optional[str] = None,\n    verbose: bool = True,\n    **kwargs  # pylint: disable=missing-param-doc\n):\n\"\"\"Uploads a plugin.\n\n    Args:\n        plugin_path: Path to your plugin. Either:\n\n            - a folder containing a main.py (mandatory) and a requirements.txt (optional)\n            - a .py file\n        plugin_name: name of your plugin, if not provided, it will be the name from your file\n        verbose: If false, minimal logs are displayed\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/folder\")\n        &gt;&gt;&gt; kili.upload_plugin(plugin_path=\"./path/to/my/file.py\")\n    \"\"\"\n    if kwargs.get(\"file_path\"):\n        raise TypeError(\n            '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\"'\n            \" instead\"\n        )\n\n    if not plugin_path:\n        raise TypeError('\"plugin_path is nullish, please provide a value')\n\n    return PluginUploader(self, plugin_path, plugin_name, verbose).create_plugin()\n</code></pre>"},{"location":"sdk/project/","title":"Project module","text":""},{"location":"sdk/project/#queries","title":"Queries","text":"<p>Set of Project queries.</p> Source code in <code>kili/entrypoints/queries/project/__init__.py</code> <pre><code>class QueriesProject:\n\"\"\"Set of Project queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n        skip: int = 0,\n        fields: List[str] = [\n            \"consensusTotCoverage\",\n            \"id\",\n            \"inputType\",\n            \"jsonInterface\",\n            \"minConsensusSize\",\n            \"reviewCoverage\",\n            \"roles.id\",\n            \"roles.role\",\n            \"roles.user.email\",\n            \"roles.user.id\",\n            \"title\",\n        ],\n        first: Optional[int] = None,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of projects that match a set of criteria.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings.\n            updated_at_gte: Returned projects should have a label whose update date is greater or equal\n                to this date.\n            updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n            archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n                `None` disables this filter.\n            skip: Number of projects to skip (they are ordered by their creation).\n            fields: All the fields to request among the possible fields for the projects.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n            first: Maximum number of projects to return.\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the projects is returned.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            A list of projects or a generator of projects if `as_generator` is `True`.\n\n        Examples:\n            &gt;&gt;&gt; # List all my projects\n            &gt;&gt;&gt; kili.projects()\n        \"\"\"\n        where = ProjectWhere(\n            project_id=project_id,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            archived=archived,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        projects_gen = ProjectQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return projects_gen\n        return list(projects_gen)\n\n    @typechecked\n    def count_projects(\n        self,\n        project_id: Optional[str] = None,\n        search_query: Optional[str] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        updated_at_gte: Optional[str] = None,\n        updated_at_lte: Optional[str] = None,\n        archived: Optional[bool] = None,\n    ) -&gt; int:\n        # pylint: disable=line-too-long\n\"\"\"Counts the number of projects with a search_query.\n\n        Args:\n            project_id: Select a specific project through its project_id.\n            search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n            should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot\n                or consensus settings\n            updated_at_gte: Returned projects should have a label\n                whose update date is greater\n                or equal to this date.\n            updated_at_lte: Returned projects should have a label\n                whose update date is lower or equal to this date.\n            archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n                None disable this filter.\n\n        !!! info \"Dates format\"\n            Date strings should have format: \"YYYY-MM-DD\"\n\n        Returns:\n            The number of projects with the parameters provided\n        \"\"\"\n        where = ProjectWhere(\n            project_id=project_id,\n            search_query=search_query,\n            should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n            updated_at_gte=updated_at_gte,\n            updated_at_lte=updated_at_lte,\n            archived=archived,\n        )\n        return ProjectQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.queries.project.__init__.QueriesProject.count_projects","title":"<code>count_projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, archived=None)</code>","text":"<p>Counts the number of projects with a search_query.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>archived</code> <code>Optional[bool]</code> <p>If <code>True</code>, only archived projects are returned, if <code>False</code>, only active projects are returned. None disable this filter.</p> <code>None</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of projects with the parameters provided</p> Source code in <code>kili/entrypoints/queries/project/__init__.py</code> <pre><code>@typechecked\ndef count_projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    archived: Optional[bool] = None,\n) -&gt; int:\n    # pylint: disable=line-too-long\n\"\"\"Counts the number of projects with a search_query.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot\n            or consensus settings\n        updated_at_gte: Returned projects should have a label\n            whose update date is greater\n            or equal to this date.\n        updated_at_lte: Returned projects should have a label\n            whose update date is lower or equal to this date.\n        archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n            None disable this filter.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        The number of projects with the parameters provided\n    \"\"\"\n    where = ProjectWhere(\n        project_id=project_id,\n        search_query=search_query,\n        should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        archived=archived,\n    )\n    return ProjectQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.queries.project.__init__.QueriesProject.projects","title":"<code>projects(self, project_id=None, search_query=None, should_relaunch_kpi_computation=None, updated_at_gte=None, updated_at_lte=None, archived=None, skip=0, fields=['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'], first=None, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of projects that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>Optional[str]</code> <p>Select a specific project through its project_id.</p> <code>None</code> <code>search_query</code> <code>Optional[str]</code> <p>Returned projects with a title or a description matching this PostgreSQL ILIKE pattern.</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings.</p> <code>None</code> <code>updated_at_gte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is greater or equal to this date.</p> <code>None</code> <code>updated_at_lte</code> <code>Optional[str]</code> <p>Returned projects should have a label whose update date is lower or equal to this date.</p> <code>None</code> <code>archived</code> <code>Optional[bool]</code> <p>If <code>True</code>, only archived projects are returned, if <code>False</code>, only active projects are returned. <code>None</code> disables this filter.</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of projects to skip (they are ordered by their creation).</p> <code>0</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projects. See the documentation for all possible fields.</p> <code>['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of projects to return.</p> <code>None</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the projects is returned.</p> <code>False</code> <p>Dates format</p> <p>Date strings should have format: \"YYYY-MM-DD\"</p> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A list of projects or a generator of projects if <code>as_generator</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # List all my projects\n&gt;&gt;&gt; kili.projects()\n</code></pre> Source code in <code>kili/entrypoints/queries/project/__init__.py</code> <pre><code>@typechecked\ndef projects(\n    self,\n    project_id: Optional[str] = None,\n    search_query: Optional[str] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    updated_at_gte: Optional[str] = None,\n    updated_at_lte: Optional[str] = None,\n    archived: Optional[bool] = None,\n    skip: int = 0,\n    fields: List[str] = [\n        \"consensusTotCoverage\",\n        \"id\",\n        \"inputType\",\n        \"jsonInterface\",\n        \"minConsensusSize\",\n        \"reviewCoverage\",\n        \"roles.id\",\n        \"roles.role\",\n        \"roles.user.email\",\n        \"roles.user.id\",\n        \"title\",\n    ],\n    first: Optional[int] = None,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of projects that match a set of criteria.\n\n    Args:\n        project_id: Select a specific project through its project_id.\n        search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern.\n        should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings.\n        updated_at_gte: Returned projects should have a label whose update date is greater or equal\n            to this date.\n        updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date.\n        archived: If `True`, only archived projects are returned, if `False`, only active projects are returned.\n            `None` disables this filter.\n        skip: Number of projects to skip (they are ordered by their creation).\n        fields: All the fields to request among the possible fields for the projects.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields.\n        first: Maximum number of projects to return.\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the projects is returned.\n\n    !!! info \"Dates format\"\n        Date strings should have format: \"YYYY-MM-DD\"\n\n    Returns:\n        A list of projects or a generator of projects if `as_generator` is `True`.\n\n    Examples:\n        &gt;&gt;&gt; # List all my projects\n        &gt;&gt;&gt; kili.projects()\n    \"\"\"\n    where = ProjectWhere(\n        project_id=project_id,\n        search_query=search_query,\n        should_relaunch_kpi_computation=should_relaunch_kpi_computation,\n        updated_at_gte=updated_at_gte,\n        updated_at_lte=updated_at_lte,\n        archived=archived,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    projects_gen = ProjectQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return projects_gen\n    return list(projects_gen)\n</code></pre>"},{"location":"sdk/project/#mutations","title":"Mutations","text":"<p>Set of Project mutations.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>class MutationsProject:\n\"\"\"Set of Project mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,too-many-locals\n    @typechecked\n    def append_to_roles(\n        self,\n        project_id: str,\n        user_email: str,\n        role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"] = \"LABELER\",\n    ) -&gt; Dict:\n\"\"\"Add a user to a project.\n\n        !!! info\n            If the user does not exist in your organization, he/she is invited and added\n                both to your organization and project. This function can also be used to change\n                the role of the user in the project.\n\n        Args:\n            project_id: Identifier of the project\n            user_email: The email of the user.\n                This email is used as the unique identifier of the user.\n            role: The role of the user.\n\n        Returns:\n            A dictionnary with the project user information.\n\n\n        Examples:\n            &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n        \"\"\"\n        variables = {\n            \"data\": {\"role\": role, \"userEmail\": user_email},\n            \"where\": {\"id\": project_id},\n        }\n        result = self.graphql_client.execute(GQL_APPEND_TO_ROLES, variables)\n\n        project_data = format_result(\"data\", result)\n        for project_user in project_data[\"roles\"]:\n            if project_user[\"user\"][\"email\"] == user_email and project_user[\"role\"] == role:\n                return project_user\n\n        raise MutationError(\n            f\"Failed to mutate user {user_email} to role {role} for project {project_id}.\"\n        )\n\n    @typechecked\n    def update_properties_in_project(\n        self,\n        project_id: str,\n        can_navigate_between_assets: Optional[bool] = None,\n        can_skip_asset: Optional[bool] = None,\n        consensus_mark: Optional[float] = None,\n        consensus_tot_coverage: Optional[int] = None,\n        description: Optional[str] = None,\n        honeypot_mark: Optional[float] = None,\n        instructions: Optional[str] = None,\n        input_type: Optional[str] = None,\n        json_interface: Optional[dict] = None,\n        min_consensus_size: Optional[int] = None,\n        number_of_assets: Optional[int] = None,\n        number_of_skipped_assets: Optional[int] = None,\n        number_of_remaining_assets: Optional[int] = None,\n        number_of_reviewed_assets: Optional[int] = None,\n        review_coverage: Optional[int] = None,\n        should_relaunch_kpi_computation: Optional[bool] = None,\n        title: Optional[str] = None,\n        use_honeypot: Optional[bool] = None,\n        metadata_types: Optional[dict] = None,\n    ) -&gt; Dict[str, Any]:\n\"\"\"Update properties of a project.\n\n        Args:\n            project_id: Identifier of the project.\n            can_navigate_between_assets:\n                Activate / Deactivate the use of next and previous buttons in labeling interface.\n            can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n            consensus_mark: Should be between 0 and 1.\n            consensus_tot_coverage: Should be between 0 and 100.\n                It is the percentage of the dataset that will be annotated several times.\n            description: Description of the project.\n            honeypot_mark: Should be between 0 and 1\n            instructions: Instructions of the project.\n            input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            min_consensus_size: Should be between 1 and 10\n                Number of people that will annotate the same asset, for consensus computation.\n            number_of_assets: Defaults to 0\n            number_of_skipped_assets: Defaults to 0\n            number_of_remaining_assets: Defaults to 0\n            number_of_reviewed_assets: Defaults to 0\n            review_coverage: Allow to set the percentage of assets\n                that will be queued in the review interface.\n                Should be between 0 and 100\n            should_relaunch_kpi_computation: Technical field, added to indicate changes\n                in honeypot or consensus settings\n            title: Title of the project\n            use_honeypot: Activate / Deactivate the use of honeypot in the project\n            metadata_types: Types of the project metadata.\n                Should be a `dict` of metadata fields name as keys and metadata types as values.\n                Currently, possible types are: `string`, `number`\n\n        Returns:\n            A dict with the changed properties which indicates if the mutation was successful,\n                else an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n        !!! example \"Change Metadata Types\"\n            Metadata fields are by default interpreted as `string` types. To change the type\n            of a metadata field, you can use the `update_properties_in_project` function with the\n            metadata_types argument. `metadata_types` is given as a dict of metadata field names\n            as keys and metadata types as values.\n            Example:\n            ```\n            kili.update_properties_in_project(\n                project_id = project_id,\n                metadata_types = {\n                    'customConsensus': 'number',\n                    'sensitiveData': 'string',\n                    'uploadedFromCloud': 'string',\n                    'modelLabelErrorScore': 'number'\n                }\n            )\n            ```\n            Not providing a type for a metadata field or providing an unsupported one\n            will default to the `string` type.\n        \"\"\"\n        verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n        variables = {\n            \"canNavigateBetweenAssets\": can_navigate_between_assets,\n            \"canSkipAsset\": can_skip_asset,\n            \"consensusMark\": consensus_mark,\n            \"consensusTotCoverage\": consensus_tot_coverage,\n            \"description\": description,\n            \"honeypotMark\": honeypot_mark,\n            \"instructions\": instructions,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n            \"metadataTypes\": metadata_types,\n            \"minConsensusSize\": min_consensus_size,\n            \"numberOfAssets\": number_of_assets,\n            \"numberOfSkippedAssets\": number_of_skipped_assets,\n            \"numberOfRemainingAssets\": number_of_remaining_assets,\n            \"numberOfReviewedAssets\": number_of_reviewed_assets,\n            \"projectID\": project_id,\n            \"reviewCoverage\": review_coverage,\n            \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n            \"title\": title,\n            \"useHoneyPot\": use_honeypot,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        result = format_result(\"data\", result)\n\n        variables.pop(\"projectID\")\n        variables = {k: v for k, v in variables.items() if v is not None}\n\n        new_project_settings = services.get_project(self, project_id, list(variables.keys()))\n\n        result = {**result, **new_project_settings}\n        return result\n\n    @typechecked\n    def create_project(\n        self,\n        input_type: str,\n        json_interface: dict,\n        title: str,\n        description: str = \"\",\n        project_type: Optional[str] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n        # pylint: disable=line-too-long\n\"\"\"Create a project.\n\n        Args:\n            input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n            json_interface: The json parameters of the project, see Edit your interface.\n            title: Title of the project.\n            description: Description of the project.\n            project_type: Currently, one of:\n\n                - `IMAGE_CLASSIFICATION_MULTI`\n                - `IMAGE_CLASSIFICATION_SINGLE`\n                - `IMAGE_OBJECT_DETECTION_POLYGON`\n                - `IMAGE_OBJECT_DETECTION_RECTANGLE`\n                - `IMAGE_OBJECT_DETECTION_SEMANTIC`\n                - `IMAGE_POSE_ESTIMATION`\n                - `OCR`\n                - `PDF_CLASSIFICATION_MULTI`\n                - `PDF_CLASSIFICATION_SINGLE`\n                - `PDF_NAMED_ENTITY_RECOGNITION`\n                - `PDF_OBJECT_DETECTION_RECTANGLE`\n                - `SPEECH_TO_TEXT`\n                - `TEXT_CLASSIFICATION_MULTI`\n                - `TEXT_CLASSIFICATION_SINGLE`\n                - `TEXT_NER`\n                - `TEXT_TRANSCRIPTION`\n                - `TIME_SERIES`\n                - `VIDEO_CLASSIFICATION_SINGLE`\n                - `VIDEO_FRAME_CLASSIFICATION`\n                - `VIDEO_FRAME_OBJECT_TRACKING`\n\n\n        Returns:\n            A dict with the id of the created project.\n\n        Examples:\n            &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n        !!! example \"Recipe\"\n            For more detailed examples on how to create projects,\n                see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"description\": description,\n                \"inputType\": input_type,\n                \"jsonInterface\": dumps(json_interface),\n                \"projectType\": project_type,\n                \"title\": title,\n            }\n        }\n        result = self.graphql_client.execute(GQL_CREATE_PROJECT, variables)\n        result = format_result(\"data\", result)\n\n        # We check during 60s for the project to be created\n        for attempt in Retrying(\n            stop=stop_after_delay(60),\n            wait=wait_fixed(1),\n            retry=retry_if_exception_type(NotFound),\n            reraise=True,\n        ):\n            with attempt:\n                _ = services.get_project(self, project_id=result[\"id\"], fields=[\"id\"])\n\n        return result\n\n    @typechecked\n    def update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n\"\"\"Update properties of a role.\n\n        !!! info\n            To be able to change someone's role, you must be either of:\n\n            - an admin of the project\n            - a team manager of the project\n            - an admin of the organization\n\n        Args:\n            role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n            project_id: Identifier of the project\n            user_id: The email or identifier of the user with updated role\n            role: The new role.\n                Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"roleID\": role_id,\n            \"projectID\": project_id,\n            \"userID\": user_id,\n            \"role\": role,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_from_roles(self, role_id: str):\n\"\"\"Delete users by their role_id.\n\n        Args:\n            role_id: Identifier of the project user (not the ID of the user)\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": role_id}}\n        result = self.graphql_client.execute(GQL_DELETE_FROM_ROLES, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def delete_project(self, project_id: str) -&gt; str:\n\"\"\"Delete a project permanently.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\"where\": {\"id\": project_id}}\n        result = self.graphql_client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def archive_project(self, project_id: str):\n\"\"\"Archive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful, or an error message.\n        \"\"\"\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": True,\n        }\n\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def unarchive_project(self, project_id: str):\n\"\"\"Unarchive a project.\n\n        Args:\n            project_id: Identifier of the project\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"projectID\": project_id,\n            \"archived\": False,\n        }\n\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def copy_project(  # pylint: disable=too-many-arguments\n        self,\n        from_project_id: str,\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        copy_json_interface: bool = True,\n        copy_quality_settings: bool = True,\n        copy_members: bool = True,\n        copy_assets: bool = False,\n        copy_labels: bool = False,\n        disable_tqdm: bool = False,\n    ) -&gt; str:\n\"\"\"Create new project from an existing project.\n\n        Args:\n            from_project_id: Project ID to copy from.\n            title: Title for the new project. Defaults to source project\n                title if `None` is provided.\n            description: Description for the new project. Defaults to empty string\n                if `None` is provided.\n            copy_json_interface: Include json interface in the copy.\n            copy_quality_settings: Include quality settings in the copy.\n            copy_members: Include members in the copy.\n            copy_assets: Include assets in the copy.\n            copy_labels: Include labels in the copy.\n            disable_tqdm: Disable tqdm progress bars.\n\n        Returns:\n            The created project ID.\n\n        Examples:\n            &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n        \"\"\"\n        return ProjectCopier(self).copy_project(\n            from_project_id,\n            title,\n            description,\n            copy_json_interface,\n            copy_quality_settings,\n            copy_members,\n            copy_assets,\n            copy_labels,\n            disable_tqdm,\n        )\n\n    @typechecked\n    def update_project_anonymization(\n        self, project_id: str, should_anonymize: bool = True\n    ) -&gt; Dict[Literal[\"id\"], str]:\n\"\"\"Anonymize the project for the labelers and reviewers.\n\n        !!! info\n            Compatible with versions of the Kili app &gt;= 2.135.0\n\n        Args:\n            project_id: Identifier of the project\n            should_anonymize: The value to be applied. Defaults to `True`.\n\n        Returns:\n            A dict with the id of the project which indicates if the mutation was successful,\n                or an error message.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n            &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n        \"\"\"\n        variables = {\n            \"input\": {\n                \"id\": project_id,\n                \"shouldAnonymize\": should_anonymize,\n            }\n        }\n\n        result = self.graphql_client.execute(GQL_PROJECT_UPDATE_ANONYMIZATION, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.append_to_roles","title":"<code>append_to_roles(self, project_id, user_email, role='LABELER')</code>","text":"<p>Add a user to a project.</p> <p>Info</p> <p>If the user does not exist in your organization, he/she is invited and added     both to your organization and project. This function can also be used to change     the role of the user in the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_email</code> <code>str</code> <p>The email of the user. This email is used as the unique identifier of the user.</p> required <code>role</code> <code>typing_extensions.Literal['ADMIN', 'TEAM_MANAGER', 'REVIEWER', 'LABELER']</code> <p>The role of the user.</p> <code>'LABELER'</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionnary with the project user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef append_to_roles(\n    self,\n    project_id: str,\n    user_email: str,\n    role: Literal[\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"] = \"LABELER\",\n) -&gt; Dict:\n\"\"\"Add a user to a project.\n\n    !!! info\n        If the user does not exist in your organization, he/she is invited and added\n            both to your organization and project. This function can also be used to change\n            the role of the user in the project.\n\n    Args:\n        project_id: Identifier of the project\n        user_email: The email of the user.\n            This email is used as the unique identifier of the user.\n        role: The role of the user.\n\n    Returns:\n        A dictionnary with the project user information.\n\n\n    Examples:\n        &gt;&gt;&gt; kili.append_to_roles(project_id=project_id, user_email='john@doe.com')\n    \"\"\"\n    variables = {\n        \"data\": {\"role\": role, \"userEmail\": user_email},\n        \"where\": {\"id\": project_id},\n    }\n    result = self.graphql_client.execute(GQL_APPEND_TO_ROLES, variables)\n\n    project_data = format_result(\"data\", result)\n    for project_user in project_data[\"roles\"]:\n        if project_user[\"user\"][\"email\"] == user_email and project_user[\"role\"] == role:\n            return project_user\n\n    raise MutationError(\n        f\"Failed to mutate user {user_email} to role {role} for project {project_id}.\"\n    )\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.archive_project","title":"<code>archive_project(self, project_id)</code>","text":"<p>Archive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful, or an error message.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef archive_project(self, project_id: str):\n\"\"\"Archive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful, or an error message.\n    \"\"\"\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": True,\n    }\n\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.copy_project","title":"<code>copy_project(self, from_project_id, title=None, description=None, copy_json_interface=True, copy_quality_settings=True, copy_members=True, copy_assets=False, copy_labels=False, disable_tqdm=False)</code>","text":"<p>Create new project from an existing project.</p> <p>Parameters:</p> Name Type Description Default <code>from_project_id</code> <code>str</code> <p>Project ID to copy from.</p> required <code>title</code> <code>Optional[str]</code> <p>Title for the new project. Defaults to source project title if <code>None</code> is provided.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description for the new project. Defaults to empty string if <code>None</code> is provided.</p> <code>None</code> <code>copy_json_interface</code> <code>bool</code> <p>Include json interface in the copy.</p> <code>True</code> <code>copy_quality_settings</code> <code>bool</code> <p>Include quality settings in the copy.</p> <code>True</code> <code>copy_members</code> <code>bool</code> <p>Include members in the copy.</p> <code>True</code> <code>copy_assets</code> <code>bool</code> <p>Include assets in the copy.</p> <code>False</code> <code>copy_labels</code> <code>bool</code> <p>Include labels in the copy.</p> <code>False</code> <code>disable_tqdm</code> <code>bool</code> <p>Disable tqdm progress bars.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The created project ID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef copy_project(  # pylint: disable=too-many-arguments\n    self,\n    from_project_id: str,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    copy_json_interface: bool = True,\n    copy_quality_settings: bool = True,\n    copy_members: bool = True,\n    copy_assets: bool = False,\n    copy_labels: bool = False,\n    disable_tqdm: bool = False,\n) -&gt; str:\n\"\"\"Create new project from an existing project.\n\n    Args:\n        from_project_id: Project ID to copy from.\n        title: Title for the new project. Defaults to source project\n            title if `None` is provided.\n        description: Description for the new project. Defaults to empty string\n            if `None` is provided.\n        copy_json_interface: Include json interface in the copy.\n        copy_quality_settings: Include quality settings in the copy.\n        copy_members: Include members in the copy.\n        copy_assets: Include assets in the copy.\n        copy_labels: Include labels in the copy.\n        disable_tqdm: Disable tqdm progress bars.\n\n    Returns:\n        The created project ID.\n\n    Examples:\n        &gt;&gt;&gt; kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\")\n    \"\"\"\n    return ProjectCopier(self).copy_project(\n        from_project_id,\n        title,\n        description,\n        copy_json_interface,\n        copy_quality_settings,\n        copy_members,\n        copy_assets,\n        copy_labels,\n        disable_tqdm,\n    )\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.create_project","title":"<code>create_project(self, input_type, json_interface, title, description='', project_type=None)</code>","text":"<p>Create a project.</p> <p>Parameters:</p> Name Type Description Default <code>input_type</code> <code>str</code> <p>Currently, one of <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code> or <code>VIDEO</code>.</p> required <code>json_interface</code> <code>dict</code> <p>The json parameters of the project, see Edit your interface.</p> required <code>title</code> <code>str</code> <p>Title of the project.</p> required <code>description</code> <code>str</code> <p>Description of the project.</p> <code>''</code> <code>project_type</code> <code>Optional[str]</code> <p>Currently, one of:</p> <ul> <li><code>IMAGE_CLASSIFICATION_MULTI</code></li> <li><code>IMAGE_CLASSIFICATION_SINGLE</code></li> <li><code>IMAGE_OBJECT_DETECTION_POLYGON</code></li> <li><code>IMAGE_OBJECT_DETECTION_RECTANGLE</code></li> <li><code>IMAGE_OBJECT_DETECTION_SEMANTIC</code></li> <li><code>IMAGE_POSE_ESTIMATION</code></li> <li><code>OCR</code></li> <li><code>PDF_CLASSIFICATION_MULTI</code></li> <li><code>PDF_CLASSIFICATION_SINGLE</code></li> <li><code>PDF_NAMED_ENTITY_RECOGNITION</code></li> <li><code>PDF_OBJECT_DETECTION_RECTANGLE</code></li> <li><code>SPEECH_TO_TEXT</code></li> <li><code>TEXT_CLASSIFICATION_MULTI</code></li> <li><code>TEXT_CLASSIFICATION_SINGLE</code></li> <li><code>TEXT_NER</code></li> <li><code>TEXT_TRANSCRIPTION</code></li> <li><code>TIME_SERIES</code></li> <li><code>VIDEO_CLASSIFICATION_SINGLE</code></li> <li><code>VIDEO_FRAME_CLASSIFICATION</code></li> <li><code>VIDEO_FRAME_OBJECT_TRACKING</code></li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['id'], str]</code> <p>A dict with the id of the created project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n</code></pre> <p>Recipe</p> <p>For more detailed examples on how to create projects,     see the recipe.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef create_project(\n    self,\n    input_type: str,\n    json_interface: dict,\n    title: str,\n    description: str = \"\",\n    project_type: Optional[str] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n    # pylint: disable=line-too-long\n\"\"\"Create a project.\n\n    Args:\n        input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        title: Title of the project.\n        description: Description of the project.\n        project_type: Currently, one of:\n\n            - `IMAGE_CLASSIFICATION_MULTI`\n            - `IMAGE_CLASSIFICATION_SINGLE`\n            - `IMAGE_OBJECT_DETECTION_POLYGON`\n            - `IMAGE_OBJECT_DETECTION_RECTANGLE`\n            - `IMAGE_OBJECT_DETECTION_SEMANTIC`\n            - `IMAGE_POSE_ESTIMATION`\n            - `OCR`\n            - `PDF_CLASSIFICATION_MULTI`\n            - `PDF_CLASSIFICATION_SINGLE`\n            - `PDF_NAMED_ENTITY_RECOGNITION`\n            - `PDF_OBJECT_DETECTION_RECTANGLE`\n            - `SPEECH_TO_TEXT`\n            - `TEXT_CLASSIFICATION_MULTI`\n            - `TEXT_CLASSIFICATION_SINGLE`\n            - `TEXT_NER`\n            - `TEXT_TRANSCRIPTION`\n            - `TIME_SERIES`\n            - `VIDEO_CLASSIFICATION_SINGLE`\n            - `VIDEO_FRAME_CLASSIFICATION`\n            - `VIDEO_FRAME_OBJECT_TRACKING`\n\n\n    Returns:\n        A dict with the id of the created project.\n\n    Examples:\n        &gt;&gt;&gt; kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example')\n\n    !!! example \"Recipe\"\n        For more detailed examples on how to create projects,\n            see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project).\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"description\": description,\n            \"inputType\": input_type,\n            \"jsonInterface\": dumps(json_interface),\n            \"projectType\": project_type,\n            \"title\": title,\n        }\n    }\n    result = self.graphql_client.execute(GQL_CREATE_PROJECT, variables)\n    result = format_result(\"data\", result)\n\n    # We check during 60s for the project to be created\n    for attempt in Retrying(\n        stop=stop_after_delay(60),\n        wait=wait_fixed(1),\n        retry=retry_if_exception_type(NotFound),\n        reraise=True,\n    ):\n        with attempt:\n            _ = services.get_project(self, project_id=result[\"id\"], fields=[\"id\"])\n\n    return result\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.delete_from_roles","title":"<code>delete_from_roles(self, role_id)</code>","text":"<p>Delete users by their role_id.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Identifier of the project user (not the ID of the user)</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_from_roles(self, role_id: str):\n\"\"\"Delete users by their role_id.\n\n    Args:\n        role_id: Identifier of the project user (not the ID of the user)\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": role_id}}\n    result = self.graphql_client.execute(GQL_DELETE_FROM_ROLES, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.delete_project","title":"<code>delete_project(self, project_id)</code>","text":"<p>Delete a project permanently.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>str</code> <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef delete_project(self, project_id: str) -&gt; str:\n\"\"\"Delete a project permanently.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\"where\": {\"id\": project_id}}\n    result = self.graphql_client.execute(GQL_PROJECT_DELETE_ASYNCHRONOUSLY, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.unarchive_project","title":"<code>unarchive_project(self, project_id)</code>","text":"<p>Unarchive a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef unarchive_project(self, project_id: str):\n\"\"\"Unarchive a project.\n\n    Args:\n        project_id: Identifier of the project\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"projectID\": project_id,\n        \"archived\": False,\n    }\n\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_project_anonymization","title":"<code>update_project_anonymization(self, project_id, should_anonymize=True)</code>","text":"<p>Anonymize the project for the labelers and reviewers.</p> <p>Info</p> <p>Compatible with versions of the Kili app &gt;= 2.135.0</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>should_anonymize</code> <code>bool</code> <p>The value to be applied. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['id'], str]</code> <p>A dict with the id of the project which indicates if the mutation was successful,     or an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n&gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n</code></pre> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_project_anonymization(\n    self, project_id: str, should_anonymize: bool = True\n) -&gt; Dict[Literal[\"id\"], str]:\n\"\"\"Anonymize the project for the labelers and reviewers.\n\n    !!! info\n        Compatible with versions of the Kili app &gt;= 2.135.0\n\n    Args:\n        project_id: Identifier of the project\n        should_anonymize: The value to be applied. Defaults to `True`.\n\n    Returns:\n        A dict with the id of the project which indicates if the mutation was successful,\n            or an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id)\n        &gt;&gt;&gt; kili.update_project_anonymization(project_id=project_id, should_anonymize=False)\n    \"\"\"\n    variables = {\n        \"input\": {\n            \"id\": project_id,\n            \"shouldAnonymize\": should_anonymize,\n        }\n    }\n\n    result = self.graphql_client.execute(GQL_PROJECT_UPDATE_ANONYMIZATION, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_properties_in_project","title":"<code>update_properties_in_project(self, project_id, can_navigate_between_assets=None, can_skip_asset=None, consensus_mark=None, consensus_tot_coverage=None, description=None, honeypot_mark=None, instructions=None, input_type=None, json_interface=None, min_consensus_size=None, number_of_assets=None, number_of_skipped_assets=None, number_of_remaining_assets=None, number_of_reviewed_assets=None, review_coverage=None, should_relaunch_kpi_computation=None, title=None, use_honeypot=None, metadata_types=None)</code>","text":"<p>Update properties of a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project.</p> required <code>can_navigate_between_assets</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of next and previous buttons in labeling interface.</p> <code>None</code> <code>can_skip_asset</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of skip button in labeling interface.</p> <code>None</code> <code>consensus_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1.</p> <code>None</code> <code>consensus_tot_coverage</code> <code>Optional[int]</code> <p>Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description of the project.</p> <code>None</code> <code>honeypot_mark</code> <code>Optional[float]</code> <p>Should be between 0 and 1</p> <code>None</code> <code>instructions</code> <code>Optional[str]</code> <p>Instructions of the project.</p> <code>None</code> <code>input_type</code> <code>Optional[str]</code> <p>Currently, one of <code>IMAGE</code>, <code>PDF</code>, <code>TEXT</code> or <code>VIDEO</code>.</p> <code>None</code> <code>json_interface</code> <code>Optional[dict]</code> <p>The json parameters of the project, see Edit your interface.</p> <code>None</code> <code>min_consensus_size</code> <code>Optional[int]</code> <p>Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation.</p> <code>None</code> <code>number_of_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_skipped_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_remaining_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>number_of_reviewed_assets</code> <code>Optional[int]</code> <p>Defaults to 0</p> <code>None</code> <code>review_coverage</code> <code>Optional[int]</code> <p>Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100</p> <code>None</code> <code>should_relaunch_kpi_computation</code> <code>Optional[bool]</code> <p>Technical field, added to indicate changes in honeypot or consensus settings</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title of the project</p> <code>None</code> <code>use_honeypot</code> <code>Optional[bool]</code> <p>Activate / Deactivate the use of honeypot in the project</p> <code>None</code> <code>metadata_types</code> <code>Optional[dict]</code> <p>Types of the project metadata. Should be a <code>dict</code> of metadata fields name as keys and metadata types as values. Currently, possible types are: <code>string</code>, <code>number</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dict with the changed properties which indicates if the mutation was successful,     else an error message.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n</code></pre> <p>Change Metadata Types</p> <p>Metadata fields are by default interpreted as <code>string</code> types. To change the type of a metadata field, you can use the <code>update_properties_in_project</code> function with the metadata_types argument. <code>metadata_types</code> is given as a dict of metadata field names as keys and metadata types as values. Example: <pre><code>kili.update_properties_in_project(\n    project_id = project_id,\n    metadata_types = {\n        'customConsensus': 'number',\n        'sensitiveData': 'string',\n        'uploadedFromCloud': 'string',\n        'modelLabelErrorScore': 'number'\n    }\n)\n</code></pre> Not providing a type for a metadata field or providing an unsupported one will default to the <code>string</code> type.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project(\n    self,\n    project_id: str,\n    can_navigate_between_assets: Optional[bool] = None,\n    can_skip_asset: Optional[bool] = None,\n    consensus_mark: Optional[float] = None,\n    consensus_tot_coverage: Optional[int] = None,\n    description: Optional[str] = None,\n    honeypot_mark: Optional[float] = None,\n    instructions: Optional[str] = None,\n    input_type: Optional[str] = None,\n    json_interface: Optional[dict] = None,\n    min_consensus_size: Optional[int] = None,\n    number_of_assets: Optional[int] = None,\n    number_of_skipped_assets: Optional[int] = None,\n    number_of_remaining_assets: Optional[int] = None,\n    number_of_reviewed_assets: Optional[int] = None,\n    review_coverage: Optional[int] = None,\n    should_relaunch_kpi_computation: Optional[bool] = None,\n    title: Optional[str] = None,\n    use_honeypot: Optional[bool] = None,\n    metadata_types: Optional[dict] = None,\n) -&gt; Dict[str, Any]:\n\"\"\"Update properties of a project.\n\n    Args:\n        project_id: Identifier of the project.\n        can_navigate_between_assets:\n            Activate / Deactivate the use of next and previous buttons in labeling interface.\n        can_skip_asset: Activate / Deactivate the use of skip button in labeling interface.\n        consensus_mark: Should be between 0 and 1.\n        consensus_tot_coverage: Should be between 0 and 100.\n            It is the percentage of the dataset that will be annotated several times.\n        description: Description of the project.\n        honeypot_mark: Should be between 0 and 1\n        instructions: Instructions of the project.\n        input_type: Currently, one of `IMAGE`, `PDF`, `TEXT` or `VIDEO`.\n        json_interface: The json parameters of the project, see Edit your interface.\n        min_consensus_size: Should be between 1 and 10\n            Number of people that will annotate the same asset, for consensus computation.\n        number_of_assets: Defaults to 0\n        number_of_skipped_assets: Defaults to 0\n        number_of_remaining_assets: Defaults to 0\n        number_of_reviewed_assets: Defaults to 0\n        review_coverage: Allow to set the percentage of assets\n            that will be queued in the review interface.\n            Should be between 0 and 100\n        should_relaunch_kpi_computation: Technical field, added to indicate changes\n            in honeypot or consensus settings\n        title: Title of the project\n        use_honeypot: Activate / Deactivate the use of honeypot in the project\n        metadata_types: Types of the project metadata.\n            Should be a `dict` of metadata fields name as keys and metadata types as values.\n            Currently, possible types are: `string`, `number`\n\n    Returns:\n        A dict with the changed properties which indicates if the mutation was successful,\n            else an error message.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project(project_id=project_id, title='New title')\n\n    !!! example \"Change Metadata Types\"\n        Metadata fields are by default interpreted as `string` types. To change the type\n        of a metadata field, you can use the `update_properties_in_project` function with the\n        metadata_types argument. `metadata_types` is given as a dict of metadata field names\n        as keys and metadata types as values.\n        Example:\n        ```\n        kili.update_properties_in_project(\n            project_id = project_id,\n            metadata_types = {\n                'customConsensus': 'number',\n                'sensitiveData': 'string',\n                'uploadedFromCloud': 'string',\n                'modelLabelErrorScore': 'number'\n            }\n        )\n        ```\n        Not providing a type for a metadata field or providing an unsupported one\n        will default to the `string` type.\n    \"\"\"\n    verify_argument_ranges(consensus_tot_coverage, min_consensus_size, review_coverage)\n\n    variables = {\n        \"canNavigateBetweenAssets\": can_navigate_between_assets,\n        \"canSkipAsset\": can_skip_asset,\n        \"consensusMark\": consensus_mark,\n        \"consensusTotCoverage\": consensus_tot_coverage,\n        \"description\": description,\n        \"honeypotMark\": honeypot_mark,\n        \"instructions\": instructions,\n        \"inputType\": input_type,\n        \"jsonInterface\": dumps(json_interface) if json_interface is not None else None,\n        \"metadataTypes\": metadata_types,\n        \"minConsensusSize\": min_consensus_size,\n        \"numberOfAssets\": number_of_assets,\n        \"numberOfSkippedAssets\": number_of_skipped_assets,\n        \"numberOfRemainingAssets\": number_of_remaining_assets,\n        \"numberOfReviewedAssets\": number_of_reviewed_assets,\n        \"projectID\": project_id,\n        \"reviewCoverage\": review_coverage,\n        \"shouldRelaunchKpiComputation\": should_relaunch_kpi_computation,\n        \"title\": title,\n        \"useHoneyPot\": use_honeypot,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT, variables)\n    result = format_result(\"data\", result)\n\n    variables.pop(\"projectID\")\n    variables = {k: v for k, v in variables.items() if v is not None}\n\n    new_project_settings = services.get_project(self, project_id, list(variables.keys()))\n\n    result = {**result, **new_project_settings}\n    return result\n</code></pre>"},{"location":"sdk/project/#kili.entrypoints.mutations.project.__init__.MutationsProject.update_properties_in_role","title":"<code>update_properties_in_role(self, role_id, project_id, user_id, role)</code>","text":"<p>Update properties of a role.</p> <p>Info</p> <p>To be able to change someone's role, you must be either of:</p> <ul> <li>an admin of the project</li> <li>a team manager of the project</li> <li>an admin of the organization</li> </ul> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Role identifier of the user. E.g. : 'to-be-deactivated'</p> required <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>user_id</code> <code>str</code> <p>The email or identifier of the user with updated role</p> required <code>role</code> <code>str</code> <p>The new role. Possible choices are: <code>ADMIN</code>, <code>TEAM_MANAGER</code>, <code>REVIEWER</code>, <code>LABELER</code></p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/project/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_role(self, role_id: str, project_id: str, user_id: str, role: str):\n\"\"\"Update properties of a role.\n\n    !!! info\n        To be able to change someone's role, you must be either of:\n\n        - an admin of the project\n        - a team manager of the project\n        - an admin of the organization\n\n    Args:\n        role_id: Role identifier of the user. E.g. : 'to-be-deactivated'\n        project_id: Identifier of the project\n        user_id: The email or identifier of the user with updated role\n        role: The new role.\n            Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER`\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"roleID\": role_id,\n        \"projectID\": project_id,\n        \"userID\": user_id,\n        \"role\": role,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_ROLE, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_user/","title":"Project User module","text":""},{"location":"sdk/project_user/#queries","title":"Queries","text":"<p>Set of ProjectUser queries.</p> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>class QueriesProjectUser:\n\"\"\"Set of ProjectUser queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,redefined-builtin,dangerous-default-value,invalid-name\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\n            \"activated\",\n            \"id\",\n            \"role\",\n            \"starred\",\n            \"user.email\",\n            \"user.id\",\n        ],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Return project users (possibly with their KPIs) that match a set of criteria.\n\n        Args:\n            project_id: Identifier of the project\n            email: Email of the user\n            id: Identifier of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the projectUsers\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of project users to skip\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # Retrieve consensus marks of all users in project\n            &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n            ```\n        \"\"\"\n        where = ProjectUserWhere(\n            project_id=project_id, email=email, _id=id, organization_id=organization_id\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_users_gen = ProjectUserQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return project_users_gen\n        return list(project_users_gen)\n\n    @typechecked\n    def count_project_users(\n        self,\n        project_id: str,\n        email: Optional[str] = None,\n        id: Optional[str] = None,\n        organization_id: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Counts the number of projects and their users that match a set of criteria.\n\n        Args:\n            email: Email of the user\n            id: Identifier of the user\n            organization_id: Identifier of the user's organization\n            project_id: Identifier of the project\n\n        Returns:\n            The number of project users with the parameters provided\n        \"\"\"\n        where = ProjectUserWhere(\n            project_id=project_id, email=email, _id=id, organization_id=organization_id\n        )\n        return ProjectUserQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project_user/#kili.entrypoints.queries.project_user.__init__.QueriesProjectUser.count_project_users","title":"<code>count_project_users(self, project_id, email=None, id=None, organization_id=None)</code>","text":"<p>Counts the number of projects and their users that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>id</code> <code>Optional[str]</code> <p>Identifier of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of project users with the parameters provided</p> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef count_project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n) -&gt; int:\n\"\"\"Counts the number of projects and their users that match a set of criteria.\n\n    Args:\n        email: Email of the user\n        id: Identifier of the user\n        organization_id: Identifier of the user's organization\n        project_id: Identifier of the project\n\n    Returns:\n        The number of project users with the parameters provided\n    \"\"\"\n    where = ProjectUserWhere(\n        project_id=project_id, email=email, _id=id, organization_id=organization_id\n    )\n    return ProjectUserQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project_user/#kili.entrypoints.queries.project_user.__init__.QueriesProjectUser.project_users","title":"<code>project_users(self, project_id, email=None, id=None, organization_id=None, fields=['activated', 'id', 'role', 'starred', 'user.email', 'user.id'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Return project users (possibly with their KPIs) that match a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Identifier of the project</p> required <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>id</code> <code>Optional[str]</code> <p>Identifier of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields.</p> <code>['activated', 'id', 'role', 'starred', 'user.email', 'user.id']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project users to skip</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code># Retrieve consensus marks of all users in project\n&gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n</code></pre> Source code in <code>kili/entrypoints/queries/project_user/__init__.py</code> <pre><code>@typechecked\ndef project_users(\n    self,\n    project_id: str,\n    email: Optional[str] = None,\n    id: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\n        \"activated\",\n        \"id\",\n        \"role\",\n        \"starred\",\n        \"user.email\",\n        \"user.id\",\n    ],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Return project users (possibly with their KPIs) that match a set of criteria.\n\n    Args:\n        project_id: Identifier of the project\n        email: Email of the user\n        id: Identifier of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the projectUsers\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of project users to skip\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # Retrieve consensus marks of all users in project\n        &gt;&gt;&gt; kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email'])\n        ```\n    \"\"\"\n    where = ProjectUserWhere(\n        project_id=project_id, email=email, _id=id, organization_id=organization_id\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_users_gen = ProjectUserQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return project_users_gen\n    return list(project_users_gen)\n</code></pre>"},{"location":"sdk/project_version/","title":"Project Version module","text":""},{"location":"sdk/project_version/#queries","title":"Queries","text":"<p>Set of ProjectVersion queries.</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>class QueriesProjectVersion:\n\"\"\"Set of ProjectVersion queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def project_version(\n        self,\n        project_id: str,\n        first: Optional[int] = None,\n        skip: int = 0,\n        fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n        Args:\n            project_id: Filter on Id of project\n            fields: All the fields to request among the possible fields for the project versions\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n            first: Number of project versions to query\n            skip: Number of project versions to skip (they are ordered by their date\n                of creation, first to last).\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the project versions is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        project_versions_gen = ProjectVersionQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return project_versions_gen\n        return list(project_versions_gen)\n\n    @typechecked\n    def count_project_versions(self, project_id: str) -&gt; int:\n\"\"\"Count the number of project versions.\n\n        Args:\n            project_id: Filter on ID of project\n\n        Returns:\n            The number of project versions with the parameters provided\n        \"\"\"\n        where = ProjectVersionWhere(\n            project_id=project_id,\n        )\n        return ProjectVersionQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","title":"<code>count_project_versions(self, project_id)</code>","text":"<p>Count the number of project versions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on ID of project</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of project versions with the parameters provided</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef count_project_versions(self, project_id: str) -&gt; int:\n\"\"\"Count the number of project versions.\n\n    Args:\n        project_id: Filter on ID of project\n\n    Returns:\n        The number of project versions with the parameters provided\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    return ProjectVersionQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.queries.project_version.__init__.QueriesProjectVersion.project_version","title":"<code>project_version(self, project_id, first=None, skip=0, fields=['createdAt', 'id', 'content', 'name', 'projectId'], disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of project versions respecting a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Filter on Id of project</p> required <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the project versions See the documentation for all possible fields.</p> <code>['createdAt', 'id', 'content', 'name', 'projectId']</code> <code>first</code> <code>Optional[int]</code> <p>Number of project versions to query</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of project versions to skip (they are ordered by their date of creation, first to last).</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the project versions is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> Source code in <code>kili/entrypoints/queries/project_version/__init__.py</code> <pre><code>@typechecked\ndef project_version(\n    self,\n    project_id: str,\n    first: Optional[int] = None,\n    skip: int = 0,\n    fields: List[str] = [\"createdAt\", \"id\", \"content\", \"name\", \"projectId\"],\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of project versions respecting a set of criteria.\n\n    Args:\n        project_id: Filter on Id of project\n        fields: All the fields to request among the possible fields for the project versions\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields.\n        first: Number of project versions to query\n        skip: Number of project versions to skip (they are ordered by their date\n            of creation, first to last).\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the project versions is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n    \"\"\"\n    where = ProjectVersionWhere(\n        project_id=project_id,\n    )\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    project_versions_gen = ProjectVersionQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return project_versions_gen\n    return list(project_versions_gen)\n</code></pre>"},{"location":"sdk/project_version/#mutations","title":"Mutations","text":"<p>Set of ProjectVersion mutations.</p> Source code in <code>kili/entrypoints/mutations/project_version/__init__.py</code> <pre><code>class MutationsProjectVersion:  # pylint: disable=too-few-public-methods\n\"\"\"Set of ProjectVersion mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    @typechecked\n    def update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n\"\"\"Update properties of a project version.\n\n        Args:\n            project_version_id: Identifier of the project version\n            content: Link to download the project version\n\n        Returns:\n            A result object which indicates if the mutation was successful.\n\n        Examples:\n            &gt;&gt;&gt; kili.update_properties_in_project_version(\n                    project_version_id=project_version_id,\n                    content='test')\n        \"\"\"\n        variables = {\n            \"content\": content,\n            \"id\": project_version_id,\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/project_version/#kili.entrypoints.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","title":"<code>update_properties_in_project_version(self, project_version_id, content)</code>","text":"<p>Update properties of a project version.</p> <p>Parameters:</p> Name Type Description Default <code>project_version_id</code> <code>str</code> <p>Identifier of the project version</p> required <code>content</code> <code>Optional[str]</code> <p>Link to download the project version</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kili.update_properties_in_project_version(\n        project_version_id=project_version_id,\n        content='test')\n</code></pre> Source code in <code>kili/entrypoints/mutations/project_version/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_project_version(self, project_version_id: str, content: Optional[str]):\n\"\"\"Update properties of a project version.\n\n    Args:\n        project_version_id: Identifier of the project version\n        content: Link to download the project version\n\n    Returns:\n        A result object which indicates if the mutation was successful.\n\n    Examples:\n        &gt;&gt;&gt; kili.update_properties_in_project_version(\n                project_version_id=project_version_id,\n                content='test')\n    \"\"\"\n    variables = {\n        \"content\": content,\n        \"id\": project_version_id,\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/","title":"User module","text":""},{"location":"sdk/user/#queries","title":"Queries","text":"<p>Set of User queries.</p> Source code in <code>kili/entrypoints/queries/user/__init__.py</code> <pre><code>class QueriesUser:\n\"\"\"Set of User queries.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments,dangerous-default-value\n\n    @overload\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[True],\n    ) -&gt; Generator[Dict, None, None]:\n        ...\n\n    @overload\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: Literal[False] = False,\n    ) -&gt; List[Dict]:\n        ...\n\n    @typechecked\n    def users(\n        self,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n        first: Optional[int] = None,\n        skip: int = 0,\n        disable_tqdm: bool = False,\n        *,\n        as_generator: bool = False,\n    ) -&gt; Iterable[Dict]:\n        # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of users given a set of criteria.\n\n        Args:\n            api_key: Query an user by its API Key\n            email: Email of the user\n            organization_id: Identifier of the user's organization\n            fields: All the fields to request among the possible fields for the users.\n                See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n            first: Maximum number of users to return\n            skip: Number of skipped users (they are ordered by creation date)\n            disable_tqdm: If `True`, the progress bar will be disabled\n            as_generator: If `True`, a generator on the users is returned.\n\n        Returns:\n            A result object which contains the query if it was successful,\n                or an error message.\n\n        Examples:\n            ```\n            # List all users in my organization\n            &gt;&gt;&gt; organization = kili.organizations()\n            &gt;&gt;&gt; organization_id = organizations[0]['id]\n            &gt;&gt;&gt; kili.users(organization_id=organization_id)\n            ```\n        \"\"\"\n\n        where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n        disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n        options = QueryOptions(disable_tqdm, first, skip)\n        users_gen = UserQuery(self.graphql_client)(where, fields, options)\n\n        if as_generator:\n            return users_gen\n        return list(users_gen)\n\n    @typechecked\n    def count_users(\n        self,\n        organization_id: Optional[str] = None,\n        api_key: Optional[str] = None,\n        email: Optional[str] = None,\n    ) -&gt; int:\n\"\"\"Get user count based on a set of constraints.\n\n        Args:\n            organization_id: Identifier of the user's organization.\n            api_key: Filter by API Key.\n            email: Filter by email.\n\n        Returns:\n            The number of organizations with the parameters provided.\n        \"\"\"\n        where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n        return UserQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.queries.user.__init__.QueriesUser.count_users","title":"<code>count_users(self, organization_id=None, api_key=None, email=None)</code>","text":"<p>Get user count based on a set of constraints.</p> <p>Parameters:</p> Name Type Description Default <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Filter by API Key.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Filter by email.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of organizations with the parameters provided.</p> Source code in <code>kili/entrypoints/queries/user/__init__.py</code> <pre><code>@typechecked\ndef count_users(\n    self,\n    organization_id: Optional[str] = None,\n    api_key: Optional[str] = None,\n    email: Optional[str] = None,\n) -&gt; int:\n\"\"\"Get user count based on a set of constraints.\n\n    Args:\n        organization_id: Identifier of the user's organization.\n        api_key: Filter by API Key.\n        email: Filter by email.\n\n    Returns:\n        The number of organizations with the parameters provided.\n    \"\"\"\n    where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n    return UserQuery(self.graphql_client).count(where)\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.queries.user.__init__.QueriesUser.users","title":"<code>users(self, api_key=None, email=None, organization_id=None, fields=['email', 'id', 'firstname', 'lastname'], first=None, skip=0, disable_tqdm=False, *, as_generator=False)</code>","text":"<p>Get a generator or a list of users given a set of criteria.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>Query an user by its API Key</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Email of the user</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Identifier of the user's organization</p> <code>None</code> <code>fields</code> <code>List[str]</code> <p>All the fields to request among the possible fields for the users. See the documentation for all possible fields.</p> <code>['email', 'id', 'firstname', 'lastname']</code> <code>first</code> <code>Optional[int]</code> <p>Maximum number of users to return</p> <code>None</code> <code>skip</code> <code>int</code> <p>Number of skipped users (they are ordered by creation date)</p> <code>0</code> <code>disable_tqdm</code> <code>bool</code> <p>If <code>True</code>, the progress bar will be disabled</p> <code>False</code> <code>as_generator</code> <code>bool</code> <p>If <code>True</code>, a generator on the users is returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterable[Dict]</code> <p>A result object which contains the query if it was successful,     or an error message.</p> <p>Examples:</p> <pre><code># List all users in my organization\n&gt;&gt;&gt; organization = kili.organizations()\n&gt;&gt;&gt; organization_id = organizations[0]['id]\n&gt;&gt;&gt; kili.users(organization_id=organization_id)\n</code></pre> Source code in <code>kili/entrypoints/queries/user/__init__.py</code> <pre><code>@typechecked\ndef users(\n    self,\n    api_key: Optional[str] = None,\n    email: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    fields: List[str] = [\"email\", \"id\", \"firstname\", \"lastname\"],\n    first: Optional[int] = None,\n    skip: int = 0,\n    disable_tqdm: bool = False,\n    *,\n    as_generator: bool = False,\n) -&gt; Iterable[Dict]:\n    # pylint: disable=line-too-long\n\"\"\"Get a generator or a list of users given a set of criteria.\n\n    Args:\n        api_key: Query an user by its API Key\n        email: Email of the user\n        organization_id: Identifier of the user's organization\n        fields: All the fields to request among the possible fields for the users.\n            See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields.\n        first: Maximum number of users to return\n        skip: Number of skipped users (they are ordered by creation date)\n        disable_tqdm: If `True`, the progress bar will be disabled\n        as_generator: If `True`, a generator on the users is returned.\n\n    Returns:\n        A result object which contains the query if it was successful,\n            or an error message.\n\n    Examples:\n        ```\n        # List all users in my organization\n        &gt;&gt;&gt; organization = kili.organizations()\n        &gt;&gt;&gt; organization_id = organizations[0]['id]\n        &gt;&gt;&gt; kili.users(organization_id=organization_id)\n        ```\n    \"\"\"\n\n    where = UserWhere(api_key=api_key, email=email, organization_id=organization_id)\n    disable_tqdm = disable_tqdm_if_as_generator(as_generator, disable_tqdm)\n    options = QueryOptions(disable_tqdm, first, skip)\n    users_gen = UserQuery(self.graphql_client)(where, fields, options)\n\n    if as_generator:\n        return users_gen\n    return list(users_gen)\n</code></pre>"},{"location":"sdk/user/#mutations","title":"Mutations","text":"<p>Set of User mutations.</p> Source code in <code>kili/entrypoints/mutations/user/__init__.py</code> <pre><code>class MutationsUser:\n\"\"\"Set of User mutations.\"\"\"\n\n    graphql_client: GraphQLClient\n\n    # pylint: disable=too-many-arguments\n    @typechecked\n    def create_user(\n        self,\n        email: str,\n        password: str,\n        organization_role: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n    ) -&gt; Dict[Literal[\"id\"], str]:\n\"\"\"Add a user to your organization.\n\n        Args:\n            email: Email of the new user, used as user's unique identifier.\n            password: On the first sign in, he will use this password and be able to change it.\n            organization_role: One of \"ADMIN\", \"USER\".\n            firstname: First name of the new user.\n            lastname: Last name of the new user.\n\n        Returns:\n            A dictionary with the id of the new user.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"email\": email,\n                \"password\": password,\n                \"organizationRole\": organization_role,\n            }\n        }\n        if firstname is not None:\n            variables[\"data\"][\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"data\"][\"lastname\"] = lastname\n        result = self.graphql_client.execute(GQL_CREATE_USER, variables)\n        return format_result(\"data\", result)\n\n    @typechecked\n    def update_password(\n        self, email: str, old_password: str, new_password_1: str, new_password_2: str\n    ):\n\"\"\"Allow to modify the password that you use to connect to Kili. \\\n        This resolver only works for on-premise installations without Auth0.\n\n        Args:\n            email: Email of the person whose password has to be updated.\n            old_password: The old password\n            new_password_1: The new password\n            new_password_2: A confirmation field for the new password\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables = {\n            \"data\": {\n                \"oldPassword\": old_password,\n                \"newPassword1\": new_password_1,\n                \"newPassword2\": new_password_2,\n            },\n            \"where\": {\"email\": email},\n        }\n        result = self.graphql_client.execute(GQL_UPDATE_PASSWORD, variables)\n        return format_result(\"data\", result)\n\n    def reset_password(self, email: str):\n\"\"\"Reset password.\n\n        !!! warning \"Method removed\"\n            This method is not available anymore.\n            Please use the Kili App instead to reset your password.\n        \"\"\"\n        raise RemovedMethodError(\n            \"reset_password() is not available anymore. Please use the Kili App instead to reset\"\n            \" your password.\"\n        )\n\n    @typechecked\n    def update_properties_in_user(\n        self,\n        email: str,\n        firstname: Optional[str] = None,\n        lastname: Optional[str] = None,\n        organization_id: Optional[str] = None,\n        organization_role: Optional[str] = None,\n        activated: Optional[bool] = None,\n    ):\n\"\"\"Update the properties of a user.\n\n        Args:\n            email: The email is the identifier of the user.\n            firstname:Change the first name of the user.\n            lastname: Change the last name of the user.\n            organization_id: Change the organization the user is related to.\n            organization_role: Change the role of the user.\n                One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n            activated: In case we want to deactivate a user, but keep it.\n\n\n        Returns:\n            A result object which indicates if the mutation was successful,\n                or an error message.\n        \"\"\"\n        variables: Dict[str, Any] = {\n            \"email\": email,\n        }\n        if firstname is not None:\n            variables[\"firstname\"] = firstname\n        if lastname is not None:\n            variables[\"lastname\"] = lastname\n        if organization_id is not None:\n            variables[\"organizationId\"] = organization_id\n        if organization_role is not None:\n            variables[\"organizationRole\"] = organization_role\n        if activated is not None:\n            variables[\"activated\"] = activated\n        result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n        return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.mutations.user.__init__.MutationsUser.create_user","title":"<code>create_user(self, email, password, organization_role, firstname=None, lastname=None)</code>","text":"<p>Add a user to your organization.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email of the new user, used as user's unique identifier.</p> required <code>password</code> <code>str</code> <p>On the first sign in, he will use this password and be able to change it.</p> required <code>organization_role</code> <code>str</code> <p>One of \"ADMIN\", \"USER\".</p> required <code>firstname</code> <code>Optional[str]</code> <p>First name of the new user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Last name of the new user.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[typing_extensions.Literal['id'], str]</code> <p>A dictionary with the id of the new user.</p> Source code in <code>kili/entrypoints/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef create_user(\n    self,\n    email: str,\n    password: str,\n    organization_role: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n) -&gt; Dict[Literal[\"id\"], str]:\n\"\"\"Add a user to your organization.\n\n    Args:\n        email: Email of the new user, used as user's unique identifier.\n        password: On the first sign in, he will use this password and be able to change it.\n        organization_role: One of \"ADMIN\", \"USER\".\n        firstname: First name of the new user.\n        lastname: Last name of the new user.\n\n    Returns:\n        A dictionary with the id of the new user.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"email\": email,\n            \"password\": password,\n            \"organizationRole\": organization_role,\n        }\n    }\n    if firstname is not None:\n        variables[\"data\"][\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"data\"][\"lastname\"] = lastname\n    result = self.graphql_client.execute(GQL_CREATE_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.mutations.user.__init__.MutationsUser.reset_password","title":"<code>reset_password(self, email)</code>","text":"<p>Reset password.</p> <p>Method removed</p> <p>This method is not available anymore. Please use the Kili App instead to reset your password.</p> Source code in <code>kili/entrypoints/mutations/user/__init__.py</code> <pre><code>def reset_password(self, email: str):\n\"\"\"Reset password.\n\n    !!! warning \"Method removed\"\n        This method is not available anymore.\n        Please use the Kili App instead to reset your password.\n    \"\"\"\n    raise RemovedMethodError(\n        \"reset_password() is not available anymore. Please use the Kili App instead to reset\"\n        \" your password.\"\n    )\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.mutations.user.__init__.MutationsUser.update_password","title":"<code>update_password(self, email, old_password, new_password_1, new_password_2)</code>","text":"<p>Allow to modify the password that you use to connect to Kili.         This resolver only works for on-premise installations without Auth0.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email of the person whose password has to be updated.</p> required <code>old_password</code> <code>str</code> <p>The old password</p> required <code>new_password_1</code> <code>str</code> <p>The new password</p> required <code>new_password_2</code> <code>str</code> <p>A confirmation field for the new password</p> required <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_password(\n    self, email: str, old_password: str, new_password_1: str, new_password_2: str\n):\n\"\"\"Allow to modify the password that you use to connect to Kili. \\\n    This resolver only works for on-premise installations without Auth0.\n\n    Args:\n        email: Email of the person whose password has to be updated.\n        old_password: The old password\n        new_password_1: The new password\n        new_password_2: A confirmation field for the new password\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables = {\n        \"data\": {\n            \"oldPassword\": old_password,\n            \"newPassword1\": new_password_1,\n            \"newPassword2\": new_password_2,\n        },\n        \"where\": {\"email\": email},\n    }\n    result = self.graphql_client.execute(GQL_UPDATE_PASSWORD, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/user/#kili.entrypoints.mutations.user.__init__.MutationsUser.update_properties_in_user","title":"<code>update_properties_in_user(self, email, firstname=None, lastname=None, organization_id=None, organization_role=None, activated=None)</code>","text":"<p>Update the properties of a user.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email is the identifier of the user.</p> required <code>firstname</code> <code>Optional[str]</code> <p>Change the first name of the user.</p> <code>None</code> <code>lastname</code> <code>Optional[str]</code> <p>Change the last name of the user.</p> <code>None</code> <code>organization_id</code> <code>Optional[str]</code> <p>Change the organization the user is related to.</p> <code>None</code> <code>organization_role</code> <code>Optional[str]</code> <p>Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".</p> <code>None</code> <code>activated</code> <code>Optional[bool]</code> <p>In case we want to deactivate a user, but keep it.</p> <code>None</code> <p>Returns:</p> Type Description <p>A result object which indicates if the mutation was successful,     or an error message.</p> Source code in <code>kili/entrypoints/mutations/user/__init__.py</code> <pre><code>@typechecked\ndef update_properties_in_user(\n    self,\n    email: str,\n    firstname: Optional[str] = None,\n    lastname: Optional[str] = None,\n    organization_id: Optional[str] = None,\n    organization_role: Optional[str] = None,\n    activated: Optional[bool] = None,\n):\n\"\"\"Update the properties of a user.\n\n    Args:\n        email: The email is the identifier of the user.\n        firstname:Change the first name of the user.\n        lastname: Change the last name of the user.\n        organization_id: Change the organization the user is related to.\n        organization_role: Change the role of the user.\n            One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\".\n        activated: In case we want to deactivate a user, but keep it.\n\n\n    Returns:\n        A result object which indicates if the mutation was successful,\n            or an error message.\n    \"\"\"\n    variables: Dict[str, Any] = {\n        \"email\": email,\n    }\n    if firstname is not None:\n        variables[\"firstname\"] = firstname\n    if lastname is not None:\n        variables[\"lastname\"] = lastname\n    if organization_id is not None:\n        variables[\"organizationId\"] = organization_id\n    if organization_role is not None:\n        variables[\"organizationRole\"] = organization_role\n    if activated is not None:\n        variables[\"activated\"] = activated\n    result = self.graphql_client.execute(GQL_UPDATE_PROPERTIES_IN_USER, variables)\n    return format_result(\"data\", result)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/","title":"Basic Project Setup","text":""},{"location":"sdk/tutorials/basic_project_setup/#how-to-set-up-a-basic-kili-project","title":"How to set up a basic Kili project","text":"<p>In this tutorial, we will learn how to set up a basic Kili project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Installing and instantiating Kili</li> <li>Creating a basic Kili project</li> <li>Adding assets to project</li> <li>Adding users to project</li> </ol>"},{"location":"sdk/tutorials/basic_project_setup/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clcun99cn15wx0lq4c15a4dj7\n</code></pre> <p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p>"},{"location":"sdk/tutorials/basic_project_setup/#adding-assets-to-project","title":"Adding assets to project","text":"<pre><code># Image urls\nurl1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],\n)\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#adding-users-to-project","title":"Adding users to project","text":"<p>Now we need to add users to our project. Before we do that, we have to add them to our organization. Note that you have to be an org admin to be able to do that.</p> <p>For more info on roles in an organization, refer to https://docs.kili-technology.com/docs/user-roles-in-organization.</p> <pre><code>firstname = \"Jane\"\nlastname = \"Doe\"\nemail = \"no.such.email@no.such.domain.com\"\npassword = \"12345\"\norganization_role = \"USER\"\n\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.create_user(email, password, organization_role, firstname, lastname)\nexcept GraphQLError as err:\n    print(str(err))\n</code></pre> <pre><code>error: \"[noOrganizationRights] You cannot use this function because it seems that you do not have access to this organization. Please contact you organization admin. -- This can be due to: User isn't admin from the organization | trace : false\"\n</code></pre> <p>If you already have users in your organization, here's how you can easily access their IDs:</p> <p>1) First, retrieve your organization ID:</p> <pre><code>org_id = kili.organizations()[0][\"id\"]\n</code></pre> <p>2) Then, based on your org ID, retrieve the full list of org users, with their e-mails:</p> <pre><code>all_org_users = kili.users(organization_id=org_id)\n\nall_emails = [i[\"email\"] for i in all_org_users]\n</code></pre> <p>3) We will use the e-mail of the new user to add our new user to our project:</p> <pre><code>user = kili.append_to_roles(project_id, \"no.such.email@no.such.domain.com\", role=\"LABELER\")\nprint(user)\n</code></pre> <pre><code>{'user': {'id': 'clcumy1fx15ci0lre0k21fnu7', 'email': 'no.such.email@no.such.domain.com'}, 'role': 'LABELER'}\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/basic_project_setup/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, defined its interface, created a brand new user, and finally added our new user to the new project. Well done!</p>"},{"location":"sdk/tutorials/export_a_kili_project/","title":"Exporting a Project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#how-to-export-data-from-a-kili-project","title":"How to export data from a Kili project","text":""},{"location":"sdk/tutorials/export_a_kili_project/#outline","title":"Outline","text":"<p>This tutorial explains the multiple ways to export a Kili project. It describes:</p> <ul> <li>Methods to export the labels one by one, after filtering</li> <li>The solutions for performing a full-project export</li> </ul> <p>The methods are illustrated with code snippets.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","title":"Export methods","text":"<p>With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it:</p> <ul> <li>Fetch the assets and/or the labels one by one using <code>.assets</code> or <code>.labels</code>, perform the data transformation yourself and then write the data to one or several output files.</li> <li>Export the whole project as a dataset. To do that, use the <code>.export_labels</code> method that creates an archive containing the labels in your chosen format.</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","title":"Preliminary steps","text":"<p>1) Fetch the project ID from the Kili UI (in Settings / Admin):</p> <p></p> <p>2) Ensure that your Kili API key has been set as an environment variable: <pre><code>export KILI_API_KEY=&lt;YOUR_API_KEY&gt;\n</code></pre></p> <p>3) If Kili has not been installed yet, install Kili.</p> <pre><code>%pip install  kili\n</code></pre> <p>4) Import packages and instantiate <code>Kili</code>:</p> <pre><code>from pathlib import Path\n\nfrom kili.client import Kili\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","title":"Exporting assets and labels one by one","text":"<p>To retrieve all assets of a project one by one, perform the following steps:</p>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","title":"Exporting the latest labels per asset","text":"<p>First, fetch the assets:</p> <pre><code>assets = kili.assets(\n    your_project_id,\n    fields=[\"externalId\", \"latestLabel.jsonResponse\"],\n    label_output_format=\"parsed_label\",\n)\n</code></pre> <p>Now if you print an asset, you will see that you can access its <code>latestLabel</code>:</p> <pre><code>print(assets[0])\n</code></pre> <pre><code>{'latestLabel': {'jsonResponse': {'JOB_0': {'annotations': [{'categories': [{'name': 'OBJECT_A'}], 'mid': '20230111125258113-44528', 'type': 'rectangle', 'boundingPoly': [{'normalizedVertices': [{'x': 0.6101435505380516, 'y': 0.7689773770786136}, {'x': 0.6101435505380516, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.7689773770786136}]}], 'polyline': [], 'children': {}}]}}}, 'externalId': 'car_1'}\n</code></pre> <p>You can now get your label, and write the category name into a text file for example:</p> <pre><code>for asset in assets:\n    if asset[\"latestLabel\"]:  # check if asset has annotations\n        class_ = asset[\"latestLabel\"].jobs[\"JOB_0\"].annotations[0].category.name\n        with Path(asset[\"externalId\"] + \".txt\").open(\"w\", encoding=\"utf-8\") as f:\n            f.write(class_)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","title":"Filtering specific labels per asset through the method filters","text":"<p>You can specify label filters directly in the <code>.assets</code> and the <code>.labels</code> methods. The available filters are listed in the arguments list for each one of these methods.</p> <p>When done, you can write the conversion code to get the data in the format that you need.</p> <p>Get only the assets with a consensus mark above 0.5:</p> <pre><code>assets = kili.assets(\n    your_project_id, fields=[\"externalId\", \"id\", \"consensusMark\"], consensus_mark_gt=0.5\n)\nprint(assets)\n# + asset conversion code\n</code></pre> <pre><code>[{'externalId': 'car_1', 'id': 'clcyuykzd0000bgvze2z3wk81', 'consensusMark': 0.6504290982818591}]\n</code></pre> <p>Get all the labels with a honeypot mark above 0.1:</p> <pre><code>labels = kili.labels(\n    your_project_id,\n    fields=[\"labelOf.externalId\", \"honeypotMark\", \"author.email\", \"id\"],\n    honeypot_mark_gte=0.1,\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'honeypotMark': 0.16527040499137607, 'id': 'clcyuynri2fnl0krf0d7pgabo'}, {'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.smith@kili-technology.com'}, 'honeypotMark': 0.20754115450190522, 'id': 'clcyuynri2fnm0krfhx934jee'}]\n</code></pre> <p>Get all the labels added by a specific project member:</p> <pre><code>labels = kili.labels(\n    your_project_id, fields=[\"labelOf.externalId\", \"author.email\", \"id\"], user_id=john_doe_id\n)\nprint(labels)\n# + label conversion code\n</code></pre> <pre><code>[{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'id': 'clcyuynri2fnl0krf0d7pgabo'}]\n</code></pre> <p>This code will return a list of labels authored by John Doe.</p> <p>You can also use the <code>author_in</code> parameter to filter by name directly.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","title":"Filtering specific labels per asset through the label properties","text":"<p>You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field <code>\"labels.isLatestReviewLabelForUser\"</code> to check if the label is the latest per user.</p> <pre><code>import json\n\nassets = kili.assets(\n    your_project_id,\n    fields=[\"externalId\", \"labels.jsonResponse\", \"labels.isLatestReviewLabelForUser\"],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:  # check if asset has annotations\n        for label in asset[\"labels\"]:\n            if label[\"isLatestReviewLabelForUser\"] and \"JOB_0\" in label[\"jsonResponse\"]:\n                annotation = label[\"jsonResponse\"][\"JOB_0\"]\n                with Path(asset[\"externalId\"] + \".json\").open(\"w\", encoding=\"utf-8\") as f:\n                    f.write(json.dumps(annotation))\n                break  # once we find a latest label done by a reviewer, we move on to the next asset.\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","title":"Filtering the latest label per annotator","text":"<p>When working on a project with consensus enabled, it can be useful to export the latest label made by each annotator:</p> <pre><code>from collections import defaultdict\n\nassets = kili.assets(\n    \"clb54wfkn01zb0kyadscgaf5j\",\n    fields=[\n        \"externalId\",\n        \"labels.author.email\",\n        \"labels.createdAt\",\n        \"labels.labelType\",\n        \"labels.jsonResponse\",\n    ],\n)\n\nfor asset in assets:\n    if asset[\"labels\"]:\n        latest_label_by_user = defaultdict(list)\n        for label in asset[\"labels\"]:\n            if label[\"labelType\"] == \"DEFAULT\":\n                latest_label_by_user[label[\"author\"][\"email\"]].append(label)\n        latest_label_per_user = {\n            email: max(labels, key=lambda x: x[\"createdAt\"])\n            for email, labels in latest_label_by_user.items()\n        }\n        with (Path(\"/tmp\") / (asset[\"externalId\"] + \".json\")).open(\"w\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(latest_label_per_user))\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","title":"Exporting a whole project","text":"<p>You can export your project data from the Kili UI (see documentation), but Kili SDK also enables you to export your labels and assets into several export formats.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","title":"Available formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","title":"The <code>.export_labels</code> method","text":"<p>The <code>.export_labels</code> method enables the export of a full project. It does the following preprocessing:</p> <ul> <li>Only fetches the labels of types <code>\"DEFAULT\"</code> and <code>\"REVIEW\"</code> (see the label types explanations).</li> <li>If specified, selects a subset of asset ids.</li> <li>Exports labels to one of the standard formats (only available for a restricted set of ML tasks).</li> <li>Using various method arguments, you can decide:<ul> <li>Whether or not to include the assets in the export</li> <li>Whether to export just the latest label or all the labels</li> <li>Whether to create one folder for all the jobs or one folder per job</li> <li>Whether or not to export the label-related data into one single file</li> </ul> </li> </ul> <p>Note that some formats are by default single-file, while others use many files:</p> Format Single file Multiple files Kili \u2705 \u2705 Yolo \u274c \u2705 Pascal VOC \u274c \u2705 COCO \u2705 \u274c <p>For all the formats, in the output archive, a <code>README.kili.txt</code> file is also created. Here is an example of its contents: <pre><code>Exported Labels from KILI\n=========================\n\n- Project name: Awesome annotation project\n- Project identifier: abcdefghijklmnop\n- Project description: This project contains labels, most of which are awesome.\n- Export date: 20221125-093324\n- Exported format: kili\n- Exported labels: latest\n</code></pre></p>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","title":"Kili format, one file per asset","text":"<p>The following code snippet exports the whole asset payload and the associated labels, with one json file per asset, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","title":"Kili format, one file for the whole project","text":"<p>This code snippet exports the whole asset payload and the associated labels as one file for the whole project, into the <code>/tmp/export.zip</code> folder.</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"kili\",\n    single_file=True,\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","title":"YOLO formats","text":"<p>When you have at least one Object Detection job with bounding boxes, you can also export to one of the YOLO formats. You can choose <code>\"yolo_v4\"</code>, <code>\"yolo_v5\"</code> or <code>\"yolo_v7\"</code>. The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, one file per asset is produced, containing the last created <code>DEFAULT</code> or <code>REVIEW</code> label. Each YOLO label has the following shape: <pre><code>2        0.25 0.67 0.26 0.34\n^        ^    ^    ^    ^\nclass    x    y    w    h\n</code></pre> where:</p> <ul> <li><code>class</code> is the class index in the classes list contained in the YOLO metadata file.</li> <li><code>x</code> is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>y</code> is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box.</li> <li><code>w</code> is the width relative to the image width (between 0.0 and 1.0) of the bounding box.</li> <li><code>h</code> is the height relative to the image height (between 0.0 and 1.0) of the bounding box.</li> </ul> <p>Here is an example of a YOLO annotation over an image:</p> <p></p> <p>Here is how to export to YOLO (in this example, YOLOv5):</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"yolo_v5\",\n)\n</code></pre> <pre><code>Fetching assets...\n/tmp/export.zip\n</code></pre> <p>Note that a standard YOLO file format must also include:</p> <ul> <li>The path root to the assets</li> <li>The <code>train</code>, <code>val</code> and <code>test</code> subfolders</li> </ul> <p>Placing specific data in specific folders is the decision of an ML engineer or a Data scientist, so we are not providing a code snippet here.</p>"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","title":"COCO format","text":"<p>To export your data into the COCO format, run the following code:</p> <pre><code>kili.export_labels(\n    project_id=your_project_id,\n    filename=\"/tmp/export.zip\",\n    fmt=\"coco\",\n)\n</code></pre> <pre><code>Fetching assets...\nConvert to coco format: 1it [00:00, 54.94it/s]\n/tmp/export.zip\n</code></pre> <p>This will create an archive containing both:</p> <ul> <li>The COCO annotation file</li> <li>The <code>data/</code> folder with all the assets</li> </ul>"},{"location":"sdk/tutorials/export_a_kili_project/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(your_project_id)\n</code></pre>"},{"location":"sdk/tutorials/export_a_kili_project/#summary","title":"Summary","text":"<p>In this tutorial, we have seen several ways to export labels from a Kili project:</p> <ul> <li>Using <code>.assets</code> and <code>.labels</code> and their filtering arguments, a subset of assets or labels can be selected and then exported.</li> <li>Using <code>.export_labels</code>, the whole project can be exported into a standard output format.</li> </ul>"},{"location":"sdk/tutorials/finetuning_dinov2/","title":"DINOv2 Classification Pre-annotations","text":""},{"location":"sdk/tutorials/finetuning_dinov2/#how-to-fine-tune-dinov2-for-image-classification","title":"How to fine-tune DINOv2 for image classification","text":"<p>This tutorial shows how to use the DINOv2 self-supervised vision transformer model to generate pre-annotations on a defect detection use case.</p> <p>Modern foundation models (FMs) are capable of performing many diverse tasks; large language models can quickly and accurately process natural language while models focused on image processing are very good at computer vision tasks, such as object detection or classification.</p> <p>By retraining an FM on a very limited set of examples, it is possible to even further improve its performance on a specific task, such as image classification. This process is called fine-tuning.</p> <p>Throughout this tutorial, we will:</p> <ul> <li>Configure a project on Kili.</li> <li>Fine-tune the DINOv2 model using a tiny set of labeled images on Kili.</li> <li>Generate pre-annotations on a set of images to label.</li> <li>Evaluate the quality of the generated pre-annotations in the Kili interface.</li> </ul>"},{"location":"sdk/tutorials/finetuning_dinov2/#setup","title":"Setup","text":"<p>Let's first install the Kili package and all other packages required for our experiment:</p> <pre><code>%pip install kili matplotlib numpy Pillow scikit-learn torch torchvision kaggle tqdm\n</code></pre> <pre><code>import getpass\nimport os\nimport random\nimport shutil\nimport zipfile\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sklearn\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom PIL import Image\nfrom sklearn.metrics import classification_report\nfrom torchvision import datasets, transforms\nfrom tqdm.notebook import tqdm\n\nfrom kili.client import Kili\n</code></pre> <p>To interact with Kili using the Python SDK, it is necessary to have a Kili account and an API key.</p> <pre><code>if \"KILI_API_KEY\" in os.environ:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\nelse:\n    KILI_API_KEY = getpass.getpass(\"Please enter your Kili API key: \")\n</code></pre> <pre><code>Please enter your Kili API key: \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\n</code></pre> <p>We can now initialize the Kili client:</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#kili-project-configuration","title":"Kili project configuration","text":"<p>In this section, we will create a project from scratch with existing labels on Kili.</p> <p>If you want to use your own project, you can simply skip this section and replace the <code>project_id</code> variable by your own project ID.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#download-assets-create-project","title":"Download assets &amp; create project","text":"<p>For this tutorial, we will use a real-life image dataset of products created through the process of casting from Kaggle. You can download it from here.</p> <p>We will use the Kaggle API to download the dataset.</p> <pre><code>path_to_kaggle_api_key = Path.home() / \".kaggle\" / \"kaggle.json\"\n\nif not path_to_kaggle_api_key.is_file():\n    json_key_str = getpass.getpass(\"Enter your kaggle json api key: \")\n    path_to_kaggle_api_key.parent.mkdir(parents=True, exist_ok=True)\n    path_to_kaggle_api_key.write_text(json_key_str)\n</code></pre> <pre><code>!kaggle datasets download -d ravirajsinh45/real-life-industrial-dataset-of-casting-product\n</code></pre> <p>Once the .zip file is downloaded, we can unzip it and discover the structure of the dataset:</p> <pre><code>with zipfile.ZipFile(\"real-life-industrial-dataset-of-casting-product.zip\", \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\n</code></pre> <p>We can see that the dataset has two classes of images: <code>ok_front</code> and <code>def_front</code>. <code>ok_front</code> images are images of products without defects, and <code>def_front</code> images are images of products with defects.</p> <pre><code>data_dir = Path(\".\") / \"casting_512x512\" / \"casting_512x512\"\nprint(os.listdir(data_dir))\nprint(len(os.listdir(data_dir / \"def_front\")))\nprint(len(os.listdir(data_dir / \"ok_front\")))\n</code></pre> <pre><code>['ok_front', 'def_front']\n781\n519\n</code></pre> <p>The <code>ok_front</code> class has 519 images, and the <code>def_front</code> class has 781 images.</p> <p>Let's take a look at the images:</p> <pre><code>plt.imshow(Image.open(next((data_dir / \"def_front\").iterdir())))\nplt.show()\n</code></pre> <p></p> <pre><code>plt.imshow(Image.open(next((data_dir / \"ok_front\").iterdir())))\nplt.show()\n</code></pre> <p></p> <p>We can balance the dataset and keep only <code>N</code> images in total:</p> <pre><code>N = 400\n\nfor class_name in [\"def_front\", \"ok_front\"]:\n    filepaths_to_delete = sorted(os.listdir(data_dir / class_name))[N // 2 :]\n    for filepath in filepaths_to_delete:\n        (data_dir / class_name / filepath).unlink(missing_ok=True)\n\nassert len(os.listdir(data_dir / \"def_front\")) == N // 2\nassert len(os.listdir(data_dir / \"ok_front\")) == N // 2\n</code></pre> <p>Next, we create the Kili project with its ontology showing the two categories:</p> <pre><code>project_title = \"Demo - DINOv2 Classification\"\n\njson_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"YES\": {\"children\": [], \"name\": \"Yes\", \"id\": \"category1\"},\n                    \"NO\": {\"children\": [], \"name\": \"No\", \"id\": \"category2\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Defect(s) in image?\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isNew\": False,\n        }\n    }\n}\n\nproject_id = kili.create_project(\n    title=project_title, json_interface=json_interface, input_type=\"IMAGE\"\n)[\"id\"]\n</code></pre> <p>We can then prepare the assets to be uploaded to Kili:</p> <pre><code># sort the assets by alternating between classes so that both\n# classes show up in the first page of the labeling interface\ncontent_array = []\niterator = zip((data_dir / \"def_front\").iterdir(), (data_dir / \"ok_front\").iterdir())\nfor filepath_def, filepath_ok in iterator:\n    content_array.append(filepath_def)\n    content_array.append(filepath_ok)\nprint(content_array[0])\n</code></pre> <pre><code>casting_512x512/casting_512x512/def_front/cast_def_0_1145.jpeg\n</code></pre> <p>The external ID of each asset is the name of the image displayed in the Kili interface:</p> <pre><code>external_id_array = []\nfor filepath in content_array:\n    class_ = \"def\" if \"_def_\" in filepath.name else \"ok\"\n    external_id = filepath.name.replace(\"cast_ok_0_\", \"\").replace(\"cast_def_0_\", \"\")\n    external_id = external_id.replace(\".jpeg\", \"_\" + class_[:1])\n    external_id_array.append(external_id)\nassert len(set(external_id_array)) == N\nprint(external_id_array[0])\n</code></pre> <pre><code>1145_d\n</code></pre> <p>The class of an image is available in the file name. We can extract it and add it to the Kili asset metadata:</p> <pre><code>output_class_array = [\"YES\" if \"def\" in filepath.name else \"NO\" for filepath in content_array]\nprint(output_class_array[0])\n</code></pre> <pre><code>YES\n</code></pre> <p>We input the ground truth in the metadata, this will be useful later on:</p> <pre><code>json_metadata_array = [{\"Ground Truth\": output_class} for output_class in output_class_array]\nprint(json_metadata_array[0])\n</code></pre> <pre><code>{'Ground Truth': 'YES'}\n</code></pre> <p>We now upload the assets to our Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    external_id_array=external_id_array,\n    content_array=[str(x) for x in content_array],\n    json_metadata_array=json_metadata_array,\n)\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#import-annotations","title":"Import annotations","text":"<p>In this tutorial, we will need to use ground truth annotations to fine-tune the DINOv2 model.</p> <p>We thus simulate manual labeling on some images.</p> <pre><code>nb_manually_labeled_assets = 200\n</code></pre> <pre><code>json_response_array = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"confidence\": 100, \"name\": output_class}]}}\n    for output_class in output_class_array\n]\n</code></pre> <pre><code>kili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=external_id_array[:nb_manually_labeled_assets],\n    json_response_array=json_response_array[:nb_manually_labeled_assets],\n    label_type=\"DEFAULT\",\n    seconds_to_label_array=[\n        random.randint(60, 300) for _ in range(nb_manually_labeled_assets)  # simulate labeling time\n    ],\n)\n\n# Replace the project_id below with your own project_id!\nprint(f\"\\nAccess your project at: https://cloud.kili-technology.com/label/projects/{project_id}\")\n</code></pre> <pre><code>Access your project at: https://cloud.kili-technology.com/label/projects/cliistnwa003c0j78ay1y3qlm\n</code></pre> <p></p> <p>Now we have a configured project on our Kili organization, with some assets already manually labeled.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#model-training","title":"Model training","text":"<p>In this section, we will fine-tune the DINOv2 model using labeled images from a Kili project.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#dataset-preparation","title":"Dataset preparation","text":"<p>Here, we will use the project we created earlier, but feel free to use your own project:</p> <pre><code>project_id = project_id  # put your own Kili project id here\n</code></pre> <pre><code>nb_labeled_assets = 200  # put the number of labeled assets you want to retrieve here\n</code></pre> <pre><code>data_dir = \"./data\"\n\nlabeled_assets = kili.assets(\n    project_id=project_id,\n    fields=[\n        \"id\",\n        \"content\",\n        \"labels.jsonResponse\",\n        \"externalId\",\n        \"latestLabel.jsonResponse\",\n        \"jsonMetadata\",\n    ],\n    status_in=[\"LABELED\"],  # we retrieve assets already labeled\n    download_media=True,\n    local_media_dir=data_dir,\n    first=nb_labeled_assets,\n    label_output_format=\"parsed_label\",\n)\n\nprint(f\"\\nRetrieved {len(labeled_assets)} labeled assets.\")\n</code></pre> <pre><code>Retrieved 200 labeled assets.\n</code></pre> <p>We split the train data into the two classes:</p> <pre><code>Path(\"./data/train/YES\").mkdir(parents=True, exist_ok=True)\nPath(\"./data/train/NO\").mkdir(parents=True, exist_ok=True)\n\nfor asset in labeled_assets:\n    class_name = asset[\"latestLabel\"].jobs[\"CLASSIFICATION_JOB\"].category.name\n    filepath = Path(asset[\"content\"])\n    filepath.rename(filepath.parent / \"train\" / class_name / filepath.name)\n\nprint(os.listdir(data_dir))\nprint(len(os.listdir(data_dir + \"/train/YES\")))\nprint(len(os.listdir(data_dir + \"/train/NO\")))\n</code></pre> <pre><code>['train']\n100\n100\n</code></pre> <p>Below, we prepare the pipeline that loads the images and applies some data augmentation. Data augmentation is a technique that consists of applying random transformations to the images to artificially increase the size of the dataset. This technique is very useful when the dataset is small, since it allows the model to see more images during training.</p> <p>For example, we can apply random horizontal and vertical flips and random rotations to the images:</p> <pre><code>data_transforms = {\n    \"train\": transforms.Compose(\n        [\n            transforms.Resize(224),\n            transforms.RandomRotation(360),\n            transforms.RandomHorizontalFlip(),\n            transforms.RandomVerticalFlip(),\n            transforms.ToTensor(),\n            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n        ]\n    ),\n}\n\nimage_datasets = {\n    \"train\": datasets.ImageFolder(os.path.join(data_dir, \"train\"), data_transforms[\"train\"])\n}\n\ndataloaders = {\n    \"train\": torch.utils.data.DataLoader(image_datasets[\"train\"], batch_size=8, shuffle=True)\n}\n\nclass_names = image_datasets[\"train\"].classes\n\nprint(class_names)\n</code></pre> <pre><code>['NO', 'YES']\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#model-download-fine-tuning","title":"Model download &amp; fine-tuning","text":"<p>We load the DINOv2 model from the HuggingFace library:</p> <pre><code>dinov2_vits14 = torch.hub.load(\"facebookresearch/dinov2\", \"dinov2_vits14\")\n</code></pre> <p>Let's see what is the output of this model:</p> <pre><code>input_img_tensor, class_id = next(iter(image_datasets[\"train\"]))\n\nwith torch.inference_mode():\n    output = dinov2_vits14(torch.unsqueeze(input_img_tensor, dim=0))\n\nprint(output.size())\n</code></pre> <pre><code>torch.Size([1, 384])\n</code></pre> <p>As you can see, the output is a vector of dimension 384. This is the embedding of the image.</p> <p>The embedding is a vector that represents the image in the DINOv2 model latent space. The embedding contains a compressed representation of the image, which is useful for many tasks, such as image classification.</p> <p>The embedding dimension is:</p> <ul> <li>384 for ViT-S (we are using this model in this tutorial).</li> <li>768 for ViT-B.</li> <li>1024 for ViT-L.</li> <li>1536 for ViT-g.</li> </ul> <p>To predict a class, we need to add a classification head to the DINOv2 model.</p> <p>This small neural network will take the embeddings as input, and will output a score for the binary classification.</p> <pre><code>class DinoVisionTransformerClassifier(nn.Module):\n    def __init__(self):\n        super(DinoVisionTransformerClassifier, self).__init__()\n        self.transformer = deepcopy(dinov2_vits14)\n        self.classifier = nn.Sequential(nn.Linear(384, 256), nn.ReLU(), nn.Linear(256, 1))\n\n    def forward(self, x):\n        x = self.transformer(x)\n        x = self.transformer.norm(x)\n        x = self.classifier(x)\n        return x\n\n\nmodel = DinoVisionTransformerClassifier()\n</code></pre> <p>Below, we select the device to use for training. It is recommended to use a GPU for this task:</p> <pre><code>device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nprint(\"Device: \", device)\nmodel = model.to(device)\nmodel = model.train()\n</code></pre> <pre><code>Device:  cuda:0\n</code></pre> <p>We use a binary cross-entropy loss to train the model, with the Adam optimizer.</p> <p>The binary cross-entropy loss is a standard loss function for binary classification tasks. The loss is like the error between the predicted class and the ground truth class. The higher the loss, the worse the model is.</p> <p>To decrease the loss, we will use the Adam optimizer, which is a widely used optimizer for neural networks. It is a stochastic gradient descent method that computes adaptive learning rates for each parameter of the model.</p> <pre><code>criterion = nn.BCEWithLogitsLoss()\noptimizer = optim.Adam(model.parameters(), lr=1e-6)\n</code></pre> <p>We also define the number of epochs to train the model. An epoch is a full pass through the training data.</p> <pre><code>num_epochs = 15\n</code></pre> <pre><code>epoch_losses = []\nfor epoch in range(num_epochs):\n    print(\"Epoch: \", epoch)\n\n    batch_losses = []\n    for data in dataloaders[\"train\"]:\n        # get the input batch and the labels\n        batch_of_images, labels = data\n\n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # model prediction\n        output = model(batch_of_images.to(device)).squeeze(dim=1)\n\n        # compute loss and do gradient descent\n        loss = criterion(output, labels.float().to(device))\n        loss.backward()\n        optimizer.step()\n\n        batch_losses.append(loss.item())\n\n    epoch_losses.append(np.mean(batch_losses))\n    print(f\"Mean epoch loss: {epoch_losses[-1]}\")\n\nprint(\"Finished training!\")\n</code></pre> <pre><code>Epoch:  0\nMean epoch loss: 0.7347773921489715\nEpoch:  1\nMean epoch loss: 0.5930992090702056\nEpoch:  2\nMean epoch loss: 0.5117795491218566\nEpoch:  3\nMean epoch loss: 0.4436239504814148\nEpoch:  4\nMean epoch loss: 0.34697133481502535\nEpoch:  5\nMean epoch loss: 0.2919022357463837\nEpoch:  6\nMean epoch loss: 0.18035753384232522\nEpoch:  7\nMean epoch loss: 0.117118861079216\nEpoch:  8\nMean epoch loss: 0.11755006849765777\nEpoch:  9\nMean epoch loss: 0.08585118860006333\nEpoch:  10\nMean epoch loss: 0.07716833263635635\nEpoch:  11\nMean epoch loss: 0.05035351105034351\nEpoch:  12\nMean epoch loss: 0.06317368872463704\nEpoch:  13\nMean epoch loss: 0.04912809677422047\nEpoch:  14\nMean epoch loss: 0.05099196014925837\nFinished training!\n</code></pre> <p>As you can see on the plot below, the loss decreases as the number of epochs increases. This means that the model has successfully learned to classify images.</p> <p>When the loss stops decreasing, it means that the model has converged and that we can stop the training. In this case, we could have stopped the training after 11 epochs.</p> <pre><code>plt.plot(epoch_losses)\nplt.title(\"Mean epoch loss\")\nplt.xlabel(\"Epoch Number\")\nplt.ylabel(\"Loss\")\nplt.show()\n</code></pre> <p></p> <p>Perfect! The model is now fine-tuned on the labeled images from Kili.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#predict-with-the-model-on-unlabeled-assets","title":"Predict with the model on unlabeled assets","text":"<p>In this section, we will use the fine-tuned model to generate pre-annotations on a set of images to label.</p> <pre><code>max_nb_assets_to_label = 200\n</code></pre> <pre><code>non_labeled_assets = kili.assets(\n    project_id=project_id,\n    fields=[\"id\", \"content\", \"externalId\", \"jsonMetadata\"],\n    status_in=[\"TODO\"],  # we choose assets to label\n    first=max_nb_assets_to_label,\n    download_media=True,\n)\nprint(\"\\nNumber of fetched assets to label: \", len(non_labeled_assets))\n</code></pre> <pre><code>Number of fetched assets to label:  200\n</code></pre> <p>The <code>kili.assets</code> method returns a list of assets represented as Python dictionaries:</p> <pre><code>non_labeled_assets[0]\n</code></pre> <pre><code>{'id': 'cliisunn100xcmkp9tsuj17ut',\n 'content': '/root/.cache/kili/projects/cliistnwa003c0j78ay1y3qlm/assets/3016_d.jpg',\n 'externalId': '3016_d',\n 'jsonMetadata': {'Ground Truth': 'YES'}}\n</code></pre> <p>We can now use the model to generate pre-annotations on the assets:</p> <pre><code>data_transforms = transforms.Compose(\n    [\n        transforms.Resize(256),\n        transforms.CenterCrop(224),\n        transforms.ToTensor(),\n        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n    ]\n)\n</code></pre> <p>We switch the model to evaluation mode since we don't want to update the weights of the model anymore:</p> <pre><code>model = model.eval()\n</code></pre> <pre><code>external_id_array_non_labeled_assets = []\ny_true_non_labeled_assets = []\nembeddings_non_labeled_assets = []\ny_pred_dinov2_non_labeled_assets = []\njson_response_array_non_labeled_assets = []\n\nfor asset in tqdm(non_labeled_assets):\n    external_id_array_non_labeled_assets.append(asset[\"externalId\"])\n    y_true_non_labeled_assets.append(asset[\"jsonMetadata\"][\"Ground Truth\"])\n\n    img = Image.open(asset[\"content\"])\n\n    img_tensor = data_transforms(img)\n    img_tensor = img_tensor.unsqueeze(0)\n    input_tensor = img_tensor.to(device)\n\n    # Perform inference\n    with torch.no_grad():\n        embeddings = model.transformer(input_tensor)\n        embeddings_non_labeled_assets.append(embeddings[0].cpu().numpy())\n        x = model.transformer.norm(embeddings)\n        output_tensor = model.classifier(x)\n\n    score = output_tensor[0][0].item()\n\n    score = 1 / (1 + np.exp(-score))  # sigmoid\n\n    output_class = \"YES\" if score &gt; 0.5 else \"NO\"\n\n    y_pred_dinov2_non_labeled_assets.append(output_class)\n\n    json_response_array_non_labeled_assets.append(\n        {\n            \"CLASSIFICATION_JOB\": {\n                \"categories\": [{\"confidence\": int(round(score * 100)), \"name\": output_class}]\n            }\n        }\n    )\n</code></pre> <p>We now push the predictions to Kili as pre-annotations (prediction) and inference labels.</p> <p>The pre-annotations will be helpful for the labelers to label the assets, since those pre-annotations will be displayed in the Kili interface. It will help them to label the assets faster.</p> <p>The inference labels will be used to evaluate the quality of the model against labelers.</p> <p>You can learn more about the different kinds of labels in the Kili documentation.</p> <pre><code>kili.append_labels(\n    project_id=project_id,\n    json_response_array=json_response_array_non_labeled_assets,\n    model_name=\"DINOv2\",\n    label_type=\"INFERENCE\",\n    asset_external_id_array=external_id_array_non_labeled_assets,\n)\n\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=json_response_array_non_labeled_assets,\n    model_name=\"DINOv2\",\n    label_type=\"PREDICTION\",\n    asset_external_id_array=external_id_array_non_labeled_assets,\n);\n</code></pre>"},{"location":"sdk/tutorials/finetuning_dinov2/#pre-annotations-quality-analysis","title":"Pre-annotations quality analysis","text":""},{"location":"sdk/tutorials/finetuning_dinov2/#finetuning-with-dinov2","title":"Finetuning with DINOv2","text":"<pre><code>print(classification_report(y_true_non_labeled_assets, y_pred_dinov2_non_labeled_assets))\n</code></pre> <pre><code>              precision    recall  f1-score   support\n\n          NO       0.97      0.94      0.95       100\n         YES       0.94      0.97      0.96       100\n\n    accuracy                           0.95       200\n   macro avg       0.96      0.95      0.95       200\nweighted avg       0.96      0.95      0.95       200\n</code></pre> <p>We get an accuracy of ~95% for the fine-tuned DINOv2 model on a binary classification task.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#k-nearest-neighbors","title":"K-nearest neighbors","text":"<p>We can also use the embeddings directly to find the nearest neighbors of an image, and use the class of the nearest neighbors as the predicted class.</p> <p>This method has the advantage of not requiring to fine-tune the model.</p> <p>It however takes some time to pre-compute the embeddings of all the images in the dataset.</p> <pre><code>from sklearn.neighbors import KNeighborsClassifier\n\nneigh = KNeighborsClassifier(n_neighbors=5)\n</code></pre> <pre><code>dinov2_vits14 = dinov2_vits14.to(device)\n</code></pre> <pre><code>embeddings_labeled_assets = []\ny_true_training_knn = []\n\nfor asset in tqdm(labeled_assets):\n    class_name = asset[\"jsonMetadata\"][\"Ground Truth\"]\n    y_true_training_knn.append(class_name)\n\n    filepath = asset[\"content\"].replace(\"/data/\", \"/data/train/\" + class_name + \"/\")\n    img = Image.open(filepath)\n    img_tensor = data_transforms(img)\n    img_tensor = img_tensor.unsqueeze(0)\n    input_tensor = img_tensor.to(device)\n\n    with torch.no_grad():\n        output_tensor = dinov2_vits14(input_tensor)\n    embeddings_labeled_assets.append(output_tensor[0].cpu().numpy())\n\nneigh.fit(embeddings_labeled_assets, y_true_training_knn);\n</code></pre> <pre><code>y_pred_knn = neigh.predict(embeddings_non_labeled_assets)\n</code></pre> <pre><code>print(classification_report(y_true_non_labeled_assets, y_pred_knn))\n</code></pre> <pre><code>              precision    recall  f1-score   support\n\n          NO       0.91      0.84      0.87       100\n         YES       0.85      0.92      0.88       100\n\n    accuracy                           0.88       200\n   macro avg       0.88      0.88      0.88       200\nweighted avg       0.88      0.88      0.88       200\n</code></pre> <p>As you can see, the accuracy is lower than with the fine-tuned model.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#upload-more-manual-annotations","title":"Upload more manual annotations","text":"<p>In the section above, we uploaded model-made annotations on the non-labeled assets to Kili.</p> <p>Now, we simulate manual labeling on the non-labeled assets:</p> <pre><code>gt_external_id_array = []\ngt_json_response_array = []\n\nfor asset in non_labeled_assets:\n    gt_external_id_array.append(asset[\"externalId\"])\n    gt_json_response_array.append(\n        {\n            \"CLASSIFICATION_JOB\": {\n                \"categories\": [{\"confidence\": 100, \"name\": asset[\"jsonMetadata\"][\"Ground Truth\"]}]\n            }\n        }\n    )\n</code></pre> <pre><code>kili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=gt_external_id_array,\n    json_response_array=gt_json_response_array,\n    label_type=\"DEFAULT\",\n);\n</code></pre> <p>In the Kili interface, we can filter the assets based on the disagreements between human-made labels and DINOv2-generated labels:</p> <pre><code># replace the project id below with your own!\nprint(\n    f\"https://cloud.kili-technology.com/label/projects/{project_id}/explore?inferenceMarkGte=0&amp;inferenceMarkLte=0.75\"\n)\n</code></pre> <pre><code>https://cloud.kili-technology.com/label/projects/cliistnwa003c0j78ay1y3qlm/explore?inferenceMarkGte=0&amp;inferenceMarkLte=0.75\n</code></pre> <p></p> <p>In the image above, we can see that the DINOv2 prediction has classified this asset as a negative sample, when it should have been classified as a positive sample.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to fine-tune the DINOv2 model on a very small set of labeled images, and how to use the fine-tuned model to generate pre-annotations on a set of images to label.</p> <p>We have also seen how to evaluate the quality of the generated pre-annotations, and how to use them to speed up the labeling process.</p>"},{"location":"sdk/tutorials/finetuning_dinov2/#clean-up","title":"Clean up","text":"<p>We can now delete the project we created on Kili:</p> <pre><code>kili.delete_project(project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/import_text_assets/","title":"Rich Text Assets","text":""},{"location":"sdk/tutorials/import_text_assets/#how-to-import-rich-text-assets","title":"How to import rich-text assets","text":"<p>When dealing with textual data, style can convey a lot of meaning. If you annotate a long list or a legal text, displaying structured text instead of plain boring text allows your annotator to rapidly grasp patterns within the document.</p>"},{"location":"sdk/tutorials/import_text_assets/#setup","title":"Setup","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>import getpass\nimport os\nfrom random import random\n\nfrom kili.client import Kili\n</code></pre> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <pre><code>kili = Kili(api_key=KILI_API_KEY)\n</code></pre>"},{"location":"sdk/tutorials/import_text_assets/#discover-rich-text-kili-format","title":"Discover rich-text Kili format","text":"<p>Let's create a named-entity recognition project that aims at labeling American legal documents.</p> <p>We start by defining the ontology of our project, with several categories:</p> <ul> <li><code>INSTRUCTIONS</code></li> <li><code>PREAMBLE</code></li> <li><code>RIGHTS</code></li> <li><code>REFERENCE_TO_GOD</code></li> </ul> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"instruction\": \"Categories\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"isVisible\": True,\n            \"content\": {\n                \"categories\": {\n                    \"INSTRUCTIONS\": {\"name\": \"Instructions\", \"children\": [], \"color\": \"#cc4125\"},\n                    \"PREAMBLE\": {\"name\": \"Preamble\", \"children\": [], \"color\": \"#ffd966\"},\n                    \"RIGHTS\": {\"name\": \"Rights\", \"children\": [], \"color\": \"#76a5af\"},\n                    \"REFERENCE_TO_GOD\": {\n                        \"name\": \"Reference to God\",\n                        \"children\": [],\n                        \"color\": \"#c27ba0\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n</code></pre> <p>Next, we create a project:</p> <pre><code>project_id = kili.create_project(\n    json_interface=json_interface, input_type=\"TEXT\", title=\"Import text assets tutorial\"\n)[\"id\"]\n</code></pre> <p>The method to use for adding assets to your Kili project is the <code>kili.append_many_to_dataset()</code> method.</p> <p>In case of rich text, you need to use the <code>json_content_array</code> argument:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content_1, json_content_2, etc...],\n)\n</code></pre> <p>Note that the <code>content_array</code> parameter of this method is used for uploading standard text assets.</p> <p>A <code>json_content</code> object is a Python dict that contains nodes as keys.</p> <p>Nodes can be either element nodes or text nodes.</p> <ul> <li>An element node can have children (that is a list of other elements or text nodes).</li> <li>By default, element nodes are <code>&lt;div /&gt;</code>.</li> <li>Possible types for an element node are:<ul> <li><code>blockquote</code></li> <li><code>h1</code></li> <li><code>h2</code></li> <li><code>h3</code></li> <li><code>h4</code></li> <li><code>li</code></li> <li><code>ol</code></li> <li><code>p</code></li> <li><code>table</code></li> <li><code>tbody</code></li> <li><code>td</code></li> <li><code>thead</code></li> <li><code>tr</code></li> <li><code>ul</code></li> </ul> </li> <li> <p>Available styles for a node (see Mozilla reference to learn more on CSS):</p> <ul> <li><code>alignItems</code></li> <li><code>alignSelf</code></li> <li><code>background</code></li> <li><code>backgroundColor</code></li> <li><code>border</code></li> <li><code>borderBottom</code></li> <li><code>borderLeft</code></li> <li><code>borderRadius</code></li> <li><code>borderRight</code></li> <li><code>borderTop</code></li> <li><code>color</code></li> <li><code>display</code></li> <li><code>flexDirection</code></li> <li><code>float</code></li> <li><code>fontWeight</code></li> <li><code>height</code></li> <li><code>margin</code></li> <li><code>marginBottom</code></li> <li><code>marginLeft</code></li> <li><code>marginRight</code></li> <li><code>marginTop</code></li> <li><code>maxHeight</code></li> <li><code>maxWidth</code></li> <li><code>minHeight</code></li> <li><code>minWidth</code></li> <li><code>padding</code></li> <li><code>paddingBottom</code></li> <li><code>paddingLeft</code></li> <li><code>paddingRight</code></li> <li><code>paddingTop</code></li> <li><code>textAlign</code></li> <li><code>textDecoration</code></li> <li><code>textIndent</code></li> <li><code>width</code></li> </ul> </li> <li> <p>A text node can contain text.</p> </li> <li>By default, text nodes are <code>&lt;span /&gt;</code>.</li> <li>Text nodes are identified by an <code>id</code>. The ID must be unique accross the whole document. This will allow for overlapping entities between two or more text nodes.</li> <li>Available styles for a text node:<ul> <li><code>bold: true</code></li> <li><code>code: true</code></li> <li><code>italic: true</code></li> <li><code>underline: true</code></li> <li><code>display</code></li> <li><code>float</code></li> <li><code>fontWeight</code></li> <li><code>margin</code></li> <li><code>marginBottom</code></li> <li><code>marginLeft</code></li> <li><code>marginRight</code></li> <li><code>marginTop</code></li> <li><code>padding</code></li> <li><code>paddingBottom</code></li> <li><code>paddingLeft</code></li> <li><code>paddingRight</code></li> <li><code>paddingTop</code></li> <li><code>textAlign</code></li> <li><code>textDecoration</code></li> <li><code>textIndent</code></li> </ul> </li> </ul> <p>Let's see some real examples with the corresponding result in Kili's interface!</p> <p>We can start with a really simple example:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"id\": f\"{random()}\",  # set your own id here\n                \"text\": \"The unanimous Declaration of the thirteen United States of America.\",\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p>You should be able to see the new asset in the Kili project:</p> <p></p> <p>Let's try to upload the asset again, but this time with some style:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"id\": f\"{random()}\",\n                \"bold\": True,\n                \"underline\": True,\n                \"text\": \"The unanimous Declaration of the thirteen United States of America.\",\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p> <p>Another test with an even more complex style. We can try to mix styled text nodes with plain-text nodes:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"type\": \"p\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"underline\": True,\n                        \"text\": \"The unanimous Declaration\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"text\": \" of the thirteen United States of America.\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"When in the Course of human events, it becomes necessary for one\"\n                            \" people to dissolve the political bands which have connected them with\"\n                            \" another, and to assume among the powers of the earth, the separate\"\n                            \" and equal station to which the Laws of Nature and of Nature's God\"\n                            \" entitle them, a decent respect to the opinions of mankind requires\"\n                            \" that they should declare the causes which impel them to the\"\n                            \" separation.\"\n                        ),\n                    },\n                ],\n            }\n        ]\n    }\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p> <p>Let's create a new asset with a title, a sub title and proper margins:</p> <pre><code>json_content = [\n    {\n        \"children\": [\n            {\n                \"type\": \"h1\",\n                \"children\": [\n                    {\n                        \"border\": \"1px solid black\",\n                        \"textAlign\": \"center\",\n                        \"children\": [{\"id\": f\"{random()}\", \"text\": \"Declaration of Independence\"}],\n                    },\n                ],\n            },\n            {\n                \"type\": \"h2\",\n                \"children\": [{\"id\": f\"{random()}\", \"text\": \"In Congress, July 4, 1776\"}],\n            },\n            {\n                \"type\": \"p\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"underline\": True,\n                        \"text\": \"The unanimous Declaration\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"bold\": True,\n                        \"text\": \" of the thirteen United States of America.\",\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"When in the Course of human events, it becomes necessary for one\"\n                            \" people to dissolve the political bands which have connected them with\"\n                            \" another, and to assume among the powers of the earth, the separate\"\n                            \" and equal station to which the Laws of Nature and of Nature's God\"\n                            \" entitle them, a decent respect to the opinions of mankind requires\"\n                            \" that they should declare the causes which impel them to the\"\n                            \" separation.\"\n                        ),\n                    },\n                ],\n            },\n            {\n                \"type\": \"p\",\n                \"marginLeft\": \"30px\",\n                \"marginRight\": \"30px\",\n                \"border\": \"red\",\n                \"children\": [\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"We hold these truths to be self-evident, that all men are created\"\n                            \" equal, that they are endowed by their Creator with certain\"\n                            \" unalienable Rights, that among these are Life, Liberty and the\"\n                            \" pursuit of Happiness.\"\n                        ),\n                    },\n                    {\n                        \"type\": \"ul\",\n                        \"children\": [\n                            {\n                                \"type\": \"li\",\n                                \"children\": [\n                                    {\n                                        \"id\": f\"{random()}\",\n                                        \"text\": (\n                                            \"That to secure these rights, Governments are\"\n                                            \" instituted among Men, deriving their just powers from\"\n                                            \" the consent of the governed,\"\n                                        ),\n                                    },\n                                ],\n                            },\n                            {\n                                \"type\": \"li\",\n                                \"children\": [\n                                    {\n                                        \"id\": f\"{random()}\",\n                                        \"text\": (\n                                            \"That whenever any Form of Government becomes\"\n                                            \" destructive of these ends, it is the Right of the\"\n                                            \" People to alter or to abolish it, and to institute\"\n                                            \" new Government, laying its foundation on such\"\n                                            \" principles and organizing its powers in such form, as\"\n                                            \" to them shall seem most likely to effect their Safety\"\n                                            \" and Happiness.\"\n                                        ),\n                                    },\n                                ],\n                            },\n                        ],\n                    },\n                    {\n                        \"id\": f\"{random()}\",\n                        \"text\": (\n                            \"Prudence, indeed, will dictate that Governments long established\"\n                            \" should not be changed for light and transient causes; and accordingly\"\n                            \" all experience hath shewn, that mankind are more disposed to suffer,\"\n                            \" while evils are sufferable, than to right themselves by abolishing\"\n                            \" the forms to which they are accustomed. But when a long train of\"\n                            \" abuses and usurpations, pursuing invariably the same Object evinces a\"\n                            \" design to reduce them under absolute Despotism, it is their right, it\"\n                            \" is their duty, to throw off such Government, and to provide new\"\n                            \" Guards for their future security.--Such has been the patient\"\n                            \" sufferance of these Colonies; and such is now the necessity which\"\n                            \" constrains them to alter their former Systems of Government. The\"\n                            \" history of the present King of Great Britain is a history of repeated\"\n                            \" injuries and usurpations, all having in direct object the\"\n                            \" establishment of an absolute Tyranny over these States. To prove\"\n                            \" this, let Facts be submitted to a candid world.\"\n                        ),\n                    },\n                ],\n            },\n        ],\n    },\n]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p></p>"},{"location":"sdk/tutorials/import_text_assets/#convert-html-to-rich-text-kili-format","title":"Convert HTML to rich-text Kili format","text":"<p>To make the whole process as seamless as possible, let's use simple Python code to transform raw HTML snippets directly into the Kili format.</p> <p>For this purpose, we will use BeautifulSoup 4, and will try to convert a simple table from Mozilla doc:</p> <pre><code>%pip install beautifulsoup4\n</code></pre> <pre><code>from bs4 import BeautifulSoup\n</code></pre> <pre><code>def from_html_to_kili(html: BeautifulSoup):\n    styles = {\n        \"table\": {\"border\": \"1px solid #333\"},\n        \"td\": {\"border\": \"1px solid #333\"},\n        \"th\": {\"backgroundColor\": \"#333\", \"color\": \"#fff\"},\n    }\n\n    if html is None:\n        return html\n\n    attributes = dict(styles[html.name]) if html.name in styles else {}\n    children = [from_html_to_kili(child) for child in html.findChildren(recursive=False)]\n    if len(children) == 0:\n        children.append({\"id\": f\"{random()}\", \"text\": html.text.strip(\"\\n\").strip()})\n    if len(children) != 0:\n        attributes[\"children\"] = children\n        if html.name != \"[document]\":\n            attributes[\"type\"] = html.name\n    return attributes\n</code></pre> <p>Below is our html content to convert to Kili json content:</p> <pre><code>html_doc = \"\"\"\n&lt;table&gt;\n    &lt;thead&gt;\n        &lt;tr&gt;\n            &lt;th colspan=\"2\"&gt;The table header&lt;/th&gt;\n        &lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt;\n            &lt;td&gt;The table body&lt;/td&gt;\n            &lt;td border=\"1px solid #333\"&gt;with two columns&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n\"\"\"\n</code></pre> <p>Let's convert it using our custom method:</p> <pre><code>soup = BeautifulSoup(html_doc, \"html.parser\")\njson_content = [from_html_to_kili(soup)]\nprint(json_content)\n</code></pre> <pre><code>[{'children': [{'border': '1px solid #333', 'children': [{'children': [{'children': [{'backgroundColor': '#333', 'color': '#fff', 'children': [{'id': '0.06746091905311846', 'text': 'The table header'}], 'type': 'th'}], 'type': 'tr'}], 'type': 'thead'}, {'children': [{'children': [{'border': '1px solid #333', 'children': [{'id': '0.6734828512730971', 'text': 'The table body'}], 'type': 'td'}, {'border': '1px solid #333', 'children': [{'id': '0.38249704337851276', 'text': 'with two columns'}], 'type': 'td'}], 'type': 'tr'}], 'type': 'tbody'}], 'type': 'table'}]}]\n</code></pre> <p>Finally, we upload it to our Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[json_content],\n)\n</code></pre> <p>OIn Kili, the table looks like this:</p> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>In this tutorial, we have learned how to import rich-text assets with styled text nodes into a Kili project.</p> <p>Now, armed with these techniques, you can start building your own Kili projects with styled and structured text data!</p>"},{"location":"sdk/tutorials/import_text_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/","title":"Importing Assets","text":""},{"location":"sdk/tutorials/importing_assets_and_metadata/#how-to-import-assets-to-a-kili-project","title":"How to import assets to a Kili project","text":"<p>In this tutorial, we will learn how to import assets to your project, and add metadata to those assets.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing assets to Kili</li> <li>Adding metadata to assets</li> </ol>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_assets_and_metadata/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clfwarjr500110jqbdgnw14kv\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#importing-assets-to-kili","title":"Importing assets to Kili","text":"<p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=[\"image_1\", \"image_2\", \"image_3\"],  # name to give to assets\n)\n</code></pre> <p>At this point, you should be able to see your assets in your Kili project:</p> <p></p> <p>If you prefer to add your own images, you can use a local file. The code to do that would look similar to this:</p> <pre><code>project_id = 'project_id'\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=['./image_1.jpeg'], # Path to local image\n    external_id_array=['image_1']\n)\n</code></pre> <p>The procedure looks the same for most of other data types, like PDFs or text. For more information on supported file formats, refer to our documentation.</p> <p>Because videos and Rich Text assets may be more complex to import, we've created separate tutorials devoted to them:</p> <ul> <li>For information on importing video assets, refer to this tutorial.</li> <li>For information on importing Rich Text assets, see here.</li> </ul> <p>For more information on importing assets, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#adding-metadata-to-assets","title":"Adding metadata to assets","text":"<p>In Kili, you can add extra information to an asset by using asset metadata. The metadata can contain extra information like what language the document was written in, custom quality metrics, agreement metrics etc., and can be used with Kili's advanced filters. The metadata can also contain text extracted from images or PDF documents using OCR (Optical Character Recognition), and that will be shown in the Kili labeling interface.</p> <p>Additionally, three specific metadata types can be used as information presented to labelers in Kili interface:</p> <ul> <li><code>imageUrl</code></li> <li><code>text</code></li> <li><code>url</code></li> </ul> <p>As an optional step, you can set data types for each type of your metadata. The default data type is <code>string</code>, but setting some of your metadata as <code>number</code> can really help apply filters on your assets later on.</p> <p>Note that we don't need to set data types for <code>imageUrl</code>, <code>text</code>, and <code>url</code>.</p> <pre><code>kili.update_properties_in_project(\n    project_id=project_id,\n    metadata_types={\n        \"customConsensus\": \"number\",\n        \"sensitiveData\": \"string\",\n        \"uploadedFromCloud\": \"string\",\n        \"modelLabelErrorScore\": \"number\",\n    },\n)\n</code></pre> <pre><code>{'id': 'clfwarjr500110jqbdgnw14kv',\n 'metadataTypes': {'sensitiveData': 'string',\n  'customConsensus': 'number',\n  'uploadedFromCloud': 'string',\n  'modelLabelErrorScore': 'number'}}\n</code></pre> <p>Now we can add metadata to our assets:</p> <pre><code>external_ids = [\"image_1\", \"image_2\"]\n\nkili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=external_ids,\n    json_metadatas=[\n        {\n            \"customConsensus\": 10,\n            \"sensitiveData\": \"yes\",\n            \"uploadedFromCloud\": \"no\",\n            \"modelLabelErrorScore\": 50,\n        },\n        {\n            \"customConsensus\": 40,\n            \"sensitiveData\": \"no\",\n            \"uploadedFromCloud\": \"yes\",\n            \"modelLabelErrorScore\": 30,\n        },\n    ],\n)\n\n# Add metadata that will be visible to labelers in the labeling interface:\nkili.update_properties_in_assets(\n    project_id=project_id,\n    external_ids=external_ids,\n    json_metadatas=[\n        {\"imageUrl\": \"www.example.com/image.png\", \"text\": \"some text\", \"url\": \"www.example.com\"},\n        {\"imageUrl\": \"www.example.com/image.png\", \"text\": \"some text\", \"url\": \"www.example.com\"},\n    ],\n)\n</code></pre> <p>If you want to add metadata based on Optical Character Recognition, the process is slightly different. To help you with it, we've created a separate tutorial.</p> <p>For more information on adding asset metadata, refer to our documentation.</p>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/importing_assets_and_metadata/#summary","title":"Summary","text":"<p>We've successfully set up a Kili project, imported assets to it, and finally added some metadata to our assets. Well done!</p>"},{"location":"sdk/tutorials/importing_labels/","title":"Importing Labels","text":""},{"location":"sdk/tutorials/importing_labels/#how-to-import-labels-to-a-kili-project","title":"How to import labels to a Kili project","text":"<p>In this tutorial, you will learn how to import labels to your project.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing some assets to the project</li> <li>Importing model-based pre-annotations</li> <li>Importing pre-existing labels</li> </ol>"},{"location":"sdk/tutorials/importing_labels/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_labels/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a simple image project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"content\": {\n                \"categories\": {\"OBJECT_A\": {\"name\": \"Object A\"}, \"OBJECT_B\": {\"name\": \"Object B\"}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"IMAGE\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  clfwbvgpm00330jrne4n40m70\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#importing-assets-to-kili","title":"Importing assets to Kili","text":"<p>Now, let's add some assets to be labeled.</p> <p>We will use some free off-the-shelf examples from the Internet.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/car/car_2.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n\nasset_external_id_array = [\"image_1\", \"image_2\", \"image_3\"]\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url1, url2, url3],\n    external_id_array=asset_external_id_array,\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#importing-model-based-pre-annotations-into-your-project","title":"Importing model-based pre-annotations into your project","text":"<p>When you import pre-annotations, you can use two types of labels: <code>PREDICTION</code> and <code>INFERENCE</code>.</p> <p><code>PREDICTION</code>-type annotations will be displayed on the asset during the labeling process. Labelers will be able to confirm what model produced, edit, and/or add new annotations.</p> <p>Unlike <code>PREDICTION</code>-type labels, <code>INFERENCE</code>-type annotations are not displayed on the asset during the labeling process. <code>INFERENCE</code>-type labels are used for IoU (intersection over union) calculation if you want to benchmark your model predictions, or labelers' work quality against ground truth.</p> <p>For more information on Kili label types, refer to our documentation.</p> <p>First, let's prepare some fake predictions:</p> <pre><code>json_response_array = [\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 95, \"name\": \"OBJECT_B\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 79, \"name\": \"OBJECT_A\"}]}},\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 83, \"name\": \"OBJECT_B\"}]}},\n]\n</code></pre> <p>And let's upload them as <code>PREDICTION</code> labels:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"PREDICTION\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n</code></pre> <p>In the project interface, you should now see your assets annotated by your model <code>MyModel</code>:</p> <p></p> <p>As well as the classes predicted by the model (class <code>OBJECT_B</code> for asset <code>image_1</code>):</p> <p></p> <p>You can also add <code>PREDICTION</code>-type labels directly, using the <code>create_predictions</code> method. The <code>label_type</code> will be assigned automatically as <code>PREDICTION</code>:</p> <pre><code>kili.create_predictions(\n    project_id=project_id,\n    external_id_array=asset_external_id_array,\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n)\n</code></pre> <p>To import <code>INFERENCE</code>-type labels, just change the <code>label_type</code> argument of the <code>append_labels</code> method:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    model_name=\"MyModel\",\n    label_type=\"INFERENCE\",\n    project_id=project_id,\n    asset_external_id_array=asset_external_id_array,\n)\n</code></pre> <p>This time, the labels are not shown in the labeling interface anymore, since those labels are used as ground truth to compute some metrics later on:</p> <p></p>"},{"location":"sdk/tutorials/importing_labels/#importing-pre-existing-labels-into-your-project","title":"Importing pre-existing labels into your project","text":"<p>If you want to copy and paste labels from other projects or other assets, add them with the <code>DEFAULT</code> label type. <code>DEFAULT</code> indicates that the label was generated by a human.</p> <p>In the example below, we take an existing annotation from asset <code>image_1</code>, and apply it to asset <code>image_2</code>:</p> <pre><code>asset_image_1 = kili.assets(project_id=project_id, external_id_strictly_in=[\"image_1\"])[0]\n\njson_response = asset_image_1[\"labels\"][-1][\"jsonResponse\"]\n\nkili.append_labels(\n    json_response_array=[json_response],\n    label_type=\"DEFAULT\",\n    project_id=project_id,\n    asset_external_id_array=[\"image_2\"],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/importing_labels/#summary","title":"Summary","text":"<p>Done. We've successfully set up a Kili project, imported assets to it, and then imported various types of labels to our project. Well done!</p>"},{"location":"sdk/tutorials/importing_video_assets/","title":"Video Assets","text":""},{"location":"sdk/tutorials/importing_video_assets/#how-to-import-video-assets-to-a-kili-project","title":"How to import video assets to a Kili project","text":"<p>In this tutorial, we will learn how to import video assets to Kili.</p> <p>Here are the steps that we will follow:</p> <ol> <li>Setting up a simple Kili project to work with</li> <li>Importing video assets to Kili</li> <li>Uploading a video asset using a path to a local file</li> <li>Uploading a video asset using an URL</li> <li>Uploading a video asset to label each frame separately</li> <li>Uploading a list of local images as one video asset</li> <li>Uploading a list of image URLs as one video asset</li> <li>Uploading a video asset with a custom sampling rate</li> <li>Cleanup</li> </ol>"},{"location":"sdk/tutorials/importing_video_assets/#setting-up-a-simple-kili-project-to-work-with","title":"Setting up a simple Kili project to work with","text":""},{"location":"sdk/tutorials/importing_video_assets/#installing-and-instantiating-kili","title":"Installing and instantiating Kili","text":"<p>First, let's install and import the required modules.</p> <pre><code>%pip install  kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n</code></pre> <p>Now, let's set up variables needed to create an instance of the Kili object.</p> <p>We will need your API key and Kili's API endpoint.</p> <p>If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key.</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <p>With variables set up, we can now create an instance of the Kili object.</p> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#creating-a-basic-kili-project","title":"Creating a basic Kili project","text":"<p>To create a Kili project, you must first set up its interface.</p> <p>We will create a video project with just one simple classification job and two categories: <code>OBJECT_A</code> and <code>OBJECT_B</code>.</p> <p>To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface.</p> <pre><code>interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Object A\", \"id\": \"category3\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Object B\", \"id\": \"category4\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"mlTask\": \"CLASSIFICATION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n\nresult = kili.create_project(\n    title=\"Test Project\",\n    description=\"Project Description\",\n    input_type=\"VIDEO\",\n    json_interface=interface,\n)\n</code></pre> <p>For further processing, we will need to find out what our project ID is.</p> <p>We can easily retrieve it from the project creation response message:</p> <pre><code>project_id = result[\"id\"]\nprint(\"Project ID: \", project_id)\n</code></pre> <pre><code>Project ID:  cld90h71d0ha50jptd28xfjg1\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#importing-video-assets-to-kili","title":"Importing video assets to Kili","text":"<p>Now, let's add some video assets to be labeled. You can videos using URLs or use your local assets.</p> <p>We will use a free off-the-shelf asset from the Internet.</p>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-a-path-to-a-local-file","title":"Uploading a video asset using a path to a local file","text":"<p>To show an example of how to upload a local video, we must first download it:</p> <pre><code>import urllib.request\n\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\",\n    \"test.mp4\",\n)\n</code></pre> <p>Now, we can easily upload the video to our project:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[\"./test.mp4\"], external_id_array=[\"video_1_from_local\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-using-an-url","title":"Uploading a video asset using an URL","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with the URL of the video that you want to upload.</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id, content_array=[url], external_id_array=[\"video_2_from_url\"]\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-to-label-each-frame-separately","title":"Uploading a video asset to label each frame separately","text":"<p>To upload your video and be able to label frames separately, as individual images, refer to this code:</p> <pre><code>url = \"https://storage.googleapis.com/label-public-staging/asset-test-sample/video/short_video.mp4\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[url],\n    external_id_array=[\"video_2_from_url_split_frames\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-local-images-as-one-video-asset","title":"Uploading a list of local images as one video asset","text":"<p>We can create a video, by using local images as frames. Let's first download some images from the Internet:</p> <pre><code>urllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\",\n    \"image_1.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\",\n    \"image_2.jpg\",\n)\nurllib.request.urlretrieve(\n    \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\",\n    \"image_3.jpg\",\n)\n</code></pre> <p>Now, let's put them together as one video:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[\"./image_1.jpg\", \"./image_2.jpg\", \"./image_3.jpg\"]],\n    external_id_array=[\"video_3_from_local_images\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-list-of-image-urls-as-one-video-asset","title":"Uploading a list of image URLs as one video asset","text":"<p>You can of course upload videos using URLs as well. To do so, simply replace <code>'./test.mp4'</code> with a set of URLs of images that you want to upload as a video.</p> <pre><code>url1 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000001.jpg\"\nurl2 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000002.jpg\"\nurl3 = \"https://storage.googleapis.com/label-public-staging/Frame/vid2_frame/video2-img000003.jpg\"\n\nassets = kili.append_many_to_dataset(\n    project_id=project_id,\n    json_content_array=[[url1, url2, url3]],\n    external_id_array=[\"video_4_from_image_urls\"],\n    json_metadata_array=[{\"processingParameters\": {\"shouldUseNativeVideo\": False}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#uploading-a-video-asset-with-a-custom-sampling-rate","title":"Uploading a video asset with a custom sampling rate","text":"<p>To upload a video with a custom sampling rate (let's say, 10 frames per second), use this code:</p> <pre><code>assets = kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[\"./test.mp4\"],\n    external_id_array=[\"video_5_custom\"],\n    json_metadata_array=[{\"processingParameters\": {\"framesPlayedPerSecond\": 10}}],\n)\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id);\n</code></pre>"},{"location":"sdk/tutorials/importing_video_assets/#summary","title":"Summary","text":"<p>Done. We've successfully set up a video project, defined its interface, and uploaded a bunch of assets to it, using various Kili's upload methods. Well done!</p>"},{"location":"sdk/tutorials/inference_labels/","title":"Inference Labels","text":""},{"location":"sdk/tutorials/inference_labels/#how-to-import-inference-labels","title":"How to import inference labels","text":"<p>In this tutorial, we will walk through the process of using Kili to evaluate the performance of a machine learning model in production.</p> <p>We will learn how to push model-generated labels to Kili and how to visualize their quality.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n\nif \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n\nkili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#context","title":"Context","text":""},{"location":"sdk/tutorials/inference_labels/#agreement","title":"Agreement","text":"<p>Let's say you have a trained machine learning model \\(m\\), which can, given data \\(x\\), output a prediction (i.e., an inference label): \\(\\hat{y} = m(x)\\).</p> <p>What you will probably want to do is monitor the quality of such predictions, as the model evolves. Kili allows you to better monitor and iterate on your model, thanks to the concept of agreement. An agreement is a quantitative measure of similarity between two different labels. In Kili, there are three main features derived from agreement:</p> <ul> <li>Consensus, which is the agreement between two labelers.</li> <li>Honeypot, which is the agreement between a \"super human annotator\" and a labeler.</li> <li>Inference, which is the agreement between a model-generated label and a human.</li> </ul> <p>Those numbers can be monitored from the queue page or the analytics page. You can find how the agreement is computed here.</p> <p>In this tutorial, we will put an emphasis on Inference.</p>"},{"location":"sdk/tutorials/inference_labels/#use-cases","title":"Use cases","text":"<p>We identify two main use cases for the use of inference labels.</p> <p>The first use case is when you have a model in production. When it receives assets, it automatically feeds a Kili project with both the asset and the predicted label. You also have human workforce whose job is to monitor the quality of the model. They manually label a portion of the data after it had been pre-labeled by the model. When a human submits a label, the inference score (model vs. human) for that label is automatically computed. Low inference scores can indicate either a model performing badly on some kind of data, or a disagreement between humans and the model. This can help you to:</p> <ul> <li>Detect data drift.</li> <li>Identify data on which the model needs improvement.</li> </ul> <p>The second use case is when you used Kili to label data and you have the first iteration of your model. You can now use a part of the labeled dataset as testing data, and quickly get test scores. Of course, you could use your own metrics (rather than our own definition of agreement), but using Kili lets you quickly filter and indentify the assets where your model differs the most from the ground truth.</p> <ul> <li>When you push an inference-type label to an asset, the inference score is automatically computed for the most recent label added to this asset.</li> <li>You can filter on low inference score, to understand why your model is failing, and how to fix it (getting more data, splitting or merging categories, etc.).</li> </ul> <p>With Kili, you can quickly iterate on the data used to train your model, to get a better model faster.</p>"},{"location":"sdk/tutorials/inference_labels/#in-practice","title":"In practice","text":""},{"location":"sdk/tutorials/inference_labels/#use-case-1","title":"Use case 1","text":"<p>We start by creating a project and defining a model which, given an asset input \\(x\\), returns a category (random in our example):</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\n                    \"RED\": {\"name\": \"Red\"},\n                    \"BLACK\": {\"name\": \"Black\"},\n                    \"WHITE\": {\"name\": \"White\"},\n                    \"GREY\": {\"name\": \"Grey\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"required\": 0,\n            \"isChild\": False,\n            \"instruction\": \"Color\",\n        }\n    }\n}\n\nproject_id = kili.create_project(\n    title=\"Project demo inference\", input_type=\"IMAGE\", json_interface=json_interface\n)[\"id\"]\n</code></pre> <p>Then we can simulate that our model is in production. Each time it receives an asset, we upload it to Kili along with the predicted label.</p> <pre><code>stream_of_assets = [\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n        ),\n        \"external_id\": \"black_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/grey_car.jpg\",\n        \"external_id\": \"grey_car.jpg\",\n    },\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/white_car.jpg\"\n        ),\n        \"external_id\": \"white_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/red_car.jpg\",\n        \"external_id\": \"red_car.jpg\",\n    },\n]\n</code></pre> <p>We import the assets into the Kili project:</p> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[asset[\"url\"] for asset in stream_of_assets],\n    external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n)\n</code></pre> <p>We simulate some model predictions:</p> <pre><code>predictions = {\n    \"black_car.jpg\": \"WHITE\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"RED\",\n    \"red_car.jpg\": \"BLACK\",\n}\n</code></pre> <p>And we upload those predictions to Kili:</p> <pre><code>predicted_categories = [predictions[asset[\"external_id\"]] for asset in stream_of_assets]\ninference_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": predicted_category}]}}\n    for predicted_category in predicted_categories\n]\n\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n    json_response_array=inference_labels,\n    label_type=\"INFERENCE\",  # We import model-generated labels as \"INFERENCE\" labels\n)\n</code></pre> <p>Then, human labelers can annotate a subsample of the assets pushed to Kili.</p> <p>Note: you can automatically prioritize assets to be reviewed by a human by using the model's certainty score. When the model is unsure of its predictions, this may indicate wrong labels.</p> <pre><code>ground_truths = {\n    \"black_car.jpg\": \"BLACK\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"WHITE\",\n    \"red_car.jpg\": \"RED\",\n}\n\nhuman_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": ground_truths[asset[\"external_id\"]]}]}}\n    for asset in stream_of_assets\n]\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=human_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in stream_of_assets],\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>You can now fetch the agreement between the human and the model, for human labels:</p> <pre><code>labels = kili.labels(\n    project_id=project_id, fields=[\"inferenceMark\", \"id\", \"labelOf.id\"], type_in=[\"DEFAULT\"]\n)\nprint(labels)\n</code></pre> <pre><code>[{'labelOf': {'id': 'cleoicx8s0000h8vzn0qu3mpz'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02eg0jx8cub2c6q6'}, {'labelOf': {'id': 'cleoicx8s0001h8vzh742in5x'}, 'inferenceMark': 1, 'id': 'cleoicz3b02eh0jx8fe1iap2a'}, {'labelOf': {'id': 'cleoicx8s0002h8vz0jhz2co8'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02ei0jx8bi4ifnkw'}, {'labelOf': {'id': 'cleoicx8s0003h8vzbiaawl1j'}, 'inferenceMark': 0.5, 'id': 'cleoicz3b02ej0jx86n5c2m0a'}]\n</code></pre> <p>This allows you to identify problems:</p> <pre><code>for label in labels:\n    # this label has disagreement between human and model\n    if label[\"inferenceMark\"] &lt; 1:\n        asset_id = label[\"labelOf\"][\"id\"]\n        # get the model-generated label\n        inference_label = kili.labels(\n            project_id=project_id,\n            asset_id=asset_id,\n            type_in=[\"INFERENCE\"],\n            output_format=\"parsed_label\",\n            disable_tqdm=True,\n        )[0]\n        # get the human-made label\n        human_label = kili.labels(\n            project_id=project_id,\n            label_id=label[\"id\"],\n            output_format=\"parsed_label\",\n            disable_tqdm=True,\n        )[0]\n\n        inference_category = inference_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        human_category = human_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        print(\n            f\"The model predicted {inference_category} but the human predicted {human_category} for\"\n            f\" asset with id {asset_id}.\"\n        )\n</code></pre> <pre><code>The model predicted WHITE but the human predicted BLACK for asset with id cleoicx8s0000h8vzn0qu3mpz.\nThe model predicted RED but the human predicted WHITE for asset with id cleoicx8s0002h8vz0jhz2co8.\nThe model predicted BLACK but the human predicted RED for asset with id cleoicx8s0003h8vzbiaawl1j.\n</code></pre> <p>You can also find the assets with most disagreement directly from the interface with the \"Human/Model IoU\" filter.</p> <p>Low IoU indicates low agreement:</p> <p></p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#use-case-2","title":"Use case 2","text":"<p>We can invert the previous use case.</p> <p>We start with a human-labeled dataset and we insert model predictions to it, to simulate testing our model on test data.</p> <pre><code>project_id = kili.create_project(\n    title=\"Project demo inference 2\", input_type=\"IMAGE\", json_interface=json_interface\n)[\"id\"]\n</code></pre> <pre><code>labeled_assets = [\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/black_car.jpg\"\n        ),\n        \"external_id\": \"black_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/grey_car.jpg\",\n        \"external_id\": \"grey_car.jpg\",\n    },\n    {\n        \"url\": (\n            \"https://storage.googleapis.com/label-public-staging/recipes/inference/white_car.jpg\"\n        ),\n        \"external_id\": \"white_car.jpg\",\n    },\n    {\n        \"url\": \"https://storage.googleapis.com/label-public-staging/recipes/inference/red_car.jpg\",\n        \"external_id\": \"red_car.jpg\",\n    },\n]\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[asset[\"url\"] for asset in labeled_assets],\n    external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n)\n</code></pre> <p><code>ground_truths</code> represents labels made by human annotators:</p> <pre><code>ground_truths = {\n    \"black_car.jpg\": \"BLACK\",\n    \"grey_car.jpg\": \"GREY\",\n    \"white_car.jpg\": \"WHITE\",\n    \"red_car.jpg\": \"RED\",\n}\n</code></pre> <p>Now, we import the human labels:</p> <pre><code>human_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": ground_truths[asset[\"external_id\"]]}]}}\n    for asset in labeled_assets\n]\n\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=human_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n    label_type=\"DEFAULT\",\n)\n</code></pre> <p>We take 80% of the training data and use it to train a model.</p> <p>We can then run the trained model against the remaining 20% of the labeled assets, and upload predictions to Kili:</p> <pre><code>test_labels = [\n    {\"CLASSIFICATION_JOB\": {\"categories\": [{\"name\": predictions[asset[\"external_id\"]]}]}}\n    for asset in labeled_assets\n]\nkili.append_labels(\n    project_id=project_id,\n    json_response_array=test_labels,\n    asset_external_id_array=[asset[\"external_id\"] for asset in labeled_assets],\n    label_type=\"INFERENCE\",\n)\n</code></pre> <pre><code>labels = kili.labels(\n    project_id=project_id, fields=[\"inferenceMark\", \"id\", \"labelOf.id\"], type_in=[\"DEFAULT\"]\n)\nprint(labels)\n</code></pre> <pre><code>[{'labelOf': {'id': 'cleoid2lk0004h8vzyqb6bfp5'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fg0jx831mhak3l'}, {'labelOf': {'id': 'cleoid2lk0005h8vzmodn4ce8'}, 'inferenceMark': 1, 'id': 'cleoid3m802fh0jx893nia1og'}, {'labelOf': {'id': 'cleoid2lk0006h8vza2xtc6h5'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fi0jx861b52nd5'}, {'labelOf': {'id': 'cleoid2lk0007h8vzkp2yodiu'}, 'inferenceMark': 0.5, 'id': 'cleoid3m802fj0jx8g5xj0lt2'}]\n</code></pre> <p>We can now print out a list of disagreements between human and machine labels:</p> <pre><code>for label in labels:\n    if label[\"inferenceMark\"] &lt; 1:\n        inference_label = list(\n            kili.labels(\n                project_id=project_id,\n                asset_id=label[\"labelOf\"][\"id\"],\n                type_in=[\"INFERENCE\"],\n                output_format=\"parsed_label\",\n                disable_tqdm=True,\n            )\n        )[0]\n        human_label = list(\n            kili.labels(\n                project_id=project_id,\n                label_id=label[\"id\"],\n                output_format=\"parsed_label\",\n                disable_tqdm=True,\n            )\n        )[0]\n\n        inference_category = inference_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n        human_category = human_label.jobs[\"CLASSIFICATION_JOB\"].category.name\n\n        print(\n            f\"The human predicted {human_category} but the model predicted {inference_category} for\"\n            f\" asset with id {asset_id}.\"\n        )\n</code></pre> <pre><code>The human predicted BLACK but the model predicted WHITE for asset with id cleoicx8s0003h8vzbiaawl1j.\nThe human predicted WHITE but the model predicted RED for asset with id cleoicx8s0003h8vzbiaawl1j.\nThe human predicted RED but the model predicted BLACK for asset with id cleoicx8s0003h8vzbiaawl1j.\n</code></pre> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/inference_labels/#conclusion","title":"Conclusion","text":"<p>Congratulations! You can now upload your own inference labels to your Kili project \ud83d\ude80.</p>"},{"location":"sdk/tutorials/label_parsing/","title":"Parsing Labels","text":""},{"location":"sdk/tutorials/label_parsing/#how-to-use-the-label-parser","title":"How to use the label parser","text":"<p>This tutorial shows how to use the label parser to easily access labels' content.</p>"},{"location":"sdk/tutorials/label_parsing/#setup","title":"Setup","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#kili-labels","title":"Kili labels","text":"<p>In Kili SDK, a label is a dictionary that follows a json structure as described in the documentation:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='dict')[0]\n\nprint(my_label)\n</code></pre> <pre><code>{\n\"id\": \"abc123\",\n\"author\": {\"email\": \"john.doe@kili-techonology.com\", \"id\": \"123456\"},\n\"createdAt\": \"2020-02-20T14:00:00.000Z\",\n\"labelType\": \"DEFAULT\",\n\"secondsToLabel\": 10,\n\"jsonResponse\": {},\n...  // many other possible fields!\n}\n</code></pre> <p>The <code>jsonResponse</code> field is the one that contains the actual label data, that is the data that the annotator has entered in the interface (the bounding boxes, polygons, text, etc.).</p> <p>Is it however quite difficult to extract the label data from the <code>jsonResponse</code> field, as it is a nested dictionary. This is why we have developed a label parser that allows you to extract the label data in a more convenient way.</p>"},{"location":"sdk/tutorials/label_parsing/#parsed-label-integration-to-kililabels","title":"Parsed Label integration to kili.labels()","text":"<p>The <code>kili.labels()</code> method has an <code>output_format</code> argument that enables automatic label parsing:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='parsed_label')[0]\n\n# example of how to access the category name of the first label\n# (only for a classification job)\nmy_label.jobs[\"MY_JOB_NAME\"].category.name\n</code></pre> <p>Instead of:</p> <pre><code>my_label = kili.labels(project_id=\"my_project_id\", output_format='dict')[0]\n\nmy_label[\"jsonResponse\"][\"jobs\"][\"MY_JOB_NAME\"][\"categories\"][0][\"name\"]\n</code></pre> <p>As you can see, the parsed label is much easier to use than the raw label, and helps you develop your own scripts faster using your IDE auto-completion, type checking, etc.</p>"},{"location":"sdk/tutorials/label_parsing/#parsed-label-integration-to-kiliassets","title":"Parsed Label integration to kili.assets()","text":"<p>The <code>kili.assets()</code> method has a <code>label_output_format</code> argument that enables automatic label parsing:</p> <pre><code>my_asset = kili.assets(project_id=\"my_project_id\", label_output_format='parsed_label')[0]\n\n# example of how to access the category name of the first label\n# (only for a classification job)\nmy_asset[\"labels\"][0].jobs[\"MY_JOB_NAME\"].category.name\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#parsedlabel-class","title":"ParsedLabel class","text":"<p>The <code>ParsedLabel</code> class represents a Kili label with a parsed json response.</p> <p>As we have seen earlier, the <code>kili.labels(..., output_format='parsed_label')</code> will automatically return a list of <code>ParsedLabel</code> objects, but you can also create a <code>ParsedLabel</code> object from a raw dict label.</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n</code></pre> <p>This class directly inherits from <code>dict</code>, and thus behaves like a dictionary.</p> <pre><code>print(ParsedLabel.__bases__[0])\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <p>Converting a label to a <code>ParsedLabel</code> is as simple as:</p> <pre><code>my_label = {\n    \"author\": {\"email\": \"first.last@kili-technology.com\", \"id\": \"123456\"},\n    \"id\": \"clh0fsi9u0tli0j666l4sfhpz\",\n    \"jsonResponse\": {\"CLASSIFICATION_JOB\": {\"categories\": [{\"confidence\": 100, \"name\": \"A\"}]}},\n    \"labelType\": \"DEFAULT\",\n    \"secondsToLabel\": 5,\n}\n\nmy_parsed_label = ParsedLabel(my_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(my_parsed_label[\"author\"][\"email\"])\n</code></pre> <pre><code>first.last@kili-technology.com\n</code></pre> <p>In a parsed label, the <code>jsonResponse</code> dict key is not accessible anymore, since it is parsed and transformed into a <code>.jobs</code> object:</p> <pre><code>try:\n    my_parsed_label[\"jsonResponse\"]\nexcept KeyError as err:\n    print(f\"The key {err} is not accessible anymore.\")\n</code></pre> <pre><code>The key 'jsonResponse' is not accessible anymore.\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#jobs-attribute","title":".jobs attribute","text":"<p>The <code>.jobs</code> attribute of a <code>ParsedLabel</code> class is a dictionary-like object that contains the json response data of a parsed label.</p> <p>The keys are the names of the jobs, and the values are the parsed job responses.</p> <p>Let's illustrate this with the previous label.</p> <pre><code>print(list(my_parsed_label.jobs.keys()))\n</code></pre> <pre><code>['CLASSIFICATION_JOB']\n</code></pre> <p>The values are <code>ParsedJob</code> objects, which are also dictionary-like objects that contain the job response data.</p> <p>The available data attributes are specific to the job interface described in the ontology (also called the json interface).</p> <pre><code>print(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"])\n</code></pre> <pre><code>{'categories': [{'name': 'A', 'confidence': 100}]}\n</code></pre> <p>For example, for a classification job, the available data attributes are <code>categories</code> or <code>category</code>, and a category object can have a <code>name</code> and a <code>confidence</code> attribute.</p> <pre><code>print(my_parsed_label.jobs[\"CLASSIFICATION_JOB\"].categories[0].name)\n</code></pre> <pre><code>A\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#autocomplete","title":"Autocomplete","text":"<p>The <code>ParsedLabel</code> class enables your IDE to explore the possible attributes during development:</p> <p></p> <p>Note that some attributes will not be avaible at runtime, since they are specific to the project ontology that will only be known at runtime.</p>"},{"location":"sdk/tutorials/label_parsing/#get-the-json-response-from-a-parsed-label","title":"Get the json response from a parsed label","text":"<p>If you need to get the json response from a parsed label, you can use the <code>.json_response</code> attribute:</p> <pre><code>print(type(my_parsed_label.json_response))\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <pre><code>print(my_parsed_label.json_response)\n</code></pre> <pre><code>{'CLASSIFICATION_JOB': {'categories': [{'name': 'A', 'confidence': 100}]}}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#convert-parsedlabel-to-python-dict","title":"Convert ParsedLabel to Python dict","text":"<p>A <code>ParsedLabel</code> is a custom class and is not serializable by default. However, it is possible to convert it to a Python dict using the <code>to_dict</code> method:</p> <pre><code>print(type(my_parsed_label))\n</code></pre> <pre><code>&lt;class 'kili.utils.labels.parsing.ParsedLabel'&gt;\n</code></pre> <pre><code>label_as_dict = my_parsed_label.to_dict()\n</code></pre> <pre><code>print(type(label_as_dict))\n</code></pre> <pre><code>&lt;class 'dict'&gt;\n</code></pre> <pre><code>print(label_as_dict)\n</code></pre> <pre><code>{'author': {'email': 'first.last@kili-technology.com', 'id': '123456'}, 'id': 'clh0fsi9u0tli0j666l4sfhpz', 'labelType': 'DEFAULT', 'secondsToLabel': 5, 'jsonResponse': {'CLASSIFICATION_JOB': {'categories': [{'name': 'A', 'confidence': 100}]}}}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#task-specific-attributes","title":"Task specific attributes","text":""},{"location":"sdk/tutorials/label_parsing/#classification-jobs","title":"Classification jobs","text":"<p>We define a json interface for two classification jobs:</p> <ul> <li>a single-class classification job, with name <code>SINGLE_CLASS_JOB</code> and three categories <code>A</code>, <code>B</code> and <code>C</code></li> <li>a multi-class classification job, with name <code>MULTI_CLASS_JOB</code> and three categories <code>D</code>, <code>E</code> and <code>F</code>.</li> </ul> <pre><code>json_interface = {\n    \"jobs\": {\n        \"SINGLE_CLASS_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\"},\n                    \"C\": {\"children\": [], \"name\": \"C\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"MULTI_CLASS_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"D\": {\"children\": [], \"name\": \"D\"},\n                    \"E\": {\"children\": [], \"name\": \"E\"},\n                    \"F\": {\"children\": [], \"name\": \"F\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n</code></pre> <p>For this tutorial, we will work with already existing labels.</p> <p>Note that those labels could have been downloaded from a real Kili project using the <code>kili.labels()</code> method.</p> <p>To learn more about the json response format for classification jobs, please refer to the documentation.</p> <pre><code>json_responses = [\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 75, \"name\": \"A\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [{\"confidence\": 1, \"name\": \"D\"}, {\"confidence\": 1, \"name\": \"E\"}]\n        },\n    },\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 50, \"name\": \"B\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [{\"confidence\": 2, \"name\": \"E\"}, {\"confidence\": 2, \"name\": \"F\"}]\n        },\n    },\n    {\n        \"SINGLE_CLASS_JOB\": {\"categories\": [{\"confidence\": 25, \"name\": \"C\"}]},\n        \"MULTI_CLASS_JOB\": {\n            \"categories\": [{\"confidence\": 3, \"name\": \"F\"}, {\"confidence\": 3, \"name\": \"D\"}]\n        },\n    },\n]\n</code></pre> <pre><code>labels = [\n    ParsedLabel({\"jsonResponse\": label}, json_interface=json_interface, input_type=\"IMAGE\")\n    for label in json_responses\n]\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"])\n</code></pre> <pre><code>{'categories': [{'name': 'A', 'confidence': 75}]}\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].categories)\n</code></pre> <pre><code>[{'name': 'A', 'confidence': 75}]\n</code></pre> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].categories[0].name)\n</code></pre> <pre><code>A\n</code></pre> <p>Since <code>SINGLE_CLASS_JOB</code> is a single-category classification job, the <code>.category</code> attribute is available, and is an alias for <code>.categories[0]</code>:</p> <pre><code>print(labels[0].jobs[\"SINGLE_CLASS_JOB\"].category.name)\nprint(labels[0].jobs[\"SINGLE_CLASS_JOB\"].category.confidence)\n</code></pre> <pre><code>A\n75\n</code></pre> <p>The <code>.category</code> attribute is forbidden for multi-category classification jobs:</p> <pre><code>try:\n    print(labels[0].jobs[\"MULTI_CLASS_JOB\"].category.name)\nexcept Exception as err:\n    print(\"Error: \", err)\n</code></pre> <pre><code>Error:  The attribute 'category' is not compatible with the job.\n</code></pre> <p>It is also possible to iterate over the job names:</p> <pre><code>for i, label in enumerate(labels):\n    print(f\"\\nLabel {i}\")\n    for job_name, job_data in label.jobs.items():\n        print(\"job_name: \", job_name)\n        for category in job_data.categories:\n            print(\"category: \", category.name, category.confidence)\n</code></pre> <pre><code>Label 0\njob_name:  SINGLE_CLASS_JOB\ncategory:  A 75\njob_name:  MULTI_CLASS_JOB\ncategory:  D 1\ncategory:  E 1\n\nLabel 1\njob_name:  SINGLE_CLASS_JOB\ncategory:  B 50\njob_name:  MULTI_CLASS_JOB\ncategory:  E 2\ncategory:  F 2\n\nLabel 2\njob_name:  SINGLE_CLASS_JOB\ncategory:  C 25\njob_name:  MULTI_CLASS_JOB\ncategory:  F 3\ncategory:  D 3\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#transcription-jobs","title":"Transcription jobs","text":"<p>For a transcription job, you can access the label data through the <code>.text</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\"TRANSCRIPTION_JOB\": {\"mlTask\": \"TRANSCRIPTION\", \"required\": 1, \"isChild\": False}}\n}\n\ndict_label = {\n    \"jsonResponse\": {\"TRANSCRIPTION_JOB\": {\"text\": \"This is a transcription annotation...\"}}\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(label.jobs[\"TRANSCRIPTION_JOB\"].text)\n</code></pre> <pre><code>This is a transcription annotation...\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#object-detection-jobs","title":"Object detection jobs","text":""},{"location":"sdk/tutorials/label_parsing/#standard-object-detection-job","title":"Standard object detection job","text":"<p>For standard object detection jobs, a parsed label has an <code>.annotations</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"rectangle\"],\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\"categories\": {\"A\": {}, \"B\": {}}, \"input\": \"radio\"},\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.54, \"y\": 0.52},\n                                {\"x\": 0.54, \"y\": 0.33},\n                                {\"x\": 0.70, \"y\": 0.33},\n                                {\"x\": 0.70, \"y\": 0.52},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"B\"}],\n                    \"mid\": \"20230315142306286-25528\",\n                    \"type\": \"rectangle\",\n                }\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>B\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].type)\n</code></pre> <pre><code>rectangle\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly)\n</code></pre> <pre><code>[{'normalizedVertices': [{'x': 0.54, 'y': 0.52}, {'x': 0.54, 'y': 0.33}, {'x': 0.7, 'y': 0.33}, {'x': 0.7, 'y': 0.52}]}]\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].bounding_poly[0].normalized_vertices)\n</code></pre> <pre><code>[{'x': 0.54, 'y': 0.52}, {'x': 0.54, 'y': 0.33}, {'x': 0.7, 'y': 0.33}, {'x': 0.7, 'y': 0.52}]\n</code></pre> <p>The <code>.bounding_poly_annotations</code> attribute is equivalent to <code>.annotations</code>:</p> <pre><code>print(\n    label.jobs[\"OBJECT_DETECTION_JOB\"].annotations\n    == label.jobs[\"OBJECT_DETECTION_JOB\"].bounding_poly_annotations\n)\n</code></pre> <pre><code>True\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#point-detection-jobs","title":"Point detection jobs","text":"<p>The point coordinates of a point detection label are accessible through the <code>.point</code> attribute:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Class\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"marker\"],\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"point\": {\"x\": 0.10, \"y\": 0.20},\n                    \"categories\": [{\"name\": \"A\"}],\n                    \"mid\": \"20230323113855529-11197\",\n                    \"type\": \"marker\",\n                },\n                {\n                    \"children\": {},\n                    \"point\": {\"x\": 0.30, \"y\": 0.40},\n                    \"categories\": [{\"name\": \"B\"}],\n                    \"mid\": \"20230323113857016-51829\",\n                    \"type\": \"marker\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].type)\n</code></pre> <pre><code>marker\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].point)\n</code></pre> <pre><code>{'x': 0.3, 'y': 0.4}\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[1].category.name)\n</code></pre> <pre><code>B\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#line-detection-jobs","title":"Line detection jobs","text":"<p>A polyline parsed label has a <code>.polyline</code> attribute.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Job name\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"polyline\"],\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"polyline\": [{\"x\": 0.59, \"y\": 0.40}, {\"x\": 0.25, \"y\": 0.30}],\n                    \"categories\": [{\"name\": \"A\"}],\n                    \"mid\": \"20230428163557647-23000\",\n                    \"type\": \"polyline\",\n                },\n                {\n                    \"children\": {},\n                    \"polyline\": [{\"x\": 0.70, \"y\": 0.50}, {\"x\": 0.40, \"y\": 0.70}],\n                    \"categories\": [{\"name\": \"B\"}],\n                    \"mid\": \"20230428163606237-86143\",\n                    \"type\": \"polyline\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(len(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations))\n</code></pre> <pre><code>2\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>A\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].polyline)\n</code></pre> <pre><code>[{'x': 0.59, 'y': 0.4}, {'x': 0.25, 'y': 0.3}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#pose-estimation-jobs","title":"Pose estimation jobs","text":"<p>A pose estimation parsed label annotation has a <code>.points</code> attribute that returns the list of points that make up the annotation.</p> <p>Read more about pose estimation json response in the documentation.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"HEAD\": {\n                        \"children\": [],\n                        \"name\": \"Head\",\n                        \"color\": \"#733AFB\",\n                        \"points\": [\n                            {\"code\": \"RIGHT_EARBASE\", \"name\": \"Right earbase\"},\n                            {\"code\": \"RIGHT_EYE\", \"name\": \"Right eye\"},\n                            {\"code\": \"NOSE\", \"name\": \"Nose\"},\n                            {\"code\": \"LEFT_EYE\", \"name\": \"Left eye\"},\n                            {\"code\": \"LEFT_EARBASE\", \"name\": \"Left earbase\"},\n                        ],\n                    },\n                    \"BODY\": {\n                        \"children\": [],\n                        \"name\": \"Body\",\n                        \"color\": \"#3CD876\",\n                        \"points\": [\n                            {\"code\": \"THROAT\", \"name\": \"Throat\"},\n                            {\"code\": \"WITHERS\", \"name\": \"Withers\"},\n                            {\"code\": \"TAILBASE\", \"name\": \"Tailbase\"},\n                        ],\n                    },\n                    \"FRONT_RIGHT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Front right leg\",\n                        \"color\": \"#3BCADB\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"FRONT_LEFT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Front left leg\",\n                        \"color\": \"#199CFC\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"BACK_RIGHT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Back right leg\",\n                        \"color\": \"#FA484A\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                    \"BACK_LEFT_LEG\": {\n                        \"children\": [],\n                        \"name\": \"Back left leg\",\n                        \"color\": \"#ECB82A\",\n                        \"points\": [\n                            {\"code\": \"PAW\", \"name\": \"Paw\"},\n                            {\"code\": \"KNEE\", \"name\": \"Knee\"},\n                            {\"code\": \"ELBOW\", \"name\": \"Elbow\"},\n                        ],\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Body parts from the animal point of view\",\n            \"isChild\": False,\n            \"tools\": [\"pose\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 0,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"JOB_0\": {\n            \"annotations\": [\n                {\n                    \"categories\": [{\"name\": \"HEAD\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175803297-40094\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"RIGHT_EARBASE\",\n                            \"mid\": \"20230220170039711-76095\",\n                            \"point\": {\"x\": 0.350897302238901, \"y\": 0.18537832978498114},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"RIGHT_EYE\",\n                            \"mid\": \"20230220170039711-75233\",\n                            \"point\": {\"x\": 0.3581081932428414, \"y\": 0.2305347416594279},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"NOSE\",\n                            \"mid\": \"20230220170039711-59132\",\n                            \"point\": {\"x\": 0.38815357242592613, \"y\": 0.32807259130823285},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"LEFT_EYE\",\n                            \"mid\": \"20230220170039711-27852\",\n                            \"point\": {\"x\": 0.4386476019456967, \"y\": 0.23889914422760516},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"LEFT_EARBASE\",\n                            \"mid\": \"20230220170039711-40802\",\n                            \"point\": {\"x\": 0.46187314422288966, \"y\": 0.1875659030559057},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BODY\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175812521-86245\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"THROAT\",\n                            \"mid\": \"20230220170039712-55565\",\n                            \"point\": {\"x\": 0.41045627160921705, \"y\": 0.3819115257598137},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"WITHERS\",\n                            \"mid\": \"20230220170039712-92408\",\n                            \"point\": {\"x\": 0.4818714352479842, \"y\": 0.2536057346999746},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"TAILBASE\",\n                            \"mid\": \"20230220170039712-18390\",\n                            \"point\": {\"x\": 0.6107470753777133, \"y\": 0.17341461528757518},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"FRONT_RIGHT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175821453-77849\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-77846\",\n                            \"point\": {\"x\": 0.3776217136143816, \"y\": 0.9050043662345423},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-53563\",\n                            \"point\": {\"x\": 0.4014267681606373, \"y\": 0.7026760034094114},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-78929\",\n                            \"point\": {\"x\": 0.3907555368123158, \"y\": 0.5151521549373389},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"FRONT_LEFT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175828920-37602\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-72948\",\n                            \"point\": {\"x\": 0.46873761205005, \"y\": 0.9148740424699144},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-67331\",\n                            \"point\": {\"x\": 0.4695584759999209, \"y\": 0.703909712938833},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-86687\",\n                            \"point\": {\"x\": 0.4958261223957892, \"y\": 0.541060055055191},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BACK_RIGHT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175834605-4761\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-95942\",\n                            \"point\": {\"x\": 0.5303024082903665, \"y\": 0.7470895464685865},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-89543\",\n                            \"point\": {\"x\": 0.5623755076892811, \"y\": 0.5105044952809976},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-61950\",\n                            \"point\": {\"x\": 0.5359355740081666, \"y\": 0.4003228503073476},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n                {\n                    \"categories\": [{\"name\": \"BACK_LEFT_LEG\"}],\n                    \"children\": {},\n                    \"mid\": \"20230220175849088-95977\",\n                    \"points\": [\n                        {\n                            \"children\": {},\n                            \"code\": \"PAW\",\n                            \"mid\": \"20230220170039712-40305\",\n                            \"point\": {\"x\": 0.6741443182503564, \"y\": 0.7362865546532311},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"KNEE\",\n                            \"mid\": \"20230220170039712-36409\",\n                            \"point\": {\"x\": 0.6753461334176798, \"y\": 0.49605444348117467},\n                            \"type\": \"marker\",\n                        },\n                        {\n                            \"children\": {},\n                            \"code\": \"ELBOW\",\n                            \"mid\": \"20230220170039712-60395\",\n                            \"point\": {\"x\": 0.6380898632306548, \"y\": 0.38045402908259107},\n                            \"type\": \"marker\",\n                        },\n                    ],\n                    \"type\": \"pose\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['JOB_0']\n</code></pre> <pre><code>print(label.jobs[\"JOB_0\"].annotations[0].category)\n</code></pre> <pre><code>{'name': 'HEAD'}\n</code></pre> <pre><code>print(\"Number of points in this annotation: \", len(label.jobs[\"JOB_0\"].annotations[0].points))\n</code></pre> <pre><code>Number of points in this annotation:  5\n</code></pre> <pre><code>for point in label.jobs[\"JOB_0\"].annotations[0].points:\n    print(point.code, point.point)\n</code></pre> <pre><code>RIGHT_EARBASE {'x': 0.350897302238901, 'y': 0.18537832978498114}\nRIGHT_EYE {'x': 0.3581081932428414, 'y': 0.2305347416594279}\nNOSE {'x': 0.38815357242592613, 'y': 0.32807259130823285}\nLEFT_EYE {'x': 0.4386476019456967, 'y': 0.23889914422760516}\nLEFT_EARBASE {'x': 0.46187314422288966, 'y': 0.1875659030559057}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#video-jobs","title":"Video jobs","text":"<p>A video label has an additional attribute <code>.frames</code> that returns the annotations for each frame.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"FRAME_CLASSIF_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Object A\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Object B\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"mlTask\": \"CLASSIFICATION\",\n            \"models\": {},\n            \"isVisible\": False,\n            \"required\": 1,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"0\": {},\n        \"1\": {},\n        \"2\": {},\n        \"3\": {},\n        \"4\": {},\n        \"5\": {\n            \"FRAME_CLASSIF_JOB\": {\n                \"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_A\"}],\n                \"isKeyFrame\": True,\n                \"annotations\": [],\n            }\n        },\n        \"6\": {\n            \"FRAME_CLASSIF_JOB\": {\n                \"categories\": [{\"confidence\": 42, \"name\": \"OBJECT_B\"}],\n                \"isKeyFrame\": False,\n                \"annotations\": [],\n            }\n        },\n        \"7\": {},\n        \"8\": {},\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"VIDEO\")\n</code></pre> <pre><code>for i, frame_annotations in enumerate(label.jobs[\"FRAME_CLASSIF_JOB\"].frames):\n    print(f\"Frame {i}: {frame_annotations}\")\n</code></pre> <pre><code>Frame 0: {}\nFrame 1: {}\nFrame 2: {}\nFrame 3: {}\nFrame 4: {}\nFrame 5: {'isKeyFrame': True, 'categories': [{'name': 'OBJECT_A', 'confidence': 100}], 'annotations': []}\nFrame 6: {'isKeyFrame': False, 'categories': [{'name': 'OBJECT_B', 'confidence': 42}], 'annotations': []}\nFrame 7: {}\nFrame 8: {}\n</code></pre> <pre><code>frame = label.jobs[\"FRAME_CLASSIF_JOB\"].frames[5]\n</code></pre> <pre><code>print(frame.category.name)\n</code></pre> <pre><code>OBJECT_A\n</code></pre> <p>The syntax is similar for object detection jobs on video:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\"children\": [], \"name\": \"Train\", \"color\": \"#733AFB\"},\n                    \"OBJECT_B\": {\"children\": [], \"name\": \"Car\", \"color\": \"#3CD876\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Track objects A and B\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {\"tracking\": {}},\n            \"isVisible\": True,\n            \"required\": 0,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"0\": {},\n        \"1\": {\n            \"JOB_0\": {\n                \"annotations\": [\n                    {\n                        \"children\": {},\n                        \"boundingPoly\": [\n                            {\n                                \"normalizedVertices\": [\n                                    {\"x\": 0.30, \"y\": 0.63},\n                                    {\"x\": 0.30, \"y\": 0.55},\n                                    {\"x\": 0.36, \"y\": 0.55},\n                                    {\"x\": 0.36, \"y\": 0.63},\n                                ]\n                            }\n                        ],\n                        \"categories\": [{\"name\": \"OBJECT_B\"}],\n                        \"mid\": \"20230407140827577-43802\",\n                        \"type\": \"rectangle\",\n                        \"isKeyFrame\": True,\n                    }\n                ]\n            }\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"VIDEO\")\n</code></pre> <pre><code>print(label.jobs[\"JOB_0\"].frames[1].annotations[0].category.name)\n</code></pre> <pre><code>OBJECT_B\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#named-entities-recognition-jobs","title":"Named entities recognition jobs","text":"<p>For NER jobs, the content of the job reponse is a list of annotations.</p> <p>Those annotations can be accessed through the <code>.annotations</code> or <code>.entity_annotations</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NER_JOB\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\"ORG\": {}, \"PERSON\": {}},\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\ndict_label = {\n    \"jsonResponse\": {\n        \"NER_JOB\": {\n            \"annotations\": [\n                {\n                    \"categories\": [{\"name\": \"ORG\", \"confidence\": 42}],\n                    \"beginOffset\": 21,\n                    \"content\": \"this is the text for Kili\",\n                    \"mid\": \"mid_a\",\n                },\n                {\n                    \"categories\": [{\"name\": \"PERSON\", \"confidence\": 100}],\n                    \"beginOffset\": 8,\n                    \"content\": \"this is Toto's text\",\n                    \"mid\": \"mid_b\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(\"Number of annotations in this label: \", len(label.jobs[\"NER_JOB\"].annotations))\n</code></pre> <pre><code>Number of annotations in this label:  2\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations == label.jobs[\"NER_JOB\"].entity_annotations)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].category)\n</code></pre> <pre><code>{'name': 'ORG', 'confidence': 42}\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].begin_offset)\n</code></pre> <pre><code>21\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].content)\n</code></pre> <pre><code>this is the text for Kili\n</code></pre> <pre><code>print(label.jobs[\"NER_JOB\"].annotations[0].mid)\n</code></pre> <pre><code>mid_a\n</code></pre> <p>It is also possible to iterate over the annotations of this label:</p> <pre><code>for annotation in label.jobs[\"NER_JOB\"].annotations:\n    print(annotation)\n</code></pre> <pre><code>{'categories': [{'name': 'ORG', 'confidence': 42}], 'beginOffset': 21, 'content': 'this is the text for Kili', 'mid': 'mid_a'}\n{'categories': [{'name': 'PERSON', 'confidence': 100}], 'beginOffset': 8, 'content': \"this is Toto's text\", 'mid': 'mid_b'}\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#named-entities-recognition-in-pdf-jobs","title":"Named entities recognition in PDF jobs","text":"<p>For PDF assets, a parsed NER label has a few additional attributes such as <code>.page_number_array</code> and <code>.polys</code>.</p> <p>The description of those attributes can be found in the documentation.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                    \"C\": {\"children\": [], \"name\": \"C\", \"color\": \"#D33BCE\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Job name\",\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        }\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"annotations\": [\n                        {\n                            \"boundingPoly\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.46269795405629893, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.46269795405629893, \"y\": 0.278286415605941},\n                                            {\"x\": 0.602529939052542, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.602529939052542, \"y\": 0.278286415605941},\n                                        ]\n                                    ]\n                                }\n                            ],\n                            \"pageNumberArray\": [1],\n                            \"polys\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.46269795405629893, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.46269795405629893, \"y\": 0.278286415605941},\n                                            {\"x\": 0.602529939052542, \"y\": 0.26256487006078677},\n                                            {\"x\": 0.602529939052542, \"y\": 0.278286415605941},\n                                        ]\n                                    ]\n                                }\n                            ],\n                        }\n                    ],\n                    \"categories\": [{\"confidence\": 100, \"name\": \"C\"}],\n                    \"content\": \"Some content\",\n                    \"mid\": \"20230502085706687-73004\",\n                },\n                {\n                    \"children\": {},\n                    \"annotations\": [\n                        {\n                            \"boundingPoly\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.18745653985687646, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.18745653985687646, \"y\": 0.45263593566837257},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.45263593566837257},\n                                        ]\n                                    ]\n                                }\n                            ],\n                            \"pageNumberArray\": [1],\n                            \"polys\": [\n                                {\n                                    \"normalizedVertices\": [\n                                        [\n                                            {\"x\": 0.18745653985687646, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.18745653985687646, \"y\": 0.45263593566837257},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.4369143838760365},\n                                            {\"x\": 0.4306102589135375, \"y\": 0.45263593566837257},\n                                        ]\n                                    ]\n                                }\n                            ],\n                        }\n                    ],\n                    \"categories\": [{\"confidence\": 100, \"name\": \"A\"}],\n                    \"content\": \"chier    compress\u00e9   \u201cCoregist\",\n                    \"mid\": \"20230502085709115-90490\",\n                },\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"PDF\")\n</code></pre> <pre><code>print(\"Number of annotations: \", len(label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations))\n</code></pre> <pre><code>Number of annotations:  2\n</code></pre> <pre><code>first_ann = label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0]\n</code></pre> <pre><code>print(first_ann.content)\n</code></pre> <pre><code>Some content\n</code></pre> <pre><code>print(first_ann.category)\n</code></pre> <pre><code>{'name': 'C', 'confidence': 100}\n</code></pre> <p>The NER in PDFs json response format is a bit complex, and thus requires to use the <code>.annotations</code> attribute a second time. You can read more about it in the documentation.</p> <pre><code>print(first_ann.annotations[0].page_number_array)\n</code></pre> <pre><code>[1]\n</code></pre> <pre><code>print(first_ann.annotations[0].polys)\n</code></pre> <pre><code>[{'normalizedVertices': [[{'x': 0.46269795405629893, 'y': 0.26256487006078677}, {'x': 0.46269795405629893, 'y': 0.278286415605941}, {'x': 0.602529939052542, 'y': 0.26256487006078677}, {'x': 0.602529939052542, 'y': 0.278286415605941}]]}]\n</code></pre> <pre><code>print(first_ann.annotations[0].bounding_poly)\n</code></pre> <pre><code>[{'normalizedVertices': [[{'x': 0.46269795405629893, 'y': 0.26256487006078677}, {'x': 0.46269795405629893, 'y': 0.278286415605941}, {'x': 0.602529939052542, 'y': 0.26256487006078677}, {'x': 0.602529939052542, 'y': 0.278286415605941}]]}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#relation-jobs","title":"Relation jobs","text":"<p>A relation job is a job that links two annotations together. You can read more about it in the documentation.</p>"},{"location":"sdk/tutorials/label_parsing/#named-entities-relation-jobs","title":"Named entities relation jobs","text":"<p>A NER relation parsed label has the <code>.start_entities</code> and <code>.end_entities</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RELATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"RELATION_1\": {\n                        \"children\": [],\n                        \"color\": \"#472CED\",\n                        \"name\": \"Relation 1\",\n                        \"endEntities\": [\"B\"],\n                        \"startEntities\": [\"A\"],\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"mlTask\": \"NAMED_ENTITIES_RELATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"color\": \"#5CE7B7\", \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\", \"color\": \"#D33BCE\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"beginId\": \"main/[0]\",\n                    \"beginOffset\": 159,\n                    \"categories\": [{\"name\": \"A\"}],\n                    \"content\": \"KBDFR\",\n                    \"endId\": \"main/[0]\",\n                    \"endOffset\": 164,\n                    \"mid\": \"123\",\n                },\n                {\n                    \"children\": {},\n                    \"beginId\": \"main/[0]\",\n                    \"beginOffset\": 145,\n                    \"categories\": [{\"name\": \"B\"}],\n                    \"content\": \"KBDJPN\",\n                    \"endId\": \"main/[0]\",\n                    \"endOffset\": 151,\n                    \"mid\": \"456\",\n                },\n            ]\n        },\n        \"NAMED_ENTITIES_RELATION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"categories\": [{\"name\": \"RELATION_1\"}],\n                    \"endEntities\": [{\"mid\": \"456\"}],\n                    \"mid\": \"20230502100607943-6453\",\n                    \"startEntities\": [{\"mid\": \"123\"}],\n                }\n            ]\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"TEXT\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['NAMED_ENTITIES_RELATION_JOB', 'NAMED_ENTITIES_RECOGNITION_JOB']\n</code></pre> <pre><code>print(\"Annotation content: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].content)\nprint(\"Category: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].category.name)\nprint(\"Begin offset: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].begin_offset)\nprint(\"End offset: \", label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations[0].end_offset)\n</code></pre> <pre><code>Annotation content:  KBDFR\nCategory:  A\nBegin offset:  159\nEnd offset:  164\n</code></pre> <p>Here is how to print the unique IDs and names of the entity recognition annotations:</p> <pre><code>for ann in label.jobs[\"NAMED_ENTITIES_RECOGNITION_JOB\"].annotations:\n    print(ann.mid, ann.category.name)\n</code></pre> <pre><code>123 A\n456 B\n</code></pre> <pre><code>print(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].category.name)\nprint(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].start_entities)\nprint(label.jobs[\"NAMED_ENTITIES_RELATION_JOB\"].annotations[0].end_entities)\n</code></pre> <pre><code>RELATION_1\n[{'mid': '123'}]\n[{'mid': '456'}]\n</code></pre> <p>We can see that the relation annotation above refers to the entity annotations using their unique IDs.</p>"},{"location":"sdk/tutorials/label_parsing/#object-detection-relation-jobs","title":"Object detection relation jobs","text":"<p>For object detection relation jobs, the relation data is accessible through the <code>.start_objects</code> and <code>.end_objects</code> attributes.</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [], \"color\": \"#472CED\", \"name\": \"A\"},\n                    \"B\": {\"children\": [], \"name\": \"B\", \"color\": \"#5CE7B7\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"BBOX\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"rectangle\"],\n            \"isChild\": False,\n        },\n        \"OBJECT_RELATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"RELATION_1\": {\n                        \"children\": [],\n                        \"color\": \"#D33BCE\",\n                        \"name\": \"Relation 1\",\n                        \"startObjects\": [\"A\"],\n                        \"endObjects\": [\"B\"],\n                    }\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Relation job\",\n            \"mlTask\": \"OBJECT_RELATION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.11634755020512799, \"y\": 0.49755605764956},\n                                {\"x\": 0.11634755020512799, \"y\": 0.22714821030828314},\n                                {\"x\": 0.4035032060305503, \"y\": 0.22714821030828314},\n                                {\"x\": 0.4035032060305503, \"y\": 0.49755605764956},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"A\"}],\n                    \"mid\": \"20230502102127826-44552\",\n                    \"type\": \"rectangle\",\n                },\n                {\n                    \"children\": {},\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.539654594568466, \"y\": 0.8005026086128164},\n                                {\"x\": 0.539654594568466, \"y\": 0.5413150038998081},\n                                {\"x\": 0.7760629146661198, \"y\": 0.5413150038998081},\n                                {\"x\": 0.7760629146661198, \"y\": 0.8005026086128164},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"B\"}],\n                    \"mid\": \"20230502102129606-15732\",\n                    \"type\": \"rectangle\",\n                },\n            ]\n        },\n        \"OBJECT_RELATION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {},\n                    \"categories\": [{\"name\": \"RELATION_1\"}],\n                    \"endObjects\": [{\"mid\": \"20230502102129606-15732\"}],\n                    \"mid\": \"20230502102131372-75485\",\n                    \"startObjects\": [{\"mid\": \"20230502102127826-44552\"}],\n                }\n            ]\n        },\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(list(label.jobs.keys()))\n</code></pre> <pre><code>['OBJECT_DETECTION_JOB', 'OBJECT_RELATION_JOB']\n</code></pre> <pre><code>for ann in label.jobs[\"OBJECT_DETECTION_JOB\"].annotations:\n    print(ann.mid, ann.category.name)\n</code></pre> <pre><code>20230502102127826-44552 A\n20230502102129606-15732 B\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].category)\nprint(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].start_objects)\nprint(label.jobs[\"OBJECT_RELATION_JOB\"].annotations[0].end_objects)\n</code></pre> <pre><code>{'name': 'RELATION_1'}\n[{'mid': '20230502102127826-44552'}]\n[{'mid': '20230502102129606-15732'}]\n</code></pre>"},{"location":"sdk/tutorials/label_parsing/#child-jobs","title":"Child jobs","text":"<p>Use the <code>.children</code> attribute to access nested (child) labels:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"A\": {\"children\": [\"TRANSCRIPTION_JOB\"], \"color\": \"#472CED\", \"name\": \"A\"}\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"BBox job\",\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"required\": 1,\n            \"tools\": [\"rectangle\"],\n            \"isChild\": False,\n        },\n        \"TRANSCRIPTION_JOB\": {\n            \"content\": {\"input\": \"textField\"},\n            \"instruction\": \"Transcription\",\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n    }\n}\n\ndict_label = {\n    \"jsonResponse\": {\n        \"OBJECT_DETECTION_JOB\": {\n            \"annotations\": [\n                {\n                    \"children\": {\n                        \"TRANSCRIPTION_JOB\": {\"text\": \"This is a transcription of a bbox\"}\n                    },\n                    \"boundingPoly\": [\n                        {\n                            \"normalizedVertices\": [\n                                {\"x\": 0.23517058020185444, \"y\": 0.40330601957210255},\n                                {\"x\": 0.23517058020185444, \"y\": 0.22939225883393688},\n                                {\"x\": 0.4468241023835235, \"y\": 0.22939225883393688},\n                                {\"x\": 0.4468241023835235, \"y\": 0.40330601957210255},\n                            ]\n                        }\n                    ],\n                    \"categories\": [{\"name\": \"A\"}],\n                    \"mid\": \"20230502102626089-88764\",\n                    \"type\": \"rectangle\",\n                }\n            ]\n        }\n    }\n}\n</code></pre> <pre><code>label = ParsedLabel(dict_label, json_interface=json_interface, input_type=\"IMAGE\")\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].type)\nprint(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].category.name)\n</code></pre> <pre><code>rectangle\nA\n</code></pre> <pre><code>print(label.jobs[\"OBJECT_DETECTION_JOB\"].annotations[0].children[\"TRANSCRIPTION_JOB\"].text)\n</code></pre> <pre><code>This is a transcription of a bbox\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/","title":"Converting and Visualizing Segmentation Labels","text":""},{"location":"sdk/tutorials/medical_imaging/#how-to-upload-medical-images-to-kili-and-visualize-segmentation-labels-with-matplotlib","title":"How to upload medical images to Kili, and visualize segmentation labels with matplotlib","text":"<p>In this tutorial, we will learn how to:</p> <ul> <li>upload medical images to Kili using pydicom</li> <li>upload dicom tags as metadata to our assets</li> <li>download segmentation labels from Kili, and convert them to Numpy masks for visualization with matplotlib.</li> </ul> <p>Data used in this tutorial comes from the RSNA Pneumonia Detection Challenge hosted on Kaggle.</p> <p>First of all, let's import the packages, and install pydicom in case you don't have it installed.</p> <pre><code>%pip install pydicom matplotlib Pillow wget numpy pandas kili\n</code></pre> <pre><code>import getpass\nimport os\nimport pickle\nfrom functools import reduce\nfrom pathlib import Path\n\nimport matplotlib.colors as mcolors\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pydicom\nimport wget\nfrom PIL import Image\n\nfrom kili.client import Kili\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#get-data","title":"Get data","text":"<p>Let's download some dicom images:</p> <pre><code>wget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/datasets/0000a175-0e68-4ca4-b1af-167204a7e0bc.dcm?raw=true\"\n)\nwget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/datasets/0005d3cc-3c3f-40b9-93c3-46231c3eb813.dcm?raw=true\"\n)\n\ndata_folder = Path(\".\")\nfiles = list(data_folder.glob(\"*.dcm\"))\nassert len(files) == 2, files\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#process-data","title":"Process data","text":"<p>A dicom image not only contains pixels (or voxels), but also dicom tags, that can contain information about the patient, the scanner, etc.</p> <p>Below, we extract the dicom tags and add them to <code>metadata_array</code>.</p> <p>We also convert all images to JPEG format.</p> <pre><code>def extract_dicom_tags(img_dicom):\n    metadata = {}\n    for key in img_dicom.keys():\n        if key.group == 32736:  # key containing the image pixels\n            continue\n        item = img_dicom.get(key)\n        if hasattr(item, \"description\") and hasattr(item, \"value\"):\n            metadata[item.description()] = str(item.value)\n    return metadata\n</code></pre> <pre><code>metadata_array = []\nprocessed_imgs = []\n\nfor file in files:\n    sample = pydicom.dcmread(str(file))\n\n    im = Image.fromarray(sample.pixel_array)\n    fpath = data_folder / f\"{file.stem}.jpeg\"\n    im.save(str(fpath))\n    processed_imgs.append(str(fpath))\n\n    metadata_array.append(extract_dicom_tags(sample))\n</code></pre> <pre><code>print(metadata_array[0])\n</code></pre> <pre><code>{'Specific Character Set': 'ISO_IR 100', 'SOP Class UID': '1.2.840.10008.5.1.4.1.1.7', 'SOP Instance UID': '1.2.276.0.7230010.3.1.4.8323329.1747.1517874292.605928', 'Study Date': '19010101', 'Study Time': '000000.00', 'Accession Number': '', 'Modality': 'CR', 'Conversion Type': 'WSD', \"Referring Physician's Name\": '', 'Series Description': 'view: PA', \"Patient's Name\": '0005d3cc-3c3f-40b9-93c3-46231c3eb813', 'Patient ID': '0005d3cc-3c3f-40b9-93c3-46231c3eb813', \"Patient's Birth Date\": '', \"Patient's Sex\": 'F', \"Patient's Age\": '22', 'Body Part Examined': 'CHEST', 'View Position': 'PA', 'Study Instance UID': '1.2.276.0.7230010.3.1.2.8323329.1747.1517874292.605927', 'Series Instance UID': '1.2.276.0.7230010.3.1.3.8323329.1747.1517874292.605926', 'Study ID': '', 'Series Number': '1', 'Instance Number': '1', 'Patient Orientation': '', 'Samples per Pixel': '1', 'Photometric Interpretation': 'MONOCHROME2', 'Rows': '1024', 'Columns': '1024', 'Pixel Spacing': '[0.14300000000000002, 0.14300000000000002]', 'Bits Allocated': '8', 'Bits Stored': '8', 'High Bit': '7', 'Pixel Representation': '0', 'Lossy Image Compression': '01', 'Lossy Image Compression Method': 'ISO_10918_1'}\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#create-the-kili-project","title":"Create the Kili project","text":"<p>Next, we need to connect to Kili, create a project, and define the annotation interface (ontology).</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <pre><code>json_interface = {\n    \"jobs\": {\n        \"CLASSIFICATION_JOB\": {\n            \"mlTask\": \"CLASSIFICATION\",\n            \"content\": {\n                \"categories\": {\"YES\": {\"name\": \"Yes\"}, \"NO\": {\"name\": \"No\"}},\n                \"input\": \"radio\",\n            },\n            \"required\": 1,\n            \"isChild\": False,\n            \"instruction\": \"Healthy ?\",\n        },\n        \"JOB_0\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"content\": {\n                \"categories\": {\n                    \"BONE\": {\"name\": \"bone\"},\n                    \"TISSUE\": {\"name\": \"tissue\"},\n                    \"LUNG\": {\"name\": \"lung\"},\n                    \"RIB\": {\"name\": \"rib\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"required\": True,\n            \"tools\": [\"polygon\"],\n            \"isChild\": False,\n            \"instruction\": \"Segmentation\",\n        },\n    }\n}\n</code></pre> <p>We can now use the Kili SDK to create our project and upload our images to the project.</p> <pre><code>title = \"Medical Imaging with Kili Technology\"\ndescription = \"This is a test project\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=processed_imgs,\n    external_id_array=processed_imgs,\n    json_metadata_array=metadata_array,\n)\n</code></pre> <p>Done! Your images and their metadata are in the project:</p> <p></p> <p></p> <p>All that remains is to start labeling! To learn more about how to label images in Kili, check out our documentation.</p>"},{"location":"sdk/tutorials/medical_imaging/#convert-kili-labels-to-numpy-masks","title":"Convert Kili labels to numpy masks","text":"<p>Once your assets are labeled, you might want to download them and visualize them using matplotlib.</p> <p>To download your labels, simply use <code>kili.labels(project_id)</code>. You can also export your labels to a zip file using <code>kili.export_labels(project_id)</code>. For more information, see the documentation.</p> <p>In this tutorial, we assume that our labels have already been downloaded and stored in a file <code>medical-labels.pkl</code>.</p> <pre><code>from kili.utils.labels.parsing import ParsedLabel\n</code></pre> <pre><code>wget.download(\n    \"https://github.com/kili-technology/kili-python-sdk/blob/main/recipes/conf/medical-labels.pkl?raw=true\"\n)\n\nwith open(\"medical-labels.pkl\", \"rb\") as f:\n    label = pickle.load(f)\n\nlabel = ParsedLabel(\n    label={\"jsonResponse\": label}, json_interface=json_interface, input_type=\"IMAGE\"\n)\n\nhealthy = label.jobs[\"CLASSIFICATION_JOB\"].category.name\nannotations = label.jobs[\"JOB_0\"].annotations\n</code></pre> <pre><code>print(healthy)\n</code></pre> <pre><code>YES\n</code></pre> <p>In this example, <code>annotations</code> is a list containing 10 masks.</p> <p>A mask is represented by a Python list of vertices, each vertex being a list of two coordinates (x, y).</p> <pre><code>print(len(annotations))\nprint(type(annotations))\nprint(len(annotations[0].bounding_poly[0].normalized_vertices))\nprint(annotations[0].bounding_poly[0].normalized_vertices[0])\n</code></pre> <pre><code>10\n&lt;class 'kili.services.label_data_parsing.annotation.AnnotationList'&gt;\n255\n{'x': 0.401891, 'y': 0.024966000000015254}\n</code></pre> <p>We assign a color to each class:</p> <pre><code>colors = plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\ncolors = [\n    tuple(int(x * 255) for x in mcolors.hex2color(hex_color))\n    for hex_color in plt.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n]\nCLASS_TO_COLOR = {}\nfor class_name, color in zip(\n    json_interface[\"jobs\"][\"JOB_0\"][\"content\"][\"categories\"].keys(), colors\n):\n    CLASS_TO_COLOR[class_name] = color\nprint(CLASS_TO_COLOR)\n</code></pre> <pre><code>{'BONE': (31, 119, 180), 'TISSUE': (255, 127, 14), 'LUNG': (44, 160, 44), 'RIB': (214, 39, 40)}\n</code></pre> <p>We convert those labels using the <code>kili.utils.labels</code> module, and plot them using matplotlib:</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n</code></pre> <pre><code>im = Image.open(processed_imgs[0])\n\nimg_width, img_height = im.size\nclass_names = []\nmasks = []\nfor annotation in annotations:\n    class_name = annotation.category.name\n    normalized_vertices = annotation.bounding_poly[0].normalized_vertices\n\n    # convert the label normalized vertices to a numpy mask\n    mask = normalized_vertices_to_mask(normalized_vertices, img_width, img_height)\n\n    # add color to the mask\n    mask_rgb = np.zeros((*mask.shape, 3), dtype=np.int32)\n    mask_rgb[mask &gt; 0] = CLASS_TO_COLOR[class_name]\n\n    class_names.append(class_name)\n    masks.append(mask_rgb)\n</code></pre> <p>Let's merge all masks into a single one:</p> <pre><code>merged_masks = reduce(lambda mask_1, mask_2: np.where(mask_1 != (0, 0, 0), mask_1, mask_2), masks)\n</code></pre>"},{"location":"sdk/tutorials/medical_imaging/#plot-the-image-and-masks","title":"Plot the image and masks","text":"<p>Finally, we can plot the image as well as the masks converted from our Kili labels:</p> <pre><code>handles = []\nlabels = []\nfor class_name, color in CLASS_TO_COLOR.items():\n    patch = mpatches.Patch(color=tuple(x / 255 for x in color), label=class_name)\n    handles.append(patch)\n    labels.append(class_name)\n</code></pre> <pre><code>fig, ax = plt.subplots(figsize=(10, 10))\nax.imshow(im, cmap=\"gray\")\nax.imshow(merged_masks, alpha=0.5)\nax.set_title(f\"Healthy: {healthy}\")\nax.legend(handles=handles, labels=labels, fontsize=16, loc=\"upper left\")\nplt.show()\n</code></pre> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>In this tutorial, we have seen how to upload medical images to Kili, and how to download the segmentation labels and convert them to Numpy masks.</p>"},{"location":"sdk/tutorials/medical_imaging/#project-cleanup","title":"Project cleanup","text":"<pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/","title":"OpenAI NER Pre-annotations","text":""},{"location":"sdk/tutorials/ner_pre_annotations_openai/#how-to-import-openai-ner-pre-annotations","title":"How to import OpenAI NER pre-annotations","text":"<p>This tutorial explains how to use a powerful OpenAI Large Language Model (LLM) to generate pre-annotations, which will then be imported into a Named Entity Recognition (NER) Kili project.</p> <p>Nowadays, LLMs are capable of performing many NLP tasks, including NER, without being explicitly trained on them, which is known as zero-shot learning.</p> <p>By using a well-designed prompt, we can generate high-quality pre-annotations for the NER task, as demonstrated in the pre-annotations quality evaluation section of this tutorial.</p> <p>Throughout this tutorial, we will thus:</p> <ul> <li>Load a dataset CoNLL2003 from the HuggingFace datasets library.</li> <li>Learn how to use the OpenAI API to generate pre-annotations.</li> <li>Import data and labels into a NER project on Kili.</li> <li>Evaluate the quality of the generated pre-annotations.</li> </ul>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#setup","title":"Setup","text":"<p>Let's start this tutorial by installing the packages we will need later on.</p> <pre><code>%pip install kili datasets evaluate ipywidgets openai scikit-learn numpy rich\n</code></pre> <pre><code>import getpass\nimport json\nimport os\nfrom collections import defaultdict\n\nimport numpy as np\nimport openai\nfrom rich.console import Console\nfrom rich.table import Table\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#data-preparation","title":"Data preparation","text":"<p>In this tutorial, we will use the CoNLL2003 dataset from the Hugging Face repository. This dataset contains more than 10,000 sentences annotated with named entities.</p> <pre><code>from datasets import load_dataset\n</code></pre> <p>To speed up the process, we will use a limited number of samples. We will also remove sentences that do not contain enough words.</p> <pre><code>MAX_DATAPOINTS = 20\nMIN_NB_TOKENS_PER_SENTENCE = 9\n</code></pre> <pre><code>dataset = load_dataset(\"conll2003\", split=\"train\").filter(\n    lambda datapoint: len(datapoint[\"tokens\"]) &gt;= MIN_NB_TOKENS_PER_SENTENCE\n)\ndataset = dataset.select(range(MAX_DATAPOINTS))\n</code></pre> <pre><code>print(dataset)\n</code></pre> <pre><code>Dataset({\n    features: ['id', 'tokens', 'pos_tags', 'chunk_tags', 'ner_tags'],\n    num_rows: 20\n})\n</code></pre> <pre><code>for i in range(3):\n    print(dataset[i])\n</code></pre> <pre><code>{'id': '0', 'tokens': ['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.'], 'pos_tags': [22, 42, 16, 21, 35, 37, 16, 21, 7], 'chunk_tags': [11, 21, 11, 12, 21, 22, 11, 12, 0], 'ner_tags': [3, 0, 7, 0, 0, 0, 7, 0, 0]}\n{'id': '3', 'tokens': ['The', 'European', 'Commission', 'said', 'on', 'Thursday', 'it', 'disagreed', 'with', 'German', 'advice', 'to', 'consumers', 'to', 'shun', 'British', 'lamb', 'until', 'scientists', 'determine', 'whether', 'mad', 'cow', 'disease', 'can', 'be', 'transmitted', 'to', 'sheep', '.'], 'pos_tags': [12, 22, 22, 38, 15, 22, 28, 38, 15, 16, 21, 35, 24, 35, 37, 16, 21, 15, 24, 41, 15, 16, 21, 21, 20, 37, 40, 35, 21, 7], 'chunk_tags': [11, 12, 12, 21, 13, 11, 11, 21, 13, 11, 12, 13, 11, 21, 22, 11, 12, 17, 11, 21, 17, 11, 12, 12, 21, 22, 22, 13, 11, 0], 'ner_tags': [0, 3, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}\n{'id': '4', 'tokens': ['Germany', \"'s\", 'representative', 'to', 'the', 'European', 'Union', \"'s\", 'veterinary', 'committee', 'Werner', 'Zwingmann', 'said', 'on', 'Wednesday', 'consumers', 'should', 'buy', 'sheepmeat', 'from', 'countries', 'other', 'than', 'Britain', 'until', 'the', 'scientific', 'advice', 'was', 'clearer', '.'], 'pos_tags': [22, 27, 21, 35, 12, 22, 22, 27, 16, 21, 22, 22, 38, 15, 22, 24, 20, 37, 21, 15, 24, 16, 15, 22, 15, 12, 16, 21, 38, 17, 7], 'chunk_tags': [11, 11, 12, 13, 11, 12, 12, 11, 12, 12, 12, 12, 21, 13, 11, 12, 21, 22, 11, 13, 11, 1, 13, 11, 17, 11, 12, 12, 21, 1, 0], 'ner_tags': [5, 0, 0, 0, 0, 3, 4, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0]}\n</code></pre> <p>Here is the meaning of each feature in the dataset:</p> <ul> <li>id: A unique identifier for each token in a sentence.</li> <li>tokens: The tokens (words or punctuation marks) in a sentence.</li> <li>pos_tags: Part-of-speech tags for each token in the sentence. Part-of-speech tagging is the process of assigning a tag to each word in a sentence that indicates its part of speech (e.g., noun, verb, adjective, etc.).</li> <li>chunk_tags: Chunking tags for each token in the sentence. Chunking is the process of grouping words into meaningful phrases based on their syntactic structure.</li> <li>ner_tags: Named Entity Recognition (NER) tags for each token in the sentence. NER is the task of identifying named entities in text and classifying them into pre-defined categories such as person, organization, location, etc.</li> </ul> <p>The sentences are split into tokens. We can regroup the tokens for later use:</p> <pre><code>fix_joined_tokens_map = {\" .\": \".\", \"( \": \"(\", \" )\": \")\", \" 's \": \"'s \", \"s ' \": \"s' \"}\n\nsentence_column = []\nfor datapoint in dataset:\n    sentence = \" \".join(datapoint[\"tokens\"])\n    for before, after in fix_joined_tokens_map.items():\n        sentence = sentence.replace(before, after)\n    sentence_column.append(sentence)\n\ndataset = dataset.add_column(\"sentence\", sentence_column)\n</code></pre> <pre><code>print(dataset[0])\n</code></pre> <pre><code>{'id': '0', 'tokens': ['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.'], 'pos_tags': [22, 42, 16, 21, 35, 37, 16, 21, 7], 'chunk_tags': [11, 21, 11, 12, 21, 22, 11, 12, 0], 'ner_tags': [3, 0, 7, 0, 0, 0, 7, 0, 0], 'sentence': 'EU rejects German call to boycott British lamb.'}\n</code></pre> <pre><code>NER_TAGS_ONTOLOGY = {\n    \"O\": 0,\n    \"B-PERSON\": 1,\n    \"I-PERSON\": 2,\n    \"B-ORGANIZATION\": 3,\n    \"I-ORGANIZATION\": 4,\n    \"B-LOCATION\": 5,\n    \"I-LOCATION\": 6,\n    \"B-MISCELLANEOUS\": 7,\n    \"I-MISCELLANEOUS\": 8,\n}\n</code></pre> <p><code>NER_TAGS_ONTOLOGY</code> is a dictionary that maps the named entity tags in the CoNLL2003 dataset to integer labels. Here is the meaning of each key-value pair in the dictionary:</p> <ul> <li>O: Represents the tag \"O\" which means that the token is not part of a named entity.</li> <li>B-PERSON: Represents the beginning of a person.</li> <li>I-PERSON: Represents a token inside a person.</li> <li>B-ORGANIZATION: Represents the beginning of an organization.</li> <li>I-ORGANIZATION: Represents a token inside an organization.</li> <li>B-LOCATION: Represents the beginning of a location.</li> <li>I-LOCATION: Represents a token inside a location.</li> <li>B-MISCELLANEOUS: Represents the beginning of a miscellaneous.</li> <li>I-MISCELLANEOUS: Represents a token inside a miscellaneous.</li> </ul> <p>During the training of a NER model, the entity names will be converted to integer labels using such a dictionary.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#connect-with-chatgpt-api","title":"Connect with ChatGPT API","text":"<p>Let's use the OpenAI API to get the pre-annotations for our dataset.</p> <pre><code>if \"OPENAI_API_KEY\" in os.environ:\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\nelse:\n    OPENAI_API_KEY = getpass.getpass(\"Please enter your OpenAI API key: \")\n</code></pre> <pre><code>openai.api_key = OPENAI_API_KEY\n</code></pre> <p>We can now define the parameters that will be used during the query to OpenAI model:</p> <ul> <li>model: the model that will be used to generate the pre-annotations. The full list is available under this link.</li> <li>temperature: the temperature of the model. The higher the temperature, the more random the text. The lower the temperature, the more likely it is to predict the next word. The default value is 0.7. It should be between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.</li> <li>max_tokens: the maximum number of tokens to generate. The default value is 64. It should be between 1 and 4096, depending on the model.</li> </ul> <pre><code>openai_query_params = {\"model\": \"text-davinci-003\", \"temperature\": 0, \"max_tokens\": 1024}\n\n\ndef ask_openai(prompt: str, openai_query_params=openai_query_params) -&gt; str:\n    response = openai.Completion.create(\n        prompt=prompt,\n        **openai_query_params,\n    )\n    return response[\"choices\"][0][\"text\"]\n</code></pre> <p>Let's test the API with a simple prompt:</p> <pre><code>print(ask_openai(\"Hello, are you here?\"))\n</code></pre> <pre><code>Yes, I am here. How can I help you?\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#prompt-design","title":"Prompt design","text":"<p>To get pre-annotations for our dataset, we need to create a prompt that tells the model what to do:</p> <pre><code>base_prompt = \"\"\"In the sentence below, give me the list of:\n- organization named entity\n- location named entity\n- person named entity\n- miscellaneous named entity.\nFormat the output in json with the following keys:\n- ORGANIZATION for organization named entity\n- LOCATION for location named entity\n- PERSON for person named entity\n- MISCELLANEOUS for miscellaneous named entity.\nSentence below:\n\"\"\"\n</code></pre> <p>Let's see if the model understands the prompt well on a simple example:</p> <pre><code>test_sentence = (\n    \"Elon Musk is the CEO of Tesla and SpaceX. He was born in South Africa and now lives in the\"\n    \" USA. He is one of the founders of OpenAI.\"\n)\n</code></pre> <pre><code>print(ask_openai(base_prompt + test_sentence))\n</code></pre> <pre><code>{\n  \"ORGANIZATION\": [\"Tesla\", \"SpaceX\", \"OpenAI\"],\n  \"LOCATION\": [\"South Africa\", \"USA\"],\n  \"PERSON\": [\"Elon Musk\"],\n  \"MISCELLANEOUS\": []\n}\n</code></pre> <p>Looks really good! Let's now process all sentences in our dataset with the previous prompt.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#create-the-pre-annotations","title":"Create the pre-annotations","text":"<p>In the code below, we will use the OpenAI API to get the pre-annotations for each sentence in our dataset.</p> <pre><code>openai_answers = []\nfor datapoint in dataset:\n    sentence = datapoint[\"sentence\"]\n    answer = ask_openai(base_prompt + sentence)\n    try:\n        answer_json = json.loads(answer)\n    except json.JSONDecodeError:\n        print(f\"Wrong json formatting:\\n{answer}\")\n        answer_json = {\"ORGANIZATION\": [], \"LOCATION\": [], \"PERSON\": [], \"MISCELLANEOUS\": []}\n    openai_answers.append(answer_json)\n</code></pre> <pre><code>print(openai_answers[:3])\n</code></pre> <pre><code>[{'ORGANIZATION': ['EU', 'German'], 'LOCATION': ['British'], 'PERSON': [], 'MISCELLANEOUS': ['lamb']}, {'ORGANIZATION': ['European Commission'], 'LOCATION': ['German', 'British'], 'PERSON': [], 'MISCELLANEOUS': ['mad cow disease']}, {'ORGANIZATION': [\"European Union's veterinary committee\"], 'LOCATION': ['Germany', 'Britain'], 'PERSON': ['Werner Zwingmann'], 'MISCELLANEOUS': []}]\n</code></pre> <p>We need to sanitize the json to make sure that the values are of type list:</p> <pre><code>for i, _ in enumerate(openai_answers):\n    json_dict = openai_answers[i]\n    for category in json_dict:\n        if isinstance(json_dict[category], str):\n            json_dict[category] = [json_dict[category]]\n        elif isinstance(json_dict[category], list):\n            continue\n        else:\n            print(f\"Unknown value type '{json_dict[category]}' for value '{json_dict[category]}'\")\n            json_dict[category] = []\n</code></pre>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#import-dataset-and-pre-annotations-to-kili","title":"Import dataset and pre-annotations to Kili","text":"<p>Now that we have both the data and the pre-annotations, we can import them to a Kili project.</p> <pre><code>if \"KILI_API_KEY\" in os.environ:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\nelse:\n    KILI_API_KEY = getpass.getpass(\"Please enter your Kili API key: \")\n</code></pre> <pre><code>from kili.client import Kili\n</code></pre> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # no need to pass the API_KEY if it is already in your environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <p>Below, we define the ontology (json interface) of the project. We define the 4 classes as well as their corresponding colors:</p> <pre><code>COLORS = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\"]\n\nENTITY_TYPES = [\n    (\"PERSON\", \"Person\"),\n    (\"ORGANIZATION\", \"Organization\"),\n    (\"LOCATION\", \"Location\"),\n    (\"MISCELLANEOUS\", \"Miscellaneous\"),\n]\n\nENTITY_TYPES_WITH_COLORS = [\n    (entity_type[0], entity_type[1], color) for entity_type, color in zip(ENTITY_TYPES, COLORS)\n]\nprint(ENTITY_TYPES_WITH_COLORS)\n</code></pre> <pre><code>[('PERSON', 'Person', '#1f77b4'), ('ORGANIZATION', 'Organization', '#ff7f0e'), ('LOCATION', 'Location', '#2ca02c'), ('MISCELLANEOUS', 'Miscellaneous', '#d62728')]\n</code></pre> <pre><code>json_interface = {\n    \"jobs\": {\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"content\": {\n                \"categories\": {\n                    name: {\"name\": name_pretty, \"children\": [], \"color\": color}\n                    for name, name_pretty, color in ENTITY_TYPES_WITH_COLORS\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"\",\n            \"required\": 1,\n            \"isChild\": False,\n        }\n    },\n}\n</code></pre> <p>Let's now create the project with its ontology:</p> <pre><code>project = kili.create_project(\n    title=\"CoNLL Named Entity Recognition with OpenAI pre-annotations\",\n    input_type=\"TEXT\",\n    json_interface=json_interface,\n)\nproject_id = project[\"id\"]\n</code></pre> <p>We now import the sentences to the project:</p> <pre><code>external_id_array = []\ncontent_array = []\nfor datapoint in dataset:\n    sentence = datapoint[\"sentence\"]\n    content_array.append(sentence)\n    external_id_array.append(datapoint[\"id\"])\n\nprint(content_array[:3])\nprint(external_id_array[:3])\n</code></pre> <pre><code>['EU rejects German call to boycott British lamb.', 'The European Commission said on Thursday it disagreed with German advice to consumers to shun British lamb until scientists determine whether mad cow disease can be transmitted to sheep.', \"Germany's representative to the European Union's veterinary committee Werner Zwingmann said on Wednesday consumers should buy sheepmeat from countries other than Britain until the scientific advice was clearer.\"]\n['0', '3', '4']\n</code></pre> <pre><code>kili.append_many_to_dataset(\n    project_id=project_id, content_array=content_array, external_id_array=external_id_array\n)\n</code></pre> <pre><code>{'id': 'clf14l26401or0jv4e0d7d9ge'}\n</code></pre> <p>If you go to the project page, you should be able to see your assets:</p> <p></p> <p>And on the labeling interface, you will see the sentence and the ontology:</p> <p></p> <p>We can finally import our OpenAI-generated pre-annotations!</p> <pre><code>json_response_array = []\n\nfor datapoint, sentence_annotations in zip(dataset, openai_answers):\n    full_sentence = datapoint[\"sentence\"]\n    annotations = []  # list of annotations for the sentence\n    for category, _ in ENTITY_TYPES:\n        sentence_annotations_cat = sentence_annotations[category]\n        for content in sentence_annotations_cat:\n            begin_offset = full_sentence.find(content)\n            assert (\n                begin_offset != -1\n            ), f\"Cannot find offset of '{content}' in sentence '{full_sentence}'\"\n            annotation = {\n                \"categories\": [{\"name\": category}],\n                \"beginOffset\": begin_offset,\n                \"content\": content,\n            }\n            annotations.append(annotation)\n\n    json_resp = {\"NAMED_ENTITIES_RECOGNITION_JOB\": {\"annotations\": annotations}}\n    json_response_array.append(json_resp)\n</code></pre> <pre><code>print(json_response_array[0])\n</code></pre> <pre><code>{'NAMED_ENTITIES_RECOGNITION_JOB': {'annotations': [{'categories': [{'name': 'ORGANIZATION'}], 'beginOffset': 0, 'content': 'EU'}, {'categories': [{'name': 'ORGANIZATION'}], 'beginOffset': 11, 'content': 'German'}, {'categories': [{'name': 'LOCATION'}], 'beginOffset': 34, 'content': 'British'}, {'categories': [{'name': 'MISCELLANEOUS'}], 'beginOffset': 42, 'content': 'lamb'}]}}\n</code></pre> <p>We then import the annotations using the <code>kili.create_predictions()</code> method:</p> <pre><code>kili.create_predictions(\n    project_id,\n    external_id_array=external_id_array,\n    json_response_array=json_response_array,\n    model_name=openai_query_params[\"model\"],\n)\n</code></pre> <pre><code>{'id': 'clf14l26401or0jv4e0d7d9ge'}\n</code></pre> <p>In the main project page, you should now be able to see that the assets have been pre-annotated with the model you chose before:</p> <p></p> <p>On the labeling interface for a specific asset, you can see the pre-annotations:</p> <p></p> <p>Great! We have successfully pre-annotated our dataset. Looks like this solution has the potential to save us a lot of time in future projects.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#pre-annotations-quality-evaluation","title":"Pre-annotations quality evaluation","text":"<p>Because OpenAI-generated pre-annotations are not perfect, it would be great to have a way to measure the model's accuracy.</p> <p>Since our dataset CoNLL2003 has been annotated, we can easily evaluate the quality of the pre-annotations generated by OpenAI.</p> <pre><code>def format_sentence_annotations(sentence_annotations):\n\"\"\"\n    Maps a token to its NER tag (B-ORGANIZATION, I-ORGANIZATION, etc.) class value.\n    \"\"\"\n    ret = defaultdict(list)\n    for category, _ in ENTITY_TYPES:\n        sentence_annotations_cat = sentence_annotations[category]\n        for content in sentence_annotations_cat:\n            content_split = content.split(\" \")\n            for i, token in enumerate(content_split):\n                if i == 0:\n                    ret[token].append(NER_TAGS_ONTOLOGY[f\"B-{category}\"])\n                else:\n                    ret[token].append(NER_TAGS_ONTOLOGY[f\"I-{category}\"])\n    return ret\n\n\nreferences = []\npredictions = []\nfor datapoint, sentence_annotations in zip(dataset, openai_answers):\n    references.append(datapoint[\"ner_tags\"])\n\n    sentence_annotations = format_sentence_annotations(sentence_annotations)\n    ner_tags_predicted = []\n    for token in datapoint[\"tokens\"]:\n        if token in sentence_annotations and len(sentence_annotations[token]) &gt; 0:\n            ner_tags_predicted.append(sentence_annotations[token][0])\n            del sentence_annotations[token][0]\n        else:\n            ner_tags_predicted.append(NER_TAGS_ONTOLOGY[\"O\"])\n    predictions.append(ner_tags_predicted)\n</code></pre> <pre><code>print(dataset[0][\"tokens\"])\nprint(references[0])\nprint(predictions[0])\nprint(NER_TAGS_ONTOLOGY)\n</code></pre> <pre><code>['EU', 'rejects', 'German', 'call', 'to', 'boycott', 'British', 'lamb', '.']\n[3, 0, 7, 0, 0, 0, 7, 0, 0]\n[3, 0, 3, 0, 0, 0, 5, 7, 0]\n{'O': 0, 'B-PERSON': 1, 'I-PERSON': 2, 'B-ORGANIZATION': 3, 'I-ORGANIZATION': 4, 'B-LOCATION': 5, 'I-LOCATION': 6, 'B-MISCELLANEOUS': 7, 'I-MISCELLANEOUS': 8}\n</code></pre> <pre><code>def flatten_list(list_):\n    ret = []\n    for sublist in list_:\n        ret.extend(sublist)\n    return ret\n\n\nreferences = flatten_list(references)\npredictions = flatten_list(predictions)\nreferences = np.array(references)\npredictions = np.array(predictions)\n</code></pre> <pre><code>from sklearn.metrics import f1_score\n</code></pre> <p>We will use the F1 score to report the results.</p> <pre><code>table = Table(title=f\"Results\")\n\ntable.add_column(\"Class\")\ntable.add_column(\"F1\")\ntable.add_column(\"Nb samples\", justify=\"center\")\n\nfor class_name, class_value in NER_TAGS_ONTOLOGY.items():\n    y_true = np.where(references == class_value, 1, 0)\n    y_pred = np.where(predictions == class_value, 1, 0)\n    table.add_row(\n        class_name,\n        f\"{f1_score(y_true, y_pred) * 100:6.1f}%\",\n        f\"{y_true.sum():3d}\",\n        end_section=True,\n    )\n\n# Group tokens regardless of their positions in the entities\nNER_TAGS_ONTOLOGY_GROUPED = {\n    \"PERSON\": (1, 2),\n    \"ORGANIZATION\": (3, 4),\n    \"LOCATION\": (5, 6),\n    \"MISCELLANEOUS\": (7, 8),\n}\nfor class_name, class_values in NER_TAGS_ONTOLOGY_GROUPED.items():\n    y_true = np.where((references == class_values[0]) | (references == class_values[1]), 1, 0)\n    y_pred = np.where((predictions == class_values[0]) | (predictions == class_values[1]), 1, 0)\n    table.add_row(\n        class_name,\n        f\"{f1_score(y_true, y_pred) * 100:6.1f}%\",\n        f\"{y_true.sum():3d}\",\n        style=\"bold green\",\n        end_section=True,\n    )\n\n\ntable.add_row(\n    \"All\",\n    f\"{f1_score(references, predictions, average='weighted') * 100:6.1f}%\",\n    f\"{len(references):3d}\",\n    style=f\"bold bright_red\",\n)\n</code></pre> <pre><code>console = Console()\nconsole.print(table)\n</code></pre> <pre>                 Results                  \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Class           \u2503 F1      \u2503 Nb samples \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 O               \u2502   93.4% \u2502    468     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-PERSON        \u2502   90.9% \u2502     12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-PERSON        \u2502  100.0% \u2502     10     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-ORGANIZATION  \u2502   58.8% \u2502     12     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-ORGANIZATION  \u2502   44.4% \u2502      8     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-LOCATION      \u2502   71.4% \u2502     14     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-LOCATION      \u2502    0.0% \u2502      0     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 B-MISCELLANEOUS \u2502   10.3% \u2502     15     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 I-MISCELLANEOUS \u2502   31.2% \u2502      5     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PERSON          \u2502   95.2% \u2502     22     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ORGANIZATION    \u2502   53.8% \u2502     20     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 LOCATION        \u2502   71.4% \u2502     14     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MISCELLANEOUS   \u2502   19.7% \u2502     20     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 All             \u2502   88.6% \u2502    544     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <p>Quite good!</p> <p>As we can see, the pre-annotations are not perfect, but the LLM seems to be able to generate pre-annotations that are good enough to help us speed up the labelling process in future projects.</p>"},{"location":"sdk/tutorials/ner_pre_annotations_openai/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we have seen how to use the OpenAI API to generate pre-annotations for a dataset. We have also seen how to import the data and the pre-annotations to a Kili project, and how to evaluate the quality of these pre-annotations.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/","title":"OCR Pre-annotations","text":""},{"location":"sdk/tutorials/ocr_pre_annotations/#how-to-import-ocr-pre-annotations","title":"How to import OCR pre-annotations","text":"<p>In this tutorial we will see how to import OCR pre-annotations in Kili using Google vision API.</p> <p>Pre-annotating your data with OCR will save you a lot of time when annotating transcriptions in Kili.</p> <p>The data that we use comes from The Street View Text Dataset.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/#loading-an-image-from-the-street-view-dataset-in-kili","title":"Loading an image from The Street View Dataset in Kili","text":"<p>Follow this link to get the image for this tutorial:</p> <p></p> <p>We will use the Google Vision API to perform Optical Character Recognition on the different inscriptions in this image.</p> <p>To use the google API, we need to install some packages:</p> <pre><code>%pip install google-cloud google-cloud-vision Pillow kili google-cloud-storage wget\n</code></pre> <pre><code>import getpass\nimport io\nimport json\nimport os\n\nimport wget\nfrom google.cloud import vision\nfrom google.oauth2 import service_account\nfrom PIL import Image\n\nfrom kili.client import Kili\n</code></pre> <p>We can now create the project ontology (json interface).</p> <p>For a transcription task on images, the ontology is a classification job with nested transcriptions for each category:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {  # this job is for annotating the bounding boxes\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"rectangle\"],\n            \"instruction\": \"Categories\",\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\n                    \"STORE_INFORMATIONS\": {\"name\": \"Store informations\", \"children\": [\"JOB_1\"]},\n                    \"PRODUCTS\": {\"name\": \"Products\", \"children\": [\"JOB_2\"]},\n                },\n                \"input\": \"radio\",\n            },\n        },\n        \"JOB_1\": {\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"instruction\": \"Transcription of store informations\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n        \"JOB_2\": {\n            \"mlTask\": \"TRANSCRIPTION\",\n            \"instruction\": \"Transcription of products\",\n            \"required\": 1,\n            \"isChild\": True,\n        },\n    }\n}\n</code></pre> <p>Let's initialize the Kili client and create our project:</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n\nkili = Kili(api_key=KILI_API_KEY)\n\n# Create an OCR project\nproject = kili.create_project(\n    description=\"OCR street view\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n    title=\"Street text annotation\",\n)\nproject_id = project[\"id\"]\n</code></pre>"},{"location":"sdk/tutorials/ocr_pre_annotations/#creating-ocr-annotations-using-google-vision-api","title":"Creating OCR annotations using Google Vision API","text":"<p>We will now see how to perform OCR preannotation on our image using Google Vision API.</p> <p>First you will need to create an account on Google Cloud:</p> <ol> <li>create a project (or use an existing one)</li> <li>then go to the Cloud Vision API page</li> <li>activate the API for your project</li> </ol> <p>Now that the API is activated we will need to get a secret key in order to call the API later in our project:</p> <ol> <li>go to API and services page</li> <li>and create a service account with authorization to use the vision API</li> </ol> <p>On the service account details page:</p> <ol> <li>click on add a key</li> <li>download the key using json format</li> <li>place the key in your environment variables or in a file</li> </ol> <pre><code>google_key_str = os.getenv(\"KILI_API_CLOUD_VISION\")\n\nif not google_key_str:\n    path_to_json_key = \"./google_cloud_key.json\"\n    with open(path_to_json_key) as file:\n        google_key_str = file.read()\n\nGOOGLE_KEY = json.loads(google_key_str)\n\nassert GOOGLE_KEY\n</code></pre> <p>We can now start adding OCR pre-annotations to the asset metadata:</p> <pre><code>def implicit():\n    from google.cloud import storage\n\n    # If you don't specify credentials when constructing the client, the\n    # client library will look for credentials in the environment.\n    storage_client = storage.Client()\n\n    # Make an authenticated API request\n    buckets = list(storage_client.list_buckets())\n    print(buckets)\n</code></pre> <pre><code>def detect_text(path):\n\"\"\"Detects text in the file.\"\"\"\n    credentials = service_account.Credentials.from_service_account_info(GOOGLE_KEY)\n    client = vision.ImageAnnotatorClient(credentials=credentials)\n\n    with open(path, \"rb\") as image_file:\n        content = image_file.read()\n\n    response = client.text_detection({\"content\": content})\n    texts = response._pb.text_annotations\n    text_annotations = []\n\n    for text in texts:\n        vertices = [{\"x\": vertex.x, \"y\": vertex.y} for vertex in text.bounding_poly.vertices]\n\n        tmp = {\n            \"description\": text.description,\n            \"boundingPoly\": {\n                \"vertices\": vertices,\n            },\n        }\n\n        text_annotations.append(tmp)\n\n    if response.error.message:\n        raise Exception(\n            \"{}\\nFor more info on error messages, check: \"\n            \"https://cloud.google.com/apis/design/errors\".format(response.error.message)\n        )\n\n    return text_annotations\n</code></pre> <pre><code>PATH_TO_IMG = wget.download(\n    \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/store_front.jpeg\"\n)\n</code></pre> <pre><code>text_annotations = detect_text(PATH_TO_IMG)\nassert len(text_annotations) &gt; 0\nprint(f\"Found {len(text_annotations)} boxes of text.\")\nprint(text_annotations[0])\n</code></pre> <pre><code>Found 22 boxes of text.\n{'description': \"CD\\nITALIAN $1\\nESPRESSO Shot\\nplus tax\\nFINE ITALIAN\\nIMPORTS &amp; DELI\\nJIM\\nIMMY'S FRESH MEATS\\nSAUSAGES\\nFOOD STORE\\nIX\", 'boundingPoly': {'vertices': [{'x': 24, 'y': 6}, {'x': 1668, 'y': 6}, {'x': 1668, 'y': 553}, {'x': 24, 'y': 553}]}}\n</code></pre> <pre><code>im = Image.open(PATH_TO_IMG)\nIMG_WIDTH, IMG_HEIGHT = im.size\nprint(im.size)\n</code></pre> <pre><code>(1680, 1050)\n</code></pre> <p>We now need to convert the OCR predictions to the Kili asset metadata format:</p> <pre><code>full_text_annotations = {\n    \"fullTextAnnotation\": {\n        \"pages\": [{\"height\": IMG_HEIGHT, \"width\": IMG_WIDTH}],\n    },\n    \"textAnnotations\": text_annotations,\n}\n</code></pre> <p>We follow the Google Vision API <code>AnnotateImageResponse</code> format. So in the end, the OCR data to insert into Kili as a JSON metadata contains:</p> <ul> <li>Full text annotation. A list of pages in the document with their respective heights and widths.</li> <li>A list of text annotations with:<ul> <li>text content</li> <li>bounding box coordinates.</li> </ul> </li> </ul> <pre><code>{\n\"fullTextAnnotation\": { \"pages\": [{ \"height\": 914, \"width\": 813 }] },\n\"textAnnotations\": [\n{\n\"description\": \"7SB75\",\n\"boundingPoly\": {\n\"vertices\": [\n{ \"x\": 536, \"y\": 259 },\n{ \"x\": 529, \"y\": 514 },\n{ \"x\": 449, \"y\": 512 },\n{ \"x\": 456, \"y\": 257 }\n]\n}\n},\n{\n\"description\": \"09TGG\",\n\"boundingPoly\": {\n\"vertices\": [\n{ \"x\": 436, \"y\": 256 },\n{ \"x\": 435, \"y\": 515 },\n{ \"x\": 360, \"y\": 515 },\n{ \"x\": 361, \"y\": 256 }\n]\n}\n}\n]\n}\n</code></pre> <p>Let's upload the asset with its pre-annotations to Kili:</p> <pre><code>external_id = \"store\"\ncontent = PATH_TO_IMG\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[content],\n    external_id_array=[external_id],\n    json_metadata_array=[full_text_annotations],\n)\n</code></pre>"},{"location":"sdk/tutorials/ocr_pre_annotations/#annotate-in-kili","title":"Annotate in Kili","text":"<p>You can now annotate your images and you will see the text automatically extracted:</p> <p></p> <p>Congrats! \ud83d\udc4f</p> <p>Pre-annotating your assets can save you a significant amount of time and improve the accuracy of your labeling \u23f3\ud83c\udfaf.</p>"},{"location":"sdk/tutorials/ocr_pre_annotations/#cleanup","title":"Cleanup","text":"<p>To clean up, we simply need to remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/pixel_level_masks/","title":"Segmentation Pre-annotations","text":""},{"location":"sdk/tutorials/pixel_level_masks/#how-to-import-segmentation-pre-annotations","title":"How to import segmentation pre-annotations","text":"<p>In this tutorial, we will show you how to import prediction labels into your Kili project.</p> <p>You will see these predictions as pre-annotations in your labeling interface, and you will be able to modify or validate them.</p> <p>We will discover this feature on a segmentation project that is used to work with images or videos with pixel-level annotations.</p> <p>The data used in this tutorial is from the COCO dataset.</p>"},{"location":"sdk/tutorials/pixel_level_masks/#import-an-image-into-your-kili-project","title":"Import an image into your Kili project","text":"<p>Let's first inspect what our annotated image looks like in the COCO dataset.</p> Raw image With the annotations <p>Before starting, we install the requirements:</p> <pre><code>%pip install matplotlib Pillow kili opencv-python\n</code></pre> <pre><code>%matplotlib inline\n\nimport functools\nimport getpass\nimport json\nimport os\nimport time\nimport urllib.request\nfrom random import randint\n\nimport cv2\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport requests\nfrom PIL import Image\n\nfrom kili.client import Kili\n</code></pre> <p>Let's authenticate to Kili:</p> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n\nkili = Kili(api_key=KILI_API_KEY)\n</code></pre> <p>Let's create an image project in Kili where we can annotate images with a <code>semantic</code> tool and two classes: <code>HUMAN</code> and <code>MOTORCYCLE</code> at pixel level.</p> <p>We create the image project with its ontology (json_interface):</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"tools\": [\"semantic\"],\n            \"instruction\": None,\n            \"required\": 1,\n            \"isChild\": False,\n            \"content\": {\n                \"categories\": {\n                    \"MOTORCYCLE\": {\"name\": \"Motorcycle\", \"children\": [], \"color\": \"#0755FF\"},\n                    \"HUMAN\": {\"name\": \"Human\", \"children\": [], \"color\": \"#EEBA00\"},\n                },\n                \"input\": \"radio\",\n            },\n        }\n    }\n}\n</code></pre> <pre><code>project = kili.create_project(\n    description=\"COCO dataset\",\n    input_type=\"IMAGE\",\n    json_interface=json_interface,\n    title=\"Motorcycle annotation\",\n)\n\nproject_id = project[\"id\"]\n</code></pre> <p>Then, we upload the image to the project:</p> <pre><code>external_id = \"moto\"\ncontent = \"https://farm7.staticflickr.com/6153/6181981748_6a225c275d_z.jpg\"\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=[content],\n    external_id_array=[external_id],\n    json_content_array=None,\n);\n</code></pre> <p>You should now be able to visualize your asset in Kili:</p> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#import-annotations-from-a-mask","title":"Import annotations from a mask","text":"<p>Now, imagine you already have your annotation stored as a mask. You want to insert it in Kili Technology as a prediction. Here is what the mask looks like:</p> <p></p> <p>We can start by downloading the image on disk:</p> <pre><code>mask_url = \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/img/HUMAN.mask.png\"\nurllib.request.urlretrieve(mask_url, \"mask.png\");\n</code></pre> <p>Kili SDK provides a set of utils to easily create labels. See the documentation for more information.</p> <p>Now, we will use the <code>mask_to_normalized_vertices</code> helper method to create a segmentation label from the mask image.</p> <pre><code>from kili.utils.labels.image import mask_to_normalized_vertices\n</code></pre> <pre><code>mask = cv2.imread(\"mask.png\")[:, :, 0]\ncontours, _ = mask_to_normalized_vertices(mask)\nprint(f\"Found {len(contours)} contour(s) in the mask.\")\n</code></pre> <pre><code>Found 1 contour(s) in the mask.\n</code></pre> <pre><code>annotations = [\n    {\n        \"boundingPoly\": [{\"normalizedVertices\": contour} for contour in contours],\n        \"categories\": [{\"name\": \"HUMAN\", \"confidence\": 100}],\n        \"mid\": randint(100, 1000),\n        \"score\": None,\n        \"type\": \"polygon\",\n    }\n]\njson_response = {\"JOB_0\": {\"annotations\": annotations}}\n</code></pre> <pre><code>kili.create_predictions(\n    project_id=project_id,\n    external_id_array=[external_id],\n    json_response_array=[json_response],\n    model_name=\"original_mask\",\n)\n</code></pre> <pre><code>{'id': 'clfql5ikf01zz0jsxaxohccnx'}\n</code></pre> <p>That's it! Your mask was just converted to Kili Technology's standard format and uploaded as a prediction to the platform:</p> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#export-the-annotations-as-a-mask","title":"Export the annotations as a mask","text":"<p>You may want to do the reverse operation, that is download the existing annotation from Kili and convert it to a mask.</p> <p>Let's see how you can achieve this using the helper method <code>normalized_vertices_to_mask</code>!</p> <pre><code>from kili.utils.labels.image import normalized_vertices_to_mask\n</code></pre> <p>Then, we can retrieve the json response and plot the mask:</p> <pre><code>labels = kili.labels(\n    project_id=project_id, asset_external_id_in=[external_id], fields=[\"jsonResponse\"]\n)\nlabel = labels[0]\njson_response = label[\"jsonResponse\"]\nreconstructed_mask = normalized_vertices_to_mask(\n    json_response[\"JOB_0\"][\"annotations\"][0][\"boundingPoly\"][0][\"normalizedVertices\"],\n    mask.shape[1],\n    mask.shape[0],\n)\n\nplt.title(f\"Mask for HUMAN class\")\nplt.imshow(reconstructed_mask, cmap=\"gray\")\nplt.show()\n</code></pre> <p></p>"},{"location":"sdk/tutorials/pixel_level_masks/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/pixel_level_masks/#conclusion","title":"Conclusion","text":"<p>You can now try uploading your own predictions using <code>kili.create_predictions()</code>!</p>"},{"location":"sdk/tutorials/plugins_development/","title":"Developing Plugins","text":""},{"location":"sdk/tutorials/plugins_development/#how-to-develop-and-test-a-kili-plugin","title":"How to develop and test a Kili plugin","text":""},{"location":"sdk/tutorials/plugins_development/#preliminary","title":"Preliminary","text":"<p>This notebook will teach you how to build your first plugin.</p> <p>A plugin is an uploaded Python script triggered by an event that you define.</p> <p>For instance, you can trigger a plugin when a labeler clicks on Submit with the <code>on_submit</code> handler.</p> <p>The plugin should have different methods for the different types of events:</p> <ul> <li><code>on_submit</code></li> <li><code>on_review</code></li> </ul> <p>These methods have a predefined set of parameters:</p> <ul> <li>the <code>label</code> submitted</li> <li>the <code>asset_id</code> of the asset labeled</li> </ul> <p>Some attributes are available in the class:</p> <ul> <li><code>self.kili</code></li> <li><code>self.project_id</code></li> </ul> <p>Therefore, the skeleton of the plugin should look like this:</p> <pre><code>from kili.plugins import PluginCore\nfrom typing import Dict\nimport numpy as np\n\nclass PluginHandler(PluginCore):\n\"\"\"Custom plugin\"\"\"\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Review action\"\"\"\n        # Do something...\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"Dedicated handler for Submit action\"\"\"\n        # Do something...\n</code></pre> <p>Do not hesitate to reach out to us if you need more.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_development/#instantiate-kili","title":"Instantiate Kili","text":"<pre><code>%pip install  kili\n</code></pre> <pre><code>%load_ext autoreload\n%autoreload 2\n\nimport os\n\nfrom kili.client import Kili\n\napi_endpoint = os.getenv(\"KILI_API_ENDPOINT\")\napi_key = os.getenv(\"KILI_API_KEY\")\n\n\nkili = Kili(api_endpoint=api_endpoint, api_key=api_key)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#develop-your-plugin","title":"Develop your plugin","text":"<p>The first step is to define the functions that will be called when the event is triggered. You will be able to iterate on these functions locally (more on that in the next section).</p> <p>The plugin can be defined in two ways: a single <code>.py</code> file with everything inside or a module (folder containing multiple <code>.py</code> files). In the case of the module type, a file named <code>main.py</code> needs to be at the root of the folder and will serve as the entrypoint.</p>"},{"location":"sdk/tutorials/plugins_development/#1-first-option-plugin-defined-in-a-single-file","title":"1. First option - Plugin defined in a single file","text":"<p>This cell should be the contents of the <code>.py</code> file that you will upload as a plugin at the end.</p> <p>This file should define the <code>PluginHandler</code> class that will contain the proper methods.</p> <p>We recommend using a modern IDE like VScode to get type hints and autocompletion on the methods.</p> <pre><code>from typing import Dict\n\nimport numpy as np\n\nfrom kili.plugins import PluginCore\n\n\ndef custom_function(label: Dict):\n    label_id = label.get(\"id\")\n    print(f\"My custom function for review of label with id {label_id}\")\n\n\nclass PluginHandler(PluginCore):\n\"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def custom_method(self, project_id, label_id):\n        print(f\"custom_method called for label {label_id}\")\n        random_seed = np.random.random(1)[0]\n        if random_seed &gt; 0.5:\n            self.logger.warning(\"Generating issue\")\n            # Use kili for actions with self.kili\n            self.kili.create_issues(\n                project_id=project_id,\n                label_id_array=[label_id],\n                text_array=[\"Random issue generated for this label\"],\n            )\n\n    def on_review(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Review action\n        \"\"\"\n        custom_function(label)\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        print(\"On submit called\")\n\n        project_id = self.project_id\n        label_id = label.get(\"id\")\n\n        self.custom_method(project_id, label_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#2-second-option-plugin-defined-in-a-folder","title":"2. Second option - Plugin defined in a folder","text":"<p>As said previously, the structure of the folder can be the following (the only constraint being the presence of the <code>main.py</code> file): <pre><code>plugin_folder\n|__ main.py\n|__ other_file.py\n|__ requirements.txt\n|\n|___helpers\n    |__ helper.py\n</code></pre></p> <p>You can notice that you can also include a <code>requirements.txt</code> file in the folder and the necessary packages will be installed with your plugin. Don't forget to add them, since the plugin could work on your machine if you have them installed, but it won't be possible to create the plugin if there are missing dependencies.</p> <p>Important: The main.py file need to have the same skeleton as the plugin defined in a single file (presence of the class <code>PluginHandler</code>), the difference being that it can import and call functions defined in other files</p> <p>Depending on where the folder is stored, there are two ways to import the plugin in order to test it:</p> <ul> <li>The first way is to use a relative import (having the plugin folder and the notebook in the same folder). It is simpler and we recommend it as it will also allow the IDE to detect the correct methods and propose hints and autocompletion.</li> <li>The second is to use an absolute path to the plugin folder</li> </ul>"},{"location":"sdk/tutorials/plugins_development/#21-relative-import","title":"2.1 Relative import","text":"<pre><code># Here replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#22-absolute-path-import","title":"2.2 Absolute path import","text":"<pre><code>import os\nimport sys\nfrom pathlib import Path\n\n# Input the path to the plugin folder (it should include the folder), for example '/path/to/plugin_folder'\nplugin_path = \"&lt;INSERT PATH TO PLUGIN FOLDER&gt;\"\n\nmodule_path = str(Path(plugin_path).parent.absolute())\n\n# We are inserting the path in the system PATH to be able to import the module in the next line\nsys.path.insert(0, module_path)\n\n# In the next line replace 'plugin_folder' with the actual name of the folder\nfrom plugin_folder.main import PluginHandler\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#testing-the-plugin-locally","title":"Testing the plugin locally","text":"<p>In this we will show you how to test your plugin locally before uploading it.</p> <pre><code>project_id = \"&lt;PROJECT ID&gt;\"\n</code></pre> <p>Instantiate the plugin:</p> <pre><code>my_plugin_instance = PluginHandler(kili, project_id)\n\n\ndef get_label(label_id, project_id):\n\"\"\"\n    Function to get the object Label with the same keys as it will be in the plugin\n    \"\"\"\n    label = list(\n        kili.labels(\n            project_id=project_id,\n            label_id=label_id,\n            fields=[\"id\", \"jsonResponse\", \"author.id\", \"labelType\", \"createdAt\", \"secondsToLabel\"],\n        )\n    )[0]\n\n    label[\"authorId\"] = label[\"author\"][\"id\"]\n    del label[\"author\"]\n    return label\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run","title":"Test the plugin run","text":"<p>If you already have a test project with labels added, you can directly use the IDs of these labels (see the following cell). Otherwise, you can follow the plugins_example.ipynb notebook to create a new project and then upload an asset with an associated label.</p> <pre><code>asset_id = \"&lt;YOUR_ASSET_ID&gt;\"\nlabel_id = \"&lt;YOUR_LABEL_ID&gt;\"\n</code></pre> <pre><code>label = get_label(label_id=label_id, project_id=project_id)\n\nmy_plugin_instance.on_submit(label=label, asset_id=asset_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run-on-kili","title":"Test the plugin run on Kili","text":"<p>When you finish debugging the code, you may want to upload it directly into Kili.</p> <p>Note that you might get an error if the plugin name already exists in your Kili organization.</p> <pre><code>path_to_plugin = \"path/to/my/plugin.py\"\nplugin_name = \"My first kili plugin\"\n</code></pre> <pre><code>from kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(path_to_plugin, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <p>Plugins must be activated in the project that you want them to run in. Be careful with production projects: your custom workflows or rules will also be applied</p> <pre><code>kili.activate_plugin_on_project(plugin_name, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#monitoring-the-plugin","title":"Monitoring the plugin","text":"<p>Plugin creation takes some time (around 5 minutes). The plugin will begin to run only after it's been fully created (if labeling events are to be triggered on this project).</p> <p>Additionally, you can get the logs of the runs:</p> <pre><code>kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name)\n</code></pre> <p>You can set custom date rules for filtering your logs:</p> <pre><code>from datetime import date, datetime\n\ndt = date.today()  # You can change this date if needed\nstart_date = datetime.combine(dt, datetime.min.time())\n\nkili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n</code></pre>"},{"location":"sdk/tutorials/plugins_development/#managing-your-plugin","title":"Managing your plugin","text":"<p>There are several other methods to manage your plugins and their lifecycle. To find out more, check the plugins tutorials.</p>"},{"location":"sdk/tutorials/plugins_example/","title":"Plugin Example - Programmatic QA","text":""},{"location":"sdk/tutorials/plugins_example/#how-to-create-a-plugin-for-programmatic-qa","title":"How to create a plugin for programmatic QA","text":""},{"location":"sdk/tutorials/plugins_example/#context","title":"Context","text":"<p>This notebook is an end-to-end example that you can follow to: create a project, upload a first plugin and activate it on this project, and finally start monitoring it.</p> <p>NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/plugins_example/#step-1-instantiate-kili","title":"Step 1: Instantiate Kili","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-2-create-the-project","title":"Step 2: Create the project","text":"<p>First, we need to create a new project. In our example, we will use an <code>IMAGE</code> type project with the following <code>jsonInterace</code>:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\n                        \"children\": [],\n                        \"name\": \"Object A\",\n                        \"color\": \"#733AFB\",\n                        \"id\": \"category1\",\n                    },\n                    \"OBJECT_B\": {\n                        \"children\": [],\n                        \"name\": \"Object B\",\n                        \"color\": \"#3CD876\",\n                        \"id\": \"category2\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n</code></pre> <pre><code>title = \"Plugins test project\"\ndescription = \"My first project with a plugin\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n\nprint(f\"Created project {project_id}\")\n</code></pre> <p>Upload an asset:</p> <pre><code>content_array = [\"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"]\nnames_array = [\"landscape\"]\n\nkili.append_many_to_dataset(\n    project_id=project_id, content_array=content_array, external_id_array=names_array\n)\n\nasset_id = kili.assets(project_id=project_id, fields=[\"id\"], disable_tqdm=True)[0][\"id\"]\n</code></pre> <p>This project has one job of bounding box creation with two categories.</p> <p>With our plugin, we want to make sure that the labelers don't create more than one bounding box of category A.</p> <p>To iterate on the plugin code, you can refer to the plugins_development.ipynb notebook.</p>"},{"location":"sdk/tutorials/plugins_example/#step-3-write-the-plugin","title":"Step 3: Write the plugin","text":"<pre><code>from kili.plugins import PluginCore\nfrom typing import Dict, List, Optional\n\ndef check_rules_on_label(label: Dict) -&gt; List[Optional[str]]:\n    #custom methods\n    print('Custom method - checking number of bboxes')\n\n    counter = 0\n    for annotation in label['jsonResponse'][\"JOB_0\"][\"annotations\"]:\n        if annotation[\"categories\"][0][\"name\"] == \"OBJECT_A\":\n            counter += 1\n\n    if counter &lt;= 1:\n        return []\n    return [f\"There are too many BBox ({counter}) - Only 1 BBox of Object A accepted\"]\n\n\nclass PluginHandler(PluginCore):\n\"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        self.logger.info(\"On submit called\")\n\n        issues_array = check_rules_on_label(label)\n\n        project_id = self.project_id\n\n        if len(issues_array) &gt; 0:\n            print(\"Creating an issue...\")\n\n            self.kili.create_issues(\n                project_id=project_id,\n                label_id_array=[label['id']] * len(issues_array),\n                text_array=issues_array,\n            )\n\n            print(\"Issue created!\")\n\n            self.kili.send_back_to_queue(asset_ids=[asset_id])\n</code></pre> <pre><code>import urllib.request\nfrom pathlib import Path\n\nplugin_folder = \"plugin_folder\"\n\nPath(plugin_folder).mkdir(parents=True, exist_ok=True)\nurllib.request.urlretrieve(\n    \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/main/recipes/plugins_library/plugin_image.py\",\n    \"plugin_folder/main.py\",\n)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-upload-the-plugin-from-a-folder","title":"Step 4: Upload the plugin from a folder","text":"<p>With the plugin defined in a separate <code>Python</code> file, you can create a folder containing:</p> <ul> <li>A <code>main.py</code> file which is the entrypoint of the plugin and must have a <code>PluginHandler</code> class which implements a <code>PluginCore</code> class</li> <li>(optionally) a <code>requirements.txt</code> (if you need specific PyPi packages in your plugin)</li> </ul> <pre><code>folder/\n     main.py\n     requirements.txt\n</code></pre> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <p>Here is an example of a <code>requirements.txt</code> file: numpy scikit-learn pandas==1.5.1 git+https://github.com/yzhao062/pyod.git</p> <pre><code>requirements_path = Path(plugin_folder) / \"requirements.txt\"\n\npackages_list = [\n    \"numpy\\n\",\n    \"scikit-learn\\n\",\n    \"pandas==1.5.1\\n\",\n    \"git+https://github.com/yzhao062/pyod.git\\n\",\n]\n\nwith requirements_path.open(\"w\") as f:\n    f.writelines(packages_list)\n</code></pre> <pre><code>plugin_name = \"Plugin bbox count\"\nfrom kili.exceptions import GraphQLError\n\ntry:\n    kili.upload_plugin(plugin_folder, plugin_name)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=plugin_name, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-4-bis-upload-the-plugin-from-a-py-file","title":"Step 4 bis: Upload the plugin from a .py file","text":"<p>Alternatively, you can also create a plugin directly from a <code>.py</code> file.</p> <ul> <li>The upload will create the necessary builds to execute the plugin (it will take a few minutes)</li> <li>After the activation, you can start using your plugin right away.</li> </ul> <pre><code>path_to_plugin = Path(plugin_folder) / \"main.py\"\nplugin_name_file = \"Plugin bbox count - file\"\n\ntry:\n    kili.upload_plugin(str(path_to_plugin), plugin_name_file)\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=plugin_name_file, project_id=project_id)\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-5-plugin-in-action","title":"Step 5: Plugin in action","text":"<p>Wait for the plugin to be successfully deployed.</p> <p>After that, you can test it by labelling in the Kili interface or just by uploading the following label.</p> <p>When you add the label that contains errors, you will see a new issue automatically created in the Kili app.</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.79, \"y\": 0.20},\n                            {\"x\": 0.79, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.20},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161456406-47055\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.87, \"y\": 0.36},\n                            {\"x\": 0.87, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.36},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161459298-45160\",\n                \"type\": \"rectangle\",\n            },\n        ]\n    }\n}\n</code></pre> <pre><code>kili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n</code></pre> <p>If you use the base plugin provided, the plugin should:</p> <ul> <li>Create an issue with information that three bboxes were found, instead of one</li> <li>Send the asset back to the labeling queue (status <code>ONGOING</code>)</li> </ul> <pre><code>print(\n    kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\", \"issues.comments.text\"])\n)\n\nprint(\n    f\"Go to my project: {kili.api_endpoint.split('/api')[0]}/label/projects/{project_id}/menu/queue\"\n)\n</code></pre> <p>Woah! Amazing! Well done :) \ud83d\ude80</p> <p>Let's test now to post a proper label, this one for example:</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\nkili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n\nprint(kili.assets(project_id=project_id, asset_id=asset_id, fields=[\"status\"]))\n\nprint(\n    f\"Go to my project: {kili.api_endpoint.split('/api')[0]}/label/projects/{project_id}/menu/queue\"\n)\n</code></pre> <p>The status of your asset should have now changed to <code>LABELED</code>. In this plugin, previous issues remain but you can solve them through the API as well.</p> <p>Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins development tutorial.</p>"},{"location":"sdk/tutorials/plugins_example/#step-6-monitor-the-plugin","title":"Step 6: Monitor the plugin","text":"<p>To monitor a certain plugin, you can get its logs by using the following command:</p> <pre><code>import json\nfrom datetime import date, datetime\n\ndt = (\n    date.today()\n)  # You can change this date if needed, or omit it to set it at the plugin creation date\nstart_date = datetime.combine(dt, datetime.min.time())\n\nlogs = kili.get_plugin_logs(project_id=project_id, plugin_name=plugin_name, start_date=start_date)\n\nlogs_json = json.loads(logs)\nprint(json.dumps(logs_json, indent=4))\n</code></pre>"},{"location":"sdk/tutorials/plugins_example/#step-7-manage-the-plugin","title":"Step 7: Manage the plugin","text":"<p>You also have several other methods to manage your plugins.</p> <p>Get the list of all uploaded plugins in your organization:</p> <pre><code>plugins = kili.list_plugins()\n</code></pre> <p>Update a plugin with new source code:</p> <pre><code># Insert the path to the updated plugin\nnew_path_to_plugin = Path(plugin_folder) / \"main.py\"\n\n# Change to True if you want to update the plugin\nshould_update = False\n\nif should_update:\n    kili.update_plugin(plugin_name=plugin_name, plugin_path=str(new_path_to_plugin))\n</code></pre> <p>Deactivate the plugin on a certain project (the plugin can still be active for other projects):</p> <pre><code>kili.deactivate_plugin_on_project(plugin_name=plugin_name, project_id=project_id);\n</code></pre> <p>Delete the plugin completely (deactivates the plugin from all projects):</p> <pre><code>if delete_plugin_from_org:\n    kili.delete_plugin(plugin_name=plugin_name)\n</code></pre>"},{"location":"sdk/tutorials/plugins_library/","title":"Plugins library","text":""},{"location":"sdk/tutorials/plugins_library/#context","title":"Context","text":"<p>In this section you can find multiple examples of use-cases where our system of plugins can help you in the Kili projects.</p> <p>You can also refer to our tutorial to develop your plugin and iterate on it locally, before uploading the final version to Kili.</p> <p>For further information concerning the Kili plugins, refer to the Reference page</p>"},{"location":"sdk/tutorials/plugins_library/#library-of-pre-built-plugins","title":"Library of pre-built plugins","text":"<p>In the folder <code>plugins_library</code> you can find multiple examples of plugins that are ready to use in your projects. They can be split in various use-cases:</p>"},{"location":"sdk/tutorials/plugins_library/#1-programmatic-qa","title":"1. Programmatic QA","text":"<p>One application of plugins is to automate your quality checks: you can directly write your business rules in a Python script and upload them to Kili to have each new label automatically checked.</p>"},{"location":"sdk/tutorials/plugins_library/#11-image-object-detection-example","title":"1.1 Image Object Detection example","text":"<p>Let's imagine a project where we want to process images and detect some objects. One of the jobs is to detect an object and we are sure that in any image of the dataset we can have at most a single object of that type. In order to be sure that we will have only one object in all submitted labels, we can create a plugin that, in case a label has 2 BBoxes for that type of objects, will automatically create an issue with a clear instruction and will send the label back to the queue.</p> <ul> <li>Plugin file: <code>plugin_image.py</code></li> <li>End-to-end notebook showcasing this example: <code>plugins_example.ipynb</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#12-document-processing-example","title":"1.2 Document processing example","text":"<p>Let's imagine another project where we process invoices. The project has two jobs and several transcription tasks associated with them. One of the jobs is about payment information and must contain a proper IBAN number as well as currency. The IBAN must start with FR, and the currency should be one of: EURO or DOLLAR. Kili's interface customization options are powerful and flexible, but won't help us in this specific situation so we have to turn to Kili plugins for help. We'll set up our Kili plugin to check these two rules when labelers click Submit. If the annotations don't match our predefined rules, our QA bot will add issues to the asset and send the asset back to the labeling queue. At the end, our script will calculate labeling accuracy and insert the accuracy metric in the json_metadata of the asset. All that with no need to engage a human reviewer.</p> <ul> <li>Plugin file: <code>plugin_document.py</code></li> <li>End-to-end notebook showcasing this example: <code>plugins_example_document.ipynb</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#2-consensus-resolution","title":"2. Consensus resolution","text":"<p>When working with consensus for object detection tasks, it is often handy for a reviewer to access the annotations of all the labelers involved, compare them and choose the best one. With Kili plugins, this task will be much simpler.</p> <p>For example: you can program your plugin to create an additional annotation that combines the annotations created by all the labelers. This way, you can instantaneously get a big-picture overview and only act when the situation calls for it. In large projects, this can save you a significant amount of time.</p> <ul> <li>Plugin file: <code>plugin_consensus.py</code></li> </ul>"},{"location":"sdk/tutorials/plugins_library/#3-parallel-labeling","title":"3. Parallel labeling","text":"<p>For projects with specialized workforce, you can split your workforce in several groups, with each of them focused on a specific portion of your labeling tasks. For instance, group A (experts in the A domain) only does labeling for job A and group B (experts in the B domain) only does labeling for job B. With Kili Plugins, you could then combine these workflows by aggregating the annotations done by multiple labelers as one label. Your reviewers would then be presented with the combined results.</p> <ul> <li>Plugin file: <code>parallel_labeling_plugin.py</code></li> </ul>"},{"location":"sdk/tutorials/set_up_workflows/","title":"Managing Workflows","text":""},{"location":"sdk/tutorials/set_up_workflows/#how-to-set-up-and-manage-workflows-with-kili","title":"How to set up and manage workflows with Kili","text":"<p>In this tutorial, we will learn how to set up basic Kili workflows:</p> <ol> <li>Managing reviews<ol> <li>Placing a specific percentage of project assets in the review queue</li> <li>Placing specific assets in the review queue</li> <li>Sending an asset back to the labeling queue</li> </ol> </li> <li>Setting up consensus<ol> <li>Setting consensus for a specific percentage of project assets</li> <li>Setting consensus for specific assets to compute consensus KPIs</li> </ol> </li> <li>Setting up honeypot</li> <li>Assigning labelers to assets</li> <li>Prioritizing assets in the labeling queue</li> </ol> <p>To work with this notebook, you will have to install and instantiate Kili.</p> <pre><code>%pip install kili\n</code></pre> <pre><code>import getpass\nimport os\n\nfrom kili.client import Kili\n</code></pre> <pre><code>if \"KILI_API_KEY\" not in os.environ:\n    KILI_API_KEY = getpass.getpass(\"Please enter your API key: \")\nelse:\n    KILI_API_KEY = os.environ[\"KILI_API_KEY\"]\n</code></pre> <pre><code>kili = Kili(\n    api_key=KILI_API_KEY,  # not needed if KILI_API_KEY is already in environment variables\n    # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\",\n    # the line above can be uncommented and changed if you are working with an on-premise version of Kili\n)\n</code></pre> <pre><code>project_id = \"&lt;YOUR PROJECT ID&gt;\"\n</code></pre> <p>For information on how to set up a Kili project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#managing-reviews","title":"Managing reviews","text":""},{"location":"sdk/tutorials/set_up_workflows/#placing-a-specific-percentage-of-project-assets-in-the-review-queue","title":"Placing a specific percentage of project assets in the review queue","text":"<p>You can set up the percentage of assets that will automatically appear in the review queue (1-100%).</p> <pre><code>kili.update_properties_in_project(project_id=project_id, review_coverage=50)\n</code></pre> <pre><code>{'id': 'cld95dpne0n2y0joi6wuq3u6v', 'reviewCoverage': 50}\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-consensus","title":"Setting up consensus","text":"<p>Consensus works by having more than one labeler annotate the same asset. When the asset is labeled, a consensus score is calculated to measure the agreement level between the different annotations for a given asset. This is a key measure for controlling label production quality.</p> <p>To set up consensus, you will need to have at least two project members. For information on how to add users and assign them to your project, refer to the basic project setup tutorial.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-a-specific-percentage-of-project-assets","title":"Setting consensus for a specific percentage of project assets","text":"<p>Let's set the percentage of the project dataset that will be annotated several times, to enable consensus calculations. We will also set the minimum number of labelers to label each one of these assets.</p> <pre><code>def set_consensus_coverage(project_id: str, consensus_tot_coverage: int, min_consensus_size: int):\n    kili.update_properties_in_project(\n        project_id=project_id,\n        consensus_tot_coverage=consensus_tot_coverage,\n        min_consensus_size=min_consensus_size,\n    )\n\n\nset_consensus_coverage(project_id=project_id, consensus_tot_coverage=50, min_consensus_size=3)\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-specific-assets-to-compute-consensus-kpis","title":"Setting consensus for specific assets to compute consensus KPIs","text":"<p>You can manually select specific project assets to be used for computing consensus KPIs.</p> <pre><code>def set_assets_for_consensus(project_id: str, external_ids: list):\n    kili.update_properties_in_assets(\n        project_id=project_id,\n        external_ids=external_ids,\n        is_used_for_consensus_array=[True] * len(external_ids),\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nset_assets_for_consensus(project_id=project_id, external_ids=external_ids)\n</code></pre> <p>For more information on consensus, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-honeypot","title":"Setting up honeypot","text":"<p>Honeypot (or gold standard) is a tool for auditing the work of labelers by measuring the accuracy of their annotations. Honeypot works by interspersing assets with defined ground truth label in the annotation queue. This way you can measure the agreement level between your ground truth and the annotations made by labelers.</p> <p>You can manually select specific project assets to be used as honeypots.</p> <pre><code>asset_external_id = \"1.jpg\"\njson_response = {\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}}\n\nkili.create_honeypot(\n    project_id=project_id, asset_external_id=asset_external_id, json_response=json_response\n);\n</code></pre> <p>For more information on honeypot, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#assigning-labelers-to-assets","title":"Assigning labelers to assets","text":"<p>You can assign specific labelers to specific assets in your project. You can do that by assigning users' emails to the selected asset IDs. Remember that you can assign more than one user to a specific asset.</p> <pre><code>def assign_labelers_to_assets(project_id: str, external_ids: list, to_be_labeled_by_array: list):\n    kili.update_properties_in_assets(\n        project_id=project_id,\n        external_ids=external_ids,\n        to_be_labeled_by_array=to_be_labeled_by_array,\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nto_be_labeled_by_array = [\n    [\"example1@example.com\"],\n    [\"example2@example.com\"],\n    [\"example3@example.com\"],\n]\n\nassign_labelers_to_assets(\n    project_id=project_id, external_ids=external_ids, to_be_labeled_by_array=to_be_labeled_by_array\n)\n</code></pre> <p>The <code>to_be_labeled_by_array</code> argument is a list of lists. Each of the sub-lists can contain several e-mails. This way you can assign several labelers to one asset.</p> <p>For example:</p> <p><code>to_be_labeled_by_array = [[\"example1@example.com\"], [\"example1@example.com\", \"example2@example.com\"], [\"example3@example.com\"]]</code></p> <p>For information on how to add users and assign them to your project, refer to the basic project setup tutorial. For information on assigning assets to users, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#prioritizing-assets-in-the-labeling-queue","title":"Prioritizing assets in the labeling queue","text":"<p>If you have certain assets that you need to have labeled earlier or later than the rest, you can use Kili's asset prioritization methods.</p> <pre><code>def set_priority_for_assets(project_id: str, external_ids: list, priorities: list):\n    kili.update_properties_in_assets(\n        project_id=project_id, external_ids=external_ids, priorities=priorities\n    )\n\n\nexternal_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\npriorities = [1, 5, 10]\nset_priority_for_assets(project_id=project_id, external_ids=external_ids, priorities=priorities)\n</code></pre> <p>For information on setting asset priorities, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#placing-specific-assets-in-the-review-queue","title":"Placing specific assets in the review queue","text":"<p>When done with your basic workflow setup, you can place specific, labeled assets in the review queue. As this requires the assets to be labeled, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs.</p> <pre><code>json_response_array = [\n    {\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}} for i in range(3)\n]\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    json_response_array=json_response_array,\n    label_type=\"DEFAULT\",\n)\n</code></pre> <pre><code>[{'id': 'cld95duf80o3k0jpa5f8bdolk'},\n {'id': 'cld95duf80o3l0jpa6tkv947s'},\n {'id': 'cld95duf90o3m0jpaccwo0awt'}]\n</code></pre> <p>Now, let's place some assets in the review queue. The method will return a project ID and a list of asset IDs placed in the review queue.</p> <pre><code>external_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nkili.add_to_review(project_id=project_id, external_ids=external_ids)\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#sending-an-asset-back-to-the-labeling-queue","title":"Sending an asset back to the labeling queue","text":"<p>You can also send specific labeled assets back to the labeling queue. asset_names, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs.</p> <pre><code>json_response_array = [{\"JOB_0\": {\"categories\": [{\"confidence\": 100, \"name\": \"OBJECT_B\"}]}}] * 3\nkili.append_labels(\n    project_id=project_id,\n    asset_external_id_array=[\"1.jpg\", \"2.jpg\", \"3.jpg\"],\n    json_response_array=json_response_array,\n    label_type=\"DEFAULT\",\n)\n</code></pre> <pre><code>[{'id': 'cld95dy130iss0ko864g7c7hr'},\n {'id': 'cld95dy130ist0ko8fgokak6h'},\n {'id': 'cld95dy130isu0ko8gb0s1ckc'}]\n</code></pre> <p>Now, we will send some of our assets back to the labeling queue. The method will return a project ID and a list of asset IDs that were sent back to the labeling queue.</p> <pre><code>external_ids = [\"1.jpg\", \"2.jpg\", \"3.jpg\"]\nkili.send_back_to_queue(project_id=project_id, external_ids=external_ids)\n</code></pre> <pre><code>{'id': 'cld95dpne0n2y0joi6wuq3u6v',\n 'asset_ids': ['cld95dq340006wvszexj8u1uh',\n  'cld95dq340007wvszoxdhet57',\n  'cld95dq340008wvszveinxcy2']}\n</code></pre> <p>For more information on asset statuses, refer to our documentation.</p>"},{"location":"sdk/tutorials/set_up_workflows/#cleanup","title":"Cleanup","text":"<p>We can remove the project that we created:</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/set_up_workflows/#summary","title":"Summary","text":"<p>Done!</p> <p>We have learned how to handle the review workflow, set up consensus and honeypot in a project, assign specific labelers to specific assets, and how to prioritize assets in the labeling queue.</p>"},{"location":"sdk/tutorials/tagtog_to_kili/","title":"Converting Tagtog Labels","text":""},{"location":"sdk/tutorials/tagtog_to_kili/#how-to-convert-a-tagtog-project-to-kili","title":"How to convert a Tagtog project to Kili","text":""},{"location":"sdk/tutorials/tagtog_to_kili/#setup","title":"Setup","text":"<pre><code>%pip install kili rich beautifulsoup4\n</code></pre> <pre><code>import json\nimport os\nimport pprint\nfrom pathlib import Path\n\nfrom bs4 import BeautifulSoup\nfrom rich import print_json\n\nfrom kili.client import Kili\n</code></pre> <pre><code>kili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/tagtog_to_kili/#get-data","title":"Get data","text":"<p>For this recipe, we will use data from the Apartment reviews project made by Jennifer D. Ames.</p> <p>The dataset consists in guests' reviews of apartments/houses for short-term lodging and tourism-related activities. The reviews have been obtained from Inside Airbnb. Each review has been manually annotated in tagtog.</p> <p>To download the project data, it is required to be logged in to tagtog. Then, you can download the project data.</p> <p>Once the .zip file is downloaded, we can unzip it:</p> <pre><code>!tar -xvf tagtog_ApartmentReviews.zip\n</code></pre> <pre><code>print(Path(\"ApartmentReviews/README.md\").read_text(encoding=\"utf-8\"))\n</code></pre> <pre><code>This dataset lives in: https://tagtog.com/JaqenNLP/ApartmentReviews\n\nThis zip was generated with:\n  * date: _2023-05-10T11:25:54.902Z_\n  * search: `*`\n  * total found documents: **228**\n\nThe dataset is here written in the [anndoc format](https://docs.tagtog.com/anndoc.html). Use the `annotations-legend.json` file to help you interpret the annotations.\n\n\nWhat great things will you do with the dataset? :-) Enjoy!\n</code></pre> <p>Let's take a look at the ontology:</p> <pre><code>tagtog_class_id_to_class_name = json.loads(\n    Path(\"ApartmentReviews/annotations-legend.json\").read_text(encoding=\"utf-8\")\n)\npprint.pprint(tagtog_class_id_to_class_name)\n</code></pre> <pre><code>{'e_1': 'Loyalty',\n 'e_13': 'TechOpinion',\n 'e_14': 'FoodOpinion',\n 'e_2': 'RoomOpinion',\n 'e_4': 'ApartmentOpinion',\n 'e_5': 'Location',\n 'e_6': 'KitchenOpinion',\n 'e_7': 'BathroomOpinion',\n 'e_8': 'HostOpinion',\n 'e_9': 'PricePayment',\n 'f_10': 'RoomItem',\n 'f_11': 'OutdoorFeature',\n 'f_12': 'BathroomFeature',\n 'f_15': 'TechFeature',\n 'f_16': 'FoodFeature',\n 'f_17': 'LocationFeature',\n 'f_19': 'LoyaltyFeature',\n 'f_20': 'ApartmentFeature',\n 'f_21': 'HostCharacter',\n 'f_22': 'isLocationQuiet',\n 'f_23': 'Sentiment',\n 'f_24': 'isCriticalProblem',\n 'f_25': 'KitchenFeature',\n 'f_26': 'PaymentFeature',\n 'm_18': 'Sentiment'}\n</code></pre> <p>The ontology shows:</p> <ul> <li>10 entity types (keys starting with <code>e_</code>)</li> </ul> <p></p> <ul> <li>1 document label (key starting with <code>m_</code>)</li> </ul> <p></p> <ul> <li>14 entity labels (keys starting with <code>f_</code>)</li> </ul> <p></p> <p>An entity label is used to tag an entity type, and aims at giving more information about the entity being annotated. For example, the <code>\"f_17\": \"LocationFeature\"</code> label can be used to tag a <code>\"e_5\": \"Location\"</code> entity type.</p> <p>Read more about this project ontology here.</p> <p>The <code>plain.html/pool</code> folder contains the reviews in HTML format:</p> <pre><code>print(\n    Path(\"ApartmentReviews/plain.html/pool/a.km05GoV2Uh1mw9QR.UNiNXWUL8-text.plain.html\").read_text(\n        encoding=\"utf-8\"\n    )\n)\n</code></pre> <pre><code>&lt;!DOCTYPE html &gt;\n&lt;html id=\"a.km05GoV2Uh1mw9QR.UNiNXWUL8-text\" data-origid=\"text\" class=\"anndoc\" data-anndoc-version=\"3.6\" lang=\"\" xml:lang=\"\" xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;meta name=\"generator\" content=\"net.tagtog.anndoc.v3.parsers.general.PlainTextParser_NewParagraphAfter1Newline_v2_0_0\"/&gt;\n    &lt;title&gt;a.km05GoV2Uh1mw9QR.UNiNXWUL8-text&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;article&gt;\n      &lt;section data-type=\"\"&gt;\n        &lt;div class=\"content\"&gt;\n          &lt;p id=\"s1p1\"&gt;The house is beautiful, but it is next to 2 very busy roads. There are no aircons in any rooms and to open the windows you hear the cars and trucks pass - very loud. There is no braai facilities and when we asked x 2 we were told the owner had to approve... still waiting! The rooms on the lower floor is empty and depressing, very hot! Kids slept on couches with sliding doors open, so we could not arm the alarm at night. The aircons on the upper level leaks water onto table and electrical wires. I think it is over priced, for that price the basics should be in place. AIRCONS AND BRAAI&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/section&gt;\n    &lt;/article&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The annotations are stored in the folder <code>ann.json/master/pool</code>:</p> <pre><code>annotation_sample = json.loads(\n    Path(\n        \"ApartmentReviews/ann.json/master/pool/a.km05GoV2Uh1mw9QR.UNiNXWUL8-text.ann.json\"\n    ).read_text(encoding=\"utf-8\")\n)\n# select only two entities for visualization\nannotation_sample[\"entities\"] = annotation_sample[\"entities\"][:2]\npprint.pprint(annotation_sample)\n</code></pre> <pre><code>{'anncomplete': True,\n 'annotatable': {'parts': ['s1p1']},\n 'entities': [{'classId': 'e_4',\n               'confidence': {'prob': 1,\n                              'state': 'pre-added',\n                              'who': ['user:Mrdenho']},\n               'coordinates': [],\n               'fields': {'f_23': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': 'positive'}},\n               'normalizations': {},\n               'offsets': [{'start': 0, 'text': 'The house is beautiful'}],\n               'part': 's1p1'},\n              {'classId': 'e_5',\n               'confidence': {'prob': 1,\n                              'state': 'pre-added',\n                              'who': ['user:Mrdenho']},\n               'coordinates': [],\n               'fields': {'f_22': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': False},\n                          'f_23': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': 'negative'},\n                          'f_24': {'confidence': {'prob': 1,\n                                                  'state': 'pre-added',\n                                                  'who': ['user:Mrdenho']},\n                                   'value': True}},\n               'normalizations': {},\n               'offsets': [{'start': 24,\n                            'text': 'but it is next to 2 very busy roads'}],\n               'part': 's1p1'}],\n 'metas': {'m_18': {'confidence': {'prob': 1,\n                                   'state': 'pre-added',\n                                   'who': ['user:Mrdenho']},\n                    'value': 'negative'}},\n 'relations': [],\n 'sources': []}\n</code></pre>"},{"location":"sdk/tutorials/tagtog_to_kili/#create-the-kili-project","title":"Create the Kili project","text":"<p>We can start creating the Named Entity Recognition (NER) Kili project.</p> <p>To do so, we will need to define a json interface that follows the ontology of the <code>annotations-legend.json</code> file.</p> <p>Note that with Kili, the json interface can be created directly from the Kili UI.</p> <p>Here, we will use a <code>json_interface</code> variable that will be passed to <code>kili.create_project()</code>.</p> <p>We have two main jobs:</p> <ul> <li><code>SENTIMENT_CLASSIFICATION_JOB</code> for classifying the review as positive, negative or neutral</li> <li><code>NAMED_ENTITIES_RECOGNITION_JOB</code> for the entity type.</li> </ul> <p>We also have several child jobs representing the entity labels.</p> <pre><code># fmt: off\njson_interface = {\n    \"jobs\": {\n        \"SENTIMENT_CLASSIFICATION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"positive\": {\"children\": [], \"name\": \"positive\"},\n                    \"neutral\": {\"children\": [], \"name\": \"neutral\"},\n                    \"negative\": {\"children\": [], \"name\": \"negative\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Sentiment\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": False,\n        },\n        \"NAMED_ENTITIES_RECOGNITION_JOB\": {\n            \"content\": {\n                \"categories\": {\n                    \"HostOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"HostCharacter\", \"Sentiment\"],\n                        \"color\": \"#472CED\",\n                        \"name\": \"HostOpinion\",\n                    },\n                    \"RoomOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"RoomItem\", \"Sentiment\"],\n                        \"name\": \"RoomOpinion\",\n                        \"color\": \"#5CE7B7\",\n                    },\n                    \"BathroomOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"BathroomFeature\"],\n                        \"name\": \"BathroomOpinion\",\n                        \"color\": \"#D33BCE\",\n                    },\n                    \"FoodOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"FoodFeature\", \"Sentiment\"],\n                        \"name\": \"FoodOpinion\",\n                        \"color\": \"#FB753C\",\n                    },\n                    \"Location\": {\n                        \"children\": [\"LocationFeature\", \"isCriticalProblem\", \"Sentiment\", \"isLocationQuiet\"],\n                        \"name\": \"Location\",\n                        \"color\": \"#3BCADB\"\n                    },\n                    \"KitchenOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"KitchenFeature\"],\n                        \"name\": \"KitchenOpinion\",\n                        \"color\": \"#199CFC\",\n                    },\n                    \"PricePayment\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"PaymentFeature\"],\n                        \"name\": \"PricePayment\",\n                        \"color\": \"#FA484A\",\n                    },\n                    \"ApartmentOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"ApartmentFeature\", \"Sentiment\", \"KitchenFeature\"],\n                        \"name\": \"ApartmentOpinion\",\n                        \"color\": \"#ECB82A\"\n                    },\n                    \"Loyalty\": {\n                        \"children\": [\"isCriticalProblem\", \"LoyaltyFeature\", \"Sentiment\"],\n                        \"name\": \"Loyalty\",\n                        \"color\": \"#3CD876\",\n                    },\n                    \"TechOpinion\": {\n                        \"children\": [\"isCriticalProblem\", \"Sentiment\", \"TechFeature\"],\n                        \"name\": \"TechOpinion\",\n                        \"color\": \"#733AFB\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Entity type\",\n            \"mlTask\": \"NAMED_ENTITIES_RECOGNITION\",\n            \"required\": 1,\n            \"isChild\": False,\n        },\n        \"LocationFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"center\": {\"children\": [], \"name\": \"center\"},\n                    \"airport\": {\"children\": [], \"name\": \"airport\"},\n                    \"underground\": {\"children\": [], \"name\": \"underground\"},\n                    \"tram\": {\"children\": [], \"name\": \"tram\"},\n                    \"bus\": {\"children\": [], \"name\": \"bus\"},\n                    \"train\": {\"children\": [], \"name\": \"train\"},\n                    \"highway\": {\"children\": [], \"name\": \"highway\"},\n                    \"parking\": {\"children\": [], \"name\": \"parking\"},\n                    \"shopping\": {\"children\": [], \"name\": \"shopping\"},\n                    \"tourism\": {\"children\": [], \"name\": \"tourism\"},\n                    \"restaurants\": {\"children\": [], \"name\": \"restaurants\"},\n                    \"pubs\": {\"children\": [], \"name\": \"pubs\"},\n                    \"nature\": {\"children\": [], \"name\": \"nature\"},\n                    \"arrival\": {\"children\": [], \"name\": \"arrival\"},\n                    \"safety\": {\"children\": [], \"name\": \"safety\"},\n                    \"ownvehicle\": {\"children\": [], \"name\": \"ownvehicle\"},\n                    \"taxi\": {\"children\": [], \"name\": \"taxi\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"LocationFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"isCriticalProblem\": {\n            \"content\": {\n                \"categories\": {\n                    \"yes\": {\"children\": [], \"name\": \"yes\"},\n                    \"no\": {\"children\": [], \"name\": \"no\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"isCriticalProblem\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"ApartmentFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"cleanliness\": {\"children\": [], \"name\": \"cleanliness\"},\n                    \"stairs\": {\"children\": [], \"name\": \"stairs\"},\n                    \"compliantDescription\": {\"children\": [], \"name\": \"compliantDescription\"},\n                    \"look\": {\"children\": [], \"name\": \"look\"},\n                    \"space\": {\"children\": [], \"name\": \"space\"},\n                    \"climate\": {\"children\": [], \"name\": \"climate\"},\n                    \"pets\": {\"children\": [], \"name\": \"pets\"},\n                    \"gym\": {\"children\": [], \"name\": \"gym\"},\n                    \"safety\": {\"children\": [], \"name\": \"safety\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"ApartmentFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"FoodFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"breakfast\": {\"children\": [], \"name\": \"breakfast\"},\n                    \"drinks\": {\"children\": [], \"name\": \"drinks\"},\n                    \"snacks\": {\"children\": [], \"name\": \"snacks\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"FoodFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"LoyaltyFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"solo\": {\"children\": [], \"name\": \"solo\"},\n                    \"couples\": {\"children\": [], \"name\": \"couples\"},\n                    \"family\": {\"children\": [], \"name\": \"family\"},\n                    \"friends\": {\"children\": [], \"name\": \"friends\"},\n                    \"repeat\": {\"children\": [], \"name\": \"repeat\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"LoyaltyFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"HostCharacter\": {\n            \"content\": {\n                \"categories\": {\n                    \"friendliness\": {\"children\": [], \"name\": \"friendliness\"},\n                    \"politeness\": {\"children\": [], \"name\": \"politeness\"},\n                    \"communication\": {\"children\": [], \"name\": \"communication\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"HostCharacter\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"RoomItem\": {\n            \"content\": {\n                \"categories\": {\n                    \"bed\": {\"children\": [], \"name\": \"bed\"},\n                    \"wardrobe\": {\"children\": [], \"name\": \"wardrobe\"},\n                    \"chair\": {\"children\": [], \"name\": \"chair\"},\n                    \"desk\": {\"children\": [], \"name\": \"desk\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"RoomItem\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"Sentiment\": {\n            \"content\": {\n                \"categories\": {\n                    \"positive\": {\"children\": [], \"name\": \"positive\"},\n                    \"negative\": {\"children\": [], \"name\": \"negative\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Sentiment\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"TechFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"wifi\": {\"children\": [], \"name\": \"wifi\"},\n                    \"keypad\": {\"children\": [], \"name\": \"keypad\"},\n                    \"smarthome\": {\"children\": [], \"name\": \"smarthome\"},\n                    \"mobile\": {\"children\": [], \"name\": \"mobile\"},\n                    \"tv\": {\"children\": [], \"name\": \"tv\"},\n                    \"videogames\": {\"children\": [], \"name\": \"videogames\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"TechFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"BathroomFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"shower\": {\"children\": [], \"name\": \"shower\"},\n                    \"bathtub\": {\"children\": [], \"name\": \"bathtub\"},\n                    \"wc\": {\"children\": [], \"name\": \"wc\"},\n                    \"amenities\": {\"children\": [], \"name\": \"amenities\"},\n                    \"hairdryer\": {\"children\": [], \"name\": \"hairdryer\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"BathroomFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"PaymentFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"refund\": {\"children\": [], \"name\": \"refund\"},\n                    \"deposit\": {\"children\": [], \"name\": \"deposit\"},\n                    \"payment_methods\": {\"children\": [], \"name\": \"payment methods\"},\n                    \"extra_charges\": {\"children\": [], \"name\": \"extra charges\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"PaymentFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"isLocationQuiet\": {\n            \"content\": {\n                \"categories\": {\n                    \"Quiet\": {\"children\": [], \"name\": \"Quiet\"},\n                    \"Noisy\": {\"children\": [], \"name\": \"Noisy\"},\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"isLocationQuiet\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"OutdoorFeature\": {\n            \"content\": {\n                \"categories\": {\n                    \"garden\": {\"children\": [], \"name\": \"garden\"},\n                    \"patio\": {\"children\": [], \"name\": \"patio\"},\n                    \"balcon\": {\"children\": [], \"name\": \"balcon\"},\n                    \"terrace\": {\"children\": [], \"name\": \"terrace\"},\n                    \"view\": {\"children\": [], \"name\": \"view\"},\n                    \"pool\": {\"children\": [], \"name\": \"pool\"},\n                    \"barbecue\": {\"children\": [], \"name\": \"barbecue\"},\n                },\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"OutdoorFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n        \"KitchenFeature\": {\n            \"content\": {\n                \"categories\": {\"appliances\": {\"children\": [], \"name\": \"appliances\"}},\n                \"input\": \"checkbox\",\n            },\n            \"instruction\": \"KitchenFeature\",\n            \"mlTask\": \"CLASSIFICATION\",\n            \"required\": 0,\n            \"isChild\": True,\n        },\n    }\n}\n# fmt: on\n</code></pre> <p>Let's create the text project with our ontology:</p> <pre><code>project_id = kili.create_project(\n    input_type=\"TEXT\", json_interface=json_interface, title=\"Tagtog to Kili recipe\"\n)[\"id\"]\n</code></pre> <p>In the Kili project created, we can see the ontology that follows the same structure as the one in tagtog:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#upload-assets","title":"Upload assets","text":"<p>Now that the project is created, we can upload our assets.</p> <pre><code>filepaths = [\n    Path(\"ApartmentReviews/plain.html/pool/\") / filepath\n    for filepath in os.listdir(\"ApartmentReviews/plain.html/pool/\")\n]\nprint(len(filepaths))\n</code></pre> <pre><code>228\n</code></pre> <pre><code>external_ids = [filepath.name.replace(\".plain.html\", \"\") for filepath in filepaths]\nassets = [\n    BeautifulSoup(file.read_text(encoding=\"utf-8\"), \"html.parser\").find(\"body\").get_text().strip()\n    for file in filepaths\n]\n</code></pre> <pre><code>print(external_ids[0])\nprint(assets[0])\n</code></pre> <pre><code>aKRwFKFHhO5FoLBBCEUJl8gkQoBS-text\nJason was great! He welcomed us with cold waters and fully explained the apartment and its many amenities. He provided anything we could have forgotten and made sure to answer the many questions we had. He was quick to answer any additional questions throughout the stay as well. The apartment is located on a quiet hutong right off a main street that is right in the center of the old town and is just a short walk to the metro. The shower is a bit hard to get in and out of, and would be difficult if you have mobility issues. But the apartment was great and we really enjoyed a little bit of local living while in Beijing. Thanks Jason!\n</code></pre> <pre><code>kili.append_many_to_dataset(project_id, content_array=assets, external_id_array=external_ids)\n</code></pre> <p>Our assets have been successfully uploaded to Kili:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#upload-existing-annotations","title":"Upload existing annotations","text":"<p>Now that our project is created with its assets, we can upload the annotations we made in tagtog.</p> <p>But first we need to convert the tagtog annotations to the Kili format.</p> <pre><code>json_response_array = []\n\nfor asset_name, asset in zip(external_ids, assets):\n    # load the tagtog json annotation\n    annotation_path = Path(\"ApartmentReviews/ann.json/master/pool/\") / (asset_name + \".ann.json\")\n    tagtog_annotation = json.loads(annotation_path.read_text(encoding=\"utf-8\"))\n\n    # skip if not annotated\n    if not tagtog_annotation[\"anncomplete\"]:\n        continue\n\n    # kili json response\n    json_response = {}\n\n    # overall review sentiment classification\n    try:\n        sentiment_class = tagtog_annotation[\"metas\"][\"m_18\"][\"value\"]\n    except KeyError:\n        pass  # the asset is not annotated for sentiment\n    else:\n        assert sentiment_class in (\"positive\", \"negative\", \"neutral\"), sentiment_class\n        sentiment_confidence = int(\n            round(tagtog_annotation[\"metas\"][\"m_18\"][\"confidence\"][\"prob\"] * 100)\n        )\n\n        # we add the sentiment classification to the json response\n        json_response[\"SENTIMENT_CLASSIFICATION_JOB\"] = {}\n        json_response[\"SENTIMENT_CLASSIFICATION_JOB\"][\"categories\"] = [\n            {\"name\": sentiment_class, \"confidence\": sentiment_confidence}\n        ]\n\n    # we skip assets with complex html for the sake of clarity\n    if len(tagtog_annotation[\"annotatable\"][\"parts\"]) &gt; 1:\n        json_response_array.append(json_response)\n        continue\n\n    # Named entities recognition job\n    json_response[\"NAMED_ENTITIES_RECOGNITION_JOB\"] = {\"annotations\": []}\n    for entity in tagtog_annotation[\"entities\"]:\n        ner_class = tagtog_class_id_to_class_name[entity[\"classId\"]]\n\n        # make sure the class is in the json interface\n        assert (\n            ner_class\n            in json_interface[\"jobs\"][\"NAMED_ENTITIES_RECOGNITION_JOB\"][\"content\"][\"categories\"]\n        ), ner_class\n\n        confidence = int(round(entity[\"confidence\"][\"prob\"] * 100))\n\n        # get the begin offset and the content of the entity\n        assert len(entity[\"offsets\"]) == 1, entity[\"offsets\"]\n        begin_offset = entity[\"offsets\"][0][\"start\"]\n        content = entity[\"offsets\"][0][\"text\"]\n\n        # we verify that the content and begin_offset match the asset content\n        assert content == asset[begin_offset : begin_offset + len(content)], (\n            content,\n            asset[begin_offset : begin_offset + len(content)],\n        )\n\n        entity_annotation = {\n            \"children\": {},\n            \"beginOffset\": begin_offset,\n            \"categories\": [{\"name\": ner_class, \"confidence\": confidence}],\n            \"content\": content,\n        }\n\n        # an named entity can have tagtog entity labels\n        # we convert them to Kili children annotations\n        for field_id in entity[\"fields\"]:\n            entity_label = tagtog_class_id_to_class_name[field_id]\n            job_interface = json_interface[\"jobs\"][entity_label]\n            confidence = int(round(entity[\"fields\"][field_id][\"confidence\"][\"prob\"] * 100))\n            label_class = entity[\"fields\"][field_id][\"value\"]\n\n            # we convert boolean fields to match our json interface\n            if entity_label == \"isLocationQuiet\":\n                label_class = \"Quiet\" if label_class else \"Noisy\"\n\n            if entity_label == \"isCriticalProblem\":\n                label_class = \"yes\" if label_class else \"no\"\n\n            if entity_label == \"HostCharacter\" and label_class == \"friendly\":\n                label_class = \"friendliness\"\n\n            # some job names have spaces that we converted to \"_\" in our json interface\n            label_class = label_class.replace(\" \", \"_\")\n            assert label_class in job_interface[\"content\"][\"categories\"], f\"{label_class} {entity}\"\n\n            if entity_label not in entity_annotation[\"children\"]:\n                entity_annotation[\"children\"][entity_label] = {\"categories\": []}\n\n            # we add the child annotations to the NER annotation\n            entity_annotation[\"children\"][entity_label][\"categories\"].append(\n                {\"name\": label_class, \"confidence\": confidence}\n            )\n\n        json_response[\"NAMED_ENTITIES_RECOGNITION_JOB\"][\"annotations\"].append(entity_annotation)\n\n    json_response_array.append(json_response)\n</code></pre> <p>We can now upload the Kili annotations to our project:</p> <pre><code>kili.append_labels(\n    json_response_array=json_response_array,\n    project_id=project_id,\n    asset_external_id_array=external_ids,\n)\n</code></pre> <p>We can see that this asset's labels in tagtog labeling interface:</p> <p></p> <p>match the Kili labels we converted previously:</p> <p></p> <p>We also see that the entity labels (child annotations in Kili) are shown in the labeling interface:</p> <p></p>"},{"location":"sdk/tutorials/tagtog_to_kili/#conclusion","title":"Conclusion","text":"<p>In this recipe, we saw how to convert a tagtog project to Kili.</p> <p>As you can see, the Kili json interface and the json response formats are really flexible and can be adapted to a lot of use cases.</p>"},{"location":"sdk/tutorials/tagtog_to_kili/#project-cleanup","title":"Project cleanup","text":"<pre><code>kili.delete_project(project_id)\n</code></pre>"},{"location":"sdk/tutorials/webhooks_example/","title":"Webhooks","text":""},{"location":"sdk/tutorials/webhooks_example/#how-to-develop-a-kili-webhook","title":"How to develop a Kili Webhook","text":""},{"location":"sdk/tutorials/webhooks_example/#context","title":"Context","text":"<p>This notebook is an end-to-end example that you can follow to create a project, register a first webhook and activate it on this project for the corresponding events in Kili.</p> <p>For more information on the available events, please refer to the documentation.</p> <p>Webhooks are really similar to the plugins, except they are self hosted, and will require a webservice deployed on your premise, callable by Kili (You can implement a header-based security).</p> <p>If you are a Europe SaaS user, plugins &amp; webhooks are available for paying-customers in beta for now. If you are a US/ On Premise customer, only webhooks are available as of version 1.128.0.</p> <p>Webhook allow you to easily access your custom code, manage the CI/CD of the version of the plugin deployed, and easily integrate it with your own stack.</p> <p>If you are looking for a more of-the-shelf capability, you can have a look at the plugins development tutorial.</p> <p>NB: The webhook capabilities of Kili are under active development, and compatible with version 2.128.0 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-1-instantiate-kili","title":"Step 1: Instantiate Kili","text":"<pre><code>%pip install kili\n</code></pre> <pre><code>from kili.client import Kili\n\nkili = Kili()\n</code></pre>"},{"location":"sdk/tutorials/webhooks_example/#step-2-create-the-project","title":"Step 2: Create the project","text":"<p>First, we need to create a new project. In our example, we will use an <code>IMAGE</code> type project with the following <code>jsonInterace</code>:</p> <pre><code>json_interface = {\n    \"jobs\": {\n        \"JOB_0\": {\n            \"content\": {\n                \"categories\": {\n                    \"OBJECT_A\": {\n                        \"children\": [],\n                        \"name\": \"Object A\",\n                        \"color\": \"#733AFB\",\n                        \"id\": \"category1\",\n                    },\n                    \"OBJECT_B\": {\n                        \"children\": [],\n                        \"name\": \"Object B\",\n                        \"color\": \"#3CD876\",\n                        \"id\": \"category2\",\n                    },\n                },\n                \"input\": \"radio\",\n            },\n            \"instruction\": \"Categories\",\n            \"isChild\": False,\n            \"tools\": [\"rectangle\"],\n            \"mlTask\": \"OBJECT_DETECTION\",\n            \"models\": {},\n            \"isVisible\": True,\n            \"required\": 1,\n            \"isNew\": False,\n        }\n    }\n}\n</code></pre> <pre><code>title = \"Webhooks test project\"\ndescription = \"My first project with a webhook\"\ninput_type = \"IMAGE\"\n\nproject = kili.create_project(\n    title=title, description=description, input_type=input_type, json_interface=json_interface\n)\nproject_id = project[\"id\"]\n\nprint(f\"Created project {project_id}\")\n</code></pre> <pre><code>Created project clfcblkni05pq0jrq8wgib142\n</code></pre> <p>Upload an asset:</p> <pre><code>content_array = [\"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\"]\nnames_array = [\"landscape2\"]\n\nkili.append_many_to_dataset(\n    project_id=project_id,\n    content_array=content_array,\n    external_id_array=names_array,\n    disable_tqdm=True,\n)\n\nasset_id = kili.assets(project_id=project_id, fields=[\"id\"], disable_tqdm=True)[0][\"id\"]\n</code></pre> <p>This project has one job of bounding box creation with two categories.</p> <p>With our plugin, we want to make sure that the labelers don't create more than one bounding box of category A.</p> <p>To iterate on the plugin code, you can refer to the plugins development tutorial.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-3-write-host-the-webhook","title":"Step 3: Write &amp; host the webhook","text":"<p>The webhook rely on the same handlers provided by the plugins. For maximum compatibility, we encourage you to define it with the same base class. Below is an example with FastAPI webservice.</p> <pre><code># file plugin.py\n\"\"\"\nCustom module with basic plugin example\n\"\"\"\nfrom typing import Dict\n\nfrom kili.plugins import PluginCore\n\n\ndef check_rules_on_label(label: Dict):\n\"\"\"\n    Custom function to check rules on label.\n    For basic rules, a handy object is `search` that \\\n        provides various analytics on objects\n    For more advanced use-cases, you might need to \\\n        fetch the complete `jsonResponse`\n    \"\"\"\n\n    issues_array = []\n    for job_dot_category, nb_of_objects in label['search']['numberOfAnnotationsByObject'].items():\n        if job_dot_category == \"JOB_0.OBJECT_A\":\n            if nb_of_objects &gt; 1:\n                issues_array.append({\n                    'text': f'There are too many BBox ({nb_of_objects}) - Only 1 BBox of Object A accepted',\n                    'mid': None}\n                )\n    return issues_array\n\n\ndef _get_area(bounding_box):\n\"\"\"\n    Custom helper to compute size of Kili Bounding boxes\n    \"\"\"\n    x_array = [point['x'] for point in bounding_box]\n    y_array = [point['y'] for point in bounding_box]\n    width = max(x_array) - min(x_array)\n    height = max(y_array) - min(y_array)\n    return width * height\n\n\nclass PluginHandler(PluginCore):\n\"\"\"\n    Custom plugin instance\n    \"\"\"\n\n    def check_complex_rules_on_label(self, asset_id: str):\n\"\"\"\n        Custom method to check if a box is larger than 33% of the image\n        For basic rules, a handy object is `search` that \\\n            provides various analytics on objects\n        In this more complex use-case, we will \\\n            fetch the complete `jsonResponse`\n        \"\"\"\n        json_response = self.kili.labels(\n            asset_id=asset_id,\n            project_id=self.project_id,\n            fields=['jsonResponse'],\n            disable_tqdm=True\n        )[0]['jsonResponse']\n\n        issues_array = []\n        for annotation in json_response['JOB_0']['annotations']:\n            bounding_box = annotation['boundingPoly'][0]['normalizedVertices']\n            area = _get_area(bounding_box)\n            # Refuse bounding boxes larger than 0.33\n            if area &gt; 0.33:\n                issues_array.append({\n                    'text': 'BBox too large',\n                    'mid': annotation[\"mid\"]\n                })\n\n        return issues_array\n\n    def on_submit(self, label: Dict, asset_id: str) -&gt; None:\n\"\"\"\n        Dedicated handler for Submit action\n        \"\"\"\n        self.logger.info(\"On submit called\")\n\n        issues_array = check_rules_on_label(label)\n\n        issues_array += self.check_complex_rules_on_label(asset_id)\n\n        project_id = self.project_id\n\n        if len(issues_array) &gt; 0:\n            print(f'Creating {len(issues_array)} issues...')\n\n            for issue in issues_array:\n                print(issue)\n\n                self.kili.create_issues(\n                    label_id_array=[label['id']],\n                    project_id=project_id,\n                    text_array=[issue['text']],\n                    object_mid_array=[issue['mid']]\n                )\n\n            self.logger.warning(\"Issue created!\")\n\n            self.kili.send_back_to_queue(asset_ids=[asset_id])\n\n        else:\n            self.logger.info('No issues encountered')\n</code></pre> <p>You will need to deploy this on your premise for this to work. Easy solutions are FastAPI, with a few lines of codes, and to quickly test your code, we recommend ngrok that allows to quckly expose your local server. For this demo, we will also display the use of https://webhook.site that will enable us to explore the payload of the calls.</p> <pre><code>\"\"\"\nBasic app for kili webhook\nNote: Don't host it locally, it won't work as Kili can't call your localhost\n\"\"\"\n# file main.py\nimport os\nfrom typing import Dict\nfrom fastapi import FastAPI\nfrom kili.client import Kili\n\n# Assuming your plugin is in a file  `plugin.py` in the same folder\nfrom plugin import PluginHandler\n\napp = FastAPI()\nkili = Kili()\n\n\n@app.post(\"/\")\ndef main(raw_payload: Dict):\n\"\"\"\n    Basic endpoint to receive kili events\n    \"\"\"\n    event_type = raw_payload.get('eventType')\n    project_id = raw_payload.get('logPayload').get('projectId')\n\n    if not project_id:\n        print('Invalid projectId')\n        return\n\n    plugin = PluginHandler(kili, project_id)\n\n    if not event_type:\n        print('Invalid event')\n        return\n\n    payload = raw_payload.get('payload')\n    label = payload.get('label')\n    asset_id = payload.get('asset_id')\n\n    if event_type == 'onSubmit':\n        plugin.on_submit(label, asset_id)\n\n    if event_type == 'onReview':\n        plugin.on_review(label, asset_id)\n</code></pre>"},{"location":"sdk/tutorials/webhooks_example/#local-dev-webhook","title":"Local dev webhook","text":"<p>To quickly get started, setup the following folder:</p> <p><pre><code>\u251c\u2500\u2500 local_webhook\n \u00a0\u00a0 \u251c\u2500\u2500 main.py\n \u00a0\u00a0 \u2514\u2500\u2500 plugin.py\n</code></pre> with the code the code above.</p> <p>To start your fastapi app, just run <code>uvicorn main:app --reload</code> to have live reload in case your code changes.</p> <p>To start exposing your app, just run <code>ngrok http 8000</code>. You will need to register on ngrok to be able to request a public url that redirects to your computer.</p> <pre><code>Session Status                online\nAccount                       *** (Plan: Free)\nUpdate                        update available (version 2.3.41, Ctrl-U to update)\nVersion                       2.3.40\nRegion                        United States (us)\nWeb Interface                 http://127.0.0.1:4040\nForwarding                    http://your-unique-id.ngrok-free.app -&gt; http://localhost:8000\nForwarding                    https://your-unique-id.ngrok-free.app -&gt; http://localhost:8000\n\nHTTP Requests\n-------------\n\nPOST /                         200 OK\n</code></pre> <p>Then, follow the rest of the tutorial to register the webhook with the <code>https</code> url returned by <code>ngrok</code>.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-4-register-activate-the-webhook","title":"Step 4: Register &amp; activate the webhook","text":"<pre><code>import requests\n\nfrom kili.exceptions import GraphQLError\n\n# we get a new webhook listener\nres = requests.post(\"https://webhook.site/token\")\nuuid = res.json()[\"uuid\"]\nwebhook_url_from_browser = f\"https://webhook.site/#!/{uuid}\"\n\nwebhook_name = \"Webhook bbox count\"\nwebhook_url = f\"https://webhook.site/{uuid}\"\nprint(webhook_url_from_browser)\nwebhook_security_header = \"custom header\"\n\ntry:\n    kili.create_webhook(\n        plugin_name=webhook_name, webhook_url=webhook_url, header=webhook_security_header\n    )\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <pre><code>kili.activate_plugin_on_project(plugin_name=webhook_name, project_id=project_id)\n</code></pre> <pre><code>Plugin with name \"Webhook bbox count\" activated on project \"clfcblkni05pq0jrq8wgib142\"\nINFO:kili.services.plugins:Plugin with name \"Webhook bbox count\" activated on project \"clfcblkni05pq0jrq8wgib142\"\n\n\n\n\n\n'Plugin with name Webhook bbox count successfully activated'\n</code></pre> <p>Note: Similar to plugins, you have access to the methods <code>kili.update_webhook</code> &amp; <code>kili.deactivate_plugin_on_project</code> for iterations on your code.</p>"},{"location":"sdk/tutorials/webhooks_example/#step-5-webhook-in-action","title":"Step 5: Webhook in action","text":"<p>After that, you can test it by labelling in the Kili interface or just by uploading the following label.</p> <p>When you add the label that contains errors, you will see a new issue automatically created in the Kili app, if you have deployed the webhook. Else, you can visit the webhook site to check incoming events.</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.79, \"y\": 0.20},\n                            {\"x\": 0.79, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.13},\n                            {\"x\": 0.91, \"y\": 0.20},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161456406-47055\",\n                \"type\": \"rectangle\",\n            },\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.87, \"y\": 0.36},\n                            {\"x\": 0.87, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.27},\n                            {\"x\": 0.99, \"y\": 0.36},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161459298-45160\",\n                \"type\": \"rectangle\",\n            },\n        ]\n    }\n}\n</code></pre> <pre><code>kili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n</code></pre> <pre><code>[{'id': 'clfcblncs0h550js5golxg96s'}]\n</code></pre> <p>If you used &amp; hosted the base webhook provided, the webhook should:</p> <ul> <li>Create an issue with information that three bboxes were found, instead of one</li> <li>Create an issue with info that the first bbox is too large</li> <li>Send the asset back to the labeling queue (status <code>ONGOING</code>)</li> </ul> <p>If you haven't deployed your webhook just yet, you can still visit the address here :</p> <pre><code>print(f\"Go to my webhook: {webhook_url_from_browser}\")\ntry:\n    # If your webhook is live !\n    kili.issues(project_id=project_id, fields=[\"comments.text\", \"objectMid\"])\nexcept GraphQLError as error:\n    print(str(error))\n</code></pre> <pre><code>Go to my webhook: https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <p>Woah! Amazing! Well done :) \ud83d\ude80</p> <p>Let's test now to post a proper label, this one for example:</p> <pre><code>json_response = {\n    \"JOB_0\": {\n        \"annotations\": [\n            {\n                \"boundingPoly\": [\n                    {\n                        \"normalizedVertices\": [\n                            {\"x\": 0.15, \"y\": 0.84},\n                            {\"x\": 0.15, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.31},\n                            {\"x\": 0.82, \"y\": 0.84},\n                        ]\n                    }\n                ],\n                \"categories\": [{\"name\": \"OBJECT_A\"}],\n                \"children\": {},\n                \"mid\": \"20221124161451411-13314\",\n                \"type\": \"rectangle\",\n            }\n        ]\n    }\n}\nkili.append_labels(\n    json_response_array=[json_response], asset_id_array=[asset_id], label_type=\"DEFAULT\"\n)\n\nprint(f\"Go to my webhook: {webhook_url_from_browser}\")\n</code></pre> <pre><code>Go to my webhook: https://webhook.site/#!/f81dfe6a-****-****-****-4b6dfe4b0721\n</code></pre> <p>The status of your asset should have now changed to <code>LABELED</code>. In this webhook, previous issues remain but you can solve them through the API as well.</p> <p>Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins development tutorial.</p> <pre><code>kili.delete_project(project_id)\n</code></pre>"}]}