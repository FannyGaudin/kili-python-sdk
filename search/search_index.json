{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KILI SDK docs HTML Preview Automatically reloads when you edit a file. cd docs make serve Publish make gh-deploy Pushes to the gh-deploy branch and republishes as github pages.","title":"KILI SDK docs"},{"location":"#kili-sdk-docs","text":"","title":"KILI SDK docs"},{"location":"#html-preview","text":"Automatically reloads when you edit a file. cd docs make serve","title":"HTML Preview"},{"location":"#publish","text":"make gh-deploy Pushes to the gh-deploy branch and republishes as github pages.","title":"Publish"},{"location":"asset/","text":"Asset module Asset queries QueriesAsset Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : list = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If True, the progress bar will be disabled as_generator: If True, a generator on the assets is returned. Returns ------- result a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- result a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count assets ( self , asset_id = None , project_id = None , skip = 0 , fields = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in = None , consensus_mark_gt = None , consensus_mark_lt = None , disable_tqdm = False , external_id_contains = None , first = None , format = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , label_type_in = None , metadata_where = None , skipped = None , status_in = None , updated_at_gte = None , updated_at_lte = None , as_generator = False ) Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields list All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the assets is returned. False Examples: >>> kili . assets ( project_id = project_id ) # returns the assets list of the project >>> kili . assets ( asset_id = asset_id ) >>> kili . assets ( project_id = project_id , as_generator = True ) # returns a generator of the project assets Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : list = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If True, the progress bar will be disabled as_generator: If True, a generator on the assets is returned. Returns ------- result a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) count_assets ( self , asset_id = None , project_id = None , asset_id_in = None , external_id_contains = None , metadata_where = None , status_in = None , consensus_mark_gt = None , consensus_mark_lt = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_type_in = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , skipped = None , updated_at_gte = None , updated_at_lte = None ) Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- result a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count Asset mutations MutationsAsset Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset ) append_many_to_dataset ( self , project_id , content_array = None , external_id_array = None , is_honeypot_array = None , status_array = None , json_content_array = None , json_metadata_array = None ) Append assets to a project For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. None json_content_array Optional[List[List[Union[dict, str]]]] Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. None Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) delete_many_from_dataset ( self , asset_ids ) Delete assets from a project Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset ) update_properties_in_assets ( self , asset_ids , external_ids = None , priorities = None , json_metadatas = None , consensus_marks = None , honeypot_marks = None , to_be_labeled_by_array = None , contents = None , json_contents = None , status_array = None , is_used_for_consensus_array = None , is_honeypot_array = None ) Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset )","title":"Asset"},{"location":"asset/#asset-module","text":"Asset queries","title":"Asset module"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset","text":"Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : list = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If True, the progress bar will be disabled as_generator: If True, a generator on the assets is returned. Returns ------- result a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- result a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesAsset"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.assets","text":"Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields list All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the assets is returned. False Examples: >>> kili . assets ( project_id = project_id ) # returns the assets list of the project >>> kili . assets ( asset_id = asset_id ) >>> kili . assets ( project_id = project_id , as_generator = True ) # returns a generator of the project assets Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : list = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If True, the progress bar will be disabled as_generator: If True, a generator on the assets is returned. Returns ------- result a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator )","title":"assets()"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","text":"Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- result a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count Asset mutations","title":"count_assets()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset","text":"Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset )","title":"MutationsAsset"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","text":"Append assets to a project For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. None json_content_array Optional[List[List[Union[dict, str]]]] Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. None Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset )","title":"append_many_to_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","text":"Delete assets from a project Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- result a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset )","title":"delete_many_from_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","text":"Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Returns: Type Description result a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- result a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset )","title":"update_properties_in_assets()"},{"location":"issue/","text":"Issue module Issue queries QueriesIssue dataclass Set of Issue queries Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\" Set of Issue queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ list ] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- result a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- result the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count count_issues ( self , project_id = None ) Count and return the number of api keys with the given constraints Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int the number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- result the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count issues ( self , fields = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first = 100 , project_id = None , skip = 0 , disable_tqdm = False , as_generator = False ) Gets a generator or a list of issues that match a set of criteria Parameters: Name Type Description Default fields Optional[list] See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the issues is returned. False Examples: # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ list ] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- result a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"Issue"},{"location":"issue/#issue-module","text":"Issue queries","title":"Issue module"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue","text":"Set of Issue queries Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\" Set of Issue queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ list ] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- result a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- result the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesIssue"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","text":"Count and return the number of api keys with the given constraints Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int the number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- result the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_issues()"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.issues","text":"Gets a generator or a list of issues that match a set of criteria Parameters: Name Type Description Default fields Optional[list] See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the issues is returned. False Examples: # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ list ] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- result a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"issues()"}]}