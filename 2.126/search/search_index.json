{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started with the Kili Python SDK What is Kili? Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here . If you are looking for the Kili product documentation, it is located here . The Kili Python SDK Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners. Requirements You only need Python 3.7 or higher. Installation Install the Kili client with pip: pip install kili Usage Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: python kili = Kili(api_key='<you api key value here>')","title":"Getting Started"},{"location":"#getting-started-with-the-kili-python-sdk","text":"","title":"Getting started with the Kili Python SDK"},{"location":"#what-is-kili","text":"Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here . If you are looking for the Kili product documentation, it is located here .","title":"What is Kili?"},{"location":"#the-kili-python-sdk","text":"Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.","title":"The Kili Python SDK"},{"location":"#requirements","text":"You only need Python 3.7 or higher.","title":"Requirements"},{"location":"#installation","text":"Install the Kili client with pip: pip install kili","title":"Installation"},{"location":"#usage","text":"Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: python kili = Kili(api_key='<you api key value here>')","title":"Usage"},{"location":"label_export/","text":"Exporting kili projects There are several ways to export labels from a Kili project. With the CLI You can export a project using the kili project export command: kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export.zip More options here . With the Python SDK You can also use the Python SDK: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) More details here . From the Kili UI You can refer to this Kili documentation page . Available formats Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 And more to come!","title":"Exporting kili projects"},{"location":"label_export/#exporting-kili-projects","text":"There are several ways to export labels from a Kili project.","title":"Exporting kili projects"},{"location":"label_export/#with-the-cli","text":"You can export a project using the kili project export command: kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export.zip More options here .","title":"With the CLI"},{"location":"label_export/#with-the-python-sdk","text":"You can also use the Python SDK: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) More details here .","title":"With the Python SDK"},{"location":"label_export/#from-the-kili-ui","text":"You can refer to this Kili documentation page .","title":"From the Kili UI"},{"location":"label_export/#available-formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 And more to come!","title":"Available formats"},{"location":"cli/","text":"Getting started with the Kili CLI What is Kili CLI Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks. Authentication Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Info While launching commands, you can also provide you API key through the --api-key option. If you set your api key in the KILI_API_KEY environment variable and provide it once again through the --api-key option, Kili CLI will use the api key value provided in command options. Usage The main command is kili . It currently has only one subcommand project that entails all the commands for project management : kili project [COMMAND] Workflow example Let's take an example where you want to start a project from scratch You can download ressources to run this example here . Once in the current directory where all files are stored, you can run the following commands: Create a project To create an IMAGE project: kili project create \\ json_interface.json \\ --title \"Quality inspection\" \\ --input-type IMAGE \\ --description \"Steel defects on production line\" Ouput: ID URL <project_id> https://cloud.kili-technology.com/label/projects/<project_id>/ List your projects kili project list --max 10 Ouput: TITLE ID PROGRESS DESCRIPTION Quality inspection <project_id> 0.0% Steel defects on production line... Recover your project ID export project_id=$(kili project list \\ | grep -m1 \"Quality inspection\" \\ | awk '{print $3}') Add a member to your project kili project member add \\ <email_adress> \\ --project-id $project_id \\ --role REVIEWER Ouput: 1 member(s) have been successfully added to project: <project_id> List the project's members kili project member list --project-id $project_id Ouput: ROLE NAME EMAIL ID ORGANIZATION ADMIN <your_name> <your_email> <your_member_id> <your_organization> REVIEWER <reviewer_name> <email_adress> <member_id> <your_organization> Import data to your project To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths) kili project import \\ assets \\ --project-id $project_id Ouput: 40 files have been successfully imported Import labels to your project To import labels, provide a list of files or folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths kili project label \\ ground_truths \\ --project-id $project_id Outputs: 40 labels have been successfully imported If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface. kili project label \\ ground_truths \\ --project-id $project_id \\ --prediction \\ --model-name YOLO-run-3 Outputs: 40 labels have been successfully imported Get metrics of your project kili project describe $project_id Ouput: Title Quality inspection Description Steel defects on production line Dataset KPIs ------------ Total number of assets 40 Number of remaining assets 10 Skipped assets 0 Progress 25.0% Quality KPIs ------------ Project consensus N/A Project honeypot N/A Number of reviewed assets 0 Number of open issues 0 Number of solved issues 0 Number of open questions 0 Number of solved questions 0","title":"Getting Started"},{"location":"cli/#getting-started-with-the-kili-cli","text":"","title":"Getting started with the Kili CLI"},{"location":"cli/#what-is-kili-cli","text":"Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.","title":"What is Kili CLI"},{"location":"cli/#authentication","text":"Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Info While launching commands, you can also provide you API key through the --api-key option. If you set your api key in the KILI_API_KEY environment variable and provide it once again through the --api-key option, Kili CLI will use the api key value provided in command options.","title":"Authentication"},{"location":"cli/#usage","text":"The main command is kili . It currently has only one subcommand project that entails all the commands for project management : kili project [COMMAND]","title":"Usage"},{"location":"cli/#workflow-example","text":"Let's take an example where you want to start a project from scratch You can download ressources to run this example here . Once in the current directory where all files are stored, you can run the following commands:","title":"Workflow example"},{"location":"cli/#create-a-project","text":"To create an IMAGE project: kili project create \\ json_interface.json \\ --title \"Quality inspection\" \\ --input-type IMAGE \\ --description \"Steel defects on production line\" Ouput: ID URL <project_id> https://cloud.kili-technology.com/label/projects/<project_id>/","title":"Create a project"},{"location":"cli/#list-your-projects","text":"kili project list --max 10 Ouput: TITLE ID PROGRESS DESCRIPTION Quality inspection <project_id> 0.0% Steel defects on production line...","title":"List your projects"},{"location":"cli/#recover-your-project-id","text":"export project_id=$(kili project list \\ | grep -m1 \"Quality inspection\" \\ | awk '{print $3}')","title":"Recover your project ID"},{"location":"cli/#add-a-member-to-your-project","text":"kili project member add \\ <email_adress> \\ --project-id $project_id \\ --role REVIEWER Ouput: 1 member(s) have been successfully added to project: <project_id>","title":"Add a member to your project"},{"location":"cli/#list-the-projects-members","text":"kili project member list --project-id $project_id Ouput: ROLE NAME EMAIL ID ORGANIZATION ADMIN <your_name> <your_email> <your_member_id> <your_organization> REVIEWER <reviewer_name> <email_adress> <member_id> <your_organization>","title":"List the project's members"},{"location":"cli/#import-data-to-your-project","text":"To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths) kili project import \\ assets \\ --project-id $project_id Ouput: 40 files have been successfully imported","title":"Import data to your project"},{"location":"cli/#import-labels-to-your-project","text":"To import labels, provide a list of files or folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths kili project label \\ ground_truths \\ --project-id $project_id Outputs: 40 labels have been successfully imported If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface. kili project label \\ ground_truths \\ --project-id $project_id \\ --prediction \\ --model-name YOLO-run-3 Outputs: 40 labels have been successfully imported","title":"Import labels to your project"},{"location":"cli/#get-metrics-of-your-project","text":"kili project describe $project_id Ouput: Title Quality inspection Description Steel defects on production line Dataset KPIs ------------ Total number of assets 40 Number of remaining assets 10 Skipped assets 0 Progress 25.0% Quality KPIs ------------ Project consensus N/A Project honeypot N/A Number of reviewed assets 0 Number of open issues 0 Number of solved issues 0 Number of open questions 0 Number of solved questions 0","title":"Get metrics of your project"},{"location":"cli/reference/","text":"kili Kili Command line Interface To get all the available commands, please type: kili project --help . Usage: kili [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --help boolean Show this message and exit. False project Commands to interact with a Kili project Usage: kili project [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False copy Copy a Kili project. The copy can include or not the json interface, quality settings and members of the source project. By default, the json interface, quality settings and projects members are copied. If no title is provided, the source project title will be used. If no description is provided, the description will be set to an empty string. Returns the new project id and title once the copy is finished. Examples Copy a project and set a new title and new description: kili project copy clbqn56b331234567890l41c0 \\ --title \"New project title\" \\ --description \"New project description\" Copy the json interface but not the members: kili project copy clbqn56b331234567890l41c0 \\ --with-json-interface \\ --without-members Usage: kili project copy [OPTIONS] FROM_PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --title text New project title. None --description text New project description. None --with-json-interface / --without-json-interface boolean Copy json interface. True --with-quality-settings / --without-quality-settings boolean Copy quality settings. True --with-members / --without-members boolean Copy members. True --help boolean Show this message and exit. False create Create a Kili project interface must be a path pointing to your json interface file If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied). Examples kili project create \\ path/to/interface.json \\ --input-type TEXT \\ --title \"Invoice annotation project\" kili project create \\ --from-project <project_id_src> \\ --input-type TEXT \\ --title \"Invoice annotation project\" To build a Kili project interface, please visit: https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings Usage: kili project create [OPTIONS] [INTERFACE] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --from-project text project_id of another Kili project None --title text Project Title. _required --input-type choice ( AUDIO | IMAGE | PDF | TEXT | TIME_SERIES | VIDEO | VIDEO_LEGACY ) Project input data type. Please check your license to see which ones you have access to. _required --description text Project description. `` --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False describe Show project description and analytics. Examples kili project describe --project-id <project_id> Usage: kili project describe [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --help boolean Show this message and exit. False export Export the Kili labels of a project to a given format. The supported formats are: YOLO V4, V5, V7 for object detection tasks (bounding box). Kili (a.k.a raw) for all tasks. COCO for object detection tasks (semantic or bounding box) Pascal VOC for object detection tasks. Examples kili project export \\ --project-id <project_id> \\ --output-format coco \\ --output-file /tmp/export.zip kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export_split.zip \\ --layout split Unsupported exports Currently, this command does not support the export of videos that have not been cut into separated frames. For such exports, please use the Kili UI. Usage: kili project export [OPTIONS] Options: Name Type Description Default --output-format choice ( raw | kili | yolo_v4 | yolo_v5 | yolo_v7 | coco | pascal_voc ) Format into which the label data will be converted _required --output-file text File into which the labels are saved. _required --layout choice ( split | merged ) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. merged --single-file boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). False --with-assets / --without-assets boolean Download assets in the export. True --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --verbose boolean Show more logs False --help boolean Show this message and exit. False import Add assets into a project Files can be paths to files or to folders. You can provide several paths separated by spaces. If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns: external_id : external id of the asset. content : paths to the asset file or a url hosting the asset. Examples kili project import \\ dir1/dir2/ dir1/dir3/test1.png \\ --project-id <project_id> kili project import \\ dir1/dir3/video.mp4 \\ --project-id <project_id> \\ --frames \\ --fps 24 kili project import \\ --from-csv assets_list.csv \\ --project-id <project_id> \\ --frames \\ --fps 24 Unsupported imports Currently, this command does not support: the import of videos from local frames, rich text and time series assets the import of assets with metadata or with a custom external_id For such imports, please use the append_many_to_dataset method in the Kili SDK. Usage: kili project import [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:external_id, content required columns: None --frames boolean Only for a frame project, import videos as frames. The import time is longer with this option. False --fps integer Only for a frame project, import videos with a specific frame rate None --verbose boolean Show more logs False --help boolean Show this message and exit. False label Import labels or predictions Files can be paths to files or to folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. Examples To import default labels: kili project label \\ dir/labels/ dir/ground-truth/image1.json \\ --project-id <project_id> To import labels as predictions: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-run-3 To import labels as predictions in the Yolo v5 format into a target job: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-v5 \\ --metadata-file classes.yml \\ --target-job IMAGE_DETECTION_JOB \\ --input-format yolo_v5 Usage: kili project label [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --prediction boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface False --model-name text Name of the model that generated predictions, if labels are sent as predictions None --verbose boolean Show more logs False --input-format choice ( yolo_v4 | yolo_v5 | yolo_v7 | kili | raw ) Format in which the labels are encoded kili --metadata-file text File containing format metadata (if relevant to the input format) None --target-job text Job name in the project where to upload the labels (if relevant to the input format) None --help boolean Show this message and exit. False list List your projects Examples kili project list --max 10 --stdout-format pretty Usage: kili project list [OPTIONS] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --max integer Maximum number of project to display. 100 --help boolean Show this message and exit. False member Commands to interact with Kili project members Usage: kili project member [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False add Add members to a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member add \\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com jane.doe@test.com kili project member add \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member add \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member add [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False list List the members of the project Examples kili project member list <project_id> --stdout-format pretty Usage: kili project member list [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False rm Remove members from a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member rm \\ --project-id <project_id> \\ john.doe@test.com kili project member rm \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member rm \\ --project-id <project_id> \\ --all Usage: kili project member rm [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:email required columns: role None --all boolean Remove all users from project False --help boolean Show this message and exit. False update Update member's role of a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member update\\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com kili project member update \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member update \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member update [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"Reference"},{"location":"cli/reference/#kili","text":"Kili Command line Interface To get all the available commands, please type: kili project --help . Usage: kili [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --help boolean Show this message and exit. False","title":"kili"},{"location":"cli/reference/#project","text":"Commands to interact with a Kili project Usage: kili project [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"project"},{"location":"cli/reference/#copy","text":"Copy a Kili project. The copy can include or not the json interface, quality settings and members of the source project. By default, the json interface, quality settings and projects members are copied. If no title is provided, the source project title will be used. If no description is provided, the description will be set to an empty string. Returns the new project id and title once the copy is finished. Examples Copy a project and set a new title and new description: kili project copy clbqn56b331234567890l41c0 \\ --title \"New project title\" \\ --description \"New project description\" Copy the json interface but not the members: kili project copy clbqn56b331234567890l41c0 \\ --with-json-interface \\ --without-members Usage: kili project copy [OPTIONS] FROM_PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --title text New project title. None --description text New project description. None --with-json-interface / --without-json-interface boolean Copy json interface. True --with-quality-settings / --without-quality-settings boolean Copy quality settings. True --with-members / --without-members boolean Copy members. True --help boolean Show this message and exit. False","title":"copy"},{"location":"cli/reference/#create","text":"Create a Kili project interface must be a path pointing to your json interface file If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied). Examples kili project create \\ path/to/interface.json \\ --input-type TEXT \\ --title \"Invoice annotation project\" kili project create \\ --from-project <project_id_src> \\ --input-type TEXT \\ --title \"Invoice annotation project\" To build a Kili project interface, please visit: https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings Usage: kili project create [OPTIONS] [INTERFACE] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --from-project text project_id of another Kili project None --title text Project Title. _required --input-type choice ( AUDIO | IMAGE | PDF | TEXT | TIME_SERIES | VIDEO | VIDEO_LEGACY ) Project input data type. Please check your license to see which ones you have access to. _required --description text Project description. `` --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False","title":"create"},{"location":"cli/reference/#describe","text":"Show project description and analytics. Examples kili project describe --project-id <project_id> Usage: kili project describe [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --help boolean Show this message and exit. False","title":"describe"},{"location":"cli/reference/#export","text":"Export the Kili labels of a project to a given format. The supported formats are: YOLO V4, V5, V7 for object detection tasks (bounding box). Kili (a.k.a raw) for all tasks. COCO for object detection tasks (semantic or bounding box) Pascal VOC for object detection tasks. Examples kili project export \\ --project-id <project_id> \\ --output-format coco \\ --output-file /tmp/export.zip kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export_split.zip \\ --layout split Unsupported exports Currently, this command does not support the export of videos that have not been cut into separated frames. For such exports, please use the Kili UI. Usage: kili project export [OPTIONS] Options: Name Type Description Default --output-format choice ( raw | kili | yolo_v4 | yolo_v5 | yolo_v7 | coco | pascal_voc ) Format into which the label data will be converted _required --output-file text File into which the labels are saved. _required --layout choice ( split | merged ) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. merged --single-file boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). False --with-assets / --without-assets boolean Download assets in the export. True --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --verbose boolean Show more logs False --help boolean Show this message and exit. False","title":"export"},{"location":"cli/reference/#import","text":"Add assets into a project Files can be paths to files or to folders. You can provide several paths separated by spaces. If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns: external_id : external id of the asset. content : paths to the asset file or a url hosting the asset. Examples kili project import \\ dir1/dir2/ dir1/dir3/test1.png \\ --project-id <project_id> kili project import \\ dir1/dir3/video.mp4 \\ --project-id <project_id> \\ --frames \\ --fps 24 kili project import \\ --from-csv assets_list.csv \\ --project-id <project_id> \\ --frames \\ --fps 24 Unsupported imports Currently, this command does not support: the import of videos from local frames, rich text and time series assets the import of assets with metadata or with a custom external_id For such imports, please use the append_many_to_dataset method in the Kili SDK. Usage: kili project import [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:external_id, content required columns: None --frames boolean Only for a frame project, import videos as frames. The import time is longer with this option. False --fps integer Only for a frame project, import videos with a specific frame rate None --verbose boolean Show more logs False --help boolean Show this message and exit. False","title":"import"},{"location":"cli/reference/#label","text":"Import labels or predictions Files can be paths to files or to folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. Examples To import default labels: kili project label \\ dir/labels/ dir/ground-truth/image1.json \\ --project-id <project_id> To import labels as predictions: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-run-3 To import labels as predictions in the Yolo v5 format into a target job: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-v5 \\ --metadata-file classes.yml \\ --target-job IMAGE_DETECTION_JOB \\ --input-format yolo_v5 Usage: kili project label [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --prediction boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface False --model-name text Name of the model that generated predictions, if labels are sent as predictions None --verbose boolean Show more logs False --input-format choice ( yolo_v4 | yolo_v5 | yolo_v7 | kili | raw ) Format in which the labels are encoded kili --metadata-file text File containing format metadata (if relevant to the input format) None --target-job text Job name in the project where to upload the labels (if relevant to the input format) None --help boolean Show this message and exit. False","title":"label"},{"location":"cli/reference/#list","text":"List your projects Examples kili project list --max 10 --stdout-format pretty Usage: kili project list [OPTIONS] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --max integer Maximum number of project to display. 100 --help boolean Show this message and exit. False","title":"list"},{"location":"cli/reference/#member","text":"Commands to interact with Kili project members Usage: kili project member [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"member"},{"location":"cli/reference/#add","text":"Add members to a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member add \\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com jane.doe@test.com kili project member add \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member add \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member add [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"add"},{"location":"cli/reference/#list_1","text":"List the members of the project Examples kili project member list <project_id> --stdout-format pretty Usage: kili project member list [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False","title":"list"},{"location":"cli/reference/#rm","text":"Remove members from a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member rm \\ --project-id <project_id> \\ john.doe@test.com kili project member rm \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member rm \\ --project-id <project_id> \\ --all Usage: kili project member rm [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:email required columns: role None --all boolean Remove all users from project False --help boolean Show this message and exit. False","title":"rm"},{"location":"cli/reference/#update","text":"Update member's role of a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member update\\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com kili project member update \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member update \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member update [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"update"},{"location":"sdk/api_key/","text":"API Key module Queries Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"user_id\" , \"api_key_id\" , \"api_key\" ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm , ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( \"data\" , result ) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) return format_result ( \"data\" , result , int ) api_keys ( self , api_key_id = None , user_id = None , api_key = None , skip = 0 , fields = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. None disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"user_id\" , \"api_key_id\" , \"api_key\" ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm , ) if as_generator : return api_keys_generator return list ( api_keys_generator ) count_api_keys ( self , api_key_id = None , user_id = None , api_key = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"API Key"},{"location":"sdk/api_key/#api-key-module","text":"","title":"API Key module"},{"location":"sdk/api_key/#queries","text":"Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"user_id\" , \"api_key_id\" , \"api_key\" ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm , ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( \"data\" , result ) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","text":"Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. None disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"user_id\" , \"api_key_id\" , \"api_key\" ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm , ) if as_generator : return api_keys_generator return list ( api_keys_generator )","title":"api_keys()"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , \"apiKey\" : api_key }, \"id\" : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_api_keys()"},{"location":"sdk/asset/","text":"Asset module Queries Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"skip\" , \"first\" , \"disable_tqdm\" , \"format\" , \"fields\" , \"self\" , \"as_generator\" , \"message\" , \"download_media\" , \"local_media_dir\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } post_call_process = get_post_assets_call_process ( download_media , local_media_dir , project_id ) asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm , post_call_process , ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( \"data\" , result , _object = List [ Asset ]) return assets @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) variables = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) return format_result ( \"data\" , result , int ) assets ( self , project_id , asset_id = None , skip = 0 , fields = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in = None , consensus_mark_gt = None , consensus_mark_lt = None , disable_tqdm = False , external_id_contains = None , first = None , format = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_type_in = None , metadata_where = None , skipped = None , status_in = None , updated_at_gte = None , updated_at_lte = None , as_generator = False , label_category_search = None , download_media = False , local_media_dir = None ) Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None download_media bool Tell is the media have to be downloaded or not. False local_media_dir Optional[str] Directory where the media are downloaded if download_media is True. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"skip\" , \"first\" , \"disable_tqdm\" , \"format\" , \"fields\" , \"self\" , \"as_generator\" , \"message\" , \"download_media\" , \"local_media_dir\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } post_call_process = get_post_assets_call_process ( download_media , local_media_dir , project_id ) asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm , post_call_process , ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) count_assets ( self , project_id , asset_id = None , asset_id_in = None , external_id_contains = None , metadata_where = None , status_in = None , consensus_mark_gt = None , consensus_mark_lt = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_type_in = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , skipped = None , updated_at_gte = None , updated_at_lte = None , label_category_search = None ) Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default project_id str Identifier of the project required asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) variables = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) return format_result ( \"data\" , result , int ) Mutations Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The asset IDs to modify external_ids: Change the external id of the assets priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[ ['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"external_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"external_ids\" ], \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) @typechecked def add_to_review ( self , asset_ids : List [ str ]) -> Dict : \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset IDs to add to review Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) return format_result ( \"data\" , results [ 0 ]) @typechecked def send_back_to_queue ( self , asset_ids : List [ str ]) -> Dict [ str , str ]: \"\"\"Send assets back to queue. Args: asset_ids: The IDs of the assets to send back to queue. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) return format_result ( \"data\" , results [ 0 ]) add_to_review ( self , asset_ids ) Add assets to review. Warning Assets without any label will be ignored. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to add to review required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . add_to_review ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], Source code in kili/mutations/asset/__init__.py @typechecked def add_to_review ( self , asset_ids : List [ str ]) -> Dict : \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset IDs to add to review Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) return format_result ( \"data\" , results [ 0 ]) append_many_to_dataset ( self , project_id , content_array = None , external_id_array = None , id_array = None , is_honeypot_array = None , status_array = None , json_content_array = None , json_metadata_array = None , disable_tqdm = False ) Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. For an VIDEO_LEGACY project, the content can be only be URLs None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for VIDEO or TEXT projects only. For VIDEO projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None disable_tqdm bool If True , the progress bar will be disabled False Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result delete_many_from_dataset ( self , asset_ids ) Delete assets from a project. Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description Asset A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) send_back_to_queue ( self , asset_ids ) Send assets back to queue. Parameters: Name Type Description Default asset_ids List[str] The IDs of the assets to send back to queue. required Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . send_back_to_queue ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], Source code in kili/mutations/asset/__init__.py @typechecked def send_back_to_queue ( self , asset_ids : List [ str ]) -> Dict [ str , str ]: \"\"\"Send assets back to queue. Args: asset_ids: The IDs of the assets to send back to queue. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) return format_result ( \"data\" , results [ 0 ]) update_properties_in_assets ( self , asset_ids , external_ids = None , priorities = None , json_metadatas = None , consensus_marks = None , honeypot_marks = None , to_be_labeled_by_array = None , contents = None , json_contents = None , status_array = None , is_used_for_consensus_array = None , is_honeypot_array = None ) Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets. By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , REVIEWED None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Returns: Type Description List[dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [ [ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The asset IDs to modify external_ids: Change the external id of the assets priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[ ['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"external_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"external_ids\" ], \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"Asset"},{"location":"sdk/asset/#asset-module","text":"","title":"Asset module"},{"location":"sdk/asset/#queries","text":"Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"skip\" , \"first\" , \"disable_tqdm\" , \"format\" , \"fields\" , \"self\" , \"as_generator\" , \"message\" , \"download_media\" , \"local_media_dir\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } post_call_process = get_post_assets_call_process ( download_media , local_media_dir , project_id ) asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm , post_call_process , ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( \"data\" , result , _object = List [ Asset ]) return assets @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) variables = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets","text":"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None download_media bool Tell is the media have to be downloaded or not. False local_media_dir Optional[str] Directory where the media are downloaded if download_media is True. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"skip\" , \"first\" , \"disable_tqdm\" , \"format\" , \"fields\" , \"self\" , \"as_generator\" , \"message\" , \"download_media\" , \"local_media_dir\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } post_call_process = get_post_assets_call_process ( download_media , local_media_dir , project_id ) asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm , post_call_process , ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator )","title":"assets()"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","text":"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default project_id str Identifier of the project required asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) variables = { \"where\" : { \"id\" : asset_id , \"project\" : { \"id\" : project_id , }, \"externalIdStrictlyIn\" : external_id_contains , \"statusIn\" : status_in , \"consensusMarkGte\" : consensus_mark_gt , \"consensusMarkLte\" : consensus_mark_lt , \"honeypotMarkGte\" : honeypot_mark_gt , \"honeypotMarkLte\" : honeypot_mark_lt , \"idIn\" : asset_id_in , \"metadata\" : metadata_where , \"label\" : { \"typeIn\" : label_type_in , \"authorIn\" : label_author_in , \"consensusMarkGte\" : label_consensus_mark_gt , \"consensusMarkLte\" : label_consensus_mark_lt , \"createdAt\" : label_created_at , \"createdAtGte\" : label_created_at_gt , \"createdAtLte\" : label_created_at_lt , \"honeypotMarkGte\" : label_honeypot_mark_gt , \"honeypotMarkLte\" : label_honeypot_mark_lt , \"search\" : label_category_search , }, \"skipped\" : skipped , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_assets()"},{"location":"sdk/asset/#mutations","text":"Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The asset IDs to modify external_ids: Change the external id of the assets priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[ ['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"external_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"external_ids\" ], \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) @typechecked def add_to_review ( self , asset_ids : List [ str ]) -> Dict : \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset IDs to add to review Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) return format_result ( \"data\" , results [ 0 ]) @typechecked def send_back_to_queue ( self , asset_ids : List [ str ]) -> Dict [ str , str ]: \"\"\"Send assets back to queue. Args: asset_ids: The IDs of the assets to send back to queue. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) return format_result ( \"data\" , results [ 0 ])","title":"Mutations"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.add_to_review","text":"Add assets to review. Warning Assets without any label will be ignored. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to add to review required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . add_to_review ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], Source code in kili/mutations/asset/__init__.py @typechecked def add_to_review ( self , asset_ids : List [ str ]) -> Dict : \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset IDs to add to review Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) return format_result ( \"data\" , results [ 0 ])","title":"add_to_review()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","text":"Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. For an VIDEO_LEGACY project, the content can be only be URLs None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for VIDEO or TEXT projects only. For VIDEO projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None disable_tqdm bool If True , the progress bar will be disabled False Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result","title":"append_many_to_dataset()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","text":"Delete assets from a project. Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description Asset A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset )","title":"delete_many_from_dataset()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.send_back_to_queue","text":"Send assets back to queue. Parameters: Name Type Description Default asset_ids List[str] The IDs of the assets to send back to queue. required Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . send_back_to_queue ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], Source code in kili/mutations/asset/__init__.py @typechecked def send_back_to_queue ( self , asset_ids : List [ str ]) -> Dict [ str , str ]: \"\"\"Send assets back to queue. Args: asset_ids: The IDs of the assets to send back to queue. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\" ], \"\"\" properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) return format_result ( \"data\" , results [ 0 ])","title":"send_back_to_queue()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","text":"Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets. By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , REVIEWED None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Returns: Type Description List[dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [ [ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The asset IDs to modify external_ids: Change the external id of the assets priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[ ['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"external_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"external_ids\" ], \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"update_properties_in_assets()"},{"location":"sdk/issue/","text":"Issue module Queries Set of Issue queries. Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm , ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( \"data\" , result ) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) count_issues ( self , project_id = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) issues ( self , project_id , fields = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default project_id str Project ID the issue belongs to. required fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. None skip int Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm , ) if as_generator : return issues_generator return list ( issues_generator ) Mutations Set of Issue mutations. Source code in kili/mutations/issue/__init__.py class MutationsIssue : \"\"\"Set of Issue mutations.\"\"\" # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : asset_id = cast ( List [ Dict ], list ( QueriesLabel ( self . auth ) . labels ( project_id = project_id , label_id = label_id , fields = [ \"labelOf.id\" ], disable_tqdm = True , ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result ) append_to_issues ( self , label_id , project_id , object_mid = None , text = None , type_ = 'ISSUE' ) Create an issue. Parameters: Name Type Description Default label_id str Id of the label to add an issue to required object_mid Optional[str] Mid of the object in the label to associate the issue to None type_ Literal['ISSUE', 'QUESTION'] type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" 'ISSUE' text Optional[str] If given, write a comment related to the issue None project_id str Id of the project required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/issue/__init__.py @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : asset_id = cast ( List [ Dict ], list ( QueriesLabel ( self . auth ) . labels ( project_id = project_id , label_id = label_id , fields = [ \"labelOf.id\" ], disable_tqdm = True , ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"Issue"},{"location":"sdk/issue/#issue-module","text":"","title":"Issue module"},{"location":"sdk/issue/#queries","text":"Set of Issue queries. Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm , ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( \"data\" , result ) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"Queries"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"count_issues()"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.issues","text":"Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default project_id str Project ID the issue belongs to. required fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. None skip int Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"project\" : { \"id\" : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm , ) if as_generator : return issues_generator return list ( issues_generator )","title":"issues()"},{"location":"sdk/issue/#mutations","text":"Set of Issue mutations. Source code in kili/mutations/issue/__init__.py class MutationsIssue : \"\"\"Set of Issue mutations.\"\"\" # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : asset_id = cast ( List [ Dict ], list ( QueriesLabel ( self . auth ) . labels ( project_id = project_id , label_id = label_id , fields = [ \"labelOf.id\" ], disable_tqdm = True , ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/issue/#kili.mutations.issue.__init__.MutationsIssue.append_to_issues","text":"Create an issue. Parameters: Name Type Description Default label_id str Id of the label to add an issue to required object_mid Optional[str] Mid of the object in the label to associate the issue to None type_ Literal['ISSUE', 'QUESTION'] type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" 'ISSUE' text Optional[str] If given, write a comment related to the issue None project_id str Id of the project required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/issue/__init__.py @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : asset_id = cast ( List [ Dict ], list ( QueriesLabel ( self . auth ) . labels ( project_id = project_id , label_id = label_id , fields = [ \"labelOf.id\" ], disable_tqdm = True , ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"append_to_issues()"},{"location":"sdk/label/","text":"Label module Queries Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"as_generator\" , \"disable_tqdm\" , \"fields\" , \"first\" , \"id_contains\" , \"self\" , \"skip\" , \"message\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"idIn\" : id_contains , \"search\" : category_search , \"typeIn\" : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm , ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ] ) -> Iterable [ Dict ]: payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( \"data\" , result , _object = List [ LabelType ]) # type:ignore # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( list ( projects )) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ \"labels.\" + field for field in fields ], ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. project_id: Identifier of the project. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) variables = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"search\" : category_search , \"typeIn\" : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) return format_result ( \"data\" , result , int ) def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp )) count_labels ( self , project_id , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , honeypot_mark_gte = None , honeypot_mark_lte = None , label_id = None , type_in = None , user_id = None , category_search = None ) Get the number of labels for the given parameters. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None label_id Optional[str] Identifier of the label. None project_id str Identifier of the project. required type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. project_id: Identifier of the project. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) variables = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"search\" : category_search , \"typeIn\" : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) return format_result ( \"data\" , result , int ) export_labels ( self , project_id , filename , fmt , asset_ids = None , layout = 'split' , single_file = False , disable_tqdm = False , with_assets = True ) Export the project labels with the requested format into the requested output path. Parameters: Name Type Description Default filename str Relative or full path of the archive that will contain the exported data. required fmt Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc'] Format of the exported labels. required asset_ids Optional[List[str]] Optional list of the assets from which to export the labels. None layout Literal['split', 'merged'] Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. 'split' single_file bool Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). False disable_tqdm bool Disable the progress bar if True. False with_assets bool Download the assets in the export. True Info The supported formats are: Yolo V4, V5, V7 for object detection tasks (bounding box) Kili for all tasks. COCO for semantic segmentation tasks (bounding box and semantic segmentation) Pascal VOC for object detection tasks. Example from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") Source code in kili/queries/label/__init__.py def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp )) export_labels_as_df ( self , project_id , fields = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' ], asset_fields = [ 'externalId' ]) Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( list ( projects )) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ \"labels.\" + field for field in fields ], ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df labels ( self , project_id , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , fields = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' ], first = None , honeypot_mark_gte = None , honeypot_mark_lte = None , id_contains = None , label_id = None , skip = 0 , type_in = None , user_id = None , disable_tqdm = False , as_generator = False , category_search = None ) Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED , TO REVIEW or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None label_id Optional[str] Identifier of the label. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"as_generator\" , \"disable_tqdm\" , \"fields\" , \"first\" , \"id_contains\" , \"self\" , \"skip\" , \"message\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"idIn\" : id_contains , \"search\" : category_search , \"typeIn\" : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm , ) if as_generator : return labels_generator return list ( labels_generator ) Mutations Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ], ) -> Label : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { \"external_id_array\" : external_id_array , \"model_name_array\" : model_name_array , \"json_response_array\" : json_response_array , } def generate_variables ( batch ): return { \"data\" : { \"modelNameArray\" : batch [ \"model_name_array\" ], \"jsonResponseArray\" : [ dumps ( elem ) for elem in batch [ \"json_response_array\" ]], }, \"where\" : { \"externalIdStrictlyIn\" : batch [ \"external_id_array\" ], \"project\" : { \"id\" : project_id }, }, } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS , ) return format_result ( \"data\" , results [ 0 ], Label ) @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name ) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label ) append_labels ( self , asset_id_array = None , json_response_array = [], author_id_array = None , seconds_to_label_array = None , model_name = None , label_type = 'DEFAULT' , project_id = None , asset_external_id_array = None ) Append labels to assets. Parameters: Name Type Description Default asset_id_array Optional[List[str]] list of asset ids to append labels on None json_response_array List[Dict] list of labels to append [] author_id_array Optional[List[str]] list of the author id of the labels None seconds_to_label_array Optional[List[int]] list of times taken to produce the label, in seconds None model_name Optional[str] Only useful when uploading predictions. Name of the model when uploading predictions None label_type Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW'] Can be one of AUTOSAVE , DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' Returns: Type Description List A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( asset_id_array = [ 'cl9wmlkuc00050qsz6ut39g8h' , 'cl9wmlkuw00080qsz2kqh8aiy' ], json_response_array = [{ ... }, { ... }] ) Source code in kili/mutations/label/__init__.py @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name ) append_to_labels ( self , json_response , author_id = None , label_asset_external_id = None , label_asset_id = None , label_type = 'DEFAULT' , project_id = None , seconds_to_label = 0 ) [DEPRECATED] append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) create_honeypot ( self , json_response , asset_external_id = None , asset_id = None , project_id = None ) Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label ) create_predictions ( self , project_id , external_id_array , model_name_array , json_response_array ) Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ], ) -> Label : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { \"external_id_array\" : external_id_array , \"model_name_array\" : model_name_array , \"json_response_array\" : json_response_array , } def generate_variables ( batch ): return { \"data\" : { \"modelNameArray\" : batch [ \"model_name_array\" ], \"jsonResponseArray\" : [ dumps ( elem ) for elem in batch [ \"json_response_array\" ]], }, \"where\" : { \"externalIdStrictlyIn\" : batch [ \"external_id_array\" ], \"project\" : { \"id\" : project_id }, }, } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS , ) return format_result ( \"data\" , results [ 0 ], Label ) update_properties_in_label ( self , label_id , seconds_to_label = None , model_name = None , json_response = None ) Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) Subscriptions Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket label_created_or_updated ( self , project_id , callback ) Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description SubscriptionGraphQLClient A subscription client. Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"Label"},{"location":"sdk/label/#label-module","text":"","title":"Label module"},{"location":"sdk/label/#queries","text":"Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"as_generator\" , \"disable_tqdm\" , \"fields\" , \"first\" , \"id_contains\" , \"self\" , \"skip\" , \"message\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"idIn\" : id_contains , \"search\" : category_search , \"typeIn\" : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm , ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ] ) -> Iterable [ Dict ]: payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( \"data\" , result , _object = List [ LabelType ]) # type:ignore # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( list ( projects )) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ \"labels.\" + field for field in fields ], ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. project_id: Identifier of the project. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) variables = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"search\" : category_search , \"typeIn\" : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) return format_result ( \"data\" , result , int ) def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp ))","title":"Queries"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.count_labels","text":"Get the number of labels for the given parameters. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None label_id Optional[str] Identifier of the label. None project_id str Identifier of the project. required type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. project_id: Identifier of the project. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) variables = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"search\" : category_search , \"typeIn\" : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_labels()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels","text":"Export the project labels with the requested format into the requested output path. Parameters: Name Type Description Default filename str Relative or full path of the archive that will contain the exported data. required fmt Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc'] Format of the exported labels. required asset_ids Optional[List[str]] Optional list of the assets from which to export the labels. None layout Literal['split', 'merged'] Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. 'split' single_file bool Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). False disable_tqdm bool Disable the progress bar if True. False with_assets bool Download the assets in the export. True Info The supported formats are: Yolo V4, V5, V7 for object detection tasks (bounding box) Kili for all tasks. COCO for semantic segmentation tasks (bounding box and semantic segmentation) Pascal VOC for object detection tasks. Example from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") Source code in kili/queries/label/__init__.py def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp ))","title":"export_labels()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","text":"Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( list ( projects )) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ \"labels.\" + field for field in fields ], ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df","title":"export_labels_as_df()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.labels","text":"Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED , TO REVIEW or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None label_id Optional[str] Identifier of the label. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ \"as_generator\" , \"disable_tqdm\" , \"fields\" , \"first\" , \"id_contains\" , \"self\" , \"skip\" , \"message\" , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { \"where\" : { \"id\" : label_id , \"asset\" : { \"id\" : asset_id , \"externalIdStrictlyIn\" : asset_external_id_in , \"statusIn\" : asset_status_in , }, \"project\" : { \"id\" : project_id , }, \"user\" : { \"id\" : user_id , }, \"createdAt\" : created_at , \"createdAtGte\" : created_at_gte , \"createdAtLte\" : created_at_lte , \"authorIn\" : author_in , \"honeypotMarkGte\" : honeypot_mark_gte , \"honeypotMarkLte\" : honeypot_mark_lte , \"idIn\" : id_contains , \"search\" : category_search , \"typeIn\" : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm , ) if as_generator : return labels_generator return list ( labels_generator )","title":"labels()"},{"location":"sdk/label/#mutations","text":"Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ], ) -> Label : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { \"external_id_array\" : external_id_array , \"model_name_array\" : model_name_array , \"json_response_array\" : json_response_array , } def generate_variables ( batch ): return { \"data\" : { \"modelNameArray\" : batch [ \"model_name_array\" ], \"jsonResponseArray\" : [ dumps ( elem ) for elem in batch [ \"json_response_array\" ]], }, \"where\" : { \"externalIdStrictlyIn\" : batch [ \"external_id_array\" ], \"project\" : { \"id\" : project_id }, }, } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS , ) return format_result ( \"data\" , results [ 0 ], Label ) @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name ) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label )","title":"Mutations"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_labels","text":"Append labels to assets. Parameters: Name Type Description Default asset_id_array Optional[List[str]] list of asset ids to append labels on None json_response_array List[Dict] list of labels to append [] author_id_array Optional[List[str]] list of the author id of the labels None seconds_to_label_array Optional[List[int]] list of times taken to produce the label, in seconds None model_name Optional[str] Only useful when uploading predictions. Name of the model when uploading predictions None label_type Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW'] Can be one of AUTOSAVE , DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' Returns: Type Description List A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( asset_id_array = [ 'cl9wmlkuc00050qsz6ut39g8h' , 'cl9wmlkuw00080qsz2kqh8aiy' ], json_response_array = [{ ... }, { ... }] ) Source code in kili/mutations/label/__init__.py @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name )","title":"append_labels()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","text":"[DEPRECATED] append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label )","title":"append_to_labels()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","text":"Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label )","title":"create_honeypot()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","text":"Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ], ) -> Label : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { \"external_id_array\" : external_id_array , \"model_name_array\" : model_name_array , \"json_response_array\" : json_response_array , } def generate_variables ( batch ): return { \"data\" : { \"modelNameArray\" : batch [ \"model_name_array\" ], \"jsonResponseArray\" : [ dumps ( elem ) for elem in batch [ \"json_response_array\" ]], }, \"where\" : { \"externalIdStrictlyIn\" : batch [ \"external_id_array\" ], \"project\" : { \"id\" : project_id }, }, } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS , ) return format_result ( \"data\" , results [ 0 ], Label )","title":"create_predictions()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","text":"Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label )","title":"update_properties_in_label()"},{"location":"sdk/label/#subscriptions","text":"Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"Subscriptions"},{"location":"sdk/label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","text":"Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description SubscriptionGraphQLClient A subscription client. Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"label_created_or_updated()"},{"location":"sdk/notification/","text":"Notification module Queries Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( \"data\" , result ) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) count_notifications ( self , has_been_seen = None , user_id = None ) Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) notifications ( self , fields = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first = None , has_been_seen = None , notification_id = None , skip = 0 , user_id = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first Optional[int] Number of notifications to query None has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"Notification"},{"location":"sdk/notification/#notification-module","text":"","title":"Notification module"},{"location":"sdk/notification/#queries","text":"Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( \"data\" , result ) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","text":"Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_notifications()"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.notifications","text":"Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first Optional[int] Number of notifications to query None has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"notifications()"},{"location":"sdk/organization/","text":"Organization module Queries Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( \"data\" , result ) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result ) count_organizations ( self , email = None , organization_id = None ) Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) organization_metrics ( self , organization_id , start_date , end_date ) Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization required start_date datetime Start date of the metrics computation required end_date datetime End date of the metrics computation required Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result ) organizations ( self , email = None , organization_id = None , fields = [ 'id' , 'name' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first Optional[int] Maximum number of organizations to return. None skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"Organization"},{"location":"sdk/organization/#organization-module","text":"","title":"Organization module"},{"location":"sdk/organization/#queries","text":"Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( \"data\" , result ) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result )","title":"Queries"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","text":"Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_organizations()"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","text":"Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization required start_date datetime Start date of the metrics computation required end_date datetime End date of the metrics computation required Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result )","title":"organization_metrics()"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","text":"Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first Optional[int] Maximum number of organizations to return. None skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"organizations()"},{"location":"sdk/project/","text":"Project module Queries Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ Dict ], Generator ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"project_id\" , \"search_query\" , \"should_relaunch_kpi_computation\" , \"updated_at_gte\" , \"updated_at_lte\" , ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm , ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( \"data\" , result ) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) return format_result ( \"data\" , result , int ) count_projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None ) Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) return format_result ( \"data\" , result , int ) projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None , skip = 0 , fields = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first Optional[int] Maximum number of projects to return. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[Dict], Generator] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ Dict ], Generator ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"project_id\" , \"search_query\" , \"should_relaunch_kpi_computation\" , \"updated_at_gte\" , \"updated_at_lte\" , ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm , ) if as_generator : return projects_generator return list ( projects_generator ) Mutations Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\"Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , str ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result ) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , ) -> str : \"\"\"Copy an existing project. Copy an existing source project from its ID. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Copy the json interface from the source project to the new one. copy_quality_settings: Copy the quality settings from the source project to the new one. copy_members: Copy the members from the source project to the new one. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return CopyProject ( self . auth ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , ) append_to_roles ( self , project_id , user_email , role = 'LABELER' ) Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description Dict[str, Union[str, dict, list]] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) archive_project ( self , project_id ) Archive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) copy_project ( self , from_project_id , title = None , description = None , copy_json_interface = True , copy_quality_settings = True , copy_members = True ) Copy an existing project. Copy an existing source project from its ID. Parameters: Name Type Description Default from_project_id str Project ID to copy from. required title Optional[str] Title for the new project. Defaults to source project title if None is provided. None description Optional[str] Description for the new project. Defaults to empty string if None is provided. None copy_json_interface bool Copy the json interface from the source project to the new one. True copy_quality_settings bool Copy the quality settings from the source project to the new one. True copy_members bool Copy the members from the source project to the new one. True Returns: Type Description str The created project ID. Examples: >>> kili . copy_project ( from_project_id = \"clbqn56b331234567890l41c0\" ) Source code in kili/mutations/project/__init__.py @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , ) -> str : \"\"\"Copy an existing project. Copy an existing source project from its ID. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Copy the json interface from the source project to the new one. copy_quality_settings: Copy the quality settings from the source project to the new one. copy_members: Copy the members from the source project to the new one. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return CopyProject ( self . auth ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , ) create_project ( self , input_type , json_interface , title , description = '' , project_type = None ) Create a project. Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str Title of the project required description str Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) delete_from_roles ( self , role_id ) Delete users by their role_id. Parameters: Name Type Description Default role_id str Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) delete_project ( self , project_id ) Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description str A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) unarchive_project ( self , project_id ) Unarchive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) update_properties_in_project ( self , project_id , can_navigate_between_assets = None , can_skip_asset = None , consensus_mark = None , consensus_tot_coverage = None , description = None , honeypot_mark = None , instructions = None , input_type = None , json_interface = None , min_consensus_size = None , number_of_assets = None , number_of_skipped_assets = None , number_of_remaining_assets = None , number_of_reviewed_assets = None , review_coverage = None , should_relaunch_kpi_computation = None , title = None , use_honeypot = None , metadata_types = None ) Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required can_navigate_between_assets Optional[bool] Activate / Deactivate the use of next and previous buttons in labeling interface. None can_skip_asset Optional[bool] Activate / Deactivate the use of skip button in labeling interface. None consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None input_type Optional[str] Currently, one of AUDIO , IMAGE , PDF , TEXT , VIDEO , VIDEO_LEGACY . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_skipped_assets Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None metadata_types Optional[dict] Types of the project metadata. Should be a dict of metadata fields name as keys and metadata types as values. Currently, possible types are: string , number None Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Change Metadata Types Metadata fields are by default interpreted as string types. To change the type of a metadata field, you can use the update_properties_in_project function with the metadata_types argument. metadata_types is given as a dict of metadata field names as keys and metadata types as values. Example: kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) Not providing a type for a metadata field or providing an unsupported one will default to the string type. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , str ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) update_properties_in_role ( self , role_id , project_id , user_id , role ) Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result )","title":"Project"},{"location":"sdk/project/#project-module","text":"","title":"Project module"},{"location":"sdk/project/#queries","text":"Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ Dict ], Generator ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"project_id\" , \"search_query\" , \"should_relaunch_kpi_computation\" , \"updated_at_gte\" , \"updated_at_lte\" , ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm , ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( \"data\" , result ) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.count_projects","text":"Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_projects()"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.projects","text":"Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first Optional[int] Maximum number of projects to return. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[Dict], Generator] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ Dict ], Generator ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ \"project_id\" , \"search_query\" , \"should_relaunch_kpi_computation\" , \"updated_at_gte\" , \"updated_at_lte\" , ] } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : project_id , \"searchQuery\" : search_query , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"updatedAtGte\" : updated_at_gte , \"updatedAtLte\" : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm , ) if as_generator : return projects_generator return list ( projects_generator )","title":"projects()"},{"location":"sdk/project/#mutations","text":"Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\"Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , str ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result ) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , ) -> str : \"\"\"Copy an existing project. Copy an existing source project from its ID. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Copy the json interface from the source project to the new one. copy_quality_settings: Copy the quality settings from the source project to the new one. copy_members: Copy the members from the source project to the new one. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return CopyProject ( self . auth ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , )","title":"Mutations"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","text":"Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description Dict[str, Union[str, dict, list]] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result )","title":"append_to_roles()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.archive_project","text":"Archive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result )","title":"archive_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.copy_project","text":"Copy an existing project. Copy an existing source project from its ID. Parameters: Name Type Description Default from_project_id str Project ID to copy from. required title Optional[str] Title for the new project. Defaults to source project title if None is provided. None description Optional[str] Description for the new project. Defaults to empty string if None is provided. None copy_json_interface bool Copy the json interface from the source project to the new one. True copy_quality_settings bool Copy the quality settings from the source project to the new one. True copy_members bool Copy the members from the source project to the new one. True Returns: Type Description str The created project ID. Examples: >>> kili . copy_project ( from_project_id = \"clbqn56b331234567890l41c0\" ) Source code in kili/mutations/project/__init__.py @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , ) -> str : \"\"\"Copy an existing project. Copy an existing source project from its ID. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Copy the json interface from the source project to the new one. copy_quality_settings: Copy the quality settings from the source project to the new one. copy_members: Copy the members from the source project to the new one. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return CopyProject ( self . auth ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , )","title":"copy_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.create_project","text":"Create a project. Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str Title of the project required description str Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result )","title":"create_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","text":"Delete users by their role_id. Parameters: Name Type Description Default role_id str Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result )","title":"delete_from_roles()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_project","text":"Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description str A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result )","title":"delete_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.unarchive_project","text":"Unarchive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result )","title":"unarchive_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","text":"Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required can_navigate_between_assets Optional[bool] Activate / Deactivate the use of next and previous buttons in labeling interface. None can_skip_asset Optional[bool] Activate / Deactivate the use of skip button in labeling interface. None consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None input_type Optional[str] Currently, one of AUDIO , IMAGE , PDF , TEXT , VIDEO , VIDEO_LEGACY . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_skipped_assets Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None metadata_types Optional[dict] Types of the project metadata. Should be a dict of metadata fields name as keys and metadata types as values. Currently, possible types are: string , number None Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Change Metadata Types Metadata fields are by default interpreted as string types. To change the type of a metadata field, you can use the update_properties_in_project function with the metadata_types argument. metadata_types is given as a dict of metadata field names as keys and metadata types as values. Example: kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) Not providing a type for a metadata field or providing an unsupported one will default to the string type. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , str ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","text":"Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_role()"},{"location":"sdk/project_user/","text":"Project User module Queries Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id , } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm , ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( \"data\" , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) return format_result ( \"data\" , result , int ) count_project_users ( self , project_id , email = None , id = None , organization_id = None ) Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id str Identifier of the project required Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) return format_result ( \"data\" , result , int ) project_users ( self , project_id , email = None , id = None , organization_id = None , fields = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default project_id str Identifier of the project required email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first Optional[int] Maximum number of users to return None skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id , } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm , ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"Project User"},{"location":"sdk/project_user/#project-user-module","text":"","title":"Project User module"},{"location":"sdk/project_user/#queries","text":"Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id , } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm , ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( \"data\" , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","text":"Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id str Identifier of the project required Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_project_users()"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","text":"Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default project_id str Identifier of the project required email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first Optional[int] Maximum number of users to return None skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id , } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : id , \"project\" : { \"id\" : project_id , }, \"user\" : { \"email\" : email , \"organization\" : { \"id\" : organization_id , }, }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm , ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"project_users()"},{"location":"sdk/project_version/","text":"Project Version module Queries Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( \"data\" , result ) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) count_project_versions ( self , project_id ) Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) project_version ( self , project_id , first = None , skip = 0 , fields = [ 'createdAt' , 'id' , 'content' , 'name' , 'projectId' ], disable_tqdm = False , as_generator = False ) Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default project_id str Filter on Id of project required fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'projectId'] first Optional[int] Number of project versions to query None skip int Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) Mutations Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result ) update_properties_in_project_version ( self , project_version_id , content ) Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"Project Version"},{"location":"sdk/project_version/#project-version-module","text":"","title":"Project Version module"},{"location":"sdk/project_version/#queries","text":"Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( \"data\" , result ) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"Queries"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","text":"Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"count_project_versions()"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","text":"Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default project_id str Filter on Id of project required fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'projectId'] first Optional[int] Number of project versions to query None skip int Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator )","title":"project_version()"},{"location":"sdk/project_version/#mutations","text":"Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","text":"Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_project_version()"},{"location":"sdk/user/","text":"User module Queries Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { \"where\" : { \"apiKey\" : api_key , \"email\" : email , \"organization\" : { \"id\" : organization_id , }, } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm , ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( \"data\" , result ) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { \"where\" : { \"organization\" : { \"id\" : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( \"data\" , result , int ) count_users ( self , organization_id = None ) Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { \"where\" : { \"organization\" : { \"id\" : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( \"data\" , result , int ) users ( self , api_key = None , email = None , organization_id = None , fields = [ 'email' , 'id' , 'firstname' , 'lastname' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first Optional[int] Maximum number of users to return None skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { \"where\" : { \"apiKey\" : api_key , \"email\" : email , \"organization\" : { \"id\" : organization_id , }, } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm , ) if as_generator : return users_generator return list ( users_generator ) Mutations Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result ) create_user ( self , email , password , organization_role , firstname = None , lastname = None ) Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. required password str On the first sign in, he will use this password and be able to change it. required organization_role str One of \"ADMIN\", \"USER\". required firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) reset_password ( self , email ) Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) update_password ( self , email , old_password , new_password_1 , new_password_2 ) Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) update_properties_in_user ( self , email , firstname = None , lastname = None , organization_id = None , organization_role = None , activated = None ) Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"User"},{"location":"sdk/user/#user-module","text":"","title":"User module"},{"location":"sdk/user/#queries","text":"Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { \"where\" : { \"apiKey\" : api_key , \"email\" : email , \"organization\" : { \"id\" : organization_id , }, } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm , ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( \"data\" , result ) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { \"where\" : { \"organization\" : { \"id\" : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.count_users","text":"Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { \"where\" : { \"organization\" : { \"id\" : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_users()"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.users","text":"Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first Optional[int] Maximum number of users to return None skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { \"where\" : { \"apiKey\" : api_key , \"email\" : email , \"organization\" : { \"id\" : organization_id , }, } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm , ) if as_generator : return users_generator return list ( users_generator )","title":"users()"},{"location":"sdk/user/#mutations","text":"Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.create_user","text":"Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. required password str On the first sign in, he will use this password and be able to change it. required organization_role str One of \"ADMIN\", \"USER\". required firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result )","title":"create_user()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.reset_password","text":"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result )","title":"reset_password()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_password","text":"Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result )","title":"update_password()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","text":"Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_user()"},{"location":"sdk/tutorials/export_a_kili_project/","text":"How to export a Kili project Outline This tutorial explains the multiple ways to export a Kili project. It describes a per-label method involving label filtering and conversion, and also the solutions performing a full-project export. The methods are illustrated with code snippets. Export methods With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it: Fetch the assets and/or the labels one by one using .assets or .labels , perform the data transformation yourself, then write the data to one or several output files. Export the whole project as a dataset. To do that, use the .export_labels method that creates an archive containing the labels in your chosen format. Preliminary steps Fetch the project ID from the Kili UI (in Settings / Admin): Ensure that your Kili API key as been set as an environment variable: export KILI_API_KEY = <YOUR_API_KEY> Install Kili if it has not been done already. pip install --upgrade kili Import packages and instantiate Kili : from kili.client import Kili from pathlib import Path kili = Kili () Exporting assets and labels one by one To retrieve all assets of a project one by one, perform the following steps: Exporting the latest labels per asset First, fetch the assets: assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"latestLabel.jsonResponse\" ]) Now if you print an asset, you will see that you can access its latestLabel : print ( assets [ 0 ]) { 'latestLabel' : { 'jsonResponse' : { 'CLASSIFICATION_JOB' : { 'categories' : [{ 'name' : 'VEHICLE' }]}}}, 'externalId' : '0' } You can now get your label this way, and for example write the category name into a 0.txt file: for asset in assets : if asset [ \"latestLabel\" ]: # covers the assets without label class_ = asset [ \"latestLabel\" ][ \"jsonResponse\" ][ \"CLASSIFICATION_JOB\" ][ \"categories\" ][ 0 ][ \"name\" ] with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".txt\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( class_ ) Filtering specific labels per asset through the method filters You can specify label filters directly in the .assets and the .labels methods. The available filters are listed in the arguments of these methods. When done, you can write the conversion code to obtain the data in the format that you need. Get only the assets that have labels with a consensus mark above 0.7 assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"labels.jsonResponse\" ], label_consensus_mark_gt = 0.7 ) # + asset conversion code Get all the labels with a consensus mark above 0.7 labels = kili . labels ( \"<your_project_id>\" , fields = [ \"labelOf.externalId\" , \"jsonResponse\" ], consensus_mark_gt = 0.7 ) # + label conversion code Get all the labels done by a specific project member labels = kili . labels ( \"<your_project_id>\" , fields = [ \"labelOf.externalId\" , \"jsonResponse\" ], author_in = [ \"John Smith\" ]) # + label conversion code will directly return a list of labels authored by John Smith. In the author_in , you can also pass the first name, the last name, or the first name + last name of the user for which you want to fetch the labels. Filtering specific labels per asset through the label properties You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field \"labels.isLatestReviewLabelForUser\" to check if the label is the latest per user. from kili.client import Kili from pathlib import Path import json assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"labels.jsonResponse\" , \"labels.isLatestReviewLabelForUser\" ]) for asset in assets : if asset [ \"labels\" ]: # covers the assets without annotations for label in asset [ \"labels\" ]: if label [ \"isLatestReviewLabelForUser\" ] and \"JOB_0\" in label [ \"jsonResponse\" ]: annotation = label [ \"jsonResponse\" ][ \"JOB_0\" ] with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( annotation )) break # once we find a latest label done by a reviewer, we move on to the next asset. Filtering the latest label per annotator When working on project with consensus enabled, it can be useful to export the latest label made by each annotator: from kili.client import Kili from collections import defaultdict from pathlib import Path import json kili = Kili () assets = kili . assets ( \"clb54wfkn01zb0kyadscgaf5j\" , fields = [ \"externalId\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.labelType\" , \"labels.jsonResponse\" , ], ) for asset in assets : if asset [ \"labels\" ]: latest_label_by_user = defaultdict ( list ) for label in asset [ \"labels\" ]: if label [ \"labelType\" ] == \"DEFAULT\" : latest_label_by_user [ label [ \"author\" ][ \"email\" ]] . append ( label ) latest_label_per_user = { email : max ( labels , key = lambda x : x [ \"createdAt\" ]) for email , labels in latest_label_by_user . items () } with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( latest_label_per_user )) Exporting a whole project There is also a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats. Available formats Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 The .export_labels method The .export_labels method enables the export of a full project. It does the following preprocessing: Only fetches the labels of types \"DEFAULT\" and \"REVIEW\" (see the label types explanations ). If specified, selects a subset of asset ids. Exports labels to one of the standard formats (only available for a restricted set of ML tasks). The with_assets argument lets you decide if you want to include the assets in the export. The export_type argument tells if the latest label or all the labels are exported. The split_option argument tells if the export contains one folder for all the jobs, or one folder per job. The single_file argument tells if the labels data should be exported into one single file. Note that some formats are single file or multiple files only: Kili: single file or multiple files. YOLO: multiple files only. Pascal VOC: multiple files only. COCO: single-file only. For all the formats, in the output archive, a README.kili.txt file is also created. Here is an example of its contents: Exported Labels from KILI ========================= - Project name: Awesome annotation project - Project identifier: abcdefghijklmnop - Project description: This project contains labels, most of which are awesome. - Export date: 20221125-093324 - Exported format: kili - Exported labels: latest Kili format, one file per asset The following code snippet exports all the assets payloads and the associated labels, with one json file per asset, into the /tmp/export.zip folder. from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"kili\" , ) Kili format, one file for the whole project This code snippet exports the assets payloads and the associated labels in one file for the whole project, into the /tmp/export.zip folder. from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"kili\" , single_file = True , ) YOLO formats You can also export to on of the YOLO format, when you have at least one Object Detection job with bounding boxes. You can choose the \"yolo_v4\" , \"yolo_v5\" or \"yolo_v7\" . The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, it produces one file per asset in the Yolo format, containing the last DEFAULT or REVIEW label that has been produced. Each YOLO label has the following shape: 2 0.25 0.67 0.26 0.34 ^ ^ ^ ^ ^ class x y w h where: class is the class index in the classes list contained in the YOLO metadata file. x is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box. y is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box. w is the width relative to the image width (between 0.0 and 1.0) of the bounding box. h is the height relative to the image height (between 0.0 and 1.0) of the bounding box. Here is an example of a YOLO annotation over an image: Here is how to export to YOLO (in this example, YOLOv5): from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) Please note that a standard YOLO file format must also include the path root to the assets, and also the train , val and test subfolders. Since this is up to the ML engineer or Data scientist to know which data goes where, we do not provide this layout. COCO format To export your data into the COCO format, run the following code: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"coco\" , ) This will create an archive containing both: The COCO annotation file. A folder data/ with all the assets. Summary In this tutorial, we have seen several ways to export labels from a Kili project: Using .assets and .labels and their filtering arguments, a subset of assets or labels can be selected and then exported. Using .export_labels , the whole project can be exported into a standard output format.","title":"Export"},{"location":"sdk/tutorials/export_a_kili_project/#how-to-export-a-kili-project","text":"","title":"How to export a Kili project"},{"location":"sdk/tutorials/export_a_kili_project/#outline","text":"This tutorial explains the multiple ways to export a Kili project. It describes a per-label method involving label filtering and conversion, and also the solutions performing a full-project export. The methods are illustrated with code snippets.","title":"Outline"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","text":"With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it: Fetch the assets and/or the labels one by one using .assets or .labels , perform the data transformation yourself, then write the data to one or several output files. Export the whole project as a dataset. To do that, use the .export_labels method that creates an archive containing the labels in your chosen format.","title":"Export methods"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","text":"Fetch the project ID from the Kili UI (in Settings / Admin): Ensure that your Kili API key as been set as an environment variable: export KILI_API_KEY = <YOUR_API_KEY> Install Kili if it has not been done already. pip install --upgrade kili Import packages and instantiate Kili : from kili.client import Kili from pathlib import Path kili = Kili ()","title":"Preliminary steps"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","text":"To retrieve all assets of a project one by one, perform the following steps:","title":"Exporting assets and labels one by one"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","text":"First, fetch the assets: assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"latestLabel.jsonResponse\" ]) Now if you print an asset, you will see that you can access its latestLabel : print ( assets [ 0 ]) { 'latestLabel' : { 'jsonResponse' : { 'CLASSIFICATION_JOB' : { 'categories' : [{ 'name' : 'VEHICLE' }]}}}, 'externalId' : '0' } You can now get your label this way, and for example write the category name into a 0.txt file: for asset in assets : if asset [ \"latestLabel\" ]: # covers the assets without label class_ = asset [ \"latestLabel\" ][ \"jsonResponse\" ][ \"CLASSIFICATION_JOB\" ][ \"categories\" ][ 0 ][ \"name\" ] with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".txt\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( class_ )","title":"Exporting the latest labels per asset"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","text":"You can specify label filters directly in the .assets and the .labels methods. The available filters are listed in the arguments of these methods. When done, you can write the conversion code to obtain the data in the format that you need. Get only the assets that have labels with a consensus mark above 0.7 assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"labels.jsonResponse\" ], label_consensus_mark_gt = 0.7 ) # + asset conversion code Get all the labels with a consensus mark above 0.7 labels = kili . labels ( \"<your_project_id>\" , fields = [ \"labelOf.externalId\" , \"jsonResponse\" ], consensus_mark_gt = 0.7 ) # + label conversion code Get all the labels done by a specific project member labels = kili . labels ( \"<your_project_id>\" , fields = [ \"labelOf.externalId\" , \"jsonResponse\" ], author_in = [ \"John Smith\" ]) # + label conversion code will directly return a list of labels authored by John Smith. In the author_in , you can also pass the first name, the last name, or the first name + last name of the user for which you want to fetch the labels.","title":"Filtering specific labels per asset through the method filters"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","text":"You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field \"labels.isLatestReviewLabelForUser\" to check if the label is the latest per user. from kili.client import Kili from pathlib import Path import json assets = kili . assets ( \"<your_project_id>\" , fields = [ \"externalId\" , \"labels.jsonResponse\" , \"labels.isLatestReviewLabelForUser\" ]) for asset in assets : if asset [ \"labels\" ]: # covers the assets without annotations for label in asset [ \"labels\" ]: if label [ \"isLatestReviewLabelForUser\" ] and \"JOB_0\" in label [ \"jsonResponse\" ]: annotation = label [ \"jsonResponse\" ][ \"JOB_0\" ] with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( annotation )) break # once we find a latest label done by a reviewer, we move on to the next asset.","title":"Filtering specific labels per asset through the label properties"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","text":"When working on project with consensus enabled, it can be useful to export the latest label made by each annotator: from kili.client import Kili from collections import defaultdict from pathlib import Path import json kili = Kili () assets = kili . assets ( \"clb54wfkn01zb0kyadscgaf5j\" , fields = [ \"externalId\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.labelType\" , \"labels.jsonResponse\" , ], ) for asset in assets : if asset [ \"labels\" ]: latest_label_by_user = defaultdict ( list ) for label in asset [ \"labels\" ]: if label [ \"labelType\" ] == \"DEFAULT\" : latest_label_by_user [ label [ \"author\" ][ \"email\" ]] . append ( label ) latest_label_per_user = { email : max ( labels , key = lambda x : x [ \"createdAt\" ]) for email , labels in latest_label_by_user . items () } with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( latest_label_per_user ))","title":"Filtering the latest label per annotator"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","text":"There is also a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats.","title":"Exporting a whole project"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705","title":"Available formats"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","text":"The .export_labels method enables the export of a full project. It does the following preprocessing: Only fetches the labels of types \"DEFAULT\" and \"REVIEW\" (see the label types explanations ). If specified, selects a subset of asset ids. Exports labels to one of the standard formats (only available for a restricted set of ML tasks). The with_assets argument lets you decide if you want to include the assets in the export. The export_type argument tells if the latest label or all the labels are exported. The split_option argument tells if the export contains one folder for all the jobs, or one folder per job. The single_file argument tells if the labels data should be exported into one single file. Note that some formats are single file or multiple files only: Kili: single file or multiple files. YOLO: multiple files only. Pascal VOC: multiple files only. COCO: single-file only. For all the formats, in the output archive, a README.kili.txt file is also created. Here is an example of its contents: Exported Labels from KILI ========================= - Project name: Awesome annotation project - Project identifier: abcdefghijklmnop - Project description: This project contains labels, most of which are awesome. - Export date: 20221125-093324 - Exported format: kili - Exported labels: latest","title":"The .export_labels method"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","text":"The following code snippet exports all the assets payloads and the associated labels, with one json file per asset, into the /tmp/export.zip folder. from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"kili\" , )","title":"Kili format, one file per asset"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","text":"This code snippet exports the assets payloads and the associated labels in one file for the whole project, into the /tmp/export.zip folder. from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"kili\" , single_file = True , )","title":"Kili format, one file for the whole project"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","text":"You can also export to on of the YOLO format, when you have at least one Object Detection job with bounding boxes. You can choose the \"yolo_v4\" , \"yolo_v5\" or \"yolo_v7\" . The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, it produces one file per asset in the Yolo format, containing the last DEFAULT or REVIEW label that has been produced. Each YOLO label has the following shape: 2 0.25 0.67 0.26 0.34 ^ ^ ^ ^ ^ class x y w h where: class is the class index in the classes list contained in the YOLO metadata file. x is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box. y is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box. w is the width relative to the image width (between 0.0 and 1.0) of the bounding box. h is the height relative to the image height (between 0.0 and 1.0) of the bounding box. Here is an example of a YOLO annotation over an image: Here is how to export to YOLO (in this example, YOLOv5): from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) Please note that a standard YOLO file format must also include the path root to the assets, and also the train , val and test subfolders. Since this is up to the ML engineer or Data scientist to know which data goes where, we do not provide this layout.","title":"YOLO formats"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","text":"To export your data into the COCO format, run the following code: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<your_project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"coco\" , ) This will create an archive containing both: The COCO annotation file. A folder data/ with all the assets.","title":"COCO format"},{"location":"sdk/tutorials/export_a_kili_project/#summary","text":"In this tutorial, we have seen several ways to export labels from a Kili project: Using .assets and .labels and their filtering arguments, a subset of assets or labels can be selected and then exported. Using .export_labels , the whole project can be exported into a standard output format.","title":"Summary"}]}