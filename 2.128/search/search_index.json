{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started with the Kili Python SDK What is Kili? Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here . If you are looking for the Kili product documentation, it is located here . The Kili Python SDK Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners. Requirements You only need Python 3.7 or higher. Installation Install the Kili client with pip: pip install kili Usage Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: python kili = Kili(api_key='<you api key value here>')","title":"Getting Started"},{"location":"#getting-started-with-the-kili-python-sdk","text":"","title":"Getting started with the Kili Python SDK"},{"location":"#what-is-kili","text":"Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info about the product here . If you are looking for the Kili product documentation, it is located here .","title":"What is Kili?"},{"location":"#the-kili-python-sdk","text":"Kili Python SDK has been designed to perform complex project-related tasks by using the Python programming language. Using Kili Python SDK, you can write scripts for repetitive tasks and then integrate them in one machine learning or data science workflow. For people who are familiar with Python, it may be perfect middle ground between complex GraphQL queries and simple, but less flexible CLI one-liners.","title":"The Kili Python SDK"},{"location":"#requirements","text":"You only need Python 3.7 or higher.","title":"Requirements"},{"location":"#installation","text":"Install the Kili client with pip: pip install kili","title":"Installation"},{"location":"#usage","text":"Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: python kili = Kili(api_key='<you api key value here>')","title":"Usage"},{"location":"label_export/","text":"Exporting kili projects There are several ways to export labels from a Kili project. With the CLI You can export a project using the kili project export command: kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export.zip More options here . With the Python SDK You can also use the Python SDK: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) More details here . From the Kili UI You can refer to this Kili documentation page . Available formats Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 And more to come!","title":"Exporting kili projects"},{"location":"label_export/#exporting-kili-projects","text":"There are several ways to export labels from a Kili project.","title":"Exporting kili projects"},{"location":"label_export/#with-the-cli","text":"You can export a project using the kili project export command: kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export.zip More options here .","title":"With the CLI"},{"location":"label_export/#with-the-python-sdk","text":"You can also use the Python SDK: from kili.client import Kili kili = Kili () kili . export_labels ( project_id = \"<project_id>\" , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) More details here .","title":"With the Python SDK"},{"location":"label_export/#from-the-kili-ui","text":"You can refer to this Kili documentation page .","title":"From the Kili UI"},{"location":"label_export/#available-formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 And more to come!","title":"Available formats"},{"location":"cli/","text":"Getting started with the Kili CLI What is Kili CLI Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks. Authentication Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Info While launching commands, you can also provide you API key through the --api-key option. If you set your api key in the KILI_API_KEY environment variable and provide it once again through the --api-key option, Kili CLI will use the api key value provided in command options. Usage The main command is kili . It currently has only one subcommand project that entails all the commands for project management : kili project [COMMAND] Workflow example Let's take an example where you want to start a project from scratch You can download ressources to run this example here . Once in the current directory where all files are stored, you can run the following commands: Create a project To create an IMAGE project: kili project create \\ json_interface.json \\ --title \"Quality inspection\" \\ --input-type IMAGE \\ --description \"Steel defects on production line\" Ouput: ID URL <project_id> https://cloud.kili-technology.com/label/projects/<project_id>/ List your projects kili project list --max 10 Ouput: TITLE ID PROGRESS DESCRIPTION Quality inspection <project_id> 0.0% Steel defects on production line... Recover your project ID export project_id=$(kili project list \\ | grep -m1 \"Quality inspection\" \\ | awk '{print $3}') Add a member to your project kili project member add \\ <email_adress> \\ --project-id $project_id \\ --role REVIEWER Ouput: 1 member(s) have been successfully added to project: <project_id> List the project's members kili project member list --project-id $project_id Ouput: ROLE NAME EMAIL ID ORGANIZATION ADMIN <your_name> <your_email> <your_member_id> <your_organization> REVIEWER <reviewer_name> <email_adress> <member_id> <your_organization> Import data to your project To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths) kili project import \\ assets \\ --project-id $project_id Ouput: 40 files have been successfully imported Import labels to your project To import labels, provide a list of files or folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths kili project label \\ ground_truths \\ --project-id $project_id Outputs: 40 labels have been successfully imported If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface. kili project label \\ ground_truths \\ --project-id $project_id \\ --prediction \\ --model-name YOLO-run-3 Outputs: 40 labels have been successfully imported Get metrics of your project kili project describe $project_id Ouput: Title Quality inspection Description Steel defects on production line Dataset KPIs ------------ Total number of assets 40 Number of remaining assets 10 Skipped assets 0 Progress 25.0% Quality KPIs ------------ Project consensus N/A Project honeypot N/A Number of reviewed assets 0 Number of open issues 0 Number of solved issues 0 Number of open questions 0 Number of solved questions 0","title":"Getting Started"},{"location":"cli/#getting-started-with-the-kili-cli","text":"","title":"Getting started with the Kili CLI"},{"location":"cli/#what-is-kili-cli","text":"Kili CLI has been designed to run key actions on your projects with powerful commands. For the actions it supports, the CLI offers a more compact way to manage your projects than the Python SDK. Note that the Python SDK offers more options and may still be used for more complex project management tasks.","title":"What is Kili CLI"},{"location":"cli/#authentication","text":"Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value that you copied earlier: export KILI_API_KEY = '<you api key value here>' Info While launching commands, you can also provide you API key through the --api-key option. If you set your api key in the KILI_API_KEY environment variable and provide it once again through the --api-key option, Kili CLI will use the api key value provided in command options.","title":"Authentication"},{"location":"cli/#usage","text":"The main command is kili . It currently has only one subcommand project that entails all the commands for project management : kili project [COMMAND]","title":"Usage"},{"location":"cli/#workflow-example","text":"Let's take an example where you want to start a project from scratch You can download ressources to run this example here . Once in the current directory where all files are stored, you can run the following commands:","title":"Workflow example"},{"location":"cli/#create-a-project","text":"To create an IMAGE project: kili project create \\ json_interface.json \\ --title \"Quality inspection\" \\ --input-type IMAGE \\ --description \"Steel defects on production line\" Ouput: ID URL <project_id> https://cloud.kili-technology.com/label/projects/<project_id>/","title":"Create a project"},{"location":"cli/#list-your-projects","text":"kili project list --max 10 Ouput: TITLE ID PROGRESS DESCRIPTION Quality inspection <project_id> 0.0% Steel defects on production line...","title":"List your projects"},{"location":"cli/#recover-your-project-id","text":"export project_id=$(kili project list \\ | grep -m1 \"Quality inspection\" \\ | awk '{print $3}')","title":"Recover your project ID"},{"location":"cli/#add-a-member-to-your-project","text":"kili project member add \\ <email_adress> \\ --project-id $project_id \\ --role REVIEWER Ouput: 1 member(s) have been successfully added to project: <project_id>","title":"Add a member to your project"},{"location":"cli/#list-the-projects-members","text":"kili project member list --project-id $project_id Ouput: ROLE NAME EMAIL ID ORGANIZATION ADMIN <your_name> <your_email> <your_member_id> <your_organization> REVIEWER <reviewer_name> <email_adress> <member_id> <your_organization>","title":"List the project's members"},{"location":"cli/#import-data-to-your-project","text":"To import data, provide a list of files or folders (you can also procide a csv file external_id and file's paths) kili project import \\ assets \\ --project-id $project_id Ouput: 40 files have been successfully imported","title":"Import data to your project"},{"location":"cli/#import-labels-to-your-project","text":"To import labels, provide a list of files or folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. In the demo folder, the labels are in a folder called ground_truths kili project label \\ ground_truths \\ --project-id $project_id Outputs: 40 labels have been successfully imported If you have run a pre-annotation model, you can also import labels as predictions. These labels will be seen as pre-annotation in the labeling interface. kili project label \\ ground_truths \\ --project-id $project_id \\ --prediction \\ --model-name YOLO-run-3 Outputs: 40 labels have been successfully imported","title":"Import labels to your project"},{"location":"cli/#get-metrics-of-your-project","text":"kili project describe $project_id Ouput: Title Quality inspection Description Steel defects on production line Dataset KPIs ------------ Total number of assets 40 Number of remaining assets 10 Skipped assets 0 Progress 25.0% Quality KPIs ------------ Project consensus N/A Project honeypot N/A Number of reviewed assets 0 Number of open issues 0 Number of solved issues 0 Number of open questions 0 Number of solved questions 0","title":"Get metrics of your project"},{"location":"cli/reference/","text":"kili Kili Command line Interface To get all the available commands, please type: kili project --help . Usage: kili [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --help boolean Show this message and exit. False project Commands to interact with a Kili project Usage: kili project [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False copy Copy an existing Kili project. The copy can include or not the json interface, quality settings, members, assets and labels of the source project. By default, only the json interface, quality settings and project members are copied. If no title is provided, the source project title will be used. If no description is provided, the description will be set to an empty string. Returns the new project id and title once the copy is finished. Examples Copy a project and set a new title and new description: kili project copy clbqn56b331234567890l41c0 \\ --title \"New project title\" \\ --description \"New project description\" Copy the json interface but not the members: kili project copy clbqn56b331234567890l41c0 \\ --with-json-interface \\ --without-members Usage: kili project copy [OPTIONS] FROM_PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --title text New project title. None --description text New project description. None --with-json-interface / --without-json-interface boolean Copy json interface. True --with-quality-settings / --without-quality-settings boolean Copy quality settings. True --with-members / --without-members boolean Copy members. True --with-assets / --without-assets boolean Copy assets. False --with-labels / --without-labels boolean Copy labels. False --help boolean Show this message and exit. False create Create a Kili project interface must be a path pointing to your json interface file If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied). Examples kili project create \\ path/to/interface.json \\ --input-type TEXT \\ --title \"Invoice annotation project\" kili project create \\ --from-project <project_id_src> \\ --input-type TEXT \\ --title \"Invoice annotation project\" To build a Kili project interface, please visit: https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings Usage: kili project create [OPTIONS] [INTERFACE] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --from-project text project_id of another Kili project None --title text Project Title. _required --input-type choice ( AUDIO | IMAGE | PDF | TEXT | TIME_SERIES | VIDEO | VIDEO_LEGACY ) Project input data type. Please check your license to see which ones you have access to. _required --description text Project description. `` --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False describe Show project description and analytics. Examples kili project describe --project-id <project_id> Usage: kili project describe [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --help boolean Show this message and exit. False export Export the Kili labels of a project to a given format. The supported formats are: YOLO V4, V5, V7 for object detection tasks (bounding box). Kili (a.k.a raw) for all tasks. COCO for object detection tasks (semantic or bounding box) Pascal VOC for object detection tasks. Examples kili project export \\ --project-id <project_id> \\ --output-format coco \\ --output-file /tmp/export.zip kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export_split.zip \\ --layout split Unsupported exports Currently, this command does not support the export of videos that have not been cut into separated frames. For such exports, please use the Kili UI. Usage: kili project export [OPTIONS] Options: Name Type Description Default --output-format choice ( raw | kili | yolo_v4 | yolo_v5 | yolo_v7 | coco | pascal_voc ) Format into which the label data will be converted _required --output-file text File into which the labels are saved. _required --layout choice ( split | merged ) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. merged --single-file boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). False --with-assets / --without-assets boolean Download assets in the export. True --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --verbose boolean Show more logs False --help boolean Show this message and exit. False import Add assets into a project Files can be paths to files or to folders. You can provide several paths separated by spaces. If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns: external_id : external id of the asset. content : paths to the asset file or a url hosting the asset. Examples kili project import \\ dir1/dir2/ dir1/dir3/test1.png \\ --project-id <project_id> kili project import \\ dir1/dir3/video.mp4 \\ --project-id <project_id> \\ --frames \\ --fps 24 kili project import \\ --from-csv assets_list.csv \\ --project-id <project_id> \\ --frames \\ --fps 24 Unsupported imports Currently, this command does not support: the import of videos from local frames, rich text and time series assets the import of assets with metadata or with a custom external_id For such imports, please use the append_many_to_dataset method in the Kili SDK. Usage: kili project import [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:external_id, content required columns: None --frames boolean Only for a frame project, import videos as frames. The import time is longer with this option. False --fps integer Only for a frame project, import videos with a specific frame rate None --verbose boolean Show more logs False --help boolean Show this message and exit. False label Import labels or predictions Files can be paths to files or to folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. Examples To import default labels: kili project label \\ dir/labels/ dir/ground-truth/image1.json \\ --project-id <project_id> To import labels as predictions: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-run-3 To import labels as predictions in the Yolo v5 format into a target job: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-v5 \\ --metadata-file classes.yml \\ --target-job IMAGE_DETECTION_JOB \\ --input-format yolo_v5 Usage: kili project label [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --prediction boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface False --model-name text Name of the model that generated predictions, if labels are sent as predictions None --verbose boolean Show more logs False --input-format choice ( yolo_v4 | yolo_v5 | yolo_v7 | kili | raw ) Format in which the labels are encoded kili --metadata-file text File containing format metadata (if relevant to the input format) None --target-job text Job name in the project where to upload the labels (if relevant to the input format) None --help boolean Show this message and exit. False list List your projects Examples kili project list --max 10 --stdout-format pretty Usage: kili project list [OPTIONS] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --max integer Maximum number of project to display. 100 --help boolean Show this message and exit. False member Commands to interact with Kili project members Usage: kili project member [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False add Add members to a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member add \\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com jane.doe@test.com kili project member add \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member add \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member add [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False list List the members of the project Examples kili project member list <project_id> --stdout-format pretty Usage: kili project member list [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False rm Remove members from a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member rm \\ --project-id <project_id> \\ john.doe@test.com kili project member rm \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member rm \\ --project-id <project_id> \\ --all Usage: kili project member rm [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:email required columns: role None --all boolean Remove all users from project False --help boolean Show this message and exit. False update Update member's role of a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member update\\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com kili project member update \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member update \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member update [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"Reference"},{"location":"cli/reference/#kili","text":"Kili Command line Interface To get all the available commands, please type: kili project --help . Usage: kili [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --version boolean Show the version and exit. False --help boolean Show this message and exit. False","title":"kili"},{"location":"cli/reference/#project","text":"Commands to interact with a Kili project Usage: kili project [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"project"},{"location":"cli/reference/#copy","text":"Copy an existing Kili project. The copy can include or not the json interface, quality settings, members, assets and labels of the source project. By default, only the json interface, quality settings and project members are copied. If no title is provided, the source project title will be used. If no description is provided, the description will be set to an empty string. Returns the new project id and title once the copy is finished. Examples Copy a project and set a new title and new description: kili project copy clbqn56b331234567890l41c0 \\ --title \"New project title\" \\ --description \"New project description\" Copy the json interface but not the members: kili project copy clbqn56b331234567890l41c0 \\ --with-json-interface \\ --without-members Usage: kili project copy [OPTIONS] FROM_PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --title text New project title. None --description text New project description. None --with-json-interface / --without-json-interface boolean Copy json interface. True --with-quality-settings / --without-quality-settings boolean Copy quality settings. True --with-members / --without-members boolean Copy members. True --with-assets / --without-assets boolean Copy assets. False --with-labels / --without-labels boolean Copy labels. False --help boolean Show this message and exit. False","title":"copy"},{"location":"cli/reference/#create","text":"Create a Kili project interface must be a path pointing to your json interface file If no interface is provided, --from-project can be used to create a new project with the json_interface of another project (assets will not be copied). Examples kili project create \\ path/to/interface.json \\ --input-type TEXT \\ --title \"Invoice annotation project\" kili project create \\ --from-project <project_id_src> \\ --input-type TEXT \\ --title \"Invoice annotation project\" To build a Kili project interface, please visit: https://docs.kili-technology.com/docs/customizing-the-interface-through-json-settings Usage: kili project create [OPTIONS] [INTERFACE] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --from-project text project_id of another Kili project None --title text Project Title. _required --input-type choice ( AUDIO | IMAGE | PDF | TEXT | TIME_SERIES | VIDEO | VIDEO_LEGACY ) Project input data type. Please check your license to see which ones you have access to. _required --description text Project description. `` --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False","title":"create"},{"location":"cli/reference/#describe","text":"Show project description and analytics. Examples kili project describe --project-id <project_id> Usage: kili project describe [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --help boolean Show this message and exit. False","title":"describe"},{"location":"cli/reference/#export","text":"Export the Kili labels of a project to a given format. The supported formats are: YOLO V4, V5, V7 for object detection tasks (bounding box). Kili (a.k.a raw) for all tasks. COCO for object detection tasks (semantic or bounding box) Pascal VOC for object detection tasks. Examples kili project export \\ --project-id <project_id> \\ --output-format coco \\ --output-file /tmp/export.zip kili project export \\ --project-id <project_id> \\ --output-format yolo_v5 \\ --output-file /tmp/export_split.zip \\ --layout split Unsupported exports Currently, this command does not support the export of videos that have not been cut into separated frames. For such exports, please use the Kili UI. Usage: kili project export [OPTIONS] Options: Name Type Description Default --output-format choice ( raw | kili | yolo_v4 | yolo_v5 | yolo_v7 | coco | pascal_voc ) Format into which the label data will be converted _required --output-file text File into which the labels are saved. _required --layout choice ( split | merged ) Layout of the label files: 'split' to group labels per job, 'merged' to have one folder with every labels. merged --single-file boolean Layout of the label files. Single file mode is only available for some specific formats (COCO and Kili). False --with-assets / --without-assets boolean Download assets in the export. True --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --verbose boolean Show more logs False --help boolean Show this message and exit. False","title":"export"},{"location":"cli/reference/#import","text":"Add assets into a project Files can be paths to files or to folders. You can provide several paths separated by spaces. If no Files are provided, --from-csv can be used to import assets from a CSV file with two columns: external_id : external id of the asset. content : paths to the asset file or a url hosting the asset. Examples kili project import \\ dir1/dir2/ dir1/dir3/test1.png \\ --project-id <project_id> kili project import \\ dir1/dir3/video.mp4 \\ --project-id <project_id> \\ --frames \\ --fps 24 kili project import \\ --from-csv assets_list.csv \\ --project-id <project_id> \\ --frames \\ --fps 24 Unsupported imports Currently, this command does not support: the import of videos from local frames, rich text and time series assets the import of assets with metadata or with a custom external_id For such imports, please use the append_many_to_dataset method in the Kili SDK. Usage: kili project import [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:external_id, content required columns: None --frames boolean Only for a frame project, import videos as frames. The import time is longer with this option. False --fps integer Only for a frame project, import videos with a specific frame rate None --verbose boolean Show more logs False --help boolean Show this message and exit. False","title":"import"},{"location":"cli/reference/#label","text":"Import labels or predictions Files can be paths to files or to folders. You can provide several paths separated by spaces. Label files are JSON files containing labels in the Kili format: the value corresponding to the jsonResponse field of a label (see here for example). File's name must be equal to asset's external_id. Examples To import default labels: kili project label \\ dir/labels/ dir/ground-truth/image1.json \\ --project-id <project_id> To import labels as predictions: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-run-3 To import labels as predictions in the Yolo v5 format into a target job: kili project label \\ dir/predictions/ \\ --project-id <project_id> \\ --prediction \\ --model-name YOLO-v5 \\ --metadata-file classes.yml \\ --target-job IMAGE_DETECTION_JOB \\ --input-format yolo_v5 Usage: kili project label [OPTIONS] [FILES]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --prediction boolean Tells to import labels as predictions, which means that they will appear as pre-annotations in the Kili interface False --model-name text Name of the model that generated predictions, if labels are sent as predictions None --verbose boolean Show more logs False --input-format choice ( yolo_v4 | yolo_v5 | yolo_v7 | kili | raw ) Format in which the labels are encoded kili --metadata-file text File containing format metadata (if relevant to the input format) None --target-job text Job name in the project where to upload the labels (if relevant to the input format) None --help boolean Show this message and exit. False","title":"label"},{"location":"cli/reference/#list","text":"List your projects Examples kili project list --max 10 --stdout-format pretty Usage: kili project list [OPTIONS] Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --max integer Maximum number of project to display. 100 --help boolean Show this message and exit. False","title":"list"},{"location":"cli/reference/#member","text":"Commands to interact with Kili project members Usage: kili project member [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"member"},{"location":"cli/reference/#add","text":"Add members to a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member add \\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com jane.doe@test.com kili project member add \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member add \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member add [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"add"},{"location":"cli/reference/#list_1","text":"List the members of the project Examples kili project member list <project_id> --stdout-format pretty Usage: kili project member list [OPTIONS] PROJECT_ID Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --stdout-format text Defines how the output table is formatted (see https://pypi.org/project/tabulate/, default: plain). plain --help boolean Show this message and exit. False","title":"list"},{"location":"cli/reference/#rm","text":"Remove members from a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member rm \\ --project-id <project_id> \\ john.doe@test.com kili project member rm \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member rm \\ --project-id <project_id> \\ --all Usage: kili project member rm [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --from-csv path path to a csv file with required columns:email required columns: role None --all boolean Remove all users from project False --help boolean Show this message and exit. False","title":"rm"},{"location":"cli/reference/#update","text":"Update member's role of a Kili project Emails can be passed directly as arguments. You can provide several emails separated by spaces. Examples kili project member update\\ --project-id <project_id> \\ --role REVIEWER \\ john.doe@test.com kili project member update \\ --project-id <project_id> \\ --from-csv path/to/members.csv kili project member update \\ --project-id <project_id> \\ --from-project <project_id_scr> Usage: kili project member update [OPTIONS] [EMAILS]... Options: Name Type Description Default --api-key text Your Kili API key. None --endpoint text Kili API Endpoint. None --project-id text Id of the project _required --role choice ( ADMIN | TEAM_MANAGER | REVIEWER | LABELER ) Project role of the added user(s). None --from-csv path path to a csv file with required columns:email required columns: role None --from-project text project_id of another Kili project None --help boolean Show this message and exit. False","title":"update"},{"location":"sdk/api_key/","text":"API Key module Queries Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return APIKeyQuery ( self . auth . client )( where , fields , options ) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) return APIKeyQuery ( self . auth . client ) . count ( where ) api_keys ( self , api_key_id = None , user_id = None , api_key = None , skip = 0 , fields = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. None disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return APIKeyQuery ( self . auth . client )( where , fields , options ) count_api_keys ( self , api_key_id = None , user_id = None , api_key = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) return APIKeyQuery ( self . auth . client ) . count ( where )","title":"API Key"},{"location":"sdk/api_key/#api-key-module","text":"","title":"API Key module"},{"location":"sdk/api_key/#queries","text":"Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return APIKeyQuery ( self . auth . client )( where , fields , options ) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) return APIKeyQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","text":"Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. None disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"id\" , \"name\" , \"createdAt\" , \"revoked\" ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return APIKeyQuery ( self . auth . client )( where , fields , options )","title":"api_keys()"},{"location":"sdk/api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" where = APIKeyWhere ( api_key_id = api_key_id , user_id = user_id , api_key = api_key ) return APIKeyQuery ( self . auth . client ) . count ( where )","title":"count_api_keys()"},{"location":"sdk/asset/","text":"Asset module Queries Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Union [ Iterable [ Dict ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) post_call_function = get_download_assets_function ( self , download_media , fields , project_id , local_media_dir ) assets = AssetQuery ( self . auth . client )( where , fields , options , post_call_function ) if format == \"pandas\" : return pd . DataFrame ( assets ) return assets @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) return AssetQuery ( self . auth . client ) . count ( where ) assets ( self , project_id , asset_id = None , skip = 0 , fields = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in = None , consensus_mark_gt = None , consensus_mark_lt = None , disable_tqdm = False , external_id_contains = None , first = None , format = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_type_in = None , metadata_where = None , skipped = None , status_in = None , updated_at_gte = None , updated_at_lte = None , as_generator = False , label_category_search = None , download_media = False , local_media_dir = None ) Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED , TO_REVIEW or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None download_media bool Tell is the media have to be downloaded or not. False local_media_dir Optional[str] Directory where the media are downloaded if download_media is True. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[Iterable[Dict], pandas.core.frame.DataFrame] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py @typechecked def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Union [ Iterable [ Dict ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) post_call_function = get_download_assets_function ( self , download_media , fields , project_id , local_media_dir ) assets = AssetQuery ( self . auth . client )( where , fields , options , post_call_function ) if format == \"pandas\" : return pd . DataFrame ( assets ) return assets count_assets ( self , project_id , asset_id = None , asset_id_in = None , external_id_contains = None , metadata_where = None , status_in = None , consensus_mark_gt = None , consensus_mark_lt = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_type_in = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , skipped = None , updated_at_gte = None , updated_at_lte = None , label_category_search = None ) Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default project_id str Identifier of the project required asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) return AssetQuery ( self . auth . client ) . count ( where ) Mutations Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The internal asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1. honeypot_marks: Should be between 0 and 1. to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format. - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. json_contents: - For a NLP project, the `json_content` is a text formatted using RichText. - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW`, `REVIEWED`. is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not. is_honeypot_array: Whether to use the asset for honeypot. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" if asset_ids is not None and external_ids is not None : warnings . warn ( \"The use of `external_ids` argument has changed. It is now used to identify which\" \" properties of which assets to update. Please use\" \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\" , DeprecationWarning , ) raise MissingArgumentError ( \"Please provide either `asset_ids` or `external_ids`.\" ) asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def change_asset_external_ids ( self , new_external_ids : List [ str ], asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the external IDs of one or more assets. Args: new_external_ids: The new external IDs of the assets. asset_ids: The asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.change_asset_external_ids( new_external_ids=[\"asset1\", \"asset2\"], asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) parameters = { \"asset_ids\" : asset_ids , \"new_external_ids\" : new_external_ids , \"json_metadatas\" : None , \"to_be_labeled_by_array\" : None , } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"new_external_ids\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def delete_many_from_dataset ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of asset internal IDs to delete. external_ids: The list of asset external IDs to delete. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) @typechecked def add_to_review ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Optional [ Dict [ str , Any ]]: \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset internal IDs to add to review. external_ids: The asset external IDs to add to review. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to review. `None` if no assets have changed status (already had `TO_REVIEW` status for example). An error message if mutation failed. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) result = format_result ( \"data\" , results [ 0 ]) if isinstance ( result , dict ) and \"id\" in result : assets_in_review = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"TO_REVIEW\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_review ] return result return result @typechecked def send_back_to_queue ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Dict [ str , Any ]: \"\"\"Send assets back to queue. Args: asset_ids: List of internal IDs of assets to send back to queue. external_ids: List of external IDs of assets to send back to queue. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to queue. An error message if mutation failed. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) result = format_result ( \"data\" , results [ 0 ]) assets_in_queue = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"ONGOING\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_queue ] return result add_to_review ( self , asset_ids = None , external_ids = None , project_id = None ) Add assets to review. Warning Assets without any label will be ignored. Parameters: Name Type Description Default asset_ids Optional[List[str]] The asset internal IDs to add to review. None external_ids Optional[List[str]] The asset external IDs to add to review. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Optional[Dict[str, Any]] A dict object with the project id and the asset_ids of assets moved to review. None if no assets have changed status (already had TO_REVIEW status for example). An error message if mutation failed. Examples: >>> kili . add_to_review ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" , ], ) Source code in kili/mutations/asset/__init__.py @typechecked def add_to_review ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Optional [ Dict [ str , Any ]]: \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset internal IDs to add to review. external_ids: The asset external IDs to add to review. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to review. `None` if no assets have changed status (already had `TO_REVIEW` status for example). An error message if mutation failed. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) result = format_result ( \"data\" , results [ 0 ]) if isinstance ( result , dict ) and \"id\" in result : assets_in_review = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"TO_REVIEW\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_review ] return result return result append_many_to_dataset ( self , project_id , content_array = None , external_id_array = None , id_array = None , is_honeypot_array = None , status_array = None , json_content_array = None , json_metadata_array = None , disable_tqdm = False ) Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. For an VIDEO_LEGACY project, the content can be only be URLs None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for VIDEO or TEXT projects only. For VIDEO projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None disable_tqdm bool If True , the progress bar will be disabled False Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result change_asset_external_ids ( self , new_external_ids , asset_ids = None , external_ids = None , project_id = None ) Update the external IDs of one or more assets. Parameters: Name Type Description Default new_external_ids List[str] The new external IDs of the assets. required asset_ids Optional[List[str]] The asset IDs to modify. None external_ids Optional[List[str]] The external asset IDs to modify (if asset_ids is not already provided). None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description List[Dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . change_asset_external_ids ( new_external_ids = [ \"asset1\" , \"asset2\" ], asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], ) Source code in kili/mutations/asset/__init__.py @typechecked def change_asset_external_ids ( self , new_external_ids : List [ str ], asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the external IDs of one or more assets. Args: new_external_ids: The new external IDs of the assets. asset_ids: The asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.change_asset_external_ids( new_external_ids=[\"asset1\", \"asset2\"], asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) parameters = { \"asset_ids\" : asset_ids , \"new_external_ids\" : new_external_ids , \"json_metadatas\" : None , \"to_be_labeled_by_array\" : None , } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"new_external_ids\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] delete_many_from_dataset ( self , asset_ids = None , external_ids = None , project_id = None ) Delete assets from a project. Parameters: Name Type Description Default asset_ids Optional[List[str]] The list of asset internal IDs to delete. None external_ids Optional[List[str]] The list of asset external IDs to delete. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Asset A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @typechecked def delete_many_from_dataset ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of asset internal IDs to delete. external_ids: The list of asset external IDs to delete. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) send_back_to_queue ( self , asset_ids = None , external_ids = None , project_id = None ) Send assets back to queue. Parameters: Name Type Description Default asset_ids Optional[List[str]] List of internal IDs of assets to send back to queue. None external_ids Optional[List[str]] List of external IDs of assets to send back to queue. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Dict[str, Any] A dict object with the project id and the asset_ids of assets moved to queue. An error message if mutation failed. Examples: >>> kili . send_back_to_queue ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" , ], ) Source code in kili/mutations/asset/__init__.py @typechecked def send_back_to_queue ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Dict [ str , Any ]: \"\"\"Send assets back to queue. Args: asset_ids: List of internal IDs of assets to send back to queue. external_ids: List of external IDs of assets to send back to queue. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to queue. An error message if mutation failed. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) result = format_result ( \"data\" , results [ 0 ]) assets_in_queue = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"ONGOING\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_queue ] return result update_properties_in_assets ( self , asset_ids = None , external_ids = None , priorities = None , json_metadatas = None , consensus_marks = None , honeypot_marks = None , to_be_labeled_by_array = None , contents = None , json_contents = None , status_array = None , is_used_for_consensus_array = None , is_honeypot_array = None , project_id = None ) Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids Optional[List[str]] The internal asset IDs to modify. None external_ids Optional[List[str]] The external asset IDs to modify (if asset_ids is not already provided). None priorities Optional[List[int]] You can change the priority of the assets. By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1. None honeypot_marks Optional[List[float]] Should be between 0 and 1. None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format. For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText. For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , TO_REVIEW , REVIEWED . None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description List[Dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The internal asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1. honeypot_marks: Should be between 0 and 1. to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format. - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. json_contents: - For a NLP project, the `json_content` is a text formatted using RichText. - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW`, `REVIEWED`. is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not. is_honeypot_array: Whether to use the asset for honeypot. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" if asset_ids is not None and external_ids is not None : warnings . warn ( \"The use of `external_ids` argument has changed. It is now used to identify which\" \" properties of which assets to update. Please use\" \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\" , DeprecationWarning , ) raise MissingArgumentError ( \"Please provide either `asset_ids` or `external_ids`.\" ) asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"Asset"},{"location":"sdk/asset/#asset-module","text":"","title":"Asset module"},{"location":"sdk/asset/#queries","text":"Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Union [ Iterable [ Dict ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) post_call_function = get_download_assets_function ( self , download_media , fields , project_id , local_media_dir ) assets = AssetQuery ( self . auth . client )( where , fields , options , post_call_function ) if format == \"pandas\" : return pd . DataFrame ( assets ) return assets @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) return AssetQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.assets","text":"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED , TO_REVIEW or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None download_media bool Tell is the media have to be downloaded or not. False local_media_dir Optional[str] Directory where the media are downloaded if download_media is True. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[Iterable[Dict], pandas.core.frame.DataFrame] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py @typechecked def assets ( self , project_id : str , asset_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"content\" , \"createdAt\" , \"externalId\" , \"id\" , \"isHoneypot\" , \"jsonMetadata\" , \"labels.author.id\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.id\" , \"labels.jsonResponse\" , \"skipped\" , \"status\" , ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , download_media : bool = False , local_media_dir : Optional [ str ] = None , ) -> Union [ Iterable [ Dict ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: project_id: Identifier of the project. asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. download_media: Tell is the media have to be downloaded or not. local_media_dir: Directory where the media are downloaded if `download_media` is True. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id) >>> kili.assets(project_id, asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( 'Argument values as_generator==True and format==\"pandas\" are not compatible.' ) if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) post_call_function = get_download_assets_function ( self , download_media , fields , project_id , local_media_dir ) assets = AssetQuery ( self . auth . client )( where , fields , options , post_call_function ) if format == \"pandas\" : return pd . DataFrame ( assets ) return assets","title":"assets()"},{"location":"sdk/asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","text":"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default project_id str Identifier of the project required asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @typechecked def count_assets ( self , project_id : str , asset_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None , ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: project_id: Identifier of the project asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_category_search : validate_category_search_query ( label_category_search ) where = AssetWhere ( project_id = project_id , asset_id = asset_id , asset_id_in = asset_id_in , consensus_mark_gt = consensus_mark_gt , consensus_mark_lt = consensus_mark_lt , external_id_contains = external_id_contains , honeypot_mark_gt = honeypot_mark_gt , honeypot_mark_lt = honeypot_mark_lt , label_author_in = label_author_in , label_consensus_mark_gt = label_consensus_mark_gt , label_consensus_mark_lt = label_consensus_mark_lt , label_created_at = label_created_at , label_created_at_gt = label_created_at_gt , label_created_at_lt = label_created_at_lt , label_honeypot_mark_gt = label_honeypot_mark_gt , label_honeypot_mark_lt = label_honeypot_mark_lt , label_type_in = label_type_in , metadata_where = metadata_where , skipped = skipped , status_in = status_in , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , label_category_search = label_category_search , ) return AssetQuery ( self . auth . client ) . count ( where )","title":"count_assets()"},{"location":"sdk/asset/#mutations","text":"Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The internal asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1. honeypot_marks: Should be between 0 and 1. to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format. - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. json_contents: - For a NLP project, the `json_content` is a text formatted using RichText. - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW`, `REVIEWED`. is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not. is_honeypot_array: Whether to use the asset for honeypot. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" if asset_ids is not None and external_ids is not None : warnings . warn ( \"The use of `external_ids` argument has changed. It is now used to identify which\" \" properties of which assets to update. Please use\" \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\" , DeprecationWarning , ) raise MissingArgumentError ( \"Please provide either `asset_ids` or `external_ids`.\" ) asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def change_asset_external_ids ( self , new_external_ids : List [ str ], asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the external IDs of one or more assets. Args: new_external_ids: The new external IDs of the assets. asset_ids: The asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.change_asset_external_ids( new_external_ids=[\"asset1\", \"asset2\"], asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) parameters = { \"asset_ids\" : asset_ids , \"new_external_ids\" : new_external_ids , \"json_metadatas\" : None , \"to_be_labeled_by_array\" : None , } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"new_external_ids\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @typechecked def delete_many_from_dataset ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of asset internal IDs to delete. external_ids: The list of asset external IDs to delete. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset ) @typechecked def add_to_review ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Optional [ Dict [ str , Any ]]: \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset internal IDs to add to review. external_ids: The asset external IDs to add to review. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to review. `None` if no assets have changed status (already had `TO_REVIEW` status for example). An error message if mutation failed. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) result = format_result ( \"data\" , results [ 0 ]) if isinstance ( result , dict ) and \"id\" in result : assets_in_review = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"TO_REVIEW\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_review ] return result return result @typechecked def send_back_to_queue ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Dict [ str , Any ]: \"\"\"Send assets back to queue. Args: asset_ids: List of internal IDs of assets to send back to queue. external_ids: List of external IDs of assets to send back to queue. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to queue. An error message if mutation failed. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) result = format_result ( \"data\" , results [ 0 ]) assets_in_queue = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"ONGOING\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_queue ] return result","title":"Mutations"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.add_to_review","text":"Add assets to review. Warning Assets without any label will be ignored. Parameters: Name Type Description Default asset_ids Optional[List[str]] The asset internal IDs to add to review. None external_ids Optional[List[str]] The asset external IDs to add to review. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Optional[Dict[str, Any]] A dict object with the project id and the asset_ids of assets moved to review. None if no assets have changed status (already had TO_REVIEW status for example). An error message if mutation failed. Examples: >>> kili . add_to_review ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" , ], ) Source code in kili/mutations/asset/__init__.py @typechecked def add_to_review ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Optional [ Dict [ str , Any ]]: \"\"\"Add assets to review. !!! warning Assets without any label will be ignored. Args: asset_ids: The asset internal IDs to add to review. external_ids: The asset external IDs to add to review. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to review. `None` if no assets have changed status (already had `TO_REVIEW` status for example). An error message if mutation failed. Examples: >>> kili.add_to_review( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_ADD_ALL_LABELED_ASSETS_TO_REVIEW , ) result = format_result ( \"data\" , results [ 0 ]) if isinstance ( result , dict ) and \"id\" in result : assets_in_review = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"TO_REVIEW\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_review ] return result return result","title":"add_to_review()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","text":"Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. For an VIDEO_LEGACY project, the content can be only be URLs None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for VIDEO or TEXT projects only. For VIDEO projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None disable_tqdm bool If True , the progress bar will be disabled False Returns: Type Description Dict[str, str] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None , disable_tqdm : bool = False , ) -> Dict [ str , str ]: # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a VIDEO project, the content can be either URLs pointing to videos hosted on a web server or paths to existing video files on your computer. If you want to import video from frames, look at the json_content section below. - For an `VIDEO_LEGACY` project, the content can be only be URLs external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `VIDEO` or `TEXT` projects only. - For `VIDEO` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For VIDEO projects (and not VIDEO_LEGACY), you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. disable_tqdm: If `True`, the progress bar will be disabled Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://docs.kili-technology.com/recipes/importing-data). - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" if content_array is None and json_content_array is None : raise ValueError ( \"Variables content_array and json_content_array cannot be both None.\" ) nb_data = ( len ( content_array ) if content_array is not None else len ( json_content_array ) # type:ignore ) field_mapping = { \"content\" : content_array , \"json_content\" : json_content_array , \"external_id\" : external_id_array , \"id\" : id_array , \"status\" : status_array , \"json_metadata\" : json_metadata_array , \"is_honeypot\" : is_honeypot_array , } assets = [{}] * nb_data for key , value in field_mapping . items (): if value is not None : assets = [{ ** assets [ i ], key : value [ i ]} for i in range ( nb_data )] result = import_assets ( self . auth , project_id = project_id , assets = assets , disable_tqdm = disable_tqdm ) return result","title":"append_many_to_dataset()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.change_asset_external_ids","text":"Update the external IDs of one or more assets. Parameters: Name Type Description Default new_external_ids List[str] The new external IDs of the assets. required asset_ids Optional[List[str]] The asset IDs to modify. None external_ids Optional[List[str]] The external asset IDs to modify (if asset_ids is not already provided). None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description List[Dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . change_asset_external_ids ( new_external_ids = [ \"asset1\" , \"asset2\" ], asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], ) Source code in kili/mutations/asset/__init__.py @typechecked def change_asset_external_ids ( self , new_external_ids : List [ str ], asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the external IDs of one or more assets. Args: new_external_ids: The new external IDs of the assets. asset_ids: The asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.change_asset_external_ids( new_external_ids=[\"asset1\", \"asset2\"], asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) parameters = { \"asset_ids\" : asset_ids , \"new_external_ids\" : new_external_ids , \"json_metadatas\" : None , \"to_be_labeled_by_array\" : None , } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"externalId\" : batch [ \"new_external_ids\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"change_asset_external_ids()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","text":"Delete assets from a project. Parameters: Name Type Description Default asset_ids Optional[List[str]] The list of asset internal IDs to delete. None external_ids Optional[List[str]] The list of asset external IDs to delete. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Asset A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @typechecked def delete_many_from_dataset ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Asset : \"\"\"Delete assets from a project. Args: asset_ids: The list of asset internal IDs to delete. external_ids: The list of asset external IDs to delete. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( \"data\" , results [ 0 ], Asset )","title":"delete_many_from_dataset()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.send_back_to_queue","text":"Send assets back to queue. Parameters: Name Type Description Default asset_ids Optional[List[str]] List of internal IDs of assets to send back to queue. None external_ids Optional[List[str]] List of external IDs of assets to send back to queue. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description Dict[str, Any] A dict object with the project id and the asset_ids of assets moved to queue. An error message if mutation failed. Examples: >>> kili . send_back_to_queue ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" , ], ) Source code in kili/mutations/asset/__init__.py @typechecked def send_back_to_queue ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , project_id : Optional [ str ] = None , ) -> Dict [ str , Any ]: \"\"\"Send assets back to queue. Args: asset_ids: List of internal IDs of assets to send back to queue. external_ids: List of external IDs of assets to send back to queue. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A dict object with the project `id` and the `asset_ids` of assets moved to queue. An error message if mutation failed. Examples: >>> kili.send_back_to_queue( asset_ids=[ \"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\", ], ) \"\"\" asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) properties_to_batch : Dict [ str , Optional [ List [ Any ]]] = { \"asset_ids\" : asset_ids } def generate_variables ( batch ): return { \"where\" : { \"idIn\" : batch [ \"asset_ids\" ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_SEND_BACK_ASSETS_TO_QUEUE ) result = format_result ( \"data\" , results [ 0 ]) assets_in_queue = AssetQuery ( self . auth . client )( AssetWhere ( project_id = result [ \"id\" ], asset_id_in = asset_ids , status_in = [ \"ONGOING\" ]), [ \"id\" ], QueryOptions ( disable_tqdm = True ), ) result [ \"asset_ids\" ] = [ asset [ \"id\" ] for asset in assets_in_queue ] return result","title":"send_back_to_queue()"},{"location":"sdk/asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","text":"Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids Optional[List[str]] The internal asset IDs to modify. None external_ids Optional[List[str]] The external asset IDs to modify (if asset_ids is not already provided). None priorities Optional[List[int]] You can change the priority of the assets. By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1. None honeypot_marks Optional[List[float]] Should be between 0 and 1. None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format. For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText. For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , TO_REVIEW , REVIEWED . None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot. None project_id Optional[str] The project ID. Only required if external_ids argument is provided. None Returns: Type Description List[Dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @typechecked # pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : Optional [ List [ str ]] = None , external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , project_id : Optional [ str ] = None , ) -> List [ Dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids: The internal asset IDs to modify. external_ids: The external asset IDs to modify (if `asset_ids` is not already provided). priorities: You can change the priority of the assets. By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1. honeypot_marks: Should be between 0 and 1. to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format. - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. json_contents: - For a NLP project, the `json_content` is a text formatted using RichText. - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `TO_REVIEW`, `REVIEWED`. is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not. is_honeypot_array: Whether to use the asset for honeypot. project_id: The project ID. Only required if `external_ids` argument is provided. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" if asset_ids is not None and external_ids is not None : warnings . warn ( \"The use of `external_ids` argument has changed. It is now used to identify which\" \" properties of which assets to update. Please use\" \" `kili.change_asset_external_ids()` method instead to change asset external IDs.\" , DeprecationWarning , ) raise MissingArgumentError ( \"Please provide either `asset_ids` or `external_ids`.\" ) asset_ids = get_asset_ids_or_throw_error ( self , asset_ids , external_ids , project_id ) saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ \"asset_ids\" , \"priorities\" , \"json_metadatas\" , \"consensus_marks\" , \"honeypot_marks\" , \"to_be_labeled_by_array\" , \"contents\" , \"json_contents\" , \"status_array\" , \"is_used_for_consensus_array\" , \"is_honeypot_array\" , ] } properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch : Dict ) -> Dict : data = { \"priority\" : batch [ \"priorities\" ], \"jsonMetadata\" : batch [ \"json_metadatas\" ], \"consensusMark\" : batch [ \"consensus_marks\" ], \"honeypotMark\" : batch [ \"honeypot_marks\" ], \"toBeLabeledBy\" : batch [ \"to_be_labeled_by_array\" ], \"shouldResetToBeLabeledBy\" : batch [ \"should_reset_to_be_labeled_by_array\" ], \"content\" : batch [ \"contents\" ], \"jsonContent\" : batch [ \"json_contents\" ], \"status\" : batch [ \"status_array\" ], \"isUsedForConsensus\" : batch [ \"is_used_for_consensus_array\" ], \"isHoneypot\" : batch [ \"is_honeypot_array\" ], } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { \"whereArray\" : [{ \"id\" : asset_id } for asset_id in batch [ \"asset_ids\" ]], \"dataArray\" : data_array , } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS , ) formated_results = [ format_result ( \"data\" , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"update_properties_in_assets()"},{"location":"sdk/issue/","text":"Issue module Queries Set of Issue queries. Source code in kili/queries/issue/__init__.py class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" where = IssueWhere ( project_id = project_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return IssueQuery ( self . auth . client )( where , fields , options ) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" if not project_id : warnings . warn ( \"It is now required to provide a project_id when calling count_issues. This change\" \" will be enforced from 01/02/2023\" , DeprecationWarning , ) where = IssueWhere ( project_id = project_id ) return IssueQuery ( self . auth . client ) . count ( where ) count_issues ( self , project_id = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" if not project_id : warnings . warn ( \"It is now required to provide a project_id when calling count_issues. This change\" \" will be enforced from 01/02/2023\" , DeprecationWarning , ) where = IssueWhere ( project_id = project_id ) return IssueQuery ( self . auth . client ) . count ( where ) issues ( self , project_id , fields = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default project_id str Project ID the issue belongs to. required fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. None skip int Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Iterable[dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" where = IssueWhere ( project_id = project_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return IssueQuery ( self . auth . client )( where , fields , options ) Mutations Set of Issue mutations. Source code in kili/mutations/issue/__init__.py class MutationsIssue : \"\"\"Set of Issue mutations.\"\"\" # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : options = QueryOptions ( disable_tqdm = True ) where = LabelWhere ( project_id = project_id , label_id = label_id , ) asset_id = cast ( List [ Dict ], list ( LabelQuery ( self . auth . client )( where = where , fields = [ \"labelOf.id\" ], options = options ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result ) append_to_issues ( self , label_id , project_id , object_mid = None , text = None , type_ = 'ISSUE' ) Create an issue. Parameters: Name Type Description Default label_id str Id of the label to add an issue to required object_mid Optional[str] Mid of the object in the label to associate the issue to None type_ Literal['ISSUE', 'QUESTION'] type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" 'ISSUE' text Optional[str] If given, write a comment related to the issue None project_id str Id of the project required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/issue/__init__.py @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : options = QueryOptions ( disable_tqdm = True ) where = LabelWhere ( project_id = project_id , label_id = label_id , ) asset_id = cast ( List [ Dict ], list ( LabelQuery ( self . auth . client )( where = where , fields = [ \"labelOf.id\" ], options = options ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"Issue"},{"location":"sdk/issue/#issue-module","text":"","title":"Issue module"},{"location":"sdk/issue/#queries","text":"Set of Issue queries. Source code in kili/queries/issue/__init__.py class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" where = IssueWhere ( project_id = project_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return IssueQuery ( self . auth . client )( where , fields , options ) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" if not project_id : warnings . warn ( \"It is now required to provide a project_id when calling count_issues. This change\" \" will be enforced from 01/02/2023\" , DeprecationWarning , ) where = IssueWhere ( project_id = project_id ) return IssueQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" if not project_id : warnings . warn ( \"It is now required to provide a project_id when calling count_issues. This change\" \" will be enforced from 01/02/2023\" , DeprecationWarning , ) where = IssueWhere ( project_id = project_id ) return IssueQuery ( self . auth . client ) . count ( where )","title":"count_issues()"},{"location":"sdk/issue/#kili.queries.issue.__init__.QueriesIssue.issues","text":"Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default project_id str Project ID the issue belongs to. required fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. None skip int Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Iterable[dict] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @typechecked def issues ( self , project_id : str , fields : List [ str ] = [ \"id\" , \"createdAt\" , \"hasBeenSeen\" , \"issueNumber\" , \"status\" , \"type\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: project_id: Project ID the issue belongs to. fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" where = IssueWhere ( project_id = project_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return IssueQuery ( self . auth . client )( where , fields , options )","title":"issues()"},{"location":"sdk/issue/#mutations","text":"Set of Issue mutations. Source code in kili/mutations/issue/__init__.py class MutationsIssue : \"\"\"Set of Issue mutations.\"\"\" # pylint: disable=too-few-public-methods,too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : options = QueryOptions ( disable_tqdm = True ) where = LabelWhere ( project_id = project_id , label_id = label_id , ) asset_id = cast ( List [ Dict ], list ( LabelQuery ( self . auth . client )( where = where , fields = [ \"labelOf.id\" ], options = options ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/issue/#kili.mutations.issue.__init__.MutationsIssue.append_to_issues","text":"Create an issue. Parameters: Name Type Description Default label_id str Id of the label to add an issue to required object_mid Optional[str] Mid of the object in the label to associate the issue to None type_ Literal['ISSUE', 'QUESTION'] type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" 'ISSUE' text Optional[str] If given, write a comment related to the issue None project_id str Id of the project required Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/issue/__init__.py @typechecked def append_to_issues ( self , label_id : str , project_id : str , object_mid : Optional [ str ] = None , text : Optional [ str ] = None , type_ : Literal [ \"ISSUE\" , \"QUESTION\" ] = \"ISSUE\" , ) -> Dict : \"\"\"Create an issue. Args: label_id: Id of the label to add an issue to object_mid: Mid of the object in the label to associate the issue to type_: type of the issue to add. Can be either \"ISSUE\" or \"QUESTION\" text: If given, write a comment related to the issue project_id: Id of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" issue_number = get_issue_number ( self . auth , project_id , type_ ) try : options = QueryOptions ( disable_tqdm = True ) where = LabelWhere ( project_id = project_id , label_id = label_id , ) asset_id = cast ( List [ Dict ], list ( LabelQuery ( self . auth . client )( where = where , fields = [ \"labelOf.id\" ], options = options ) )[ 0 ][ \"labelOf\" ][ \"id\" ], ) except : # pylint: disable=raise-missing-from raise ValueError ( f \"Label ID { label_id } does not exist in the project of ID { project_id } \" ) variables = { \"data\" : { \"issueNumber\" : issue_number , \"labelID\" : label_id , \"objectMid\" : object_mid , \"type\" : type_ , }, \"where\" : { \"id\" : asset_id }, } if text : variables [ \"data\" ][ \"text\" ] = text result = self . auth . client . execute ( GQL_APPEND_TO_ISSUES , variables ) return format_result ( \"data\" , result )","title":"append_to_issues()"},{"location":"sdk/label/","text":"Label module Queries Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. category_search: Query to filter labels based on the content of their jsonResponse !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return LabelQuery ( self . auth . client )( where , fields , options ) # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" services . get_project ( self , project_id , [ \"id\" ]) assets = AssetQuery ( self . auth . client )( AssetWhere ( project_id = project_id ), asset_fields + [ \"labels.\" + field for field in fields ], QueryOptions ( disable_tqdm = False ), ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , id_contains : Optional [ List [ str ]] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. category_search: Query to filter labels based on the content of their jsonResponse id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) return LabelQuery ( self . auth . client ) . count ( where ) def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , external_ids : Optional [ List [ str ]] = None , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: project_id: Identifier of the project. filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets internal IDs from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. external_ids: Optional list of the assets external IDs from which to export the labels. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" if external_ids is not None and asset_ids is None : id_map = infer_ids_from_external_ids ( kili = self , asset_external_ids = external_ids , project_id = project_id ) asset_ids = [ id_map [ id ] for id in external_ids ] try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp )) count_labels ( self , project_id , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , honeypot_mark_gte = None , honeypot_mark_lte = None , label_id = None , type_in = None , user_id = None , category_search = None , id_contains = None ) Get the number of labels for the given parameters. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None label_id Optional[str] Identifier of the label. None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None category_search Optional[str] Query to filter labels based on the content of their jsonResponse None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , id_contains : Optional [ List [ str ]] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. category_search: Query to filter labels based on the content of their jsonResponse id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) return LabelQuery ( self . auth . client ) . count ( where ) export_labels ( self , project_id , filename , fmt , asset_ids = None , layout = 'split' , single_file = False , disable_tqdm = False , with_assets = True , external_ids = None ) Export the project labels with the requested format into the requested output path. Parameters: Name Type Description Default project_id str Identifier of the project. required filename str Relative or full path of the archive that will contain the exported data. required fmt Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc'] Format of the exported labels. required asset_ids Optional[List[str]] Optional list of the assets internal IDs from which to export the labels. None layout Literal['split', 'merged'] Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. 'split' single_file bool Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). False disable_tqdm bool Disable the progress bar if True. False with_assets bool Download the assets in the export. True external_ids Optional[List[str]] Optional list of the assets external IDs from which to export the labels. None Info The supported formats are: Yolo V4, V5, V7 for object detection tasks (bounding box) Kili for all tasks. COCO for semantic segmentation tasks (bounding box and semantic segmentation) Pascal VOC for object detection tasks. Example from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") Source code in kili/queries/label/__init__.py def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , external_ids : Optional [ List [ str ]] = None , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: project_id: Identifier of the project. filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets internal IDs from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. external_ids: Optional list of the assets external IDs from which to export the labels. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" if external_ids is not None and asset_ids is None : id_map = infer_ids_from_external_ids ( kili = self , asset_external_ids = external_ids , project_id = project_id ) asset_ids = [ id_map [ id ] for id in external_ids ] try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp )) export_labels_as_df ( self , project_id , fields = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' ], asset_fields = [ 'externalId' ]) Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" services . get_project ( self , project_id , [ \"id\" ]) assets = AssetQuery ( self . auth . client )( AssetWhere ( project_id = project_id ), asset_fields + [ \"labels.\" + field for field in fields ], QueryOptions ( disable_tqdm = False ), ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df labels ( self , project_id , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , fields = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' ], first = None , honeypot_mark_gte = None , honeypot_mark_lte = None , id_contains = None , label_id = None , skip = 0 , type_in = None , user_id = None , disable_tqdm = False , as_generator = False , category_search = None ) Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED , TO REVIEW or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None label_id Optional[str] Identifier of the label. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False category_search Optional[str] Query to filter labels based on the content of their jsonResponse None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. category_search: Query to filter labels based on the content of their jsonResponse !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return LabelQuery ( self . auth . client )( where , fields , options ) Mutations Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_predictions ( self , project_id : str , external_id_array : Optional [ List [ str ]] = None , model_name_array : Optional [ List [ str ]] = None , json_response_array : Optional [ List [ dict ]] = None , model_name : Optional [ str ] = None , asset_id_array : Optional [ List [ str ]] = None , ) -> dict : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project. external_id_array: The external IDs of the assets for which we want to add predictions. model_name_array: In case you want to precise from which model the label originated. json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). asset_id_array: The internal IDs of the assets for which we want to add predictions. Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" if json_response_array is None or len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one prediction to upload\" ) assert_all_arrays_have_same_size ( [ external_id_array , json_response_array , model_name_array , asset_id_array ] ) if model_name is None : if model_name_array is None : raise ValueError ( \"You must provide a model name with the model_name argument \" ) if len ( set ( model_name_array )) > 1 : raise ValueError ( \"Creating predictions from different models is not supported anymore. Separate\" \" your calls by models.\" ) warnings . warn ( \"The use of `model_name_array` is deprecated. Creating predictions from different\" \" models is not supported anymore. Please use `model_name` argument instead to\" \" provide the predictions model name.\" , DeprecationWarning , ) model_name = model_name_array [ 0 ] labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , } for ( asset_id , asset_external_id , json_response ) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), external_id_array or [ None ] * len ( json_response_array ), json_response_array , ) ) ] services . import_labels_from_dict ( self , project_id , labels , \"PREDICTION\" , model_name ) return { \"id\" : project_id } @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , disable_tqdm : bool = False , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset internal ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` project_id: Identifier of the project asset_external_id_array: list of asset external ids to append labels on Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name , disable_tqdm ) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label ) append_labels ( self , asset_id_array = None , json_response_array = [], author_id_array = None , seconds_to_label_array = None , model_name = None , label_type = 'DEFAULT' , project_id = None , asset_external_id_array = None , disable_tqdm = False ) Append labels to assets. Parameters: Name Type Description Default asset_id_array Optional[List[str]] list of asset internal ids to append labels on None json_response_array List[Dict] list of labels to append [] author_id_array Optional[List[str]] list of the author id of the labels None seconds_to_label_array Optional[List[int]] list of times taken to produce the label, in seconds None model_name Optional[str] Only useful when uploading predictions. Name of the model when uploading predictions None label_type Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW'] Can be one of AUTOSAVE , DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' project_id Optional[str] Identifier of the project None asset_external_id_array Optional[List[str]] list of asset external ids to append labels on None Returns: Type Description List A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( asset_id_array = [ 'cl9wmlkuc00050qsz6ut39g8h' , 'cl9wmlkuw00080qsz2kqh8aiy' ], json_response_array = [{ ... }, { ... }] ) Source code in kili/mutations/label/__init__.py @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , disable_tqdm : bool = False , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset internal ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` project_id: Identifier of the project asset_external_id_array: list of asset external ids to append labels on Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name , disable_tqdm ) append_to_labels ( self , json_response , author_id = None , label_asset_external_id = None , label_asset_id = None , label_type = 'DEFAULT' , project_id = None , seconds_to_label = 0 ) [DEPRECATED] append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) create_honeypot ( self , json_response , asset_external_id = None , asset_id = None , project_id = None ) Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label ) create_predictions ( self , project_id , external_id_array = None , model_name_array = None , json_response_array = None , model_name = None , asset_id_array = None ) Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project. required external_id_array Optional[List[str]] The external IDs of the assets for which we want to add predictions. None model_name_array Optional[List[str]] In case you want to precise from which model the label originated. None json_response_array Optional[List[dict]] The predictions are given here. For examples, see the recipe . None asset_id_array Optional[List[str]] The internal IDs of the assets for which we want to add predictions. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @typechecked def create_predictions ( self , project_id : str , external_id_array : Optional [ List [ str ]] = None , model_name_array : Optional [ List [ str ]] = None , json_response_array : Optional [ List [ dict ]] = None , model_name : Optional [ str ] = None , asset_id_array : Optional [ List [ str ]] = None , ) -> dict : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project. external_id_array: The external IDs of the assets for which we want to add predictions. model_name_array: In case you want to precise from which model the label originated. json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). asset_id_array: The internal IDs of the assets for which we want to add predictions. Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" if json_response_array is None or len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one prediction to upload\" ) assert_all_arrays_have_same_size ( [ external_id_array , json_response_array , model_name_array , asset_id_array ] ) if model_name is None : if model_name_array is None : raise ValueError ( \"You must provide a model name with the model_name argument \" ) if len ( set ( model_name_array )) > 1 : raise ValueError ( \"Creating predictions from different models is not supported anymore. Separate\" \" your calls by models.\" ) warnings . warn ( \"The use of `model_name_array` is deprecated. Creating predictions from different\" \" models is not supported anymore. Please use `model_name` argument instead to\" \" provide the predictions model name.\" , DeprecationWarning , ) model_name = model_name_array [ 0 ] labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , } for ( asset_id , asset_external_id , json_response ) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), external_id_array or [ None ] * len ( json_response_array ), json_response_array , ) ) ] services . import_labels_from_dict ( self , project_id , labels , \"PREDICTION\" , model_name ) return { \"id\" : project_id } update_properties_in_label ( self , label_id , seconds_to_label = None , model_name = None , json_response = None ) Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) Subscriptions Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket label_created_or_updated ( self , project_id , callback ) Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description SubscriptionGraphQLClient A subscription client. Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"Label"},{"location":"sdk/label/#label-module","text":"","title":"Label module"},{"location":"sdk/label/#queries","text":"Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. category_search: Query to filter labels based on the content of their jsonResponse !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return LabelQuery ( self . auth . client )( where , fields , options ) # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" services . get_project ( self , project_id , [ \"id\" ]) assets = AssetQuery ( self . auth . client )( AssetWhere ( project_id = project_id ), asset_fields + [ \"labels.\" + field for field in fields ], QueryOptions ( disable_tqdm = False ), ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , id_contains : Optional [ List [ str ]] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. category_search: Query to filter labels based on the content of their jsonResponse id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) return LabelQuery ( self . auth . client ) . count ( where ) def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , external_ids : Optional [ List [ str ]] = None , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: project_id: Identifier of the project. filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets internal IDs from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. external_ids: Optional list of the assets external IDs from which to export the labels. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" if external_ids is not None and asset_ids is None : id_map = infer_ids_from_external_ids ( kili = self , asset_external_ids = external_ids , project_id = project_id ) asset_ids = [ id_map [ id ] for id in external_ids ] try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp ))","title":"Queries"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.count_labels","text":"Get the number of labels for the given parameters. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None label_id Optional[str] Identifier of the label. None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None category_search Optional[str] Query to filter labels based on the content of their jsonResponse None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @typechecked def count_labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , label_id : Optional [ str ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None , id_contains : Optional [ List [ str ]] = None , ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. label_id: Identifier of the label. type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. category_search: Query to filter labels based on the content of their jsonResponse id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) return LabelQuery ( self . auth . client ) . count ( where )","title":"count_labels()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels","text":"Export the project labels with the requested format into the requested output path. Parameters: Name Type Description Default project_id str Identifier of the project. required filename str Relative or full path of the archive that will contain the exported data. required fmt Literal['raw', 'kili', 'yolo_v4', 'yolo_v5', 'yolo_v7', 'coco', 'pascal_voc'] Format of the exported labels. required asset_ids Optional[List[str]] Optional list of the assets internal IDs from which to export the labels. None layout Literal['split', 'merged'] Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. 'split' single_file bool Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). False disable_tqdm bool Disable the progress bar if True. False with_assets bool Download the assets in the export. True external_ids Optional[List[str]] Optional list of the assets external IDs from which to export the labels. None Info The supported formats are: Yolo V4, V5, V7 for object detection tasks (bounding box) Kili for all tasks. COCO for semantic segmentation tasks (bounding box and semantic segmentation) Pascal VOC for object detection tasks. Example from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") Source code in kili/queries/label/__init__.py def export_labels ( self , project_id : str , filename : str , fmt : LabelFormat , asset_ids : Optional [ List [ str ]] = None , layout : SplitOption = \"split\" , single_file : bool = False , disable_tqdm : bool = False , with_assets : bool = True , external_ids : Optional [ List [ str ]] = None , ): \"\"\" Export the project labels with the requested format into the requested output path. Args: project_id: Identifier of the project. filename: Relative or full path of the archive that will contain the exported data. fmt: Format of the exported labels. asset_ids: Optional list of the assets internal IDs from which to export the labels. layout: Layout of the exported files: \"split\" means there is one folder per job, \"merged\" that there is one folder with every labels. single_file: Layout of the exported labels. Single file mode is only available for some specific formats (COCO and Kili). disable_tqdm: Disable the progress bar if True. with_assets: Download the assets in the export. external_ids: Optional list of the assets external IDs from which to export the labels. !!! Info The supported formats are: - Yolo V4, V5, V7 for object detection tasks (bounding box) - Kili for all tasks. - COCO for semantic segmentation tasks (bounding box and semantic segmentation) - Pascal VOC for object detection tasks. !!! Example ``` from kili.client import Kili kili = Kili() kili.export_labels(\"your_project_id\", \"export.zip\", \"yolo_v4\") ``` \"\"\" if external_ids is not None and asset_ids is None : id_map = infer_ids_from_external_ids ( kili = self , asset_external_ids = external_ids , project_id = project_id ) asset_ids = [ id_map [ id ] for id in external_ids ] try : services . export_labels ( self , asset_ids = asset_ids , project_id = cast ( ProjectId , project_id ), export_type = \"latest\" , label_format = fmt , split_option = layout , single_file = single_file , output_file = filename , disable_tqdm = disable_tqdm , log_level = \"WARNING\" , with_assets = with_assets , ) except NoCompatibleJobError as excp : print ( str ( excp ))","title":"export_labels()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","text":"Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"createdAt\" , \"id\" , \"labelType\" , ], asset_fields : List [ str ] = [ \"externalId\" ], ) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" services . get_project ( self , project_id , [ \"id\" ]) assets = AssetQuery ( self . auth . client )( AssetWhere ( project_id = project_id ), asset_fields + [ \"labels.\" + field for field in fields ], QueryOptions ( disable_tqdm = False ), ) labels = [ dict ( label , ** dict (( f \"asset_ { key } \" , asset [ key ]) for key in asset if key != \"labels\" ), ) for asset in assets for label in asset [ \"labels\" ] ] labels_df = pd . DataFrame ( labels ) return labels_df","title":"export_labels_as_df()"},{"location":"sdk/label/#kili.queries.label.__init__.QueriesLabel.labels","text":"Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default project_id str Identifier of the project. required asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED , TO REVIEW or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None label_id Optional[str] Identifier of the label. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False category_search Optional[str] Query to filter labels based on the content of their jsonResponse None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @typechecked def labels ( self , project_id : str , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ \"author.email\" , \"author.id\" , \"id\" , \"jsonResponse\" , \"labelType\" , \"secondsToLabel\" , ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , skip : int = 0 , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: project_id: Identifier of the project. asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED`, `TO REVIEW` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have been made by authors in that list, if given. An author can be designated by the first name, the last name, or the first name + last name. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. label_id: Identifier of the label. skip: Number of labels to skip (they are ordered by their date of creation, first to last). type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. category_search: Query to filter labels based on the content of their jsonResponse !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if category_search : validate_category_search_query ( category_search ) where = LabelWhere ( project_id = project_id , asset_id = asset_id , asset_status_in = asset_status_in , asset_external_id_in = asset_external_id_in , author_in = author_in , created_at = created_at , created_at_gte = created_at_gte , created_at_lte = created_at_lte , honeypot_mark_gte = honeypot_mark_gte , honeypot_mark_lte = honeypot_mark_lte , id_contains = id_contains , label_id = label_id , type_in = type_in , user_id = user_id , category_search = category_search , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return LabelQuery ( self . auth . client )( where , fields , options )","title":"labels()"},{"location":"sdk/label/#mutations","text":"Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_predictions ( self , project_id : str , external_id_array : Optional [ List [ str ]] = None , model_name_array : Optional [ List [ str ]] = None , json_response_array : Optional [ List [ dict ]] = None , model_name : Optional [ str ] = None , asset_id_array : Optional [ List [ str ]] = None , ) -> dict : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project. external_id_array: The external IDs of the assets for which we want to add predictions. model_name_array: In case you want to precise from which model the label originated. json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). asset_id_array: The internal IDs of the assets for which we want to add predictions. Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" if json_response_array is None or len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one prediction to upload\" ) assert_all_arrays_have_same_size ( [ external_id_array , json_response_array , model_name_array , asset_id_array ] ) if model_name is None : if model_name_array is None : raise ValueError ( \"You must provide a model name with the model_name argument \" ) if len ( set ( model_name_array )) > 1 : raise ValueError ( \"Creating predictions from different models is not supported anymore. Separate\" \" your calls by models.\" ) warnings . warn ( \"The use of `model_name_array` is deprecated. Creating predictions from different\" \" models is not supported anymore. Please use `model_name` argument instead to\" \" provide the predictions model name.\" , DeprecationWarning , ) model_name = model_name_array [ 0 ] labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , } for ( asset_id , asset_external_id , json_response ) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), external_id_array or [ None ] * len ( json_response_array ), json_response_array , ) ) ] services . import_labels_from_dict ( self , project_id , labels , \"PREDICTION\" , model_name ) return { \"id\" : project_id } @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label ) @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , disable_tqdm : bool = False , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset internal ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` project_id: Identifier of the project asset_external_id_array: list of asset external ids to append labels on Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name , disable_tqdm ) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label ) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label )","title":"Mutations"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_labels","text":"Append labels to assets. Parameters: Name Type Description Default asset_id_array Optional[List[str]] list of asset internal ids to append labels on None json_response_array List[Dict] list of labels to append [] author_id_array Optional[List[str]] list of the author id of the labels None seconds_to_label_array Optional[List[int]] list of times taken to produce the label, in seconds None model_name Optional[str] Only useful when uploading predictions. Name of the model when uploading predictions None label_type Literal['AUTOSAVE', 'DEFAULT', 'INFERENCE', 'PREDICTION', 'REVIEW'] Can be one of AUTOSAVE , DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' project_id Optional[str] Identifier of the project None asset_external_id_array Optional[List[str]] list of asset external ids to append labels on None Returns: Type Description List A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( asset_id_array = [ 'cl9wmlkuc00050qsz6ut39g8h' , 'cl9wmlkuw00080qsz2kqh8aiy' ], json_response_array = [{ ... }, { ... }] ) Source code in kili/mutations/label/__init__.py @typechecked def append_labels ( # pylint: disable=dangerous-default-value self , asset_id_array : Optional [ List [ str ]] = None , json_response_array : List [ Dict ] = [], author_id_array : Optional [ List [ str ]] = None , seconds_to_label_array : Optional [ List [ int ]] = None , model_name : Optional [ str ] = None , label_type : LabelType = \"DEFAULT\" , project_id : Optional [ str ] = None , asset_external_id_array : Optional [ List [ str ]] = None , disable_tqdm : bool = False , ) -> List : \"\"\"Append labels to assets. Args: asset_id_array: list of asset internal ids to append labels on json_response_array: list of labels to append author_id_array: list of the author id of the labels seconds_to_label_array: list of times taken to produce the label, in seconds model_name: Only useful when uploading predictions. Name of the model when uploading predictions label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` project_id: Identifier of the project asset_external_id_array: list of asset external ids to append labels on Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels( asset_id_array=['cl9wmlkuc00050qsz6ut39g8h', 'cl9wmlkuw00080qsz2kqh8aiy'], json_response_array=[{...}, {...}] ) \"\"\" if len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one label to upload\" ) check_asset_identifier_arguments ( project_id , asset_id_array , asset_external_id_array ) assert_all_arrays_have_same_size ( [ seconds_to_label_array , author_id_array , json_response_array , asset_external_id_array , asset_id_array , ] ) labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , \"seconds_to_label\" : seconds_to_label , \"author_id\" : author_id , } for ( asset_id , asset_external_id , json_response , seconds_to_label , author_id ,) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), asset_external_id_array or [ None ] * len ( json_response_array ), json_response_array , seconds_to_label_array or [ None ] * len ( json_response_array ), author_id_array or [ None ] * len ( json_response_array ), ) ) ] return services . import_labels_from_dict ( self , project_id , labels , label_type , model_name , disable_tqdm )","title":"append_labels()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","text":"[DEPRECATED] append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of DEFAULT , PREDICTION , REVIEW or INFERENCE 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @deprecate ( msg = ( \"append_to_labels method is deprecated. Please use append_labels instead. This new\" \" function allows to import several labels 10 times faster.\" ) ) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = \"DEFAULT\" , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , ): \"\"\" !!! danger \"[DEPRECATED]\" append_to_labels method is deprecated. Please use append_labels instead. This new function allows to import several labels 10 times faster. Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `DEFAULT`, `PREDICTION`, `REVIEW` or `INFERENCE` seconds_to_label: Time to create the label !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id check_asset_identifier_arguments ( project_id , [ label_asset_id ] if label_asset_id else None , [ label_asset_external_id ] if label_asset_external_id else None , ) if label_asset_id is None : assert label_asset_external_id and project_id label_asset_id = infer_ids_from_external_ids ( self , [ label_asset_external_id ], project_id )[ label_asset_external_id ] variables = { \"data\" : { \"authorID\" : author_id , \"jsonResponse\" : dumps ( json_response ), \"labelType\" : label_type , \"secondsToLabel\" : seconds_to_label , }, \"where\" : { \"id\" : label_asset_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( \"data\" , result , Label )","title":"append_to_labels()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","text":"Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , ) -> Label : \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" if asset_id is None : if asset_external_id is None or project_id is None : raise Exception ( \"Either provide asset_id or external_id and project_id\" ) asset_id = infer_ids_from_external_ids ( self , [ asset_external_id ], project_id )[ asset_external_id ] variables = { \"data\" : { \"jsonResponse\" : dumps ( json_response )}, \"where\" : { \"id\" : asset_id }, } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( \"data\" , result , Label )","title":"create_honeypot()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","text":"Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project. required external_id_array Optional[List[str]] The external IDs of the assets for which we want to add predictions. None model_name_array Optional[List[str]] In case you want to precise from which model the label originated. None json_response_array Optional[List[dict]] The predictions are given here. For examples, see the recipe . None asset_id_array Optional[List[str]] The internal IDs of the assets for which we want to add predictions. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @typechecked def create_predictions ( self , project_id : str , external_id_array : Optional [ List [ str ]] = None , model_name_array : Optional [ List [ str ]] = None , json_response_array : Optional [ List [ dict ]] = None , model_name : Optional [ str ] = None , asset_id_array : Optional [ List [ str ]] = None , ) -> dict : # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project. external_id_array: The external IDs of the assets for which we want to add predictions. model_name_array: In case you want to precise from which model the label originated. json_response_array: The predictions are given here. For examples, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). asset_id_array: The internal IDs of the assets for which we want to add predictions. Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://docs.kili-technology.com/recipes/importing-labels-and-predictions). \"\"\" if json_response_array is None or len ( json_response_array ) == 0 : raise ValueError ( \"json_response_array is empty, you must provide at least one prediction to upload\" ) assert_all_arrays_have_same_size ( [ external_id_array , json_response_array , model_name_array , asset_id_array ] ) if model_name is None : if model_name_array is None : raise ValueError ( \"You must provide a model name with the model_name argument \" ) if len ( set ( model_name_array )) > 1 : raise ValueError ( \"Creating predictions from different models is not supported anymore. Separate\" \" your calls by models.\" ) warnings . warn ( \"The use of `model_name_array` is deprecated. Creating predictions from different\" \" models is not supported anymore. Please use `model_name` argument instead to\" \" provide the predictions model name.\" , DeprecationWarning , ) model_name = model_name_array [ 0 ] labels = [ { \"asset_id\" : asset_id , \"asset_external_id\" : asset_external_id , \"json_response\" : json_response , } for ( asset_id , asset_external_id , json_response ) in list ( zip ( asset_id_array or [ None ] * len ( json_response_array ), external_id_array or [ None ] * len ( json_response_array ), json_response_array , ) ) ] services . import_labels_from_dict ( self , project_id , labels , \"PREDICTION\" , model_name ) return { \"id\" : project_id }","title":"create_predictions()"},{"location":"sdk/label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","text":"Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description Label A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None , ) -> Label : \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { \"labelID\" : label_id , \"secondsToLabel\" : seconds_to_label , \"modelName\" : model_name , \"jsonResponse\" : formatted_json_response , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( \"data\" , result , Label )","title":"update_properties_in_label()"},{"location":"sdk/label/#subscriptions","text":"Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"Subscriptions"},{"location":"sdk/label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","text":"Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description SubscriptionGraphQLClient A subscription client. Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ] ) -> SubscriptionGraphQLClient : # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client. !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( \"http\" , \"ws\" ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { \"Accept\" : \"application/json\" , \"Content-Type\" : \"application/json\" } authorization = f \" { self . auth . client . token } \" headers [ \"Authorization\" ] = authorization variables = { \"projectID\" : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization , ) return websocket","title":"label_created_or_updated()"},{"location":"sdk/notification/","text":"Notification module Queries Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( \"data\" , result ) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) count_notifications ( self , has_been_seen = None , user_id = None ) Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) notifications ( self , fields = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first = None , has_been_seen = None , notification_id = None , skip = 0 , user_id = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first Optional[int] Number of notifications to query None has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"Notification"},{"location":"sdk/notification/#notification-module","text":"","title":"Notification module"},{"location":"sdk/notification/#queries","text":"Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( \"data\" , result ) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"Queries"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","text":"Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { \"where\" : { \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_notifications()"},{"location":"sdk/notification/#kili.queries.notification.__init__.QueriesNotification.notifications","text":"Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first Optional[int] Number of notifications to query None has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @typechecked def notifications ( self , fields : List [ str ] = [ \"createdAt\" , \"hasBeenSeen\" , \"id\" , \"message\" , \"status\" , \"userID\" , ], first : Optional [ int ] = None , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { \"where\" : { \"id\" : notification_id , \"user\" : { \"id\" : user_id , }, \"hasBeenSeen\" : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm , ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"notifications()"},{"location":"sdk/organization/","text":"Organization module Queries Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( \"data\" , result ) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result ) count_organizations ( self , email = None , organization_id = None ) Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) organization_metrics ( self , organization_id , start_date , end_date ) Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization required start_date datetime Start date of the metrics computation required end_date datetime End date of the metrics computation required Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result ) organizations ( self , email = None , organization_id = None , fields = [ 'id' , 'name' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first Optional[int] Maximum number of organizations to return. None skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"Organization"},{"location":"sdk/organization/#organization-module","text":"","title":"Organization module"},{"location":"sdk/organization/#queries","text":"Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( \"data\" , result ) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int ) @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result )","title":"Queries"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","text":"Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( \"data\" , result , int )","title":"count_organizations()"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","text":"Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization required start_date datetime Start date of the metrics computation required end_date datetime End date of the metrics computation required Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @typechecked def organization_metrics ( self , organization_id : str , start_date : datetime , end_date : datetime , ): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" if start_date is None : start_date = datetime . now () if end_date is None : end_date = datetime . now () variables = { \"where\" : { \"organizationId\" : organization_id , \"startDate\" : start_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , \"endDate\" : end_date . isoformat ( sep = \"T\" , timespec = \"milliseconds\" ) + \"Z\" , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( \"data\" , result )","title":"organization_metrics()"},{"location":"sdk/organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","text":"Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first Optional[int] Maximum number of organizations to return. None skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"id\" , \"name\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#organization) for all possible fields. first: Maximum number of organizations to return. skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"id\" : organization_id , \"user\" : { \"email\" : email , }, } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm , ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"organizations()"},{"location":"sdk/plugins/","text":"Plugin module Plugins structure A plugin is a set of : a python file a non mendatory requirements.txt file listing all the dependencies you need for you plugin. The plugin you are going to upload has to contain a class and two methods for the different types of events: on_submit on_review You can add custom methods in your class as well. Some attributes are available in the class: self.kili self.project_id The skeleton of the plugin should look like this: from kili.plugins import PluginCore from kili.types import Label import numpy as np def custom_function (): # Do something... class PluginHandler ( PluginCore ): \"\"\"Custom plugin\"\"\" def custom_method ( self ): # Do something... def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Review action\"\"\" # Do something... def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Submit action\"\"\" # Do something... Note The plugins run has some limitations, it can use a maximum of 512mb of ram and will timeout after 60sec of run Model for Plugins Kili Plugin core class Parameters: Name Type Description Default kili Kili kili instance that plugins can make use of required project_id str the project on which plugin is ran required Implements: on_submit(self, label: Label, asset_id: str) on_review(self, label: Label, asset_id: str) Warning : if using a custom init, be sure to call super(). init () Source code in kili/services/plugins/model.py class PluginCore : \"\"\" Kili Plugin core class Args: kili: kili instance that plugins can make use of project_id: the project on which plugin is ran Implements: on_submit(self, label: Label, asset_id: str) on_review(self, label: Label, asset_id: str) # Warning : if using a custom init, be sure to call super().__init__() \"\"\" logger : logging . Logger kili : Kili project_id : str def __init__ ( self , kili : Kili , project_id : str , logger : Optional [ logging . Logger ] = None ) -> None : self . kili = kili self . project_id = project_id if logger : self . logger = logger else : self . logger = logging . getLogger () def on_submit ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the submit action, triggered when a default label is submitted into Kili. Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_submit on your plugin\" ) pass # pylint: disable=unnecessary-pass def on_review ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the review action, triggered when a default label is reviewed on Kili Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_review on your plugin\" ) pass # pylint: disable=unnecessary-pass on_review ( self , label , asset_id ) Handler for the review action, triggered when a default label is reviewed on Kili Parameters: Name Type Description Default label Label label submitted to Kili required asset_id str id of the asset on which the label was submitted required Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) Source code in kili/services/plugins/model.py def on_review ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the review action, triggered when a default label is reviewed on Kili Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_review on your plugin\" ) pass # pylint: disable=unnecessary-pass on_submit ( self , label , asset_id ) Handler for the submit action, triggered when a default label is submitted into Kili. Parameters: Name Type Description Default label Label label submitted to Kili required asset_id str id of the asset on which the label was submitted required Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) Source code in kili/services/plugins/model.py def on_submit ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the submit action, triggered when a default label is submitted into Kili. Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_submit on your plugin\" ) pass # pylint: disable=unnecessary-pass Queries Set of Plugins queries. Source code in kili/queries/plugins/__init__.py class QueriesPlugins : \"\"\"Set of Plugins queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def get_plugin_logs ( self , project_id : str , plugin_name : str , start_date : Optional [ datetime ] = None , limit : Optional [ int ] = None , skip : Optional [ int ] = None , ): # pylint: disable=line-too-long \"\"\"Get paginated logs of a plugin on a project. Args: project_id: Identifier of the project plugin_name: Name of the plugin start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date limit: Limit for pagination, if not provided, it will be 100 skip: Skip for pagination, if not provided, it will be 0 Returns: A result array which contains the logs of the plugin, or an error message. Examples: >>> kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\") \"\"\" plugin = { \"project_id\" : project_id , \"plugin_name\" : plugin_name } pretty_result = get_logs ( self . auth , plugin , start_date , limit , skip ) return json . dumps ( pretty_result , sort_keys = True , indent = 4 ) @typechecked def get_plugin_status ( self , plugin_name : str , verbose : bool = True , ): \"\"\"Update a plugin with new code. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili.get_plugin_status(plugin_name=\"my_plugin_name\") \"\"\" result = PluginUploader ( self . auth , \"\" , plugin_name , verbose ) . get_plugin_runner_status () return result # pylint: disable=dangerous-default-value @typechecked def list_plugins ( self , fields : List [ str ] = [ \"name\" , \"projectIds\" , \"id\" , \"createdAt\" , \"updatedAt\" , ], ): # pylint: disable=line-too-long \"\"\"List all plugins from your organization Args: fields: All the fields to request among the possible fields for the plugins See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields. Returns: A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili.list_plugins() >>> kili.list_plugins(fields=['name']) \"\"\" return list_plugins ( self . auth , fields ) get_plugin_logs ( self , project_id , plugin_name , start_date = None , limit = None , skip = None ) Get paginated logs of a plugin on a project. Parameters: Name Type Description Default project_id str Identifier of the project required plugin_name str Name of the plugin required start_date Optional[datetime.datetime] Datetime used to get the logs from, if not provided, it will be the plugin's creation date None limit Optional[int] Limit for pagination, if not provided, it will be 100 None skip Optional[int] Skip for pagination, if not provided, it will be 0 None Returns: Type Description A result array which contains the logs of the plugin, or an error message. Examples: >>> kili . get_plugin_logs ( project_id = \"my_project_id\" , plugin_name = \"my_plugin_name\" , start_date = \"1970/01/01\" ) Source code in kili/queries/plugins/__init__.py @typechecked def get_plugin_logs ( self , project_id : str , plugin_name : str , start_date : Optional [ datetime ] = None , limit : Optional [ int ] = None , skip : Optional [ int ] = None , ): # pylint: disable=line-too-long \"\"\"Get paginated logs of a plugin on a project. Args: project_id: Identifier of the project plugin_name: Name of the plugin start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date limit: Limit for pagination, if not provided, it will be 100 skip: Skip for pagination, if not provided, it will be 0 Returns: A result array which contains the logs of the plugin, or an error message. Examples: >>> kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\") \"\"\" plugin = { \"project_id\" : project_id , \"plugin_name\" : plugin_name } pretty_result = get_logs ( self . auth , plugin , start_date , limit , skip ) return json . dumps ( pretty_result , sort_keys = True , indent = 4 ) get_plugin_status ( self , plugin_name , verbose = True ) Update a plugin with new code. Parameters: Name Type Description Default plugin_name str Name of the plugin required verbose bool If false, minimal logs are displayed True Returns: Type Description The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili . get_plugin_status ( plugin_name = \"my_plugin_name\" ) Source code in kili/queries/plugins/__init__.py @typechecked def get_plugin_status ( self , plugin_name : str , verbose : bool = True , ): \"\"\"Update a plugin with new code. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili.get_plugin_status(plugin_name=\"my_plugin_name\") \"\"\" result = PluginUploader ( self . auth , \"\" , plugin_name , verbose ) . get_plugin_runner_status () return result list_plugins ( self , fields = [ 'name' , 'projectIds' , 'id' , 'createdAt' , 'updatedAt' ]) List all plugins from your organization Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the plugins See the documentation for all possible fields. ['name', 'projectIds', 'id', 'createdAt', 'updatedAt'] Returns: Type Description A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili . list_plugins () >>> kili . list_plugins ( fields = [ 'name' ]) Source code in kili/queries/plugins/__init__.py @typechecked def list_plugins ( self , fields : List [ str ] = [ \"name\" , \"projectIds\" , \"id\" , \"createdAt\" , \"updatedAt\" , ], ): # pylint: disable=line-too-long \"\"\"List all plugins from your organization Args: fields: All the fields to request among the possible fields for the plugins See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields. Returns: A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili.list_plugins() >>> kili.list_plugins(fields=['name']) \"\"\" return list_plugins ( self . auth , fields ) Mutations Set of Plugins mutations. Source code in kili/mutations/plugins/__init__.py class MutationsPlugins : \"\"\"Set of Plugins mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def upload_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): # pylint: disable=line-too-long \"\"\"Uploads a plugin. Args: plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file plugin_name: name of your plugin, if not provided, it will be the name from your file verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.upload_plugin(plugin_path=\"./path/to/my/file.py\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead' ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . create_plugin () @typechecked def create_webhook ( self , webhook_url : str , plugin_name : str , header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Create a webhook linked to Kili's events. Args: webhook_url: URL receiving post requests on events on Kili plugin_name: name of your plugin header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , webhook_url , plugin_name , header , verbose ) . create_webhook () @typechecked def update_webhook ( self , new_webhook_url : str , plugin_name : str , new_header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Update a webhook linked to Kili's events. Args: new_webhook_url: New URL receiving post requests on events on Kili plugin_name: name of your plugin new_header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , new_webhook_url , plugin_name , new_header , verbose ) . update_webhook () @typechecked def activate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return activate_plugin ( self . auth , plugin_name , project_id ) @typechecked def deactivate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return deactivate_plugin ( self . auth , plugin_name , project_id ) @typechecked def delete_plugin ( self , plugin_name : str , ): # pylint: disable=line-too-long \"\"\"Deletes a plugin. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.delete_plugin(plugin_name=\"my_plugin_name\") \"\"\" return delete_plugin ( self . auth , plugin_name ) @typechecked def update_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): \"\"\"Update a plugin with new code. Args: plugin_path : Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_plugin(plugin_name=\"my_plugin_name\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( \"\"\" \"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead\"\"\" ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) if not plugin_name : raise TypeError ( '\"plugin_name is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . update_plugin () activate_plugin_on_project ( self , plugin_name , project_id ) Activates a plugin on a project. Parameters: Name Type Description Default plugin_name str Name of the plugin required project_id str Identifier of the project required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . activate_plugin_on_project ( plugin_name = \"my_plugin_name\" , project_id = \"my_project_id\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def activate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return activate_plugin ( self . auth , plugin_name , project_id ) create_webhook ( self , webhook_url , plugin_name , header = None , verbose = True ) Create a webhook linked to Kili's events. Parameters: Name Type Description Default webhook_url str URL receiving post requests on events on Kili required plugin_name str name of your plugin required header Optional[str] Authorization header to access the routes None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_webhook ( webhook_url = 'https://my-custom-url-publicly-accessible/' , plugin_name = 'my webhook' , header = '...' ) Source code in kili/mutations/plugins/__init__.py @typechecked def create_webhook ( self , webhook_url : str , plugin_name : str , header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Create a webhook linked to Kili's events. Args: webhook_url: URL receiving post requests on events on Kili plugin_name: name of your plugin header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , webhook_url , plugin_name , header , verbose ) . create_webhook () deactivate_plugin_on_project ( self , plugin_name , project_id ) Activates a plugin on a project. Parameters: Name Type Description Default plugin_name str Name of the plugin required project_id str Identifier of the project required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . deactivate_plugin_on_project ( plugin_name = \"my_plugin_name\" , project_id = \"my_project_id\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def deactivate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return deactivate_plugin ( self . auth , plugin_name , project_id ) delete_plugin ( self , plugin_name ) Deletes a plugin. Parameters: Name Type Description Default plugin_name str Name of the plugin required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . delete_plugin ( plugin_name = \"my_plugin_name\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def delete_plugin ( self , plugin_name : str , ): # pylint: disable=line-too-long \"\"\"Deletes a plugin. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.delete_plugin(plugin_name=\"my_plugin_name\") \"\"\" return delete_plugin ( self . auth , plugin_name ) update_plugin ( self , plugin_path = None , plugin_name = None , verbose = True , ** kwargs ) Update a plugin with new code. Parameters: Name Type Description Default plugin_path Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file None plugin_name Optional[str] Name of the plugin None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_plugin ( plugin_name = \"my_plugin_name\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def update_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): \"\"\"Update a plugin with new code. Args: plugin_path : Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_plugin(plugin_name=\"my_plugin_name\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( \"\"\" \"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead\"\"\" ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) if not plugin_name : raise TypeError ( '\"plugin_name is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . update_plugin () update_webhook ( self , new_webhook_url , plugin_name , new_header = None , verbose = True ) Update a webhook linked to Kili's events. Parameters: Name Type Description Default new_webhook_url str New URL receiving post requests on events on Kili required plugin_name str name of your plugin required new_header Optional[str] Authorization header to access the routes None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_webhook ( webhook_url = 'https://my-custom-url-publicly-accessible/' , plugin_name = 'my webhook' , header = '...' ) Source code in kili/mutations/plugins/__init__.py @typechecked def update_webhook ( self , new_webhook_url : str , plugin_name : str , new_header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Update a webhook linked to Kili's events. Args: new_webhook_url: New URL receiving post requests on events on Kili plugin_name: name of your plugin new_header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , new_webhook_url , plugin_name , new_header , verbose ) . update_webhook () upload_plugin ( self , plugin_path = None , plugin_name = None , verbose = True , ** kwargs ) Uploads a plugin. Parameters: Name Type Description Default plugin_path Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file None plugin_name Optional[str] name of your plugin, if not provided, it will be the name from your file None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . upload_plugin ( plugin_path = \"./path/to/my/file.py\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def upload_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): # pylint: disable=line-too-long \"\"\"Uploads a plugin. Args: plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file plugin_name: name of your plugin, if not provided, it will be the name from your file verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.upload_plugin(plugin_path=\"./path/to/my/file.py\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead' ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . create_plugin ()","title":"Plugins"},{"location":"sdk/plugins/#plugin-module","text":"","title":"Plugin module"},{"location":"sdk/plugins/#plugins-structure","text":"A plugin is a set of : a python file a non mendatory requirements.txt file listing all the dependencies you need for you plugin. The plugin you are going to upload has to contain a class and two methods for the different types of events: on_submit on_review You can add custom methods in your class as well. Some attributes are available in the class: self.kili self.project_id The skeleton of the plugin should look like this: from kili.plugins import PluginCore from kili.types import Label import numpy as np def custom_function (): # Do something... class PluginHandler ( PluginCore ): \"\"\"Custom plugin\"\"\" def custom_method ( self ): # Do something... def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Review action\"\"\" # Do something... def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Submit action\"\"\" # Do something... Note The plugins run has some limitations, it can use a maximum of 512mb of ram and will timeout after 60sec of run","title":"Plugins structure"},{"location":"sdk/plugins/#model-for-plugins","text":"Kili Plugin core class Parameters: Name Type Description Default kili Kili kili instance that plugins can make use of required project_id str the project on which plugin is ran required Implements: on_submit(self, label: Label, asset_id: str) on_review(self, label: Label, asset_id: str)","title":"Model for Plugins"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore--warning-if-using-a-custom-init-be-sure-to-call-superinit","text":"Source code in kili/services/plugins/model.py class PluginCore : \"\"\" Kili Plugin core class Args: kili: kili instance that plugins can make use of project_id: the project on which plugin is ran Implements: on_submit(self, label: Label, asset_id: str) on_review(self, label: Label, asset_id: str) # Warning : if using a custom init, be sure to call super().__init__() \"\"\" logger : logging . Logger kili : Kili project_id : str def __init__ ( self , kili : Kili , project_id : str , logger : Optional [ logging . Logger ] = None ) -> None : self . kili = kili self . project_id = project_id if logger : self . logger = logger else : self . logger = logging . getLogger () def on_submit ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the submit action, triggered when a default label is submitted into Kili. Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_submit on your plugin\" ) pass # pylint: disable=unnecessary-pass def on_review ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the review action, triggered when a default label is reviewed on Kili Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_review on your plugin\" ) pass # pylint: disable=unnecessary-pass","title":"Warning : if using a custom init, be sure to call super().init()"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_review","text":"Handler for the review action, triggered when a default label is reviewed on Kili Parameters: Name Type Description Default label Label label submitted to Kili required asset_id str id of the asset on which the label was submitted required Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) Source code in kili/services/plugins/model.py def on_review ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the review action, triggered when a default label is reviewed on Kili Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_review(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_review on your plugin\" ) pass # pylint: disable=unnecessary-pass","title":"on_review()"},{"location":"sdk/plugins/#kili.services.plugins.model.PluginCore.on_submit","text":"Handler for the submit action, triggered when a default label is submitted into Kili. Parameters: Name Type Description Default label Label label submitted to Kili required asset_id str id of the asset on which the label was submitted required Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) Source code in kili/services/plugins/model.py def on_submit ( self , label : Label , asset_id : str , ) -> None : \"\"\" Handler for the submit action, triggered when a default label is submitted into Kili. Args: label: label submitted to Kili asset_id: id of the asset on which the label was submitted Example use: >>> def on_submit(self, label: Label, asset_id: str): >>> json_response = label.get('jsonResponse') >>> if label_is_respecting_business_rule(json_response): >>> return >>> else: >>> self.kili.send_back_to_queue(asset_ids=[asset_id]) \"\"\" # pylint: disable=unused-argument self . logger . warning ( \"Method not implemented. Define a custom on_submit on your plugin\" ) pass # pylint: disable=unnecessary-pass","title":"on_submit()"},{"location":"sdk/plugins/#queries","text":"Set of Plugins queries. Source code in kili/queries/plugins/__init__.py class QueriesPlugins : \"\"\"Set of Plugins queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def get_plugin_logs ( self , project_id : str , plugin_name : str , start_date : Optional [ datetime ] = None , limit : Optional [ int ] = None , skip : Optional [ int ] = None , ): # pylint: disable=line-too-long \"\"\"Get paginated logs of a plugin on a project. Args: project_id: Identifier of the project plugin_name: Name of the plugin start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date limit: Limit for pagination, if not provided, it will be 100 skip: Skip for pagination, if not provided, it will be 0 Returns: A result array which contains the logs of the plugin, or an error message. Examples: >>> kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\") \"\"\" plugin = { \"project_id\" : project_id , \"plugin_name\" : plugin_name } pretty_result = get_logs ( self . auth , plugin , start_date , limit , skip ) return json . dumps ( pretty_result , sort_keys = True , indent = 4 ) @typechecked def get_plugin_status ( self , plugin_name : str , verbose : bool = True , ): \"\"\"Update a plugin with new code. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili.get_plugin_status(plugin_name=\"my_plugin_name\") \"\"\" result = PluginUploader ( self . auth , \"\" , plugin_name , verbose ) . get_plugin_runner_status () return result # pylint: disable=dangerous-default-value @typechecked def list_plugins ( self , fields : List [ str ] = [ \"name\" , \"projectIds\" , \"id\" , \"createdAt\" , \"updatedAt\" , ], ): # pylint: disable=line-too-long \"\"\"List all plugins from your organization Args: fields: All the fields to request among the possible fields for the plugins See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields. Returns: A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili.list_plugins() >>> kili.list_plugins(fields=['name']) \"\"\" return list_plugins ( self . auth , fields )","title":"Queries"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.get_plugin_logs","text":"Get paginated logs of a plugin on a project. Parameters: Name Type Description Default project_id str Identifier of the project required plugin_name str Name of the plugin required start_date Optional[datetime.datetime] Datetime used to get the logs from, if not provided, it will be the plugin's creation date None limit Optional[int] Limit for pagination, if not provided, it will be 100 None skip Optional[int] Skip for pagination, if not provided, it will be 0 None Returns: Type Description A result array which contains the logs of the plugin, or an error message. Examples: >>> kili . get_plugin_logs ( project_id = \"my_project_id\" , plugin_name = \"my_plugin_name\" , start_date = \"1970/01/01\" ) Source code in kili/queries/plugins/__init__.py @typechecked def get_plugin_logs ( self , project_id : str , plugin_name : str , start_date : Optional [ datetime ] = None , limit : Optional [ int ] = None , skip : Optional [ int ] = None , ): # pylint: disable=line-too-long \"\"\"Get paginated logs of a plugin on a project. Args: project_id: Identifier of the project plugin_name: Name of the plugin start_date: Datetime used to get the logs from, if not provided, it will be the plugin's creation date limit: Limit for pagination, if not provided, it will be 100 skip: Skip for pagination, if not provided, it will be 0 Returns: A result array which contains the logs of the plugin, or an error message. Examples: >>> kili.get_plugin_logs(project_id=\"my_project_id\", plugin_name=\"my_plugin_name\", start_date=\"1970/01/01\") \"\"\" plugin = { \"project_id\" : project_id , \"plugin_name\" : plugin_name } pretty_result = get_logs ( self . auth , plugin , start_date , limit , skip ) return json . dumps ( pretty_result , sort_keys = True , indent = 4 )","title":"get_plugin_logs()"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.get_plugin_status","text":"Update a plugin with new code. Parameters: Name Type Description Default plugin_name str Name of the plugin required verbose bool If false, minimal logs are displayed True Returns: Type Description The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili . get_plugin_status ( plugin_name = \"my_plugin_name\" ) Source code in kili/queries/plugins/__init__.py @typechecked def get_plugin_status ( self , plugin_name : str , verbose : bool = True , ): \"\"\"Update a plugin with new code. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: The status of the plugin if query was successful or an error message otherwise. Examples: >>> kili.get_plugin_status(plugin_name=\"my_plugin_name\") \"\"\" result = PluginUploader ( self . auth , \"\" , plugin_name , verbose ) . get_plugin_runner_status () return result","title":"get_plugin_status()"},{"location":"sdk/plugins/#kili.queries.plugins.__init__.QueriesPlugins.list_plugins","text":"List all plugins from your organization Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the plugins See the documentation for all possible fields. ['name', 'projectIds', 'id', 'createdAt', 'updatedAt'] Returns: Type Description A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili . list_plugins () >>> kili . list_plugins ( fields = [ 'name' ]) Source code in kili/queries/plugins/__init__.py @typechecked def list_plugins ( self , fields : List [ str ] = [ \"name\" , \"projectIds\" , \"id\" , \"createdAt\" , \"updatedAt\" , ], ): # pylint: disable=line-too-long \"\"\"List all plugins from your organization Args: fields: All the fields to request among the possible fields for the plugins See [the documentation](https://docs.kili-technology.com/reference/graphql-api#plugins) for all possible fields. Returns: A result array which contains all the plugins from your organization, or an error message. Examples: >>> kili.list_plugins() >>> kili.list_plugins(fields=['name']) \"\"\" return list_plugins ( self . auth , fields )","title":"list_plugins()"},{"location":"sdk/plugins/#mutations","text":"Set of Plugins mutations. Source code in kili/mutations/plugins/__init__.py class MutationsPlugins : \"\"\"Set of Plugins mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def upload_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): # pylint: disable=line-too-long \"\"\"Uploads a plugin. Args: plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file plugin_name: name of your plugin, if not provided, it will be the name from your file verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.upload_plugin(plugin_path=\"./path/to/my/file.py\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead' ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . create_plugin () @typechecked def create_webhook ( self , webhook_url : str , plugin_name : str , header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Create a webhook linked to Kili's events. Args: webhook_url: URL receiving post requests on events on Kili plugin_name: name of your plugin header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , webhook_url , plugin_name , header , verbose ) . create_webhook () @typechecked def update_webhook ( self , new_webhook_url : str , plugin_name : str , new_header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Update a webhook linked to Kili's events. Args: new_webhook_url: New URL receiving post requests on events on Kili plugin_name: name of your plugin new_header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , new_webhook_url , plugin_name , new_header , verbose ) . update_webhook () @typechecked def activate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return activate_plugin ( self . auth , plugin_name , project_id ) @typechecked def deactivate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return deactivate_plugin ( self . auth , plugin_name , project_id ) @typechecked def delete_plugin ( self , plugin_name : str , ): # pylint: disable=line-too-long \"\"\"Deletes a plugin. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.delete_plugin(plugin_name=\"my_plugin_name\") \"\"\" return delete_plugin ( self . auth , plugin_name ) @typechecked def update_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): \"\"\"Update a plugin with new code. Args: plugin_path : Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_plugin(plugin_name=\"my_plugin_name\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( \"\"\" \"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead\"\"\" ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) if not plugin_name : raise TypeError ( '\"plugin_name is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . update_plugin ()","title":"Mutations"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.activate_plugin_on_project","text":"Activates a plugin on a project. Parameters: Name Type Description Default plugin_name str Name of the plugin required project_id str Identifier of the project required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . activate_plugin_on_project ( plugin_name = \"my_plugin_name\" , project_id = \"my_project_id\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def activate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.activate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return activate_plugin ( self . auth , plugin_name , project_id )","title":"activate_plugin_on_project()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.create_webhook","text":"Create a webhook linked to Kili's events. Parameters: Name Type Description Default webhook_url str URL receiving post requests on events on Kili required plugin_name str name of your plugin required header Optional[str] Authorization header to access the routes None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_webhook ( webhook_url = 'https://my-custom-url-publicly-accessible/' , plugin_name = 'my webhook' , header = '...' ) Source code in kili/mutations/plugins/__init__.py @typechecked def create_webhook ( self , webhook_url : str , plugin_name : str , header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Create a webhook linked to Kili's events. Args: webhook_url: URL receiving post requests on events on Kili plugin_name: name of your plugin header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , webhook_url , plugin_name , header , verbose ) . create_webhook ()","title":"create_webhook()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.deactivate_plugin_on_project","text":"Activates a plugin on a project. Parameters: Name Type Description Default plugin_name str Name of the plugin required project_id str Identifier of the project required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . deactivate_plugin_on_project ( plugin_name = \"my_plugin_name\" , project_id = \"my_project_id\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def deactivate_plugin_on_project ( self , plugin_name : str , project_id : str , ): # pylint: disable=line-too-long \"\"\"Activates a plugin on a project. Args: plugin_name: Name of the plugin project_id: Identifier of the project verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.deactivate_plugin_on_project(plugin_name=\"my_plugin_name\", project_id=\"my_project_id\") \"\"\" return deactivate_plugin ( self . auth , plugin_name , project_id )","title":"deactivate_plugin_on_project()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.delete_plugin","text":"Deletes a plugin. Parameters: Name Type Description Default plugin_name str Name of the plugin required verbose If false, minimal logs are displayed required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . delete_plugin ( plugin_name = \"my_plugin_name\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def delete_plugin ( self , plugin_name : str , ): # pylint: disable=line-too-long \"\"\"Deletes a plugin. Args: plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.delete_plugin(plugin_name=\"my_plugin_name\") \"\"\" return delete_plugin ( self . auth , plugin_name )","title":"delete_plugin()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.update_plugin","text":"Update a plugin with new code. Parameters: Name Type Description Default plugin_path Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file None plugin_name Optional[str] Name of the plugin None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_plugin ( plugin_name = \"my_plugin_name\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def update_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): \"\"\"Update a plugin with new code. Args: plugin_path : Path to your plugin. Either: - a folder containing a main.py (mandatory) and a requirements.txt (optional) - a .py file plugin_name: Name of the plugin verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_plugin(plugin_name=\"my_plugin_name\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( \"\"\" \"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead\"\"\" ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) if not plugin_name : raise TypeError ( '\"plugin_name is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . update_plugin ()","title":"update_plugin()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.update_webhook","text":"Update a webhook linked to Kili's events. Parameters: Name Type Description Default new_webhook_url str New URL receiving post requests on events on Kili required plugin_name str name of your plugin required new_header Optional[str] Authorization header to access the routes None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_webhook ( webhook_url = 'https://my-custom-url-publicly-accessible/' , plugin_name = 'my webhook' , header = '...' ) Source code in kili/mutations/plugins/__init__.py @typechecked def update_webhook ( self , new_webhook_url : str , plugin_name : str , new_header : Optional [ str ] = None , verbose : bool = True , ): # pylint: disable=line-too-long \"\"\"Update a webhook linked to Kili's events. Args: new_webhook_url: New URL receiving post requests on events on Kili plugin_name: name of your plugin new_header: Authorization header to access the routes verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_webhook(webhook_url='https://my-custom-url-publicly-accessible/', plugin_name='my webhook', header='...') \"\"\" return WebhookUploader ( self . auth , new_webhook_url , plugin_name , new_header , verbose ) . update_webhook ()","title":"update_webhook()"},{"location":"sdk/plugins/#kili.mutations.plugins.__init__.MutationsPlugins.upload_plugin","text":"Uploads a plugin. Parameters: Name Type Description Default plugin_path Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file None plugin_name Optional[str] name of your plugin, if not provided, it will be the name from your file None verbose bool If false, minimal logs are displayed True Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . upload_plugin ( plugin_path = \"./path/to/my/file.py\" ) Source code in kili/mutations/plugins/__init__.py @typechecked def upload_plugin ( self , plugin_path : Optional [ str ] = None , plugin_name : Optional [ str ] = None , verbose : bool = True , ** kwargs ): # pylint: disable=line-too-long \"\"\"Uploads a plugin. Args: plugin_path : Path to your plugin. Either a folder containing a main.py (mandatory) and a requirements.txt (optional) or a .py file plugin_name: name of your plugin, if not provided, it will be the name from your file verbose: If false, minimal logs are displayed Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.upload_plugin(plugin_path=\"./path/to/my/file.py\") \"\"\" if kwargs . get ( \"file_path\" ): raise TypeError ( '\"file_path\" has been deprecated for \"plugin_path\", please use \"plugin_path\" instead' ) if not plugin_path : raise TypeError ( '\"plugin_path is nullish, please provide a value' ) return PluginUploader ( self . auth , plugin_path , plugin_name , verbose ) . create_plugin ()","title":"upload_plugin()"},{"location":"sdk/project/","text":"Project module Queries Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectQuery ( self . auth . client )( where , fields , options ) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) return ProjectQuery ( self . auth . client ) . count ( where ) count_projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None ) Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) return ProjectQuery ( self . auth . client ) . count ( where ) projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None , skip = 0 , fields = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first Optional[int] Maximum number of projects to return. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectQuery ( self . auth . client )( where , fields , options ) Mutations Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\"Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , Any ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) result = format_result ( \"data\" , result ) variables . pop ( \"projectID\" ) variables = { k : v for k , v in variables . items () if v is not None } new_project_settings = services . get_project ( self , project_id , list ( variables . keys ())) result = { ** result , ** new_project_settings } return result @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result ) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , copy_assets : bool = False , copy_labels : bool = False , disable_tqdm : bool = False , ) -> str : \"\"\"Create new project from an existing project. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Include json interface in the copy. copy_quality_settings: Include quality settings in the copy. copy_members: Include members in the copy. copy_assets: Include assets in the copy. copy_labels: Include labels in the copy. disable_tqdm: Disable tqdm progress bars. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return ProjectCopier ( self ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , copy_assets , copy_labels , disable_tqdm , ) append_to_roles ( self , project_id , user_email , role = 'LABELER' ) Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description Dict[str, Union[str, dict, list]] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) archive_project ( self , project_id ) Archive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) copy_project ( self , from_project_id , title = None , description = None , copy_json_interface = True , copy_quality_settings = True , copy_members = True , copy_assets = False , copy_labels = False , disable_tqdm = False ) Create new project from an existing project. Parameters: Name Type Description Default from_project_id str Project ID to copy from. required title Optional[str] Title for the new project. Defaults to source project title if None is provided. None description Optional[str] Description for the new project. Defaults to empty string if None is provided. None copy_json_interface bool Include json interface in the copy. True copy_quality_settings bool Include quality settings in the copy. True copy_members bool Include members in the copy. True copy_assets bool Include assets in the copy. False copy_labels bool Include labels in the copy. False disable_tqdm bool Disable tqdm progress bars. False Returns: Type Description str The created project ID. Examples: >>> kili . copy_project ( from_project_id = \"clbqn56b331234567890l41c0\" ) Source code in kili/mutations/project/__init__.py @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , copy_assets : bool = False , copy_labels : bool = False , disable_tqdm : bool = False , ) -> str : \"\"\"Create new project from an existing project. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Include json interface in the copy. copy_quality_settings: Include quality settings in the copy. copy_members: Include members in the copy. copy_assets: Include assets in the copy. copy_labels: Include labels in the copy. disable_tqdm: Disable tqdm progress bars. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return ProjectCopier ( self ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , copy_assets , copy_labels , disable_tqdm , ) create_project ( self , input_type , json_interface , title , description = '' , project_type = None ) Create a project. Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str Title of the project required description str Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) delete_from_roles ( self , role_id ) Delete users by their role_id. Parameters: Name Type Description Default role_id str Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) delete_project ( self , project_id ) Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description str A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) unarchive_project ( self , project_id ) Unarchive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) update_properties_in_project ( self , project_id , can_navigate_between_assets = None , can_skip_asset = None , consensus_mark = None , consensus_tot_coverage = None , description = None , honeypot_mark = None , instructions = None , input_type = None , json_interface = None , min_consensus_size = None , number_of_assets = None , number_of_skipped_assets = None , number_of_remaining_assets = None , number_of_reviewed_assets = None , review_coverage = None , should_relaunch_kpi_computation = None , title = None , use_honeypot = None , metadata_types = None ) Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required can_navigate_between_assets Optional[bool] Activate / Deactivate the use of next and previous buttons in labeling interface. None can_skip_asset Optional[bool] Activate / Deactivate the use of skip button in labeling interface. None consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None input_type Optional[str] Currently, one of AUDIO , IMAGE , PDF , TEXT , VIDEO , VIDEO_LEGACY . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_skipped_assets Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None metadata_types Optional[dict] Types of the project metadata. Should be a dict of metadata fields name as keys and metadata types as values. Currently, possible types are: string , number None Returns: Type Description Dict[str, Any] A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Change Metadata Types Metadata fields are by default interpreted as string types. To change the type of a metadata field, you can use the update_properties_in_project function with the metadata_types argument. metadata_types is given as a dict of metadata field names as keys and metadata types as values. Example: kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) Not providing a type for a metadata field or providing an unsupported one will default to the string type. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , Any ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) result = format_result ( \"data\" , result ) variables . pop ( \"projectID\" ) variables = { k : v for k , v in variables . items () if v is not None } new_project_settings = services . get_project ( self , project_id , list ( variables . keys ())) result = { ** result , ** new_project_settings } return result update_properties_in_role ( self , role_id , project_id , user_id , role ) Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result )","title":"Project"},{"location":"sdk/project/#project-module","text":"","title":"Project module"},{"location":"sdk/project/#queries","text":"Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectQuery ( self . auth . client )( where , fields , options ) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) return ProjectQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.count_projects","text":"Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , ) -> int : # pylint: disable=line-too-long \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) return ProjectQuery ( self . auth . client ) . count ( where )","title":"count_projects()"},{"location":"sdk/project/#kili.queries.project.__init__.QueriesProject.projects","text":"Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this PostgreSQL ILIKE pattern. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first Optional[int] Maximum number of projects to return. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ \"consensusTotCoverage\" , \"id\" , \"inputType\" , \"jsonInterface\" , \"minConsensusSize\" , \"reviewCoverage\" , \"roles.id\" , \"roles.role\" , \"roles.user.email\" , \"roles.user.id\" , \"title\" , ], first : Optional [ int ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this [PostgreSQL ILIKE](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE) pattern. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" where = ProjectWhere ( project_id = project_id , search_query = search_query , should_relaunch_kpi_computation = should_relaunch_kpi_computation , updated_at_gte = updated_at_gte , updated_at_lte = updated_at_lte , ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectQuery ( self . auth . client )( where , fields , options )","title":"projects()"},{"location":"sdk/project/#mutations","text":"Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\"Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth : KiliAuth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , Any ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) result = format_result ( \"data\" , result ) variables . pop ( \"projectID\" ) variables = { k : v for k , v in variables . items () if v is not None } new_project_settings = services . get_project ( self , project_id , list ( variables . keys ())) result = { ** result , ** new_project_settings } return result @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result ) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result ) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result ) @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result ) @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , copy_assets : bool = False , copy_labels : bool = False , disable_tqdm : bool = False , ) -> str : \"\"\"Create new project from an existing project. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Include json interface in the copy. copy_quality_settings: Include quality settings in the copy. copy_members: Include members in the copy. copy_assets: Include assets in the copy. copy_labels: Include labels in the copy. disable_tqdm: Disable tqdm progress bars. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return ProjectCopier ( self ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , copy_assets , copy_labels , disable_tqdm , )","title":"Mutations"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","text":"Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description Dict[str, Union[str, dict, list]] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = \"LABELER\" ) -> Dict [ str , Union [ str , dict , list , None ]]: \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { \"data\" : { \"role\" : role , \"userEmail\" : user_email }, \"where\" : { \"id\" : project_id }, } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( \"data\" , result )","title":"append_to_roles()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.archive_project","text":"Archive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def archive_project ( self , project_id : str ): \"\"\" Archive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : True , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result )","title":"archive_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.copy_project","text":"Create new project from an existing project. Parameters: Name Type Description Default from_project_id str Project ID to copy from. required title Optional[str] Title for the new project. Defaults to source project title if None is provided. None description Optional[str] Description for the new project. Defaults to empty string if None is provided. None copy_json_interface bool Include json interface in the copy. True copy_quality_settings bool Include quality settings in the copy. True copy_members bool Include members in the copy. True copy_assets bool Include assets in the copy. False copy_labels bool Include labels in the copy. False disable_tqdm bool Disable tqdm progress bars. False Returns: Type Description str The created project ID. Examples: >>> kili . copy_project ( from_project_id = \"clbqn56b331234567890l41c0\" ) Source code in kili/mutations/project/__init__.py @typechecked def copy_project ( # pylint: disable=too-many-arguments self , from_project_id : str , title : Optional [ str ] = None , description : Optional [ str ] = None , copy_json_interface : bool = True , copy_quality_settings : bool = True , copy_members : bool = True , copy_assets : bool = False , copy_labels : bool = False , disable_tqdm : bool = False , ) -> str : \"\"\"Create new project from an existing project. Args: from_project_id: Project ID to copy from. title: Title for the new project. Defaults to source project title if `None` is provided. description: Description for the new project. Defaults to empty string if `None` is provided. copy_json_interface: Include json interface in the copy. copy_quality_settings: Include quality settings in the copy. copy_members: Include members in the copy. copy_assets: Include assets in the copy. copy_labels: Include labels in the copy. disable_tqdm: Disable tqdm progress bars. Returns: The created project ID. Examples: >>> kili.copy_project(from_project_id=\"clbqn56b331234567890l41c0\") \"\"\" return ProjectCopier ( self ) . copy_project ( from_project_id , title , description , copy_json_interface , copy_quality_settings , copy_members , copy_assets , copy_labels , disable_tqdm , )","title":"copy_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.create_project","text":"Create a project. Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str Title of the project required description str Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description Dict A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = \"\" , project_type : Optional [ str ] = None , ) -> Dict : # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type: Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, VIDEO_LEGACY, NA} json_interface: The json parameters of the project, see Edit your interface. title: Title of the project description: Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://docs.kili-technology.com/recipes/creating-a-project). \"\"\" variables = { \"data\" : { \"description\" : description , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ), \"projectType\" : project_type , \"title\" : title , } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( \"data\" , result )","title":"create_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","text":"Delete users by their role_id. Parameters: Name Type Description Default role_id str Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id: Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( \"data\" , result )","title":"delete_from_roles()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.delete_project","text":"Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description str A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def delete_project ( self , project_id : str ) -> str : \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"id\" : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( \"data\" , result )","title":"delete_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.unarchive_project","text":"Unarchive a project. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def unarchive_project ( self , project_id : str ): \"\"\" Unarchive a project. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"projectID\" : project_id , \"archived\" : False , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( \"data\" , result )","title":"unarchive_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","text":"Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required can_navigate_between_assets Optional[bool] Activate / Deactivate the use of next and previous buttons in labeling interface. None can_skip_asset Optional[bool] Activate / Deactivate the use of skip button in labeling interface. None consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None input_type Optional[str] Currently, one of AUDIO , IMAGE , PDF , TEXT , VIDEO , VIDEO_LEGACY . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_skipped_assets Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None metadata_types Optional[dict] Types of the project metadata. Should be a dict of metadata fields name as keys and metadata types as values. Currently, possible types are: string , number None Returns: Type Description Dict[str, Any] A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Change Metadata Types Metadata fields are by default interpreted as string types. To change the type of a metadata field, you can use the update_properties_in_project function with the metadata_types argument. metadata_types is given as a dict of metadata field names as keys and metadata types as values. Example: kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) Not providing a type for a metadata field or providing an unsupported one will default to the string type. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_project ( self , project_id : str , can_navigate_between_assets : Optional [ bool ] = None , can_skip_asset : Optional [ bool ] = None , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_skipped_assets : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None , metadata_types : Optional [ dict ] = None , ) -> Dict [ str , Any ]: \"\"\"Update properties of a project. Args: project_id: Identifier of the project. can_navigate_between_assets: Activate / Deactivate the use of next and previous buttons in labeling interface. can_skip_asset: Activate / Deactivate the use of skip button in labeling interface. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. input_type: Currently, one of `AUDIO`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `VIDEO_LEGACY`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_skipped_assets: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project metadata_types: Types of the project metadata. Should be a `dict` of metadata fields name as keys and metadata types as values. Currently, possible types are: `string`, `number` Returns: A dict with the changed properties which indicates if the mutation was successful, else an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') !!! example \"Change Metadata Types\" Metadata fields are by default interpreted as `string` types. To change the type of a metadata field, you can use the `update_properties_in_project` function with the metadata_types argument. `metadata_types` is given as a dict of metadata field names as keys and metadata types as values. Example: ``` kili.update_properties_in_project( project_id = project_id, metadata_types = { 'customConsensus': 'number', 'sensitiveData': 'string', 'uploadedFromCloud': 'string', 'modelLabelErrorScore': 'number' } ) ``` Not providing a type for a metadata field or providing an unsupported one will default to the `string` type. \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { \"canNavigateBetweenAssets\" : can_navigate_between_assets , \"canSkipAsset\" : can_skip_asset , \"consensusMark\" : consensus_mark , \"consensusTotCoverage\" : consensus_tot_coverage , \"description\" : description , \"honeypotMark\" : honeypot_mark , \"instructions\" : instructions , \"inputType\" : input_type , \"jsonInterface\" : dumps ( json_interface ) if json_interface is not None else None , \"metadataTypes\" : metadata_types , \"minConsensusSize\" : min_consensus_size , \"numberOfAssets\" : number_of_assets , \"numberOfSkippedAssets\" : number_of_skipped_assets , \"numberOfRemainingAssets\" : number_of_remaining_assets , \"numberOfReviewedAssets\" : number_of_reviewed_assets , \"projectID\" : project_id , \"reviewCoverage\" : review_coverage , \"shouldRelaunchKpiComputation\" : should_relaunch_kpi_computation , \"title\" : title , \"useHoneyPot\" : use_honeypot , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) result = format_result ( \"data\" , result ) variables . pop ( \"projectID\" ) variables = { k : v for k , v in variables . items () if v is not None } new_project_settings = services . get_project ( self , project_id , list ( variables . keys ())) result = { ** result , ** new_project_settings } return result","title":"update_properties_in_project()"},{"location":"sdk/project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","text":"Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"roleID\" : role_id , \"projectID\" : project_id , \"userID\" : user_id , \"role\" : role , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_role()"},{"location":"sdk/project_user/","text":"Project User module Queries Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectUserQuery ( self . auth . client )( where , fields , options ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) return ProjectUserQuery ( self . auth . client ) . count ( where ) count_project_users ( self , project_id , email = None , id = None , organization_id = None ) Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id str Identifier of the project required Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) return ProjectUserQuery ( self . auth . client ) . count ( where ) project_users ( self , project_id , email = None , id = None , organization_id = None , fields = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default project_id str Identifier of the project required email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first Optional[int] Maximum number of users to return None skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectUserQuery ( self . auth . client )( where , fields , options )","title":"Project User"},{"location":"sdk/project_user/#project-user-module","text":"","title":"Project User module"},{"location":"sdk/project_user/#queries","text":"Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectUserQuery ( self . auth . client )( where , fields , options ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) return ProjectUserQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","text":"Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id str Identifier of the project required Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) return ProjectUserQuery ( self . auth . client ) . count ( where )","title":"count_project_users()"},{"location":"sdk/project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","text":"Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default project_id str Identifier of the project required email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first Optional[int] Maximum number of users to return None skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @typechecked def project_users ( self , project_id : str , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"activated\" , \"id\" , \"role\" , \"starred\" , \"user.email\" , \"user.id\" , ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: project_id: Identifier of the project email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" where = ProjectUserWhere ( project_id = project_id , email = email , _id = id , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return ProjectUserQuery ( self . auth . client )( where , fields , options )","title":"project_users()"},{"location":"sdk/project_version/","text":"Project Version module Queries Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( \"data\" , result ) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) count_project_versions ( self , project_id ) Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count ) project_version ( self , project_id , first = None , skip = 0 , fields = [ 'createdAt' , 'id' , 'content' , 'name' , 'projectId' ], disable_tqdm = False , as_generator = False ) Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default project_id str Filter on Id of project required fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'projectId'] first Optional[int] Number of project versions to query None skip int Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) Mutations Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result ) update_properties_in_project_version ( self , project_version_id , content ) Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"Project Version"},{"location":"sdk/project_version/#project-version-module","text":"","title":"Project Version module"},{"location":"sdk/project_version/#queries","text":"Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( \"data\" , result ) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"Queries"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","text":"Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { \"where\" : { \"projectId\" : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( \"data\" , result ) return int ( count )","title":"count_project_versions()"},{"location":"sdk/project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","text":"Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default project_id str Filter on Id of project required fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'projectId'] first Optional[int] Number of project versions to query None skip int Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @typechecked def project_version ( self , project_id : str , first : Optional [ int ] = None , skip : int = 0 , fields : List [ str ] = [ \"createdAt\" , \"id\" , \"content\" , \"name\" , \"projectId\" ], disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: project_id: Filter on Id of project fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { \"where\" : { \"projectId\" : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm , ) if as_generator : return project_versions_generator return list ( project_versions_generator )","title":"project_version()"},{"location":"sdk/project_version/#mutations","text":"Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","text":"Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { \"content\" : content , \"id\" : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_project_version()"},{"location":"sdk/user/","text":"User module Queries Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return UserQuery ( self . auth . client )( where , fields , options ) @typechecked def count_users ( self , organization_id : Optional [ str ] = None , api_key : Optional [ str ] = None , email : Optional [ str ] = None , ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) return UserQuery ( self . auth . client ) . count ( where ) count_users ( self , organization_id = None , api_key = None , email = None ) Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @typechecked def count_users ( self , organization_id : Optional [ str ] = None , api_key : Optional [ str ] = None , email : Optional [ str ] = None , ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) return UserQuery ( self . auth . client ) . count ( where ) users ( self , api_key = None , email = None , organization_id = None , fields = [ 'email' , 'id' , 'firstname' , 'lastname' ], first = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first Optional[int] Maximum number of users to return None skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return UserQuery ( self . auth . client )( where , fields , options ) Mutations Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result ) create_user ( self , email , password , organization_role , firstname = None , lastname = None ) Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. required password str On the first sign in, he will use this password and be able to change it. required organization_role str One of \"ADMIN\", \"USER\". required firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) reset_password ( self , email ) Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) update_password ( self , email , old_password , new_password_1 , new_password_2 ) Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) update_properties_in_user ( self , email , firstname = None , lastname = None , organization_id = None , organization_role = None , activated = None ) Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"User"},{"location":"sdk/user/#user-module","text":"","title":"User module"},{"location":"sdk/user/#queries","text":"Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return UserQuery ( self . auth . client )( where , fields , options ) @typechecked def count_users ( self , organization_id : Optional [ str ] = None , api_key : Optional [ str ] = None , email : Optional [ str ] = None , ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) return UserQuery ( self . auth . client ) . count ( where )","title":"Queries"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.count_users","text":"Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @typechecked def count_users ( self , organization_id : Optional [ str ] = None , api_key : Optional [ str ] = None , email : Optional [ str ] = None , ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) return UserQuery ( self . auth . client ) . count ( where )","title":"count_users()"},{"location":"sdk/user/#kili.queries.user.__init__.QueriesUser.users","text":"Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first Optional[int] Maximum number of users to return None skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Iterable[Dict] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ \"email\" , \"id\" , \"firstname\" , \"lastname\" ], first : Optional [ int ] = None , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False , ) -> Iterable [ Dict ]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" where = UserWhere ( api_key = api_key , email = email , organization_id = organization_id ) options = QueryOptions ( disable_tqdm , first , skip , as_generator ) return UserQuery ( self . auth . client )( where , fields , options )","title":"users()"},{"location":"sdk/user/#mutations","text":"Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result ) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result ) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"Mutations"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.create_user","text":"Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. required password str On the first sign in, he will use this password and be able to change it. required organization_role str One of \"ADMIN\", \"USER\". required firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def create_user ( self , email : str , password : str , organization_role : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"email\" : email , \"password\" : password , \"organizationRole\" : organization_role , } } if firstname is not None : variables [ \"data\" ][ \"firstname\" ] = firstname if lastname is not None : variables [ \"data\" ][ \"lastname\" ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( \"data\" , result )","title":"create_user()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.reset_password","text":"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"where\" : { \"email\" : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( \"data\" , result )","title":"reset_password()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_password","text":"Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { \"data\" : { \"oldPassword\" : old_password , \"newPassword1\" : new_password_1 , \"newPassword2\" : new_password_2 , }, \"where\" : { \"email\" : email }, } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( \"data\" , result )","title":"update_password()"},{"location":"sdk/user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","text":"Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None , ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables : Dict [ str , Any ] = { \"email\" : email , } if firstname is not None : variables [ \"firstname\" ] = firstname if lastname is not None : variables [ \"lastname\" ] = lastname if organization_id is not None : variables [ \"organizationId\" ] = organization_id if organization_role is not None : variables [ \"organizationRole\" ] = organization_role if activated is not None : variables [ \"activated\" ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( \"data\" , result )","title":"update_properties_in_user()"},{"location":"sdk/tutorials/basic_project_setup/","text":"How to set up a basic Kili project In this tutorial, we will learn how to set up a basic Kili project. Here are the steps that we will follow: Installing and instantiating Kili Creating a basic Kili project Adding assets to project Adding users to project Installing and instantiating Kili First, let's install and import the required modules. ! pip install kili from kili.client import Kili import getpass import os Now, let's set up variables needed to create an instance of the Kili object. We will need your API key and Kili's API endpoint. If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key . if \"KILI_API_KEY\" not in os . environ : KILI_API_KEY = getpass . getpass ( \"Please enter your API key: \" ) else : KILI_API_KEY = os . environ [ \"KILI_API_KEY\" ] With variables set up, we can now create an instance of the Kili object. kili = Kili ( api_key = KILI_API_KEY , # no need to pass the API_KEY if it is already in your environment variables # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\", # the line above can be uncommented and changed if you are working with an on-premise version of Kili ) Creating a basic Kili project To create a Kili project, you must first set up its interface. We will create a simple image project with just one simple classification job and two categories: OBJECT_A and OBJECT_B . To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface . interface = { \"jobs\" : { \"JOB_0\" : { \"mlTask\" : \"CLASSIFICATION\" , \"required\" : 1 , \"content\" : { \"categories\" : { \"OBJECT_A\" : { \"name\" : \"Object A\" }, \"OBJECT_B\" : { \"name\" : \"Object B\" }}, \"input\" : \"radio\" , }, } } } result = kili . create_project ( title = \"Test Project\" , description = \"Project Description\" , input_type = \"IMAGE\" , json_interface = interface , ) For further processing, we will need to find out what our project ID is. We can easily retrieve it from the project creation response message: project_id = result [ \"id\" ] print ( \"Project ID: \" , project_id ) Project ID: clcun99cn15wx0lq4c15a4dj7 Now, let's add some assets to be labeled. We will use some free off-the-shelf examples from the Internet. Adding assets to project # Image url url1 = \"https://images.unsplash.com/photo-1546069901-ba9599a7e63c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1480&q=80\" url2 = \"https://images.unsplash.com/photo-1565958011703-44f9829ba187?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1065&q=80\" url3 = \"https://images.unsplash.com/photo-1609951651556-5334e2706168?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=987&q=80\" assets = kili . append_many_to_dataset ( project_id = project_id , content_array = [ url1 , url2 , url3 ], external_id_array = [ \"image_1\" , \"image_2\" , \"image_3\" ], ) Adding users to project Now we need to add users to our project. Before we do that, we have to add them to our organization. Note that you have to be an org admin to be able to do that . For more info on roles in an organization, refer to https://docs.kili-technology.com/docs/user-roles-in-organization . firstname = \"Jane\" lastname = \"Doe\" email = \"no.such.email@no.such.domain.com\" password = \"12345\" organization_role = \"USER\" try : kili . create_user ( email , password , organization_role , firstname , lastname ) except Exception as err : print ( str ( err )) error: \"[noOrganizationRights] You cannot use this function because it seems that you do not have access to this organization. Please contact you organization admin. -- This can be due to: User isn't admin from the organization | trace : false\" If you already have users in your organization, here's how you can easily access their IDs: 1) First, retrieve your organization ID: org_id = kili . organizations ()[ 0 ][ \"id\" ] 2) Then, based on your org ID, retrieve the full list of org users, with their e-mails: all_org_users = kili . users ( organization_id = org_id ) all_emails = [ i [ \"email\" ] for i in all_org_users ] 3) We will use the e-mail of the new user to add our new user to our project: roles = kili . append_to_roles ( project_id , \"no.such.email@no.such.domain.com\" , role = \"LABELER\" ) print ( roles [ \"roles\" ][ - 1 ]) {'user': {'id': 'clcumy1fx15ci0lre0k21fnu7', 'email': 'no.such.email@no.such.domain.com'}, 'role': 'LABELER'} Cleanup To clean up, we need to simply remove the project that we created. kili . delete_project ( project_id ); Summary Done. We've successfully set up a Kili project, defined its interface, created a brand new user, and finally added our new user to the new project. Well done!","title":"Basic Project Setup"},{"location":"sdk/tutorials/basic_project_setup/#how-to-set-up-a-basic-kili-project","text":"In this tutorial, we will learn how to set up a basic Kili project. Here are the steps that we will follow: Installing and instantiating Kili Creating a basic Kili project Adding assets to project Adding users to project","title":"How to set up a basic Kili project"},{"location":"sdk/tutorials/basic_project_setup/#installing-and-instantiating-kili","text":"First, let's install and import the required modules. ! pip install kili from kili.client import Kili import getpass import os Now, let's set up variables needed to create an instance of the Kili object. We will need your API key and Kili's API endpoint. If you are unsure how to look up your API key, refer to https://docs.kili-technology.com/docs/creating-an-api-key . if \"KILI_API_KEY\" not in os . environ : KILI_API_KEY = getpass . getpass ( \"Please enter your API key: \" ) else : KILI_API_KEY = os . environ [ \"KILI_API_KEY\" ] With variables set up, we can now create an instance of the Kili object. kili = Kili ( api_key = KILI_API_KEY , # no need to pass the API_KEY if it is already in your environment variables # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\", # the line above can be uncommented and changed if you are working with an on-premise version of Kili )","title":"Installing and instantiating Kili"},{"location":"sdk/tutorials/basic_project_setup/#creating-a-basic-kili-project","text":"To create a Kili project, you must first set up its interface. We will create a simple image project with just one simple classification job and two categories: OBJECT_A and OBJECT_B . To learn more about Kili project interfaces, refer to https://docs.kili-technology.com/docs/customizing-project-interface . interface = { \"jobs\" : { \"JOB_0\" : { \"mlTask\" : \"CLASSIFICATION\" , \"required\" : 1 , \"content\" : { \"categories\" : { \"OBJECT_A\" : { \"name\" : \"Object A\" }, \"OBJECT_B\" : { \"name\" : \"Object B\" }}, \"input\" : \"radio\" , }, } } } result = kili . create_project ( title = \"Test Project\" , description = \"Project Description\" , input_type = \"IMAGE\" , json_interface = interface , ) For further processing, we will need to find out what our project ID is. We can easily retrieve it from the project creation response message: project_id = result [ \"id\" ] print ( \"Project ID: \" , project_id ) Project ID: clcun99cn15wx0lq4c15a4dj7 Now, let's add some assets to be labeled. We will use some free off-the-shelf examples from the Internet.","title":"Creating a basic Kili project"},{"location":"sdk/tutorials/basic_project_setup/#adding-assets-to-project","text":"# Image url url1 = \"https://images.unsplash.com/photo-1546069901-ba9599a7e63c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1480&q=80\" url2 = \"https://images.unsplash.com/photo-1565958011703-44f9829ba187?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1065&q=80\" url3 = \"https://images.unsplash.com/photo-1609951651556-5334e2706168?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=987&q=80\" assets = kili . append_many_to_dataset ( project_id = project_id , content_array = [ url1 , url2 , url3 ], external_id_array = [ \"image_1\" , \"image_2\" , \"image_3\" ], )","title":"Adding assets to project"},{"location":"sdk/tutorials/basic_project_setup/#adding-users-to-project","text":"Now we need to add users to our project. Before we do that, we have to add them to our organization. Note that you have to be an org admin to be able to do that . For more info on roles in an organization, refer to https://docs.kili-technology.com/docs/user-roles-in-organization . firstname = \"Jane\" lastname = \"Doe\" email = \"no.such.email@no.such.domain.com\" password = \"12345\" organization_role = \"USER\" try : kili . create_user ( email , password , organization_role , firstname , lastname ) except Exception as err : print ( str ( err )) error: \"[noOrganizationRights] You cannot use this function because it seems that you do not have access to this organization. Please contact you organization admin. -- This can be due to: User isn't admin from the organization | trace : false\" If you already have users in your organization, here's how you can easily access their IDs: 1) First, retrieve your organization ID: org_id = kili . organizations ()[ 0 ][ \"id\" ] 2) Then, based on your org ID, retrieve the full list of org users, with their e-mails: all_org_users = kili . users ( organization_id = org_id ) all_emails = [ i [ \"email\" ] for i in all_org_users ] 3) We will use the e-mail of the new user to add our new user to our project: roles = kili . append_to_roles ( project_id , \"no.such.email@no.such.domain.com\" , role = \"LABELER\" ) print ( roles [ \"roles\" ][ - 1 ]) {'user': {'id': 'clcumy1fx15ci0lre0k21fnu7', 'email': 'no.such.email@no.such.domain.com'}, 'role': 'LABELER'}","title":"Adding users to project"},{"location":"sdk/tutorials/basic_project_setup/#cleanup","text":"To clean up, we need to simply remove the project that we created. kili . delete_project ( project_id );","title":"Cleanup"},{"location":"sdk/tutorials/basic_project_setup/#summary","text":"Done. We've successfully set up a Kili project, defined its interface, created a brand new user, and finally added our new user to the new project. Well done!","title":"Summary"},{"location":"sdk/tutorials/export_a_kili_project/","text":"How to export a Kili project Outline This tutorial explains the multiple ways to export a Kili project. It describes: Methods to export the labels one by one, after filtering The solutions for performing a full-project export The methods are illustrated with code snippets. Export methods With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it: Fetch the assets and/or the labels one by one using .assets or .labels , perform the data transformation yourself and then write the data to one or several output files. Export the whole project as a dataset. To do that, use the .export_labels method that creates an archive containing the labels in your chosen format. Preliminary steps 1) Fetch the project ID from the Kili UI (in Settings / Admin): 2) Ensure that your Kili API key has been set as an environment variable: export KILI_API_KEY = <YOUR_API_KEY> 3) If Kili has not been installed yet, install Kili. ! pip install -- upgrade kili 4) Import packages and instantiate Kili : from kili.client import Kili from pathlib import Path kili = Kili () Exporting assets and labels one by one To retrieve all assets of a project one by one, perform the following steps: Exporting the latest labels per asset First, fetch the assets: assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"latestLabel.jsonResponse\" ]) Now if you print an asset, you will see that you can access its latestLabel : print ( assets [ 0 ]) {'latestLabel': {'jsonResponse': {'JOB_0': {'annotations': [{'categories': [{'name': 'OBJECT_A'}], 'mid': '20230111125258113-44528', 'type': 'rectangle', 'boundingPoly': [{'normalizedVertices': [{'x': 0.6101435505380516, 'y': 0.7689773770786136}, {'x': 0.6101435505380516, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.7689773770786136}]}], 'polyline': [], 'children': {}}]}}}, 'externalId': 'car_1'} You can now get your label, and write the category name into a text file for example: for asset in assets : if asset [ \"latestLabel\" ]: # check if asset has annotations class_ = asset [ \"latestLabel\" ][ \"jsonResponse\" ][ \"JOB_0\" ][ \"annotations\" ][ 0 ][ \"categories\" ][ 0 ][ \"name\" ] with Path ( asset [ \"externalId\" ] + \".txt\" ) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( class_ ) Filtering specific labels per asset through the method filters You can specify label filters directly in the .assets and the .labels methods. The available filters are listed in the arguments list for each one of these methods. When done, you can write the conversion code to get the data in the format that you need. Get only the assets with a consensus mark above 0.5: assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"id\" , \"consensusMark\" ], consensus_mark_gt = 0.5 ) print ( assets ) # + asset conversion code [{'externalId': 'car_1', 'id': 'clcyuykzd0000bgvze2z3wk81', 'consensusMark': 0.6504290982818591}] Get all the labels with a honeypot mark above 0.1: labels = kili . labels ( your_project_id , fields = [ \"labelOf.externalId\" , \"honeypotMark\" , \"author.email\" , \"id\" ], honeypot_mark_gte = 0.1 , ) print ( labels ) # + label conversion code [{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'honeypotMark': 0.16527040499137607, 'id': 'clcyuynri2fnl0krf0d7pgabo'}, {'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.smith@kili-technology.com'}, 'honeypotMark': 0.20754115450190522, 'id': 'clcyuynri2fnm0krfhx934jee'}] Get all the labels added by a specific project member: labels = kili . labels ( your_project_id , fields = [ \"labelOf.externalId\" , \"author.email\" , \"id\" ], user_id = john_doe_id ) print ( labels ) # + label conversion code [{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'id': 'clcyuynri2fnl0krf0d7pgabo'}] This code will return a list of labels authored by John Doe. You can also use the author_in parameter to filter by name directly. Filtering specific labels per asset through the label properties You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field \"labels.isLatestReviewLabelForUser\" to check if the label is the latest per user. import json assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"labels.jsonResponse\" , \"labels.isLatestReviewLabelForUser\" ], ) for asset in assets : if asset [ \"labels\" ]: # check if asset has annotations for label in asset [ \"labels\" ]: if label [ \"isLatestReviewLabelForUser\" ] and \"JOB_0\" in label [ \"jsonResponse\" ]: annotation = label [ \"jsonResponse\" ][ \"JOB_0\" ] with Path ( asset [ \"externalId\" ] + \".json\" ) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( annotation )) break # once we find a latest label done by a reviewer, we move on to the next asset. Filtering the latest label per annotator When working on a project with consensus enabled, it can be useful to export the latest label made by each annotator: from collections import defaultdict assets = kili . assets ( \"clb54wfkn01zb0kyadscgaf5j\" , fields = [ \"externalId\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.labelType\" , \"labels.jsonResponse\" , ], ) for asset in assets : if asset [ \"labels\" ]: latest_label_by_user = defaultdict ( list ) for label in asset [ \"labels\" ]: if label [ \"labelType\" ] == \"DEFAULT\" : latest_label_by_user [ label [ \"author\" ][ \"email\" ]] . append ( label ) latest_label_per_user = { email : max ( labels , key = lambda x : x [ \"createdAt\" ]) for email , labels in latest_label_by_user . items () } with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( latest_label_per_user )) Exporting a whole project Kili has a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats. Available formats Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705 The .export_labels method The .export_labels method enables the export of a full project. It does the following preprocessing: Only fetches the labels of types \"DEFAULT\" and \"REVIEW\" (see the label types explanations ). If specified, selects a subset of asset ids. Exports labels to one of the standard formats (only available for a restricted set of ML tasks). Using various method arguments, you can decide: Whether or not to include the assets in the export Whether to export just the latest label or all the labels Whether to create one folder for all the jobs or one folder per job Whether or not to export the label-related data into one single file Note that some formats are by default single-file, while others use many files: Format Single file Multiple files Kili \u2705 \u2705 Yolo \u274c \u2705 Pascal VOC \u274c \u2705 COCO \u2705 \u274c For all the formats, in the output archive, a README.kili.txt file is also created. Here is an example of its contents: Exported Labels from KILI ========================= - Project name: Awesome annotation project - Project identifier: abcdefghijklmnop - Project description: This project contains labels, most of which are awesome. - Export date: 20221125-093324 - Exported format: kili - Exported labels: latest Kili format, one file per asset The following code snippet exports the whole asset payload and the associated labels, with one json file per asset, into the /tmp/export.zip folder. kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"kili\" , ) Fetching assets... /tmp/export.zip Kili format, one file for the whole project This code snippet exports the whole asset payload and the associated labels as one file for the whole project, into the /tmp/export.zip folder. kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"kili\" , single_file = True , ) Fetching assets... /tmp/export.zip YOLO formats When you have at least one Object Detection job with bounding boxes, you can also export to one of the YOLO formats. You can choose \"yolo_v4\" , \"yolo_v5\" or \"yolo_v7\" . The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, one file per asset is produced, containing the last created DEFAULT or REVIEW label. Each YOLO label has the following shape: 2 0.25 0.67 0.26 0.34 ^ ^ ^ ^ ^ class x y w h where: class is the class index in the classes list contained in the YOLO metadata file. x is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box. y is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box. w is the width relative to the image width (between 0.0 and 1.0) of the bounding box. h is the height relative to the image height (between 0.0 and 1.0) of the bounding box. Here is an example of a YOLO annotation over an image: Here is how to export to YOLO (in this example, YOLOv5): kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) Fetching assets... /tmp/export.zip Note that a standard YOLO file format must also include: The path root to the assets The train , val and test subfolders Placing specific data in specific folders is the decision of an ML engineer or a Data scientist, so we are not providing a code snippet here. COCO format To export your data into the COCO format, run the following code: kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"coco\" , ) Fetching assets... Convert to coco format: 1it [00:00, 54.94it/s] /tmp/export.zip This will create an archive containing both: The COCO annotation file The data/ folder with all the assets Summary In this tutorial, we have seen several ways to export labels from a Kili project: Using .assets and .labels and their filtering arguments, a subset of assets or labels can be selected and then exported. Using .export_labels , the whole project can be exported into a standard output format.","title":"Export"},{"location":"sdk/tutorials/export_a_kili_project/#how-to-export-a-kili-project","text":"","title":"How to export a Kili project"},{"location":"sdk/tutorials/export_a_kili_project/#outline","text":"This tutorial explains the multiple ways to export a Kili project. It describes: Methods to export the labels one by one, after filtering The solutions for performing a full-project export The methods are illustrated with code snippets.","title":"Outline"},{"location":"sdk/tutorials/export_a_kili_project/#export-methods","text":"With Kili, once you have annotated enough assets, you can export the data programmatically to train a machine learning algorithm with it. There are several ways to do it: Fetch the assets and/or the labels one by one using .assets or .labels , perform the data transformation yourself and then write the data to one or several output files. Export the whole project as a dataset. To do that, use the .export_labels method that creates an archive containing the labels in your chosen format.","title":"Export methods"},{"location":"sdk/tutorials/export_a_kili_project/#preliminary-steps","text":"1) Fetch the project ID from the Kili UI (in Settings / Admin): 2) Ensure that your Kili API key has been set as an environment variable: export KILI_API_KEY = <YOUR_API_KEY> 3) If Kili has not been installed yet, install Kili. ! pip install -- upgrade kili 4) Import packages and instantiate Kili : from kili.client import Kili from pathlib import Path kili = Kili ()","title":"Preliminary steps"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-assets-and-labels-one-by-one","text":"To retrieve all assets of a project one by one, perform the following steps:","title":"Exporting assets and labels one by one"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-the-latest-labels-per-asset","text":"First, fetch the assets: assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"latestLabel.jsonResponse\" ]) Now if you print an asset, you will see that you can access its latestLabel : print ( assets [ 0 ]) {'latestLabel': {'jsonResponse': {'JOB_0': {'annotations': [{'categories': [{'name': 'OBJECT_A'}], 'mid': '20230111125258113-44528', 'type': 'rectangle', 'boundingPoly': [{'normalizedVertices': [{'x': 0.6101435505380516, 'y': 0.7689773770786136}, {'x': 0.6101435505380516, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.39426226491370664}, {'x': 0.8962087421313937, 'y': 0.7689773770786136}]}], 'polyline': [], 'children': {}}]}}}, 'externalId': 'car_1'} You can now get your label, and write the category name into a text file for example: for asset in assets : if asset [ \"latestLabel\" ]: # check if asset has annotations class_ = asset [ \"latestLabel\" ][ \"jsonResponse\" ][ \"JOB_0\" ][ \"annotations\" ][ 0 ][ \"categories\" ][ 0 ][ \"name\" ] with Path ( asset [ \"externalId\" ] + \".txt\" ) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( class_ )","title":"Exporting the latest labels per asset"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-method-filters","text":"You can specify label filters directly in the .assets and the .labels methods. The available filters are listed in the arguments list for each one of these methods. When done, you can write the conversion code to get the data in the format that you need. Get only the assets with a consensus mark above 0.5: assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"id\" , \"consensusMark\" ], consensus_mark_gt = 0.5 ) print ( assets ) # + asset conversion code [{'externalId': 'car_1', 'id': 'clcyuykzd0000bgvze2z3wk81', 'consensusMark': 0.6504290982818591}] Get all the labels with a honeypot mark above 0.1: labels = kili . labels ( your_project_id , fields = [ \"labelOf.externalId\" , \"honeypotMark\" , \"author.email\" , \"id\" ], honeypot_mark_gte = 0.1 , ) print ( labels ) # + label conversion code [{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'honeypotMark': 0.16527040499137607, 'id': 'clcyuynri2fnl0krf0d7pgabo'}, {'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.smith@kili-technology.com'}, 'honeypotMark': 0.20754115450190522, 'id': 'clcyuynri2fnm0krfhx934jee'}] Get all the labels added by a specific project member: labels = kili . labels ( your_project_id , fields = [ \"labelOf.externalId\" , \"author.email\" , \"id\" ], user_id = john_doe_id ) print ( labels ) # + label conversion code [{'labelOf': {'externalId': 'car_1'}, 'author': {'email': 'john.doe@kili-technology.com'}, 'id': 'clcyuynri2fnl0krf0d7pgabo'}] This code will return a list of labels authored by John Doe. You can also use the author_in parameter to filter by name directly.","title":"Filtering specific labels per asset through the method filters"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-specific-labels-per-asset-through-the-label-properties","text":"You can also look for specific labels, for example the last \"review\" status label per user, and dump the result into a json file. You can use the field \"labels.isLatestReviewLabelForUser\" to check if the label is the latest per user. import json assets = kili . assets ( your_project_id , fields = [ \"externalId\" , \"labels.jsonResponse\" , \"labels.isLatestReviewLabelForUser\" ], ) for asset in assets : if asset [ \"labels\" ]: # check if asset has annotations for label in asset [ \"labels\" ]: if label [ \"isLatestReviewLabelForUser\" ] and \"JOB_0\" in label [ \"jsonResponse\" ]: annotation = label [ \"jsonResponse\" ][ \"JOB_0\" ] with Path ( asset [ \"externalId\" ] + \".json\" ) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( annotation )) break # once we find a latest label done by a reviewer, we move on to the next asset.","title":"Filtering specific labels per asset through the label properties"},{"location":"sdk/tutorials/export_a_kili_project/#filtering-the-latest-label-per-annotator","text":"When working on a project with consensus enabled, it can be useful to export the latest label made by each annotator: from collections import defaultdict assets = kili . assets ( \"clb54wfkn01zb0kyadscgaf5j\" , fields = [ \"externalId\" , \"labels.author.email\" , \"labels.createdAt\" , \"labels.labelType\" , \"labels.jsonResponse\" , ], ) for asset in assets : if asset [ \"labels\" ]: latest_label_by_user = defaultdict ( list ) for label in asset [ \"labels\" ]: if label [ \"labelType\" ] == \"DEFAULT\" : latest_label_by_user [ label [ \"author\" ][ \"email\" ]] . append ( label ) latest_label_per_user = { email : max ( labels , key = lambda x : x [ \"createdAt\" ]) for email , labels in latest_label_by_user . items () } with ( Path ( \"/tmp\" ) / ( asset [ \"externalId\" ] + \".json\" )) . open ( \"w\" , encoding = \"utf-8\" ) as f : f . write ( json . dumps ( latest_label_per_user ))","title":"Filtering the latest label per annotator"},{"location":"sdk/tutorials/export_a_kili_project/#exporting-a-whole-project","text":"Kili has a method to export the whole project into specific export formats. It can be useful when your goal is to use one of the standard output formats.","title":"Exporting a whole project"},{"location":"sdk/tutorials/export_a_kili_project/#available-formats","text":"Format UI Python Client Command Line Interface Kili (raw) \u2705 \u2705 \u2705 Kili (simple) \u2705 \u274c \u274c YOLO V4 \u2705 \u2705 \u2705 YOLO V5 \u2705 \u2705 \u2705 YOLO V7 \u274c \u2705 \u2705 Pascal VOC \u2705 \u2705 \u2705 COCO \u274c \u2705 \u2705","title":"Available formats"},{"location":"sdk/tutorials/export_a_kili_project/#the-export_labels-method","text":"The .export_labels method enables the export of a full project. It does the following preprocessing: Only fetches the labels of types \"DEFAULT\" and \"REVIEW\" (see the label types explanations ). If specified, selects a subset of asset ids. Exports labels to one of the standard formats (only available for a restricted set of ML tasks). Using various method arguments, you can decide: Whether or not to include the assets in the export Whether to export just the latest label or all the labels Whether to create one folder for all the jobs or one folder per job Whether or not to export the label-related data into one single file Note that some formats are by default single-file, while others use many files: Format Single file Multiple files Kili \u2705 \u2705 Yolo \u274c \u2705 Pascal VOC \u274c \u2705 COCO \u2705 \u274c For all the formats, in the output archive, a README.kili.txt file is also created. Here is an example of its contents: Exported Labels from KILI ========================= - Project name: Awesome annotation project - Project identifier: abcdefghijklmnop - Project description: This project contains labels, most of which are awesome. - Export date: 20221125-093324 - Exported format: kili - Exported labels: latest","title":"The .export_labels method"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-per-asset","text":"The following code snippet exports the whole asset payload and the associated labels, with one json file per asset, into the /tmp/export.zip folder. kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"kili\" , ) Fetching assets... /tmp/export.zip","title":"Kili format, one file per asset"},{"location":"sdk/tutorials/export_a_kili_project/#kili-format-one-file-for-the-whole-project","text":"This code snippet exports the whole asset payload and the associated labels as one file for the whole project, into the /tmp/export.zip folder. kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"kili\" , single_file = True , ) Fetching assets... /tmp/export.zip","title":"Kili format, one file for the whole project"},{"location":"sdk/tutorials/export_a_kili_project/#yolo-formats","text":"When you have at least one Object Detection job with bounding boxes, you can also export to one of the YOLO formats. You can choose \"yolo_v4\" , \"yolo_v5\" or \"yolo_v7\" . The difference between each format is the structure of the metadata YAML file, which specifies the object classes. In all the cases, one file per asset is produced, containing the last created DEFAULT or REVIEW label. Each YOLO label has the following shape: 2 0.25 0.67 0.26 0.34 ^ ^ ^ ^ ^ class x y w h where: class is the class index in the classes list contained in the YOLO metadata file. x is the x-coordinate relative to the image width (between 0.0 and 1.0) of the center of the bounding box. y is the y-coordinate relative to the image height (between 0.0 and 1.0) of the center of the bounding box. w is the width relative to the image width (between 0.0 and 1.0) of the bounding box. h is the height relative to the image height (between 0.0 and 1.0) of the bounding box. Here is an example of a YOLO annotation over an image: Here is how to export to YOLO (in this example, YOLOv5): kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"yolo_v5\" , ) Fetching assets... /tmp/export.zip Note that a standard YOLO file format must also include: The path root to the assets The train , val and test subfolders Placing specific data in specific folders is the decision of an ML engineer or a Data scientist, so we are not providing a code snippet here.","title":"YOLO formats"},{"location":"sdk/tutorials/export_a_kili_project/#coco-format","text":"To export your data into the COCO format, run the following code: kili . export_labels ( project_id = your_project_id , filename = \"/tmp/export.zip\" , fmt = \"coco\" , ) Fetching assets... Convert to coco format: 1it [00:00, 54.94it/s] /tmp/export.zip This will create an archive containing both: The COCO annotation file The data/ folder with all the assets","title":"COCO format"},{"location":"sdk/tutorials/export_a_kili_project/#summary","text":"In this tutorial, we have seen several ways to export labels from a Kili project: Using .assets and .labels and their filtering arguments, a subset of assets or labels can be selected and then exported. Using .export_labels , the whole project can be exported into a standard output format.","title":"Summary"},{"location":"sdk/tutorials/plugins_development/","text":"Plugins Development Preliminary This notebook will teach you how to build your first plugin. A plugin is an uploaded Python script triggered by an event that you define. For instance, you can trigger a plugin when a labeler clicks on Submit with the on_submit handler. The plugin should have different methods for the different types of events: on_submit on_review These methods have a predefined set of parameters: the label submitted the asset_id of the asset labeled Some attributes are available in the class: self.kili self.project_id Therefore, the skeleton of the plugin should look like this: from kili.plugins import PluginCore from kili.types import Label import numpy as np class PluginHandler ( PluginCore ): \"\"\"Custom plugin\"\"\" def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Review action\"\"\" # Do something... def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Submit action\"\"\" # Do something... IMPORTANT : Imports of packages inside the plugin are not permitted at the moment (except for numpy , & the various kili types). Do not hesitate to reach out to us if you need more. NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or Kili support to provide feedback. Instantiate Kili ! pip install -- upgrade kili from kili.client import Kili import os kili = Kili () Develop your plugin The first step is to define the functions that will be called when the event is triggered. You will be able to iterate on these functions locally (more on that in the next section). This cell should be the contents of the .py file that you will upload as a plugin at the end. This file should define the PluginHandler class that will contain the proper methods. We recommend using a modern IDE like VScode to get type hints and autocompletion on the methods. from kili.plugins import PluginCore from kili.types import Label import numpy as np def custom_function ( label : Label ): label_id = label . get ( \"id\" ) print ( f \"My custom function for review of label with id { label_id } \" ) class PluginHandler ( PluginCore ): \"\"\" Custom plugin instance \"\"\" def custom_method ( self , project_id , label_id ): print ( f \"custom_method called for label { label_id } \" ) random_seed = np . random . random ( 1 )[ 0 ] if random_seed > 0.5 : self . logger . warning ( \"Generating issue\" ) # Use kili for actions with self.kili self . kili . append_to_issues ( label_id = label_id , project_id = project_id , text = \"Random issue generated for this label\" , ) def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Review action \"\"\" custom_function ( label ) def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Submit action \"\"\" print ( \"On submit called\" ) project_id = self . project_id label_id = label . get ( \"id\" ) self . custom_method ( project_id , label_id ) Testing the plugin locally In this we will show you how to test your plugin locally before uploading it. project_id = \"<PROJECT ID>\" Instantiate the plugin: my_plugin_instance = PluginHandler ( kili , project_id ) def get_label ( label_id , project_id ): \"\"\" Function to get the object Label with the same keys as it will be in the plugin \"\"\" label = list ( kili . labels ( project_id = project_id , label_id = label_id , fields = [ \"id\" , \"jsonResponse\" , \"author.id\" , \"labelType\" , \"createdAt\" , \"secondsToLabel\" ], ) )[ 0 ] label [ \"authorId\" ] = label [ \"author\" ][ \"id\" ] del label [ \"author\" ] return label Test the plugin run If you already have a test project with labels added, you can directly use the IDs of these labels (see the following cell). Otherwise, you can follow the plugins_example.ipynb notebook to create a new project and then upload an asset with an associated label. asset_id = \"<YOUR_ASSET_ID>\" label_id = \"<YOUR_LABEL_ID>\" label = get_label ( label_id = label_id , project_id = project_id ) my_plugin_instance . on_submit ( label = Label ( ** label ), asset_id = asset_id ) On submit called custom_method called for label clcyqwn5a2gyk0lpn8d7w486h Test the plugin run on Kili When you finish debugging the code, you may want to upload it directly into Kili. Note that you might get an error if the plugin name already exists in your Kili organization. path_to_plugin = \"path/to/my/plugin.py\" plugin_name = \"My first kili plugin\" from kili.exceptions import GraphQLError try : kili . upload_plugin ( path_to_plugin , plugin_name ) except GraphQLError as error : print ( str ( error )) Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin.py\", plugin_name=\"My first kili plugin\") error: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"My first kili plugin\" for field 'name' | trace : false\" Plugins must be activated in the project that you want them to run in. Be careful with production projects: your custom workflows or rules will also be applied kili . activate_plugin_on_project ( plugin_name , project_id = project_id ); Plugin with name \"My first kili plugin\" activated on project \"clcyr3xsz2e8j0lrehb1ufte9\" Monitoring the plugin Plugin creation takes some time (around 5 minutes). The plugin will begin to run only after it's been fully created (if labeling events are to be triggered on this project). Additionally, you can get the logs of the runs: kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name ) You can set custom date rules for filtering your logs: from datetime import date from datetime import datetime dt = date . today () # You can change this date if needed start_date = datetime . combine ( dt , datetime . min . time ()) kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name , start_date = start_date ) Managing your plugin Here are several other methods to manage your plugins and their lifecycle: Get the list of all uploaded plugins in your organization: plugins = kili . list_plugins () print ([ plugin for plugin in plugins if plugin [ \"name\" ] == plugin_name ]) [{'name': 'My first kili plugin', 'projectIds': ['clcyoj8s129ap0krfd5k2cjvl', 'clcyqw5m42e380lredqtzh4tx'], 'id': 'clb12ceii05to019g5wkh9rvz', 'createdAt': '2022-11-28T17:27:35.802Z', 'updatedAt': '2023-01-16T11:00:36.691Z'}] Update a plugin with new source code: updated_path = \"plugin.py\" if updated_path != path_to_plugin : kili . update_plugin ( plugin_name = plugin_name , plugin_path = updated_path ) Deactivate the plugin on a certain project (the plugin can still be active for other projects): kili . deactivate_plugin_on_project ( plugin_name = plugin_name , project_id = project_id ); Plugin My first kili plugin deactivated on project clcyr3xsz2e8j0lrehb1ufte9 Delete the plugin completely (deactivates automatically the plugin from all projects): if delete_plugin_from_org : kili . delete_plugin ( plugin_name = plugin_name )","title":"Plugins Development"},{"location":"sdk/tutorials/plugins_development/#plugins-development","text":"","title":"Plugins Development"},{"location":"sdk/tutorials/plugins_development/#preliminary","text":"This notebook will teach you how to build your first plugin. A plugin is an uploaded Python script triggered by an event that you define. For instance, you can trigger a plugin when a labeler clicks on Submit with the on_submit handler. The plugin should have different methods for the different types of events: on_submit on_review These methods have a predefined set of parameters: the label submitted the asset_id of the asset labeled Some attributes are available in the class: self.kili self.project_id Therefore, the skeleton of the plugin should look like this: from kili.plugins import PluginCore from kili.types import Label import numpy as np class PluginHandler ( PluginCore ): \"\"\"Custom plugin\"\"\" def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Review action\"\"\" # Do something... def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\"Dedicated handler for Submit action\"\"\" # Do something... IMPORTANT : Imports of packages inside the plugin are not permitted at the moment (except for numpy , & the various kili types). Do not hesitate to reach out to us if you need more. NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or Kili support to provide feedback.","title":"Preliminary"},{"location":"sdk/tutorials/plugins_development/#instantiate-kili","text":"! pip install -- upgrade kili from kili.client import Kili import os kili = Kili ()","title":"Instantiate Kili"},{"location":"sdk/tutorials/plugins_development/#develop-your-plugin","text":"The first step is to define the functions that will be called when the event is triggered. You will be able to iterate on these functions locally (more on that in the next section). This cell should be the contents of the .py file that you will upload as a plugin at the end. This file should define the PluginHandler class that will contain the proper methods. We recommend using a modern IDE like VScode to get type hints and autocompletion on the methods. from kili.plugins import PluginCore from kili.types import Label import numpy as np def custom_function ( label : Label ): label_id = label . get ( \"id\" ) print ( f \"My custom function for review of label with id { label_id } \" ) class PluginHandler ( PluginCore ): \"\"\" Custom plugin instance \"\"\" def custom_method ( self , project_id , label_id ): print ( f \"custom_method called for label { label_id } \" ) random_seed = np . random . random ( 1 )[ 0 ] if random_seed > 0.5 : self . logger . warning ( \"Generating issue\" ) # Use kili for actions with self.kili self . kili . append_to_issues ( label_id = label_id , project_id = project_id , text = \"Random issue generated for this label\" , ) def on_review ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Review action \"\"\" custom_function ( label ) def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Submit action \"\"\" print ( \"On submit called\" ) project_id = self . project_id label_id = label . get ( \"id\" ) self . custom_method ( project_id , label_id )","title":"Develop your plugin"},{"location":"sdk/tutorials/plugins_development/#testing-the-plugin-locally","text":"In this we will show you how to test your plugin locally before uploading it. project_id = \"<PROJECT ID>\" Instantiate the plugin: my_plugin_instance = PluginHandler ( kili , project_id ) def get_label ( label_id , project_id ): \"\"\" Function to get the object Label with the same keys as it will be in the plugin \"\"\" label = list ( kili . labels ( project_id = project_id , label_id = label_id , fields = [ \"id\" , \"jsonResponse\" , \"author.id\" , \"labelType\" , \"createdAt\" , \"secondsToLabel\" ], ) )[ 0 ] label [ \"authorId\" ] = label [ \"author\" ][ \"id\" ] del label [ \"author\" ] return label","title":"Testing the plugin locally"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run","text":"If you already have a test project with labels added, you can directly use the IDs of these labels (see the following cell). Otherwise, you can follow the plugins_example.ipynb notebook to create a new project and then upload an asset with an associated label. asset_id = \"<YOUR_ASSET_ID>\" label_id = \"<YOUR_LABEL_ID>\" label = get_label ( label_id = label_id , project_id = project_id ) my_plugin_instance . on_submit ( label = Label ( ** label ), asset_id = asset_id ) On submit called custom_method called for label clcyqwn5a2gyk0lpn8d7w486h","title":"Test the plugin run"},{"location":"sdk/tutorials/plugins_development/#test-the-plugin-run-on-kili","text":"When you finish debugging the code, you may want to upload it directly into Kili. Note that you might get an error if the plugin name already exists in your Kili organization. path_to_plugin = \"path/to/my/plugin.py\" plugin_name = \"My first kili plugin\" from kili.exceptions import GraphQLError try : kili . upload_plugin ( path_to_plugin , plugin_name ) except GraphQLError as error : print ( str ( error )) Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin.py\", plugin_name=\"My first kili plugin\") error: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"My first kili plugin\" for field 'name' | trace : false\" Plugins must be activated in the project that you want them to run in. Be careful with production projects: your custom workflows or rules will also be applied kili . activate_plugin_on_project ( plugin_name , project_id = project_id ); Plugin with name \"My first kili plugin\" activated on project \"clcyr3xsz2e8j0lrehb1ufte9\"","title":"Test the plugin run on Kili"},{"location":"sdk/tutorials/plugins_development/#monitoring-the-plugin","text":"Plugin creation takes some time (around 5 minutes). The plugin will begin to run only after it's been fully created (if labeling events are to be triggered on this project). Additionally, you can get the logs of the runs: kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name ) You can set custom date rules for filtering your logs: from datetime import date from datetime import datetime dt = date . today () # You can change this date if needed start_date = datetime . combine ( dt , datetime . min . time ()) kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name , start_date = start_date )","title":"Monitoring the plugin"},{"location":"sdk/tutorials/plugins_development/#managing-your-plugin","text":"Here are several other methods to manage your plugins and their lifecycle: Get the list of all uploaded plugins in your organization: plugins = kili . list_plugins () print ([ plugin for plugin in plugins if plugin [ \"name\" ] == plugin_name ]) [{'name': 'My first kili plugin', 'projectIds': ['clcyoj8s129ap0krfd5k2cjvl', 'clcyqw5m42e380lredqtzh4tx'], 'id': 'clb12ceii05to019g5wkh9rvz', 'createdAt': '2022-11-28T17:27:35.802Z', 'updatedAt': '2023-01-16T11:00:36.691Z'}] Update a plugin with new source code: updated_path = \"plugin.py\" if updated_path != path_to_plugin : kili . update_plugin ( plugin_name = plugin_name , plugin_path = updated_path ) Deactivate the plugin on a certain project (the plugin can still be active for other projects): kili . deactivate_plugin_on_project ( plugin_name = plugin_name , project_id = project_id ); Plugin My first kili plugin deactivated on project clcyr3xsz2e8j0lrehb1ufte9 Delete the plugin completely (deactivates automatically the plugin from all projects): if delete_plugin_from_org : kili . delete_plugin ( plugin_name = plugin_name )","title":"Managing your plugin"},{"location":"sdk/tutorials/plugins_example/","text":"Plugins Example Context This notebook is an end-to-end example that you can follow to: create a project, upload a first plugin and activate it on this project, and finally start monitoring it. NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback. Step 1: Instantiate Kili ! pip install -- upgrade kili from kili.client import Kili import os import time kili = Kili () Step 2: Create the project First, we need to create a new project. In our example, we will use an IMAGE type project with the following jsonInterace : json_interface = { \"jobs\" : { \"JOB_0\" : { \"content\" : { \"categories\" : { \"OBJECT_A\" : { \"children\" : [], \"name\" : \"Object A\" , \"color\" : \"#733AFB\" , \"id\" : \"category1\" , }, \"OBJECT_B\" : { \"children\" : [], \"name\" : \"Object B\" , \"color\" : \"#3CD876\" , \"id\" : \"category2\" , }, }, \"input\" : \"radio\" , }, \"instruction\" : \"Categories\" , \"isChild\" : False , \"tools\" : [ \"rectangle\" ], \"mlTask\" : \"OBJECT_DETECTION\" , \"models\" : {}, \"isVisible\" : True , \"required\" : 1 , \"isNew\" : False , } } } title = \"Plugins test project\" description = \"My first project with a plugin\" input_type = \"IMAGE\" project = kili . create_project ( title = title , description = description , input_type = input_type , json_interface = json_interface ) project_id = project [ \"id\" ] print ( f \"Created project { project_id } \" ) Created project clcysbp9o2d7w0krfghuf7le1 Upload an asset: content_array = [ \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\" ] names_array = [ \"landscape\" ] kili . append_many_to_dataset ( project_id = project_id , content_array = content_array , external_id_array = names_array ) asset_id = list ( kili . assets ( project_id = project_id , fields = [ \"id\" ], disable_tqdm = True ))[ 0 ][ \"id\" ] This project has two jobs with several associated transcription tasks. We are interested in the Payment information job; more precisely the IBAN and the Currency sub-jobs. With our plugin, we want to make sure that the labelers type the correct values for the two transcriptions (so we are interested only in the on_submit handler of the plugin). The IBAN should start with FR , and that the currency should be EUR or USD . At the end, we want to calculate accuracy and insert the accuracy score in the json_metadata of the asset. To iterate on the plugin code, you can refer to the plugins_development.ipynb notebook. Step 3: Write the plugin from kili.plugins import PluginCore from kili.types import Label def check_rules_on_label ( label : Label ): #custom methods print ( 'Custom method - checking number of bboxes' ) counter = 0 for annotation in label [ 'jsonResponse' ][ \"JOB_0\" ][ \"annotations\" ]: if annotation [ \"categories\" ][ 0 ][ \"name\" ] == \"OBJECT_A\" : counter += 1 if counter == 0 : return [] return [ f 'There are too many BBox ( { counter } ) - Only 1 BBox of Object A accepted' ] class PluginHandler ( PluginCore ): \"\"\" Custom plugin instance \"\"\" def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Submit action \"\"\" self . logger . info ( \"On submit called\" ) issues_array = check_rules_on_label ( label ) project_id = self . project_id if len ( issues_array ) > 0 : print ( \"Creating an issue...\" ) for i , _ in enumerate ( issues_array ): self . kili . append_to_issues ( label_id = label [ 'id' ], project_id = project_id , text = issues_array [ i ], ) print ( \"Issue created!\" ) self . kili . send_back_to_queue ( asset_ids = [ asset_id ]) import urllib.request urllib . request . urlretrieve ( \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/master/recipes/datasets/plugins/plugin.py\" , \"plugin.py\" , ); Step 4: Upload the plugin With the plugin defined in a separate Python file, we can now upload it and activate it on our project. The upload will create the necessary builds to execute the plugin (it will take a few minutes) After the activation, you can start using your plugin right away. path_to_plugin = \"plugin.py\" plugin_name = \"Plugin bbox count\" from kili.exceptions import GraphQLError try : kili . upload_plugin ( path_to_plugin , plugin_name ) except GraphQLError as error : print ( str ( error )) Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin.py\", plugin_name=\"Plugin bbox count\") error: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"Plugin bbox count\" for field 'name' | trace : false\" kili . activate_plugin_on_project ( plugin_name , project_id = project_id ); Plugin with name \"Plugin bbox count\" activated on project \"clcysbp9o2d7w0krfghuf7le1\" Step 5: Plugin in action Wait for the plugin to be successfully deployed. After that, you can test it by labelling in the Kili interface or just by uploading the following label. When you add the label that contains errors, you will see a new issue automatically created in the Kili app. json_response = { \"JOB_0\" : { \"annotations\" : [ { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.15 , \"y\" : 0.84 }, { \"x\" : 0.15 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.84 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161451411-13314\" , \"type\" : \"rectangle\" , }, { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.79 , \"y\" : 0.20 }, { \"x\" : 0.79 , \"y\" : 0.13 }, { \"x\" : 0.91 , \"y\" : 0.13 }, { \"x\" : 0.91 , \"y\" : 0.20 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161456406-47055\" , \"type\" : \"rectangle\" , }, { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.87 , \"y\" : 0.36 }, { \"x\" : 0.87 , \"y\" : 0.27 }, { \"x\" : 0.99 , \"y\" : 0.27 }, { \"x\" : 0.99 , \"y\" : 0.36 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161459298-45160\" , \"type\" : \"rectangle\" , }, ] } } kili . append_labels ( json_response_array = [ json_response ], asset_id_array = [ asset_id ], label_type = \"DEFAULT\" ) [{'id': 'clcysc83n2asf0lq483rlc5wv'}] If you use the base plugin provided, the plugin should: Create an issue with information that three bboxes were found, instead of one Send the asset back to the labeling queue (status ONGOING ) print ( kili . assets ( project_id = project_id , asset_id = asset_id , fields = [ \"status\" , \"issues.comments.text\" ]) ) print ( f 'Go to my project: { kili . auth . api_endpoint . split ( \"/api\" )[ 0 ] } /label/projects/ { project_id } /menu/queue' ) [{'issues': [], 'status': 'LABELED'}] Go to my project: https://cloud.kili-technology.com/label/projects/clcysbp9o2d7w0krfghuf7le1/menu/queue Woah! Amazing! Well done :) \ud83d\ude80 Let's test now to post a proper label, this one for example: json_response = { \"JOB_0\" : { \"annotations\" : [ { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.15 , \"y\" : 0.84 }, { \"x\" : 0.15 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.84 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161451411-13314\" , \"type\" : \"rectangle\" , } ] } } kili . append_labels ( json_response_array = [ json_response ], asset_id_array = [ asset_id ], label_type = \"DEFAULT\" ) print ( kili . assets ( project_id = project_id , asset_id = asset_id , fields = [ \"status\" ])) print ( f 'Go to my project: { kili . auth . api_endpoint . split ( \"/api\" )[ 0 ] } /label/projects/ { project_id } /menu/queue' ) [{'status': 'LABELED'}] Go to my project: https://cloud.kili-technology.com/label/projects/clcysbp9o2d7w0krfghuf7le1/menu/queue The status of your asset should have now changed to LABELED . In this plugin, previous issues remain but you can solve them through the API as well. Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins_development.ipynb tutorial. Step 6: Monitor the plugin To monitor a certain plugin, you can get its logs by using the following command: import json from datetime import date from datetime import datetime dt = ( date . today () ) # You can change this date if needed, or omit it to set it at the plugin creation date start_date = datetime . combine ( dt , datetime . min . time ()) logs = kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name , start_date = start_date ) logs_json = json . loads ( logs ) print ( json . dumps ( logs_json , indent = 4 )) [ { \"content\": \"Issue created!\", \"createdAt\": \"2023-01-16T12:31:27.633Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"Creating an issue...\", \"createdAt\": \"2023-01-16T12:31:26.620Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"Custom method - checking number of bboxes\", \"createdAt\": \"2023-01-16T12:31:26.619Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"On submit called\", \"createdAt\": \"2023-01-16T12:31:26.619Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" } ] Step 7: Manage the plugin You also have several other methods to manage your plugins. Get the list of all uploaded plugins in your organization: plugins = kili . list_plugins () Update a plugin with new source code: new_path_to_plugin = \"plugin.py\" if new_path_to_plugin != path_to_plugin : kili . update_plugin ( plugin_name = plugin_name , plugin_path = new_path_to_plugin ) Deactivate the plugin on a certain project (the plugin can still be active for other projects): kili . deactivate_plugin_on_project ( plugin_name = plugin_name , project_id = project_id ); Plugin Plugin bbox count deactivated on project clcysbp9o2d7w0krfghuf7le1 Delete the plugin completely (deactivates the plugin from all projects): if delete_plugin_from_org : kili . delete_plugin ( plugin_name = plugin_name )","title":"Plugins Example"},{"location":"sdk/tutorials/plugins_example/#plugins-example","text":"","title":"Plugins Example"},{"location":"sdk/tutorials/plugins_example/#context","text":"This notebook is an end-to-end example that you can follow to: create a project, upload a first plugin and activate it on this project, and finally start monitoring it. NB: The plugin capabilities of Kili are under active development, and compatible with version 2.125.2 and later of Kili. Don't hesitate to reach out via Github or the Kili support to provide feedback.","title":"Context"},{"location":"sdk/tutorials/plugins_example/#step-1-instantiate-kili","text":"! pip install -- upgrade kili from kili.client import Kili import os import time kili = Kili ()","title":"Step 1: Instantiate Kili"},{"location":"sdk/tutorials/plugins_example/#step-2-create-the-project","text":"First, we need to create a new project. In our example, we will use an IMAGE type project with the following jsonInterace : json_interface = { \"jobs\" : { \"JOB_0\" : { \"content\" : { \"categories\" : { \"OBJECT_A\" : { \"children\" : [], \"name\" : \"Object A\" , \"color\" : \"#733AFB\" , \"id\" : \"category1\" , }, \"OBJECT_B\" : { \"children\" : [], \"name\" : \"Object B\" , \"color\" : \"#3CD876\" , \"id\" : \"category2\" , }, }, \"input\" : \"radio\" , }, \"instruction\" : \"Categories\" , \"isChild\" : False , \"tools\" : [ \"rectangle\" ], \"mlTask\" : \"OBJECT_DETECTION\" , \"models\" : {}, \"isVisible\" : True , \"required\" : 1 , \"isNew\" : False , } } } title = \"Plugins test project\" description = \"My first project with a plugin\" input_type = \"IMAGE\" project = kili . create_project ( title = title , description = description , input_type = input_type , json_interface = json_interface ) project_id = project [ \"id\" ] print ( f \"Created project { project_id } \" ) Created project clcysbp9o2d7w0krfghuf7le1 Upload an asset: content_array = [ \"https://storage.googleapis.com/label-public-staging/car/car_1.jpg\" ] names_array = [ \"landscape\" ] kili . append_many_to_dataset ( project_id = project_id , content_array = content_array , external_id_array = names_array ) asset_id = list ( kili . assets ( project_id = project_id , fields = [ \"id\" ], disable_tqdm = True ))[ 0 ][ \"id\" ] This project has two jobs with several associated transcription tasks. We are interested in the Payment information job; more precisely the IBAN and the Currency sub-jobs. With our plugin, we want to make sure that the labelers type the correct values for the two transcriptions (so we are interested only in the on_submit handler of the plugin). The IBAN should start with FR , and that the currency should be EUR or USD . At the end, we want to calculate accuracy and insert the accuracy score in the json_metadata of the asset. To iterate on the plugin code, you can refer to the plugins_development.ipynb notebook.","title":"Step 2: Create the project"},{"location":"sdk/tutorials/plugins_example/#step-3-write-the-plugin","text":"from kili.plugins import PluginCore from kili.types import Label def check_rules_on_label ( label : Label ): #custom methods print ( 'Custom method - checking number of bboxes' ) counter = 0 for annotation in label [ 'jsonResponse' ][ \"JOB_0\" ][ \"annotations\" ]: if annotation [ \"categories\" ][ 0 ][ \"name\" ] == \"OBJECT_A\" : counter += 1 if counter == 0 : return [] return [ f 'There are too many BBox ( { counter } ) - Only 1 BBox of Object A accepted' ] class PluginHandler ( PluginCore ): \"\"\" Custom plugin instance \"\"\" def on_submit ( self , label : Label , asset_id : str ) -> None : \"\"\" Dedicated handler for Submit action \"\"\" self . logger . info ( \"On submit called\" ) issues_array = check_rules_on_label ( label ) project_id = self . project_id if len ( issues_array ) > 0 : print ( \"Creating an issue...\" ) for i , _ in enumerate ( issues_array ): self . kili . append_to_issues ( label_id = label [ 'id' ], project_id = project_id , text = issues_array [ i ], ) print ( \"Issue created!\" ) self . kili . send_back_to_queue ( asset_ids = [ asset_id ]) import urllib.request urllib . request . urlretrieve ( \"https://raw.githubusercontent.com/kili-technology/kili-python-sdk/master/recipes/datasets/plugins/plugin.py\" , \"plugin.py\" , );","title":"Step 3: Write the plugin"},{"location":"sdk/tutorials/plugins_example/#step-4-upload-the-plugin","text":"With the plugin defined in a separate Python file, we can now upload it and activate it on our project. The upload will create the necessary builds to execute the plugin (it will take a few minutes) After the activation, you can start using your plugin right away. path_to_plugin = \"plugin.py\" plugin_name = \"Plugin bbox count\" from kili.exceptions import GraphQLError try : kili . upload_plugin ( path_to_plugin , plugin_name ) except GraphQLError as error : print ( str ( error )) Hint: A plugin with this name already exist, if you want to override it you can use the command kili.update_plugin(plugin_path=\"plugin.py\", plugin_name=\"Plugin bbox count\") error: \"[pluginsError] An error occured handling your plugin -- This can be due to: 400: Bad Request: createPlugin: an entity Plugin already exists with value \"Plugin bbox count\" for field 'name' | trace : false\" kili . activate_plugin_on_project ( plugin_name , project_id = project_id ); Plugin with name \"Plugin bbox count\" activated on project \"clcysbp9o2d7w0krfghuf7le1\"","title":"Step 4: Upload the plugin"},{"location":"sdk/tutorials/plugins_example/#step-5-plugin-in-action","text":"Wait for the plugin to be successfully deployed. After that, you can test it by labelling in the Kili interface or just by uploading the following label. When you add the label that contains errors, you will see a new issue automatically created in the Kili app. json_response = { \"JOB_0\" : { \"annotations\" : [ { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.15 , \"y\" : 0.84 }, { \"x\" : 0.15 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.84 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161451411-13314\" , \"type\" : \"rectangle\" , }, { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.79 , \"y\" : 0.20 }, { \"x\" : 0.79 , \"y\" : 0.13 }, { \"x\" : 0.91 , \"y\" : 0.13 }, { \"x\" : 0.91 , \"y\" : 0.20 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161456406-47055\" , \"type\" : \"rectangle\" , }, { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.87 , \"y\" : 0.36 }, { \"x\" : 0.87 , \"y\" : 0.27 }, { \"x\" : 0.99 , \"y\" : 0.27 }, { \"x\" : 0.99 , \"y\" : 0.36 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161459298-45160\" , \"type\" : \"rectangle\" , }, ] } } kili . append_labels ( json_response_array = [ json_response ], asset_id_array = [ asset_id ], label_type = \"DEFAULT\" ) [{'id': 'clcysc83n2asf0lq483rlc5wv'}] If you use the base plugin provided, the plugin should: Create an issue with information that three bboxes were found, instead of one Send the asset back to the labeling queue (status ONGOING ) print ( kili . assets ( project_id = project_id , asset_id = asset_id , fields = [ \"status\" , \"issues.comments.text\" ]) ) print ( f 'Go to my project: { kili . auth . api_endpoint . split ( \"/api\" )[ 0 ] } /label/projects/ { project_id } /menu/queue' ) [{'issues': [], 'status': 'LABELED'}] Go to my project: https://cloud.kili-technology.com/label/projects/clcysbp9o2d7w0krfghuf7le1/menu/queue Woah! Amazing! Well done :) \ud83d\ude80 Let's test now to post a proper label, this one for example: json_response = { \"JOB_0\" : { \"annotations\" : [ { \"boundingPoly\" : [ { \"normalizedVertices\" : [ { \"x\" : 0.15 , \"y\" : 0.84 }, { \"x\" : 0.15 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.31 }, { \"x\" : 0.82 , \"y\" : 0.84 }, ] } ], \"categories\" : [{ \"name\" : \"OBJECT_A\" }], \"children\" : {}, \"mid\" : \"20221124161451411-13314\" , \"type\" : \"rectangle\" , } ] } } kili . append_labels ( json_response_array = [ json_response ], asset_id_array = [ asset_id ], label_type = \"DEFAULT\" ) print ( kili . assets ( project_id = project_id , asset_id = asset_id , fields = [ \"status\" ])) print ( f 'Go to my project: { kili . auth . api_endpoint . split ( \"/api\" )[ 0 ] } /label/projects/ { project_id } /menu/queue' ) [{'status': 'LABELED'}] Go to my project: https://cloud.kili-technology.com/label/projects/clcysbp9o2d7w0krfghuf7le1/menu/queue The status of your asset should have now changed to LABELED . In this plugin, previous issues remain but you can solve them through the API as well. Well done! You can now iterate on the script. To learn how to avoid latency when building and deploying your plugin, refer to the plugins_development.ipynb tutorial.","title":"Step 5: Plugin in action"},{"location":"sdk/tutorials/plugins_example/#step-6-monitor-the-plugin","text":"To monitor a certain plugin, you can get its logs by using the following command: import json from datetime import date from datetime import datetime dt = ( date . today () ) # You can change this date if needed, or omit it to set it at the plugin creation date start_date = datetime . combine ( dt , datetime . min . time ()) logs = kili . get_plugin_logs ( project_id = project_id , plugin_name = plugin_name , start_date = start_date ) logs_json = json . loads ( logs ) print ( json . dumps ( logs_json , indent = 4 )) [ { \"content\": \"Issue created!\", \"createdAt\": \"2023-01-16T12:31:27.633Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"Creating an issue...\", \"createdAt\": \"2023-01-16T12:31:26.620Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"Custom method - checking number of bboxes\", \"createdAt\": \"2023-01-16T12:31:26.619Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" }, { \"content\": \"On submit called\", \"createdAt\": \"2023-01-16T12:31:26.619Z\", \"logType\": \"info\", \"metadata\": { \"assetId\": \"clcysbre30000jevzat4b7k4d\", \"labelId\": \"clcysc83n2asf0lq483rlc5wv\" }, \"pluginName\": \"Plugin bbox count\", \"projectId\": \"clcysbp9o2d7w0krfghuf7le1\", \"runId\": \"clcysc93e07wv014z5nbc0kfc\" } ]","title":"Step 6: Monitor the plugin"},{"location":"sdk/tutorials/plugins_example/#step-7-manage-the-plugin","text":"You also have several other methods to manage your plugins. Get the list of all uploaded plugins in your organization: plugins = kili . list_plugins () Update a plugin with new source code: new_path_to_plugin = \"plugin.py\" if new_path_to_plugin != path_to_plugin : kili . update_plugin ( plugin_name = plugin_name , plugin_path = new_path_to_plugin ) Deactivate the plugin on a certain project (the plugin can still be active for other projects): kili . deactivate_plugin_on_project ( plugin_name = plugin_name , project_id = project_id ); Plugin Plugin bbox count deactivated on project clcysbp9o2d7w0krfghuf7le1 Delete the plugin completely (deactivates the plugin from all projects): if delete_plugin_from_org : kili . delete_plugin ( plugin_name = plugin_name )","title":"Step 7: Manage the plugin"},{"location":"sdk/tutorials/set_up_workflows/","text":"How to set up workflows with Kili In this tutorial, we will learn how to set up basic Kili workflows: Managing reviews Placing a specific percentage of project assets in the review queue Placing specific assets in the review queue Sending an asset back to the labeling queue Setting up consensus Setting consensus for a specific percentage of project assets Setting consensus for specific assets to compute consensus KPIs Setting up honeypot Assigning labelers to assets Prioritizing assets in the labeling queue To work with this notebook, you will have to install and instantiate Kili. ! pip install -- upgrade kili from kili.client import Kili import getpass import os if \"KILI_API_KEY\" not in os . environ : KILI_API_KEY = getpass . getpass ( \"Please enter your API key: \" ) else : KILI_API_KEY = os . environ [ \"KILI_API_KEY\" ] kili = Kili ( api_key = KILI_API_KEY , # not needed if KILI_API_KEY is already in environment variables # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\", # the line above can be uncommented and changed if you are working with an on-premise version of Kili ) project_id = \"<YOUR PROJECT ID>\" For information on how to set up a Kili project, refer to the basic project setup tutorial. Managing reviews Placing a specific percentage of project assets in the review queue You can set up the percentage of assets that will automatically appear in the review queue (1-100%). kili . update_properties_in_project ( project_id = project_id , review_coverage = 50 ) {'id': 'clcym6c6v25fp0lq4ef6xh1hz', 'reviewCoverage': 50} Setting up consensus Consensus works by having more than one labeler annotate the same asset. When the asset is labeled, a consensus score is calculated to measure the agreement level between the different annotations for a given asset. This is a key measure for controlling label production quality. To set up consensus, you will need to have at least two project members. For information on how to add users and assign them to your project, refer to the basic project setup tutorial. Setting consensus for a specific percentage of project assets Let's set the percentage of the project dataset that will be annotated several times, to enable consensus calculations. We will also set the minimum number of labelers to label each one of these assets. def set_consensus_coverage ( project_id : str , consensus_tot_coverage : int , min_consensus_size : int ): kili . update_properties_in_project ( project_id = project_id , consensus_tot_coverage = consensus_tot_coverage , min_consensus_size = min_consensus_size , ) set_consensus_coverage ( project_id = project_id , consensus_tot_coverage = 50 , min_consensus_size = 3 ) Setting consensus for specific assets to compute consensus KPIs You can manually select specific project assets to be used for computing consensus KPIs. def set_assets_for_consensus ( project_id : str , external_ids : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , is_used_for_consensus_array = [ True ] * len ( external_ids ), ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] set_assets_for_consensus ( project_id = project_id , external_ids = external_ids ) For more information on consensus, refer to our documentation . Setting up honeypot Honeypot (or gold standard ) is a tool for auditing the work of labelers by measuring the accuracy of their annotations. Honeypot works by interspersing assets with defined ground truth label in the annotation queue. This way you can measure the agreement level between your ground truth and the annotations made by labelers. You can manually select specific project assets to be used as honeypots. asset_external_id = \"1.jpg\" json_response = { \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}} kili . create_honeypot ( project_id = project_id , asset_external_id = asset_external_id , json_response = json_response ); For more information on honeypot, refer to our documentation . Assigning labelers to assets You can assign specific labelers to specific assets in your project. You can do that by assigning users' emails to the selected asset IDs. Remember that you can assign more than one user to a specific asset. def assign_labelers_to_assets ( project_id : str , external_ids : list , to_be_labeled_by_array : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , to_be_labeled_by_array = to_be_labeled_by_array , ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] to_be_labeled_by_array = [ [ \"example1@example.com\" ], [ \"example2@example.com\" ], [ \"example3@example.com\" ], ] assign_labelers_to_assets ( project_id = project_id , external_ids = external_ids , to_be_labeled_by_array = to_be_labeled_by_array ) The to_be_labeled_by_array argument is a list of lists. Each of the sub-lists can contain several e-mails. This way you can assign several labelers to one asset. For example: to_be_labeled_by_array = [[\"example1@example.com\"], [\"example1@example.com\", \"example2@example.com\"], [\"example3@example.com\"]] For information on how to add users and assign them to your project, refer to the basic project setup tutorial. For information on assigning assets to users, refer to our documentation . Prioritizing assets in the labeling queue If you have certain assets that you need to have labeled earlier or later than the rest, you can use Kili's asset prioritization methods. def set_priority_for_assets ( project_id : str , external_ids : list , priorities : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , priorities = priorities ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] priorities = [ 1 , 5 , 10 ] set_priority_for_assets ( project_id = project_id , external_ids = external_ids , priorities = priorities ) For information on setting asset priorities, refer to our documentation . Placing specific assets in the review queue When done with your basic workflow setup, you can place specific, labeled assets in the review queue. As this requires the assets to be labeled, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs. json_response_array = [ { \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}} for i in range ( 3 ) ] kili . append_labels ( project_id = project_id , asset_external_id_array = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ], json_response_array = json_response_array , label_type = \"DEFAULT\" , ) [{'id': 'clcym6xfj276z0krf03o303un'}, {'id': 'clcym6xfj27700krf2snc593u'}, {'id': 'clcym6xfj27710krf31i1db27'}] Now, let's place some assets in the review queue. The method will return a project ID and a list of asset IDs placed in the review queue. external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] kili . add_to_review ( project_id = project_id , external_ids = external_ids ) For more information on asset statuses, refer to our documentation . Sending an asset back to the labeling queue You can also send specific labeled assets back to the labeling queue. asset_names, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs. json_response_array = [{ \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}}] * 3 kili . append_labels ( project_id = project_id , asset_external_id_array = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ], json_response_array = json_response_array , label_type = \"DEFAULT\" , ) [{'id': 'clcym78zz25gx0lq43sx3fqq8'}, {'id': 'clcym78zz25gy0lq4hyzp6ne3'}, {'id': 'clcym78zz25gz0lq41z4n99jr'}] Now, we will send some of our assets back to the labeling queue. The method will return a project ID and a list of asset IDs that were sent back to the labeling queue. external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] kili . send_back_to_queue ( project_id = project_id , external_ids = external_ids ) {'id': 'clcym6c6v25fp0lq4ef6xh1hz', 'asset_ids': ['clcym6clk0000kzvzkk3k0k93', 'clcym6clk0001kzvzqydzki85', 'clcym6clk0002kzvz2cu22sat']} For more information on asset statuses, refer to our documentation . Summary Done! We have learned how to handle the review workflow, set up consensus and honeypot in a project, assign specific labelers to specific assets, and how to prioritize assets in the labeling queue.","title":"Workflows"},{"location":"sdk/tutorials/set_up_workflows/#how-to-set-up-workflows-with-kili","text":"In this tutorial, we will learn how to set up basic Kili workflows: Managing reviews Placing a specific percentage of project assets in the review queue Placing specific assets in the review queue Sending an asset back to the labeling queue Setting up consensus Setting consensus for a specific percentage of project assets Setting consensus for specific assets to compute consensus KPIs Setting up honeypot Assigning labelers to assets Prioritizing assets in the labeling queue To work with this notebook, you will have to install and instantiate Kili. ! pip install -- upgrade kili from kili.client import Kili import getpass import os if \"KILI_API_KEY\" not in os . environ : KILI_API_KEY = getpass . getpass ( \"Please enter your API key: \" ) else : KILI_API_KEY = os . environ [ \"KILI_API_KEY\" ] kili = Kili ( api_key = KILI_API_KEY , # not needed if KILI_API_KEY is already in environment variables # api_endpoint=\"https://cloud.kili-technology.com/api/label/v2/graphql\", # the line above can be uncommented and changed if you are working with an on-premise version of Kili ) project_id = \"<YOUR PROJECT ID>\" For information on how to set up a Kili project, refer to the basic project setup tutorial.","title":"How to set up workflows with Kili"},{"location":"sdk/tutorials/set_up_workflows/#managing-reviews","text":"","title":"Managing reviews"},{"location":"sdk/tutorials/set_up_workflows/#placing-a-specific-percentage-of-project-assets-in-the-review-queue","text":"You can set up the percentage of assets that will automatically appear in the review queue (1-100%). kili . update_properties_in_project ( project_id = project_id , review_coverage = 50 ) {'id': 'clcym6c6v25fp0lq4ef6xh1hz', 'reviewCoverage': 50}","title":"Placing a specific percentage of project assets in the review queue"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-consensus","text":"Consensus works by having more than one labeler annotate the same asset. When the asset is labeled, a consensus score is calculated to measure the agreement level between the different annotations for a given asset. This is a key measure for controlling label production quality. To set up consensus, you will need to have at least two project members. For information on how to add users and assign them to your project, refer to the basic project setup tutorial.","title":"Setting up consensus"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-a-specific-percentage-of-project-assets","text":"Let's set the percentage of the project dataset that will be annotated several times, to enable consensus calculations. We will also set the minimum number of labelers to label each one of these assets. def set_consensus_coverage ( project_id : str , consensus_tot_coverage : int , min_consensus_size : int ): kili . update_properties_in_project ( project_id = project_id , consensus_tot_coverage = consensus_tot_coverage , min_consensus_size = min_consensus_size , ) set_consensus_coverage ( project_id = project_id , consensus_tot_coverage = 50 , min_consensus_size = 3 )","title":"Setting consensus for a specific percentage of project assets"},{"location":"sdk/tutorials/set_up_workflows/#setting-consensus-for-specific-assets-to-compute-consensus-kpis","text":"You can manually select specific project assets to be used for computing consensus KPIs. def set_assets_for_consensus ( project_id : str , external_ids : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , is_used_for_consensus_array = [ True ] * len ( external_ids ), ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] set_assets_for_consensus ( project_id = project_id , external_ids = external_ids ) For more information on consensus, refer to our documentation .","title":"Setting consensus for specific assets to compute consensus KPIs"},{"location":"sdk/tutorials/set_up_workflows/#setting-up-honeypot","text":"Honeypot (or gold standard ) is a tool for auditing the work of labelers by measuring the accuracy of their annotations. Honeypot works by interspersing assets with defined ground truth label in the annotation queue. This way you can measure the agreement level between your ground truth and the annotations made by labelers. You can manually select specific project assets to be used as honeypots. asset_external_id = \"1.jpg\" json_response = { \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}} kili . create_honeypot ( project_id = project_id , asset_external_id = asset_external_id , json_response = json_response ); For more information on honeypot, refer to our documentation .","title":"Setting up honeypot"},{"location":"sdk/tutorials/set_up_workflows/#assigning-labelers-to-assets","text":"You can assign specific labelers to specific assets in your project. You can do that by assigning users' emails to the selected asset IDs. Remember that you can assign more than one user to a specific asset. def assign_labelers_to_assets ( project_id : str , external_ids : list , to_be_labeled_by_array : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , to_be_labeled_by_array = to_be_labeled_by_array , ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] to_be_labeled_by_array = [ [ \"example1@example.com\" ], [ \"example2@example.com\" ], [ \"example3@example.com\" ], ] assign_labelers_to_assets ( project_id = project_id , external_ids = external_ids , to_be_labeled_by_array = to_be_labeled_by_array ) The to_be_labeled_by_array argument is a list of lists. Each of the sub-lists can contain several e-mails. This way you can assign several labelers to one asset. For example: to_be_labeled_by_array = [[\"example1@example.com\"], [\"example1@example.com\", \"example2@example.com\"], [\"example3@example.com\"]] For information on how to add users and assign them to your project, refer to the basic project setup tutorial. For information on assigning assets to users, refer to our documentation .","title":"Assigning labelers to assets"},{"location":"sdk/tutorials/set_up_workflows/#prioritizing-assets-in-the-labeling-queue","text":"If you have certain assets that you need to have labeled earlier or later than the rest, you can use Kili's asset prioritization methods. def set_priority_for_assets ( project_id : str , external_ids : list , priorities : list ): kili . update_properties_in_assets ( project_id = project_id , external_ids = external_ids , priorities = priorities ) external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] priorities = [ 1 , 5 , 10 ] set_priority_for_assets ( project_id = project_id , external_ids = external_ids , priorities = priorities ) For information on setting asset priorities, refer to our documentation .","title":"Prioritizing assets in the labeling queue"},{"location":"sdk/tutorials/set_up_workflows/#placing-specific-assets-in-the-review-queue","text":"When done with your basic workflow setup, you can place specific, labeled assets in the review queue. As this requires the assets to be labeled, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs. json_response_array = [ { \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}} for i in range ( 3 ) ] kili . append_labels ( project_id = project_id , asset_external_id_array = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ], json_response_array = json_response_array , label_type = \"DEFAULT\" , ) [{'id': 'clcym6xfj276z0krf03o303un'}, {'id': 'clcym6xfj27700krf2snc593u'}, {'id': 'clcym6xfj27710krf31i1db27'}] Now, let's place some assets in the review queue. The method will return a project ID and a list of asset IDs placed in the review queue. external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] kili . add_to_review ( project_id = project_id , external_ids = external_ids ) For more information on asset statuses, refer to our documentation .","title":"Placing specific assets in the review queue"},{"location":"sdk/tutorials/set_up_workflows/#sending-an-asset-back-to-the-labeling-queue","text":"You can also send specific labeled assets back to the labeling queue. asset_names, first, let's simulate adding labels to some of our assets. The method will return the list of newly-added label IDs. json_response_array = [{ \"JOB_0\" : { \"categories\" : [{ \"confidence\" : 100 , \"name\" : \"OBJECT_B\" }]}}] * 3 kili . append_labels ( project_id = project_id , asset_external_id_array = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ], json_response_array = json_response_array , label_type = \"DEFAULT\" , ) [{'id': 'clcym78zz25gx0lq43sx3fqq8'}, {'id': 'clcym78zz25gy0lq4hyzp6ne3'}, {'id': 'clcym78zz25gz0lq41z4n99jr'}] Now, we will send some of our assets back to the labeling queue. The method will return a project ID and a list of asset IDs that were sent back to the labeling queue. external_ids = [ \"1.jpg\" , \"2.jpg\" , \"3.jpg\" ] kili . send_back_to_queue ( project_id = project_id , external_ids = external_ids ) {'id': 'clcym6c6v25fp0lq4ef6xh1hz', 'asset_ids': ['clcym6clk0000kzvzkk3k0k93', 'clcym6clk0001kzvzqydzki85', 'clcym6clk0002kzvz2cu22sat']} For more information on asset statuses, refer to our documentation .","title":"Sending an asset back to the labeling queue"},{"location":"sdk/tutorials/set_up_workflows/#summary","text":"Done! We have learned how to handle the review workflow, set up consensus and honeypot in a project, assign specific labelers to specific assets, and how to prioritize assets in the labeling queue.","title":"Summary"}]}