{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kili Python SDK What is Kili? Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info here . Requirements You only need Python 3.7 or greater Installation Install the Kili client with pip: pip install kili Getting Started Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value you copied above: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: kili = Kili ( api_key = '<you api key value here>' )","title":"Kili Python SDK"},{"location":"#kili-python-sdk","text":"","title":"Kili Python SDK"},{"location":"#what-is-kili","text":"Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info here .","title":"What is Kili?"},{"location":"#requirements","text":"You only need Python 3.7 or greater","title":"Requirements"},{"location":"#installation","text":"Install the Kili client with pip: pip install kili","title":"Installation"},{"location":"#getting-started","text":"Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value you copied above: export KILI_API_KEY = '<you api key value here>' Instantiate the Kili client: from kili.client import Kili kili = Kili () Great! You can now begin to use the Kili Python SDK Info You can also pass the API key as an argument of the Kili initialization: kili = Kili ( api_key = '<you api key value here>' )","title":"Getting Started"},{"location":"api_key/","text":"API Key module Queries Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count api_keys ( self , api_key_id = None , user_id = None , api_key = None , skip = 0 , fields = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first = 100 , disable_tqdm = False , as_generator = False ) Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. 100 disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) count_api_keys ( self , api_key_id = None , user_id = None , api_key = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count Mutations Set of User mutations. Source code in kili/mutations/api_key/__init__.py class MutationsApiKey : # pylint: disable=too-few-public-methods \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\"Create an api key to connect to the API. Args: api_key: A new api key to connect with name: A name used to describe the api key. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result ) append_to_api_keys ( self , api_key , name ) Create an api key to connect to the API. Parameters: Name Type Description Default api_key str A new api key to connect with required name str A name used to describe the api key. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/api_key/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\"Create an api key to connect to the API. Args: api_key: A new api key to connect with name: A name used to describe the api key. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"API Key"},{"location":"api_key/#api-key-module","text":"","title":"API Key module"},{"location":"api_key/#queries","text":"Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","text":"Get a generator or a list of API keys that match a set of constraints. Info You can only query your own API keys Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the API key. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of API keys to return. 100 disable_tqdm bool If True , the progress bar will be disabled. False as_generator bool If True , a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . api_keys ( user_id = user_id ) >>> kili . api_keys ( api_key = api_key ) >>> kili . api_keys ( api_key = api_key , as_generator = False ) Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of API keys that match a set of constraints. !!! info You can only query your own API keys Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the API key. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first: Maximum number of API keys to return. disable_tqdm: If `True`, the progress bar will be disabled. as_generator: If `True`, a generator on the API key is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator )","title":"api_keys()"},{"location":"api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default api_key_id Optional[str] Identifier of the API key to retrieve. None user_id Optional[str] Identifier of the user. None api_key Optional[str] Value of the api key. None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_api_keys ( user_id = user_id ) 3 >>> kili . count_api_keys ( api_key = api_key ) 1 Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: api_key_id: Identifier of the API key to retrieve. user_id: Identifier of the user. api_key: Value of the api key. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_api_keys()"},{"location":"api_key/#mutations","text":"Set of User mutations. Source code in kili/mutations/api_key/__init__.py class MutationsApiKey : # pylint: disable=too-few-public-methods \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\"Create an api key to connect to the API. Args: api_key: A new api key to connect with name: A name used to describe the api key. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"Mutations"},{"location":"api_key/#kili.mutations.api_key.__init__.MutationsApiKey.append_to_api_keys","text":"Create an api key to connect to the API. Parameters: Name Type Description Default api_key str A new api key to connect with required name str A name used to describe the api key. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/api_key/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\"Create an api key to connect to the API. Args: api_key: A new api key to connect with name: A name used to describe the api key. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"append_to_api_keys()"},{"location":"asset/","text":"Asset module Queries Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_json_response_contains is not None : message = \"\"\" The field `label_json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `label_category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if label_category_search : validate_category_search_query ( label_category_search ) variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count assets ( self , asset_id = None , project_id = None , skip = 0 , fields = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in = None , consensus_mark_gt = None , consensus_mark_lt = None , disable_tqdm = False , external_id_contains = None , first = None , format = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , label_type_in = None , metadata_where = None , skipped = None , status_in = None , updated_at_gte = None , updated_at_lte = None , as_generator = False , label_category_search = None ) Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) count_assets ( self , asset_id = None , project_id = None , asset_id_in = None , external_id_contains = None , metadata_where = None , status_in = None , consensus_mark_gt = None , consensus_mark_lt = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_type_in = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , skipped = None , updated_at_gte = None , updated_at_lte = None , label_category_search = None ) Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_json_response_contains is not None : message = \"\"\" The field `label_json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `label_category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if label_category_search : validate_category_search_query ( label_category_search ) variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count Mutations Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a `VIDEO` project, the content must be either URLs or paths to existing videos on your computer. external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `FRAME` or `TEXT` projects only. - For `FRAME` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_assets.ipynb) or [other examples](https://docs.kili-technology.com/recipes/importing-data) in our documentation. - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" kili = QueriesProject ( self . auth ) projects = kili . projects ( project_id , disable_tqdm = True ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] properties_to_batch , upload_type , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) def generate_variables ( batch ): if request == GQL_APPEND_MANY_FRAMES_TO_DATASET : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ], 'uploadType' : upload_type } else : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'isHoneypotArray' : batch [ 'is_honeypot_array' ], 'statusArray' : batch [ 'status_array' ], 'jsonContentArray' : batch [ 'json_content_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ]} return { 'data' : payload_data , 'where' : { 'id' : project_id } } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , request ) return format_result ( 'data' , results [ 0 ], Asset ) @Compatible ([ 'v2' ]) @typechecked #pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids : The asset IDs to modify external_ids: Change the external id of the assets priorities : You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ 'asset_ids' , 'external_ids' , 'priorities' , 'json_metadatas' , 'consensus_marks' , 'honeypot_marks' , 'to_be_labeled_by_array' , 'contents' , 'json_contents' , 'status_array' , 'is_used_for_consensus_array' , 'is_honeypot_array' ]} properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch ): data = { 'externalId' : batch [ 'external_ids' ], 'priority' : batch [ 'priorities' ], 'jsonMetadata' : batch [ 'json_metadatas' ], 'consensusMark' : batch [ 'consensus_marks' ], 'honeypotMark' : batch [ 'honeypot_marks' ], 'toBeLabeledBy' : batch [ 'to_be_labeled_by_array' ], 'shouldResetToBeLabeledBy' : batch [ 'should_reset_to_be_labeled_by_array' ], 'content' : batch [ 'contents' ], 'jsonContent' : batch [ 'json_contents' ], 'status' : batch [ 'status_array' ], 'isUsedForConsensus' : batch [ 'is_used_for_consensus_array' ], 'isHoneypot' : batch [ 'is_honeypot_array' ] } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { 'whereArray' : [{ 'id' : asset_id } for asset_id in batch [ 'asset_ids' ]], 'dataArray' : data_array } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS ) formated_results = [ format_result ( 'data' , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch = { 'asset_ids' : asset_ids } def generate_variables ( batch ): return { 'where' : { 'idIn' : batch [ 'asset_ids' ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( 'data' , results [ 0 ], Asset ) append_many_to_dataset ( self , project_id , content_array = None , external_id_array = None , is_honeypot_array = None , status_array = None , json_content_array = None , json_metadata_array = None ) Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content must be either URLs or paths to existing videos on your computer. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for FRAME or TEXT projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe or other examples in our documentation. For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a `VIDEO` project, the content must be either URLs or paths to existing videos on your computer. external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `FRAME` or `TEXT` projects only. - For `FRAME` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_assets.ipynb) or [other examples](https://docs.kili-technology.com/recipes/importing-data) in our documentation. - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" kili = QueriesProject ( self . auth ) projects = kili . projects ( project_id , disable_tqdm = True ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] properties_to_batch , upload_type , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) def generate_variables ( batch ): if request == GQL_APPEND_MANY_FRAMES_TO_DATASET : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ], 'uploadType' : upload_type } else : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'isHoneypotArray' : batch [ 'is_honeypot_array' ], 'statusArray' : batch [ 'status_array' ], 'jsonContentArray' : batch [ 'json_content_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ]} return { 'data' : payload_data , 'where' : { 'id' : project_id } } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , request ) return format_result ( 'data' , results [ 0 ], Asset ) delete_many_from_dataset ( self , asset_ids ) Delete assets from a project. Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch = { 'asset_ids' : asset_ids } def generate_variables ( batch ): return { 'where' : { 'idIn' : batch [ 'asset_ids' ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( 'data' , results [ 0 ], Asset ) update_properties_in_assets ( self , asset_ids , external_ids = None , priorities = None , json_metadatas = None , consensus_marks = None , honeypot_marks = None , to_be_labeled_by_array = None , contents = None , json_contents = None , status_array = None , is_used_for_consensus_array = None , is_honeypot_array = None ) Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , REVIEWED None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Returns: Type Description List[dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked #pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids : The asset IDs to modify external_ids: Change the external id of the assets priorities : You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ 'asset_ids' , 'external_ids' , 'priorities' , 'json_metadatas' , 'consensus_marks' , 'honeypot_marks' , 'to_be_labeled_by_array' , 'contents' , 'json_contents' , 'status_array' , 'is_used_for_consensus_array' , 'is_honeypot_array' ]} properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch ): data = { 'externalId' : batch [ 'external_ids' ], 'priority' : batch [ 'priorities' ], 'jsonMetadata' : batch [ 'json_metadatas' ], 'consensusMark' : batch [ 'consensus_marks' ], 'honeypotMark' : batch [ 'honeypot_marks' ], 'toBeLabeledBy' : batch [ 'to_be_labeled_by_array' ], 'shouldResetToBeLabeledBy' : batch [ 'should_reset_to_be_labeled_by_array' ], 'content' : batch [ 'contents' ], 'jsonContent' : batch [ 'json_contents' ], 'status' : batch [ 'status_array' ], 'isUsedForConsensus' : batch [ 'is_used_for_consensus_array' ], 'isHoneypot' : batch [ 'is_honeypot_array' ] } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { 'whereArray' : [{ 'id' : asset_id } for asset_id in batch [ 'asset_ids' ]], 'dataArray' : data_array } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS ) formated_results = [ format_result ( 'data' , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"Asset"},{"location":"asset/#asset-module","text":"","title":"Asset module"},{"location":"asset/#queries","text":"Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_json_response_contains is not None : message = \"\"\" The field `label_json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `label_category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if label_category_search : validate_category_search_query ( label_category_search ) variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.assets","text":"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the IDs of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the assets is returned. False label_category_search Optional[str] Returned assets should have a label that follows this category search query. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] A result object which contains the query if it was successful, or an error message. Examples: # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , label_category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\"Get an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Args: asset_id: Identifier of the asset to retrieve. asset_id_in: A list of the IDs of the assets to retrieve. project_id: Identifier of the project. skip: Number of assets to skip (they are ordered by their date of creation, first to last). fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. first: Maximum number of assets to return. consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. external_id_contains: Returned assets have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the assets is returned. label_category_search: Returned assets should have a label that follows this category search query. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Example: ``` # returns the assets list of the project >>> kili.assets(project_id=project_id) >>> kili.assets(asset_id=asset_id) # returns a generator of the project assets >>> kili.assets(project_id=project_id, as_generator=True) ``` !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` label_category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` label_category_search = `(JOB_CLASSIF.CATEGORY_A.count == 1 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if label_category_search : validate_category_search_query ( label_category_search ) payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator )","title":"assets()"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","text":"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: TODO , ONGOING , LABELED or REVIEWED None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int A result object which contains the query if it was successful, or an error message. Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 How to filter based on Metadata metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , label_category_search : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of assets with the given constraints. Parameters beginning with 'label_' apply to labels, others apply to assets. Args: asset_id: The unique id of the asset to retrieve. asset_id_in: A list of the ids of the assets to retrieve. project_id: Identifier of the project external_id_contains: Returned assets should have an external id that belongs to that list, if given. metadata_where: Filters by the values of the metadata of the asset. status_in: Returned assets should have a status that belongs to that list, if given. Possible choices: `TODO`, `ONGOING`, `LABELED` or `REVIEWED` consensus_mark_gt: Minimum amount of consensus for the asset. consensus_mark_lt: Maximum amount of consensus for the asset. honeypot_mark_gt: Minimum amount of honeypot for the asset. honeypot_mark_lt: Maximum amount of consensus for the asset. label_type_in: Returned assets should have a label whose type belongs to that list, if given. label_author_in: Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt: Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt: Returned assets should have a label whose consensus is lower than this number. label_created_at: Returned assets should have a label whose creation date is equal to this date. label_created_at_gt: Returned assets should have a label whose creation date is greater than this date. label_created_at_lt: Returned assets should have a label whose creation date is lower than this date. label_honeypot_mark_gt: Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt: Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains: Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped: Returned assets should be skipped updated_at_gte: Returned assets should have a label whose update date is greated or equal to this date. updated_at_lte: Returned assets should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 !!! example \"How to filter based on Metadata\" - `metadata_where = {key1: \"value1\"}` to filter on assets whose metadata have key \"key1\" with value \"value1\" - `metadata_where = {key1: [\"value1\", \"value2\"]}` to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - `metadata_where = {key2: [2, 10]}` to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. \"\"\" if label_json_response_contains is not None : message = \"\"\" The field `label_json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `label_category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if label_category_search : validate_category_search_query ( label_category_search ) variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , 'search' : label_category_search }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_assets()"},{"location":"asset/#mutations","text":"Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a `VIDEO` project, the content must be either URLs or paths to existing videos on your computer. external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `FRAME` or `TEXT` projects only. - For `FRAME` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_assets.ipynb) or [other examples](https://docs.kili-technology.com/recipes/importing-data) in our documentation. - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" kili = QueriesProject ( self . auth ) projects = kili . projects ( project_id , disable_tqdm = True ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] properties_to_batch , upload_type , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) def generate_variables ( batch ): if request == GQL_APPEND_MANY_FRAMES_TO_DATASET : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ], 'uploadType' : upload_type } else : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'isHoneypotArray' : batch [ 'is_honeypot_array' ], 'statusArray' : batch [ 'status_array' ], 'jsonContentArray' : batch [ 'json_content_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ]} return { 'data' : payload_data , 'where' : { 'id' : project_id } } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , request ) return format_result ( 'data' , results [ 0 ], Asset ) @Compatible ([ 'v2' ]) @typechecked #pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids : The asset IDs to modify external_ids: Change the external id of the assets priorities : You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ 'asset_ids' , 'external_ids' , 'priorities' , 'json_metadatas' , 'consensus_marks' , 'honeypot_marks' , 'to_be_labeled_by_array' , 'contents' , 'json_contents' , 'status_array' , 'is_used_for_consensus_array' , 'is_honeypot_array' ]} properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch ): data = { 'externalId' : batch [ 'external_ids' ], 'priority' : batch [ 'priorities' ], 'jsonMetadata' : batch [ 'json_metadatas' ], 'consensusMark' : batch [ 'consensus_marks' ], 'honeypotMark' : batch [ 'honeypot_marks' ], 'toBeLabeledBy' : batch [ 'to_be_labeled_by_array' ], 'shouldResetToBeLabeledBy' : batch [ 'should_reset_to_be_labeled_by_array' ], 'content' : batch [ 'contents' ], 'jsonContent' : batch [ 'json_contents' ], 'status' : batch [ 'status_array' ], 'isUsedForConsensus' : batch [ 'is_used_for_consensus_array' ], 'isHoneypot' : batch [ 'is_honeypot_array' ] } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { 'whereArray' : [{ 'id' : asset_id } for asset_id in batch [ 'asset_ids' ]], 'dataArray' : data_array } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS ) formated_results = [ format_result ( 'data' , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ] @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch = { 'asset_ids' : asset_ids } def generate_variables ( batch ): return { 'where' : { 'idIn' : batch [ 'asset_ids' ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( 'data' , results [ 0 ], Asset )","title":"Mutations"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","text":"Append assets to a project. Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project Must not be None except if you provide json_content_array. For a TEXT project, the content can be either raw text, or URLs to TEXT assets. For an IMAGE / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. For a VIDEO project, the content must be either URLs or paths to existing videos on your computer. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to TODO . Other options: ONGOING , LABELED , REVIEWED . None json_content_array Optional[List[List[Union[dict, str]]]] Useful for FRAME or TEXT projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: imageUrl , text , url . Example for one asset: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] . For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] . None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Recipe For more detailed examples on how to import assets, see the recipe or other examples in our documentation. For more detailed examples on how to import text assets, see the recipe . Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\"Append assets to a project. Args: project_id: Identifier of the project content_array: List of elements added to the assets of the project Must not be None except if you provide json_content_array. - For a `TEXT` project, the content can be either raw text, or URLs to TEXT assets. - For an `IMAGE` / `PDF` project, the content can be either URLs or paths to existing images/pdf on your computer. - For a `VIDEO` project, the content must be either URLs or paths to existing videos on your computer. external_id_array: List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array: By default, all imported assets are set to `TODO`. Other options: `ONGOING`, `LABELED`, `REVIEWED`. json_content_array: Useful for `FRAME` or `TEXT` projects only. - For `FRAME` projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. - For `TEXT` projects, each element is a json_content dict, formatted according to documentation [on how to import rich-text assets](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb) json_metadata_array: The metadata given to each asset should be stored in a json like dict with keys. - Add metadata visible on the asset with the following keys: `imageUrl`, `text`, `url`. Example for one asset: `json_metadata_array = [{'imageUrl': '','text': '','url': ''}]`. - For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example for one asset: `json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}]`. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) !!! example \"Recipe\" - For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_assets.ipynb) or [other examples](https://docs.kili-technology.com/recipes/importing-data) in our documentation. - For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_text_assets.ipynb). \"\"\" kili = QueriesProject ( self . auth ) projects = kili . projects ( project_id , disable_tqdm = True ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] properties_to_batch , upload_type , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) def generate_variables ( batch ): if request == GQL_APPEND_MANY_FRAMES_TO_DATASET : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ], 'uploadType' : upload_type } else : payload_data = { 'contentArray' : batch [ 'content_array' ], 'externalIDArray' : batch [ 'external_id_array' ], 'isHoneypotArray' : batch [ 'is_honeypot_array' ], 'statusArray' : batch [ 'status_array' ], 'jsonContentArray' : batch [ 'json_content_array' ], 'jsonMetadataArray' : batch [ 'json_metadata_array' ]} return { 'data' : payload_data , 'where' : { 'id' : project_id } } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , request ) return format_result ( 'data' , results [ 0 ], Asset )","title":"append_many_to_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","text":"Delete assets from a project. Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\"Delete assets from a project. Args: asset_ids: The list of identifiers of the assets to delete. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" properties_to_batch = { 'asset_ids' : asset_ids } def generate_variables ( batch ): return { 'where' : { 'idIn' : batch [ 'asset_ids' ]}} results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_DELETE_MANY_FROM_DATASET ) return format_result ( 'data' , results [ 0 ], Asset )","title":"delete_many_from_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","text":"Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys imageUrl , text , url : json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in TODO , ONGOING , LABELED , REVIEWED None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Returns: Type Description List[dict] A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked #pylint: disable=unused-argument def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ) -> List [ dict ]: \"\"\"Update the properties of one or more assets. Args: asset_ids : The asset IDs to modify external_ids: Change the external id of the assets priorities : You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas: The metadata given to an asset should be stored in a json like dict with keys `imageUrl`, `text`, `url`: `json_metadata = {'imageUrl': '','text': '','url': ''}` consensus_marks: Should be between 0 and 1 honeypot_marks: Should be between 0 and 1 to_be_labeled_by_array: If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents: - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents: - For a NLP project, the `json_content` is a text formatted using RichText - For a Video project, the`json_content` is a json containg urls pointing to each frame of the video. status_array: Each element should be in `TODO`, `ONGOING`, `LABELED`, `REVIEWED` is_used_for_consensus_array: Whether to use the asset to compute consensus kpis or not is_honeypot_array: Whether to use the asset for honeypot Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" saved_args = locals () parameters = { k : v for ( k , v ) in saved_args . items () if k in [ 'asset_ids' , 'external_ids' , 'priorities' , 'json_metadatas' , 'consensus_marks' , 'honeypot_marks' , 'to_be_labeled_by_array' , 'contents' , 'json_contents' , 'status_array' , 'is_used_for_consensus_array' , 'is_honeypot_array' ]} properties_to_batch = process_update_properties_in_assets_parameters ( parameters ) def generate_variables ( batch ): data = { 'externalId' : batch [ 'external_ids' ], 'priority' : batch [ 'priorities' ], 'jsonMetadata' : batch [ 'json_metadatas' ], 'consensusMark' : batch [ 'consensus_marks' ], 'honeypotMark' : batch [ 'honeypot_marks' ], 'toBeLabeledBy' : batch [ 'to_be_labeled_by_array' ], 'shouldResetToBeLabeledBy' : batch [ 'should_reset_to_be_labeled_by_array' ], 'content' : batch [ 'contents' ], 'jsonContent' : batch [ 'json_contents' ], 'status' : batch [ 'status_array' ], 'isUsedForConsensus' : batch [ 'is_used_for_consensus_array' ], 'isHoneypot' : batch [ 'is_honeypot_array' ] } data_array = [ dict ( zip ( data , t )) for t in zip ( * data . values ())] return { 'whereArray' : [{ 'id' : asset_id } for asset_id in batch [ 'asset_ids' ]], 'dataArray' : data_array } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_UPDATE_PROPERTIES_IN_ASSETS ) formated_results = [ format_result ( 'data' , result , Asset ) for result in results ] return [ item for batch_list in formated_results for item in batch_list ]","title":"update_properties_in_assets()"},{"location":"issue/","text":"Issue module Queries Set of Issue queries. Source code in kili/queries/issue/__init__.py class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. project_id: Project ID the issue belongs to. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count count_issues ( self , project_id = None ) Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count issues ( self , fields = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first = 100 , project_id = None , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default fields Optional[List[str]] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. project_id: Project ID the issue belongs to. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"Issue"},{"location":"issue/#issue-module","text":"","title":"Issue module"},{"location":"issue/#queries","text":"Set of Issue queries. Source code in kili/queries/issue/__init__.py class QueriesIssue : \"\"\"Set of Issue queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. project_id: Project ID the issue belongs to. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","text":"Count and return the number of api keys with the given constraints. Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int The number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\"Count and return the number of api keys with the given constraints. Args: project_id: Project ID the issue belongs to. Returns: The number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_issues()"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.issues","text":"Get a generator or a list of issues that match a set of criteria. Parameters: Name Type Description Default fields Optional[List[str]] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the issues is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . issues ( project_id = project_id , fields = [ 'author.email' ]) # List all issues of a project and their authors Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of issues that match a set of criteria. Args: fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#issue) for all possible fields. first: Maximum number of issues to return. project_id: Project ID the issue belongs to. skip: Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the issues is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.issues(project_id=project_id, fields=['author.email']) # List all issues of a project and their authors \"\"\" count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"issues()"},{"location":"label/","text":"Label module Queries Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skip: Number of labels to skip (they are ordered by their date of creation, first to last). skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( 'data' , result , Label ) # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) return labels_df @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if json_response_contains is not None : message = \"\"\" The field `json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if category_search : validate_category_search_query ( category_search ) variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_labels ( self , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , honeypot_mark_gte = None , honeypot_mark_lte = None , json_response_contains = None , label_id = None , project_id = None , skipped = None , type_in = None , user_id = None , category_search = None ) Get the number of labels for the given parameters. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if json_response_contains is not None : message = \"\"\" The field `json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if category_search : validate_category_search_query ( category_search ) variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count export_labels_as_df ( self , project_id , fields = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields = [ 'externalId' ]) Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType', 'skipped'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) return labels_df labels ( self , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , fields = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first = None , honeypot_mark_gte = None , honeypot_mark_lte = None , id_contains = None , json_response_contains = None , label_id = None , project_id = None , skip = 0 , skipped = None , type_in = None , user_id = None , disable_tqdm = False , as_generator = False , category_search = None ) Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'skipped'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skip: Number of labels to skip (they are ordered by their date of creation, first to last). skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) Mutations Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { 'external_id_array' : external_id_array , 'model_name_array' : model_name_array , 'json_response_array' : json_response_array } def generate_variables ( batch ): return { 'data' : { 'modelNameArray' : batch [ 'model_name_array' ], 'jsonResponseArray' : [ dumps ( elem ) for elem in batch [ 'json_response_array' ]]}, 'where' : { 'externalIdStrictlyIn' : batch [ 'external_id_array' ], 'project' : { 'id' : project_id }} } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS ) return format_result ( 'data' , results [ 0 ], Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\"Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION` or `REVIEW` seconds_to_label: Time to create the label skipped: Describe if the label is skipped or not !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label ) append_to_labels ( self , json_response , author_id = None , label_asset_external_id = None , label_asset_id = None , label_type = 'DEFAULT' , project_id = None , seconds_to_label = 0 , skipped = False ) Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of AUTOSAVE , DEFAULT , PREDICTION or REVIEW 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 skipped Optional[bool] Describe if the label is skipped or not False Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\"Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION` or `REVIEW` seconds_to_label: Time to create the label skipped: Describe if the label is skipped or not !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) create_honeypot ( self , json_response , asset_external_id = None , asset_id = None , project_id = None ) Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label ) create_predictions ( self , project_id , external_id_array , model_name_array , json_response_array ) Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { 'external_id_array' : external_id_array , 'model_name_array' : model_name_array , 'json_response_array' : json_response_array } def generate_variables ( batch ): return { 'data' : { 'modelNameArray' : batch [ 'model_name_array' ], 'jsonResponseArray' : [ dumps ( elem ) for elem in batch [ 'json_response_array' ]]}, 'where' : { 'externalIdStrictlyIn' : batch [ 'external_id_array' ], 'project' : { 'id' : project_id }} } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS ) return format_result ( 'data' , results [ 0 ], Label ) update_properties_in_label ( self , label_id , seconds_to_label = None , model_name = None , json_response = None ) Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) Subscriptions Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket label_created_or_updated ( self , project_id , callback ) Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description A subscription client Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"Label"},{"location":"label/#label-module","text":"","title":"Label module"},{"location":"label/#queries","text":"Set of Label queries. Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\"Set of Label queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skip: Number of labels to skip (they are ordered by their date of creation, first to last). skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( 'data' , result , Label ) # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) return labels_df @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if json_response_contains is not None : message = \"\"\" The field `json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if category_search : validate_category_search_query ( category_search ) variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.count_labels","text":"Get the number of labels for the given parameters. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of labels with the parameters provided Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , category_search : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\"Get the number of labels for the given parameters. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of labels with the parameters provided \"\"\" if json_response_contains is not None : message = \"\"\" The field `json_response_contains` is deprecated since: 2.113 It will be removed in: 2.115 Please use `category_search` to filter based on categories in labels \"\"\" warnings . warn ( message , DeprecationWarning ) if category_search : validate_category_search_query ( category_search ) variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_labels()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","text":"Get the labels of a project as a pandas DataFrame. Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType', 'skipped'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description DataFrame pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]) -> pd . DataFrame : # pylint: disable=line-too-long \"\"\"Get the labels of a project as a pandas DataFrame. Args: project_id: Identifier of the project fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. asset_fields: All the fields to request among the possible fields for the assets. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#asset) for all possible fields. Returns: pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) return labels_df","title":"export_labels_as_df()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.labels","text":"Get a label list or a label generator from a project based on a set of criteria. Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : TODO , ONGOING , LABELED or REVIEWED None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. None fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'skipped'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the labels is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, else an error message. Examples: >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' , 'labelOf.externalId' ]) # returns a list of all labels of a project and their assets external ID >>> kili . labels ( project_id = project_id , fields = [ 'jsonResponse' ], as_generator = True ) # returns a generator of all labels of a project How to filter based on label categories The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: [job_name] is the name of the job in the interface [category_name] is the name of the category in the interface for this job [comparaison_operator] can be one of: [ == , >= , <= , < , > ] [value] is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked @deprecate ( removed_in = \"2.115\" ) def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , category_search : Optional [ str ] = None , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a label list or a label generator from a project based on a set of criteria. Args: asset_id: Identifier of the asset. asset_status_in: Returned labels should have a status that belongs to that list, if given. Possible choices : `TODO`, `ONGOING`, `LABELED` or `REVIEWED` asset_external_id_in: Returned labels should have an external id that belongs to that list, if given. author_in: Returned labels should have a label whose status belongs to that list, if given. created_at: Returned labels should have a label whose creation date is equal to this date. created_at_gte: Returned labels should have a label whose creation date is greater than this date. created_at_lte: Returned labels should have a label whose creation date is lower than this date. fields: All the fields to request among the possible fields for the labels. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#label) for all possible fields. first: Maximum number of labels to return. honeypot_mark_gte: Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte: Returned labels should have a label whose honeypot is lower than this number. id_contains: Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains: Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id: Identifier of the label. project_id: Identifier of the project. skip: Number of labels to skip (they are ordered by their date of creation, first to last). skipped: Returned labels should have a label which is skipped type_in: Returned labels should have a label whose type belongs to that list, if given. user_id: Identifier of the user. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the labels is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, else an error message. Examples: >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project !!! example \"How to filter based on label categories\" The search query is composed of logical expressions following this format: [job_name].[category_name].count [comparaison_operator] [value] where: - `[job_name]` is the name of the job in the interface - `[category_name]` is the name of the category in the interface for this job - `[comparaison_operator]` can be one of: [`==`, `>=`, `<=`, `<`, `>`] - `[value]` is an integer that represents the count of such objects of the given category in the label These operations can be separated by OR and AND operators Example: category_search = `JOB_CLASSIF.CATEGORY_A.count > 0` category_search = `JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0` category_search = `(JOB_CLASSIF.CATEGORY_A.count > 0 OR JOB_NER.CATEGORY_B.count > 0) AND JOB_BBOX.CATEGORY_C.count > 10` \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator if category_search : validate_category_search_query ( category_search ) payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'search' : category_search , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator )","title":"labels()"},{"location":"label/#mutations","text":"Set of Label mutations. Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\"Set of Label mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initializes the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { 'external_id_array' : external_id_array , 'model_name_array' : model_name_array , 'json_response_array' : json_response_array } def generate_variables ( batch ): return { 'data' : { 'modelNameArray' : batch [ 'model_name_array' ], 'jsonResponseArray' : [ dumps ( elem ) for elem in batch [ 'json_response_array' ]]}, 'where' : { 'externalIdStrictlyIn' : batch [ 'external_id_array' ], 'project' : { 'id' : project_id }} } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS ) return format_result ( 'data' , results [ 0 ], Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\"Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION` or `REVIEW` seconds_to_label: Time to create the label skipped: Describe if the label is skipped or not !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label )","title":"Mutations"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","text":"Append a label to an asset. Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset None label_asset_id Optional[str] Identifier of the asset None project_id Optional[str] Identifier of the project None label_type str Can be one of AUTOSAVE , DEFAULT , PREDICTION or REVIEW 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 skipped Optional[bool] Describe if the label is skipped or not False Warning Either provide label_asset_id or label_asset_external_id and project_id Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_labels ( label_asset_id = asset_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\"Append a label to an asset. Args: json_response: Label is given here author_id: ID of the author of the label label_asset_external_id: External identifier of the asset label_asset_id: Identifier of the asset project_id: Identifier of the project label_type: Can be one of `AUTOSAVE`, `DEFAULT`, `PREDICTION` or `REVIEW` seconds_to_label: Time to create the label skipped: Describe if the label is skipped or not !!! warning Either provide `label_asset_id` or `label_asset_external_id` and `project_id` Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label )","title":"append_to_labels()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","text":"Create honeypot for an asset. Info Uses the given json_response to create a REVIEW label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\"Create honeypot for an asset. !!! info Uses the given `json_response` to create a `REVIEW` label. This enables Kili to compute a`honeypotMark`, which measures the similarity between this label and other labels. Args: json_response: The JSON response of the honeypot label of the asset asset_id: Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id: External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id: Identifier of the project Either provide asset_id or asset_external_id and project_id Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label )","title":"create_honeypot()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","text":"Create predictions for specific assets. Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Recipe For more detailed examples on how to create predictions, see the recipe . Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\"Create predictions for specific assets. Args: project_id: Identifier of the project external_id_array: The external identifiers of the assets for which we want to add predictions model_name_array: In case you want to precise from which model the label originated json_response_array: The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). Returns: A result object which indicates if the mutation was successful, or an error message. !!! example \"Recipe\" For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/import_predictions.ipynb). \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" if len ( external_id_array ) == 0 : warnings . warn ( \"Empty IDs and prediction list\" ) properties_to_batch = { 'external_id_array' : external_id_array , 'model_name_array' : model_name_array , 'json_response_array' : json_response_array } def generate_variables ( batch ): return { 'data' : { 'modelNameArray' : batch [ 'model_name_array' ], 'jsonResponseArray' : [ dumps ( elem ) for elem in batch [ 'json_response_array' ]]}, 'where' : { 'externalIdStrictlyIn' : batch [ 'external_id_array' ], 'project' : { 'id' : project_id }} } results = _mutate_from_paginated_call ( self , properties_to_batch , generate_variables , GQL_CREATE_PREDICTIONS ) return format_result ( 'data' , results [ 0 ], Label )","title":"create_predictions()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","text":"Update properties of a label. Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_label ( label_id = label_id , json_response = { ... }) Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\"Update properties of a label. Args: label_id: Identifier of the label seconds_to_label: Time to create the label model_name: Name of the model json_response: The label is given here Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label )","title":"update_properties_in_label()"},{"location":"label/#subscriptions","text":"Set of Label subscriptions. Source code in kili/subscriptions/label/__init__.py class SubscriptionsLabel : \"\"\"Set of Label subscriptions.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"Subscriptions"},{"location":"label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","text":"Subscribe a callback to a project, which is executed when a label is created or updated. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description A subscription client Recipe For more detailed examples on how to use Webhooks, See the related recipe Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. Args: project_id: Identifier of the project callback: This function takes as input the id of the asset and its content. Returns: A subscription client !!! example \"Recipe\" For more detailed examples on how to use Webhooks, See [the related recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/webhooks.ipynb) \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"label_created_or_updated()"},{"location":"notification/","text":"Notification module Queries Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_notifications ( self , has_been_seen = None , user_id = None ) Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count notifications ( self , fields = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first = 100 , has_been_seen = None , notification_id = None , skip = 0 , user_id = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first int Number of notifications to query 100 has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"Notification"},{"location":"notification/#notification-module","text":"","title":"Notification module"},{"location":"notification/#queries","text":"Set of Notification queries. Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\"Set of Notification queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","text":"Count the number of notifications. Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int The number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\"Count the number of notifications. Args: has_been_seen: Filter on notifications that have been seen. user_id: Filter on the notifications of a specific user Returns: The number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_notifications()"},{"location":"notification/#kili.queries.notification.__init__.QueriesNotification.notifications","text":"Get a generator or a list of notifications respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first int Number of notifications to query 100 has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of notifications respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the notifications See [the documentation](https://docs.kili-technology.com/reference/graphql-api#notification) for all possible fields. first: Number of notifications to query has_been_seen: If the notifications returned should have been seen. notification_id: If given, will return the notification which has this id skip: Number of notifications to skip (they are ordered by their date of creation, first to last). user_id: If given, returns the notifications of a specific user disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the notifications is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator )","title":"notifications()"},{"location":"organization/","text":"Organization module Queries Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first: Maximum number of organizations to return. Skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result ) count_organizations ( self , email = None , organization_id = None ) Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) organization_metrics ( self , organization_id = None , start_date = datetime . datetime ( 2022 , 6 , 23 , 10 , 39 , 59 , 693858 ), end_date = datetime . datetime ( 2022 , 6 , 23 , 10 , 39 , 59 , 693860 )) Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization None start_date datetime Start date of the metrics computation datetime.datetime(2022, 6, 23, 10, 39, 59, 693858) end_date datetime End date of the metrics computation datetime.datetime(2022, 6, 23, 10, 39, 59, 693860) Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result ) organizations ( self , email = None , organization_id = None , fields = [ 'id' , 'name' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first int Maximum number of organizations to return. 100 Skip Number of skipped organizations (they are ordered by creation date) required disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first: Maximum number of organizations to return. Skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"Organization"},{"location":"organization/#organization-module","text":"","title":"Organization module"},{"location":"organization/#queries","text":"Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first: Maximum number of organizations to return. Skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result )","title":"Queries"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","text":"Count organizations that match a set of criteria. Parameters: Name Type Description Default email Optional[str] Email of a user of the organization None organization_id Optional[str] Identifier of the organization None Returns: Type Description int A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\"Count organizations that match a set of criteria. Args: email: Email of a user of the organization organization_id: Identifier of the organization Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result )","title":"count_organizations()"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","text":"Get organization metrics. Parameters: Name Type Description Default organization_id str Identifier of the organization None start_date datetime Start date of the metrics computation datetime.datetime(2022, 6, 23, 10, 39, 59, 693858) end_date datetime End date of the metrics computation datetime.datetime(2022, 6, 23, 10, 39, 59, 693860) Returns: Type Description A result object which contains the query if it was successful, or an error message. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\"Get organization metrics. Args: organization_id: Identifier of the organization start_date: Start date of the metrics computation end_date: End date of the metrics computation Returns: A result object which contains the query if it was successful, or an error message. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result )","title":"organization_metrics()"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","text":"Get a generator or a list of organizations that match a set of criteria. Parameters: Name Type Description Default email Email of a user of the organization None organization_id Identifier of the organization None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first int Maximum number of organizations to return. 100 Skip Number of skipped organizations (they are ordered by creation date) required disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> kili . organizations ( organization_id = organization_id , fields = [ 'users.email' ]) [{ 'users' : [{ 'email' : 'john@doe.com' }]}] Source code in kili/queries/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of organizations that match a set of criteria. Args: email : Email of a user of the organization organization_id : Identifier of the organization fields: All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first: Maximum number of organizations to return. Skip: Number of skipped organizations (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the organizations is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator )","title":"organizations()"},{"location":"project/","text":"Project module Queries Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None ) Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects have a title or a description that matches this string. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None , skip = 0 , fields = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first = 100 , disable_tqdm = False , as_generator = False ) Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this string. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first int Maximum number of projects to return. 100 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) Mutations Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\" Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\"Update properties of a project. Args: project_id: Identifier of the project. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. interface_category: Always use 'IV2'. input_type: Currently, one of `AUDIO`, `FRAME`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `NA`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_assets_with_empty_labels: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: The json parameters of the project, see Edit your interface. title : Title of the project description : Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/create_project.ipynb). \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. !!! warning This action is permanent and irreversible. Args: project_id: Identifier of the project Returns: The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id : Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Args: project_user_id : Identifier of the project user consensus_mark: Should be between 0 and 1. honeypot_mark: Should be between 0 and 1. number_of_labeled_assets: Number of assets the user labeled in the project. starred: Whether to star the project in the project list. total_duration: Total time the user spent in the project. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result ) __init__ ( self , auth ) special Initialize the subclass. Parameters: Name Type Description Default auth KiliAuth object required Source code in kili/mutations/project/__init__.py def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth append_to_roles ( self , project_id , user_email , role = 'LABELER' ) Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) create_project ( self , input_type , json_interface , title , description = '' , project_type = None ) Create a project. Parameters: Name Type Description Default input_type Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title Title of the project required description Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: The json parameters of the project, see Edit your interface. title : Title of the project description : Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/create_project.ipynb). \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) delete_from_roles ( self , role_id ) Delete users by their role_id. Parameters: Name Type Description Default role_id Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id : Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) delete_project ( self , project_id ) Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result ) make_project_public ( self , project_id ) Make a project public. Warning This action is permanent and irreversible. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description The public token to provide in the public URL Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. !!! warning This action is permanent and irreversible. Args: project_id: Identifier of the project Returns: The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) update_properties_in_project ( self , project_id , consensus_mark = None , consensus_tot_coverage = None , description = None , honeypot_mark = None , instructions = None , input_type = None , json_interface = None , min_consensus_size = None , number_of_assets = None , number_of_assets_with_empty_labels = None , number_of_remaining_assets = None , number_of_reviewed_assets = None , review_coverage = None , should_relaunch_kpi_computation = None , title = None , use_honeypot = None ) Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None interface_category Always use 'IV2'. required input_type Optional[str] Currently, one of AUDIO , FRAME , IMAGE , PDF , TEXT , VIDEO , NA . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_assets_with_empty_labels Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\"Update properties of a project. Args: project_id: Identifier of the project. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. interface_category: Always use 'IV2'. input_type: Currently, one of `AUDIO`, `FRAME`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `NA`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_assets_with_empty_labels: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) update_properties_in_project_user ( self , project_user_id , consensus_mark = None , honeypot_mark = None , number_of_labeled_assets = None , starred = None , total_duration = None ) Update properties of a project-user tuple Parameters: Name Type Description Default project_user_id Identifier of the project user required consensus_mark Optional[float] Should be between 0 and 1. None honeypot_mark Optional[float] Should be between 0 and 1. None number_of_labeled_assets Optional[int] Number of assets the user labeled in the project. None starred Optional[bool] Whether to star the project in the project list. None total_duration Optional[int] Total time the user spent in the project. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users : ... kili . update_properties_in_project_user ( project_user_id = project_user [ 'id' ], honeypot_mark = 0 ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Args: project_user_id : Identifier of the project user consensus_mark: Should be between 0 and 1. honeypot_mark: Should be between 0 and 1. number_of_labeled_assets: Number of assets the user labeled in the project. starred: Whether to star the project in the project list. total_duration: Total time the user spent in the project. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) update_properties_in_role ( self , role_id , project_id , user_id , role ) Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result )","title":"Project"},{"location":"project/#project-module","text":"","title":"Project module"},{"location":"project/#queries","text":"Set of Project queries. Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\"Set of Project queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"project/#kili.queries.project.__init__.QueriesProject.count_projects","text":"Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects have a title or a description that matches this string. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description int The number of projects with the parameters provided Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Args: project_id: Select a specific project through its project_id. search_query: Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: The number of projects with the parameters provided \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_projects()"},{"location":"project/#kili.queries.project.__init__.QueriesProject.projects","text":"Get a generator or a list of projects that match a set of criteria. Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this string. None should_relaunch_kpi_computation Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first int Maximum number of projects to return. 100 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the projects is returned. False Dates format Date strings should have format: \"YYYY-MM-DD\" Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili . projects () Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of projects that match a set of criteria. Args: project_id: Select a specific project through its project_id. search_query: Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte: Returned projects should have a label whose update date is greater or equal to this date. updated_at_lte: Returned projects should have a label whose update date is lower or equal to this date. skip: Number of projects to skip (they are ordered by their creation). fields: All the fields to request among the possible fields for the projects. See [the documentation](https://docs.kili-technology.com/reference/graphql-api#project) for all possible fields. first: Maximum number of projects to return. disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the projects is returned. !!! info \"Dates format\" Date strings should have format: \"YYYY-MM-DD\" Returns: A result object which contains the query if it was successful, or an error message. Examples: >>> # List all my projects >>> kili.projects() \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator )","title":"projects()"},{"location":"project/#mutations","text":"Set of Project mutations. Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\" Set of Project mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\"Update properties of a project. Args: project_id: Identifier of the project. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. interface_category: Always use 'IV2'. input_type: Currently, one of `AUDIO`, `FRAME`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `NA`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_assets_with_empty_labels: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: The json parameters of the project, see Edit your interface. title : Title of the project description : Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/create_project.ipynb). \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. !!! warning This action is permanent and irreversible. Args: project_id: Identifier of the project Returns: The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id : Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Args: project_user_id : Identifier of the project user consensus_mark: Should be between 0 and 1. honeypot_mark: Should be between 0 and 1. number_of_labeled_assets: Number of assets the user labeled in the project. starred: Whether to star the project in the project list. total_duration: Total time the user spent in the project. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result )","title":"Mutations"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.__init__","text":"Initialize the subclass. Parameters: Name Type Description Default auth KiliAuth object required Source code in kili/mutations/project/__init__.py def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth","title":"__init__()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","text":"Add a user to a project. Info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . append_to_roles ( project_id = project_id , user_email = 'john@doe.com' ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\"Add a user to a project. !!! info If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Args: project_id: Identifier of the project user_email: The email of the user. This email is used as the unique identifier of the user. role: One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result )","title":"append_to_roles()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.create_project","text":"Create a project. Parameters: Name Type Description Default input_type Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title Title of the project required description Description of the project '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE , IMAGE_CLASSIFICATION_MULTI , IMAGE_OBJECT_DETECTION_RECTANGLE , IMAGE_OBJECT_DETECTION_POLYGON , IMAGE_OBJECT_DETECTION_SEMANTIC , OCR, PDF_CLASSIFICATION_SINGLE , PDF_CLASSIFICATION_MULTI , TEXT_CLASSIFICATION_SINGLE , TEXT_CLASSIFICATION_MULTI , TEXT_TRANSCRIPTION, TEXT_NER , VIDEO_CLASSIFICATION_SINGLE , VIDEO_FRAME_CLASSIFICATION , VIDEO_FRAME_OBJECT_TRACKING , SPEECH_TO_TEXT } None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . create_project ( input_type = 'IMAGE' , json_interface = json_interface , title = 'Example' ) Recipe For more detailed examples on how to create projects, see the recipe . Source code in kili/mutations/project/__init__.py @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\"Create a project. Args: input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: The json parameters of the project, see Edit your interface. title : Title of the project description : Description of the project project_type: Currently, one of { `IMAGE_CLASSIFICATION_SINGLE`, `IMAGE_CLASSIFICATION_MULTI`, `IMAGE_OBJECT_DETECTION_RECTANGLE`, `IMAGE_OBJECT_DETECTION_POLYGON`, `IMAGE_OBJECT_DETECTION_SEMANTIC`, `OCR, PDF_CLASSIFICATION_SINGLE`, `PDF_CLASSIFICATION_MULTI`, `TEXT_CLASSIFICATION_SINGLE`, `TEXT_CLASSIFICATION_MULTI`, `TEXT_TRANSCRIPTION, TEXT_NER`, `VIDEO_CLASSIFICATION_SINGLE`, `VIDEO_FRAME_CLASSIFICATION`, `VIDEO_FRAME_OBJECT_TRACKING`, `SPEECH_TO_TEXT` } Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') !!! example \"Recipe\" For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-python-sdk/blob/master/recipes/create_project.ipynb). \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result )","title":"create_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","text":"Delete users by their role_id. Parameters: Name Type Description Default role_id Identifier of the project user (not the ID of the user) required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\"Delete users by their role_id. Args: role_id : Identifier of the project user (not the ID of the user) Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result )","title":"delete_from_roles()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.delete_project","text":"Delete a project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete a project permanently. Args: project_id: Identifier of the project Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result )","title":"delete_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.make_project_public","text":"Make a project public. Warning This action is permanent and irreversible. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description The public token to provide in the public URL Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. !!! warning This action is permanent and irreversible. Args: project_id: Identifier of the project Returns: The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result )","title":"make_project_public()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","text":"Update properties of a project. Parameters: Name Type Description Default project_id str Identifier of the project. required consensus_mark Optional[float] Should be between 0 and 1. None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Description of the project. None honeypot_mark Should be between 0 and 1 None instructions Instructions of the project. None interface_category Always use 'IV2'. required input_type Optional[str] Currently, one of AUDIO , FRAME , IMAGE , PDF , TEXT , VIDEO , NA . None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_assets_with_empty_labels Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili . update_properties_in_project ( project_id = project_id , title = 'New title' ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\"Update properties of a project. Args: project_id: Identifier of the project. consensus_mark: Should be between 0 and 1. consensus_tot_coverage: Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : Description of the project. honeypot_mark : Should be between 0 and 1 instructions : Instructions of the project. interface_category: Always use 'IV2'. input_type: Currently, one of `AUDIO`, `FRAME`, `IMAGE`, `PDF`, `TEXT`, `VIDEO`, `NA`. json_interface: The json parameters of the project, see Edit your interface. min_consensus_size: Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets: Defaults to 0 number_of_assets_with_empty_labels: Defaults to 0 number_of_remaining_assets: Defaults to 0 number_of_reviewed_assets: Defaults to 0 review_coverage: Allow to set the percentage of assets that will be queued in the review interface. Should be between 0 and 100 should_relaunch_kpi_computation: Technical field, added to indicate changes in honeypot or consensus settings title: Title of the project use_honeypot: Activate / Deactivate the use of honeypot in the project Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project_user","text":"Update properties of a project-user tuple Parameters: Name Type Description Default project_user_id Identifier of the project user required consensus_mark Optional[float] Should be between 0 and 1. None honeypot_mark Optional[float] Should be between 0 and 1. None number_of_labeled_assets Optional[int] Number of assets the user labeled in the project. None starred Optional[bool] Whether to star the project in the project list. None total_duration Optional[int] Total time the user spent in the project. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users : ... kili . update_properties_in_project_user ( project_user_id = project_user [ 'id' ], honeypot_mark = 0 ) Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Args: project_user_id : Identifier of the project user consensus_mark: Should be between 0 and 1. honeypot_mark: Should be between 0 and 1. number_of_labeled_assets: Number of assets the user labeled in the project. starred: Whether to star the project in the project list. total_duration: Total time the user spent in the project. Returns: A result object which indicates if the mutation was successful, or an error message. Examples: >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project_user()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","text":"Update properties of a role. Info To be able to change someone's role, you must be either of: an admin of the project a team manager of the project an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. Possible choices are: ADMIN , TEAM_MANAGER , REVIEWER , LABELER required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\"Update properties of a role. !!! info To be able to change someone's role, you must be either of: - an admin of the project - a team manager of the project - an admin of the organization Args: role_id: Role identifier of the user. E.g. : 'to-be-deactivated' project_id: Identifier of the project user_id: The email or identifier of the user with updated role role: The new role. Possible choices are: `ADMIN`, `TEAM_MANAGER`, `REVIEWER`, `LABELER` Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result )","title":"update_properties_in_role()"},{"location":"project_user/","text":"Project User module Queries Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( 'data' , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_project_users ( self , email = None , id = None , organization_id = None , project_id = None ) Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count project_users ( self , email = None , id = None , organization_id = None , project_id = None , fields = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first int Maximum number of users to return 100 skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"Project User"},{"location":"project_user/#project-user-module","text":"","title":"Project User module"},{"location":"project_user/#queries","text":"Set of ProjectUser queries. Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\"Set of ProjectUser queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( 'data' , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","text":"Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None Returns: Type Description int The number of project users with the parameters provided Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project Returns: The number of project users with the parameters provided \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_project_users()"},{"location":"project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","text":"Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None fields List[str] All the fields to request among the possible fields for the projectUsers See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first int Maximum number of users to return 100 skip int Number of project users to skip 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) Source code in kili/queries/project_user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Return project users (possibly with their KPIs) that match a set of criteria Args: email: Email of the user organization_id: Identifier of the user's organization project_id: Identifier of the project fields: All the fields to request among the possible fields for the projectUsers See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first: Maximum number of users to return skip: Number of project users to skip disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"project_users()"},{"location":"project_version/","text":"Project Version module Queries Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query project_id: Filter on Id of project skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count count_project_versions ( self , project_id ) Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count project_version ( self , first = 100 , skip = 0 , fields = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id = None , disable_tqdm = False , as_generator = False ) Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'project', 'projectId'] first Optional[int] Number of project versions to query 100 project_id str Filter on Id of project None skip Optional[int] Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query project_id: Filter on Id of project skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) Mutations Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result ) update_properties_in_project_version ( self , project_version_id , content ) Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"Project Version"},{"location":"project_version/#project-version-module","text":"","title":"Project Version module"},{"location":"project_version/#queries","text":"Set of ProjectVersion queries. Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\"Set of ProjectVersion queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query project_id: Filter on Id of project skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"Queries"},{"location":"project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","text":"Count the number of project versions. Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int The number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\"Count the number of project versions. Args: project_id: Filter on ID of project Returns: The number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_project_versions()"},{"location":"project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","text":"Get a generator or a list of project versions respecting a set of criteria. Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'project', 'projectId'] first Optional[int] Number of project versions to query 100 project_id str Filter on Id of project None skip Optional[int] Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of project versions respecting a set of criteria. Args: fields: All the fields to request among the possible fields for the project versions See [the documentation](https://docs.kili-technology.com/reference/graphql-api#projectVersions) for all possible fields. first: Number of project versions to query project_id: Filter on Id of project skip: Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the project versions is returned. Returns: A result object which contains the query if it was successful, or an error message. \"\"\" count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator )","title":"project_version()"},{"location":"project_version/#mutations","text":"Set of ProjectVersion mutations. Source code in kili/mutations/project_version/__init__.py class MutationsProjectVersion : \"\"\"Set of ProjectVersion mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"Mutations"},{"location":"project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","text":"Update properties of a project version. Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description A result object which indicates if the mutation was successful. Examples: >>> kili . update_properties_in_project_version ( project_version_id = project_version_id , content = 'test' ) Source code in kili/mutations/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\"Update properties of a project version. Args: project_version_id: Identifier of the project version content: Link to download the project version Returns: A result object which indicates if the mutation was successful. Examples: >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project_version()"},{"location":"user/","text":"User module Queries Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result ) count_users ( self , organization_id = None ) Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result ) users ( self , api_key = None , email = None , organization_id = None , fields = [ 'email' , 'id' , 'firstname' , 'lastname' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first int Maximum number of users to return 100 skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) Mutations Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result ) create_user ( self , email = None , password = None , organization_role = None , firstname = None , lastname = None ) Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. None password str On the first sign in, he will use this password and be able to change it. None organization_role str One of \"ADMIN\", \"USER\". None firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) reset_password ( self , email ) Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) update_password ( self , email , old_password , new_password_1 , new_password_2 ) Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) update_properties_in_user ( self , email , firstname = None , lastname = None , organization_id = None , organization_role = None , activated = None ) Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"User"},{"location":"user/#user-module","text":"","title":"User module"},{"location":"user/#queries","text":"Set of User queries. Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\"Set of User queries.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result )","title":"Queries"},{"location":"user/#kili.queries.user.__init__.QueriesUser.count_users","text":"Get user count based on a set of constraints. Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int The number of organizations with the parameters provided Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\"Get user count based on a set of constraints. Args: organization_id: Identifier of the user's organization Returns: The number of organizations with the parameters provided \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result )","title":"count_users()"},{"location":"user/#kili.queries.user.__init__.QueriesUser.users","text":"Get a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API Key None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first int Maximum number of users to return 100 skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True , the progress bar will be disabled False as_generator bool If True , a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] A result object which contains the query if it was successful, or an error message. Examples: # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\"Get a generator or a list of users given a set of criteria Args: api_key: Query an user by its API Key email: Email of the user organization_id: Identifier of the user's organization fields: All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first: Maximum number of users to return skip: Number of skipped users (they are ordered by creation date) disable_tqdm: If `True`, the progress bar will be disabled as_generator: If `True`, a generator on the users is returned. Returns: A result object which contains the query if it was successful, or an error message. Examples: ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator )","title":"users()"},{"location":"user/#mutations","text":"Set of User mutations. Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\"Set of User mutations.\"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\"Initialize the subclass. Args: auth: KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"Mutations"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.create_user","text":"Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. None password str On the first sign in, he will use this password and be able to change it. None organization_role str One of \"ADMIN\", \"USER\". None firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\"Add a user to your organization. Args: email: Email of the new user, used as user's unique identifier. password: On the first sign in, he will use this password and be able to change it. organization_role: One of \"ADMIN\", \"USER\". firstname: First name of the new user. lastname: Last name of the new user. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result )","title":"create_user()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.reset_password","text":"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\"Reset password. This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Args: email: Email of the person whose password has to be reset. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result )","title":"reset_password()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.update_password","text":"Allow to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email Email of the person whose password has to be updated. required old_password The old password required new_password_1 str The new password required new_password_2 str A confirmation field for the new password required Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\"Allow to modify the password that you use to connect to Kili. \\ This resolver only works for on-premise installations without Auth0. Args: email : Email of the person whose password has to be updated. old_password : The old password new_password_1: The new password new_password_2: A confirmation field for the new password Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result )","title":"update_password()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","text":"Update the properties of a user. Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description A result object which indicates if the mutation was successful, or an error message. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\"Update the properties of a user. Args: email: The email is the identifier of the user. firstname:Change the first name of the user. lastname: Change the last name of the user. organization_id: Change the organization the user is related to. organization_role: Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated: In case we want to deactivate a user, but keep it. Returns: A result object which indicates if the mutation was successful, or an error message. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"update_properties_in_user()"}]}