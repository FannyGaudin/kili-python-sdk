{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kili's Python SDK blablabl What is Kili? Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info here . Requirements Python >= 3.7 Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value you copied above: export KILI_API_KEY='<you api key value here>' Installation Install the Kili client with pip: pip install kili Usage Instantiate the Kili client: from kili.client import Kili kili = Kili() # You can now use the Kili client! Note that you can also pass the API key as an argument of the Kili initialization: kili = Kili(api_key='MY API KEY') Here is a sample of the operations you can do with the Kili client:","title":"Kili's Python SDK blablabl"},{"location":"#kilis-python-sdk-blablabl","text":"","title":"Kili's Python SDK blablabl"},{"location":"#what-is-kili","text":"Kili is a platform that empowers a data-centric approach to Machine Learning through quality training data creation. It provides collaborative data annotation tools and APIs that enable quick iterations between reliable dataset building and model training. More info here .","title":"What is Kili?"},{"location":"#requirements","text":"Python >= 3.7 Create and copy a Kili API key Add the KILI_API_KEY variable in your bash environment (or in the settings of your favorite IDE) by pasting the API key value you copied above: export KILI_API_KEY='<you api key value here>'","title":"Requirements"},{"location":"#installation","text":"Install the Kili client with pip: pip install kili","title":"Installation"},{"location":"#usage","text":"Instantiate the Kili client: from kili.client import Kili kili = Kili() # You can now use the Kili client! Note that you can also pass the API key as an argument of the Kili initialization: kili = Kili(api_key='MY API KEY') Here is a sample of the operations you can do with the Kili client:","title":"Usage"},{"location":"api_key/","text":"API Key module Api key queries QueriesApiKey Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of API keys that match a set of constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first : Maximum number of assets to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). Returns ------- dict A result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count api_keys ( self , api_key_id = None , user_id = None , api_key = None , skip = 0 , fields = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first = 100 , disable_tqdm = False , as_generator = False ) Gets a generator or a list of API keys that match a set of constraints Parameters: Name Type Description Default api_key_id Optional[str] The unique id of the api key to retrieve. None user_id Optional[str] Identifier of the user (you can only query your own api keys). None api_key Optional[str] Value of the api key (you can only query your own api keys). None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of assets to return. 100 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of API keys that match a set of constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first : Maximum number of assets to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) count_api_keys ( self , api_key_id = None , user_id = None , api_key = None ) Count and return the number of api keys with the given constraints Parameters: Name Type Description Default api_key_id Optional[str] The unique id of the api key to retrieve. None user_id Optional[str] Identifier of the user (you can only query your own api keys). None api_key Optional[str] Value of the api key (you can only query your own api keys). None Returns: Type Description int A result object which contains the query if it was successful, or an error message else. Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). Returns ------- dict A result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count Api key mutations MutationsApiKey Set of User mutations Source code in kili/mutations/api_key/__init__.py class MutationsApiKey : # pylint: disable=too-few-public-methods \"\"\" Set of User mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\" Create an api key to connect to the API Parameters ---------- api_key : A new api key to connect with name : A name used to describe the api key. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result ) append_to_api_keys ( self , api_key , name ) Create an api key to connect to the API Parameters: Name Type Description Default api_key str A new api key to connect with required name str A name used to describe the api key. required Source code in kili/mutations/api_key/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\" Create an api key to connect to the API Parameters ---------- api_key : A new api key to connect with name : A name used to describe the api key. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"API Key"},{"location":"api_key/#api-key-module","text":"Api key queries","title":"API Key module"},{"location":"api_key/#kili.queries.api_key.__init__.QueriesApiKey","text":"Set of ApiKey queries Source code in kili/queries/api_key/__init__.py class QueriesApiKey : \"\"\" Set of ApiKey queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of API keys that match a set of constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first : Maximum number of assets to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator ) def _query_api_keys ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_api_keys = gql_api_keys ( fragment_builder ( fields , ApiKeyType )) result = self . auth . client . execute ( _gql_api_keys , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). Returns ------- dict A result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesApiKey"},{"location":"api_key/#kili.queries.api_key.__init__.QueriesApiKey.api_keys","text":"Gets a generator or a list of API keys that match a set of constraints Parameters: Name Type Description Default api_key_id Optional[str] The unique id of the api key to retrieve. None user_id Optional[str] Identifier of the user (you can only query your own api keys). None api_key Optional[str] Value of the api key (you can only query your own api keys). None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'name', 'createdAt', 'revoked'] first Optional[int] Maximum number of assets to return. 100 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'id' , 'name' , 'createdAt' , 'revoked' ], first : Optional [ int ] = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of API keys that match a set of constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#apikey) for all possible fields. first : Maximum number of assets to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.api_keys(user_id=user_id) >>> kili.api_keys(api_key=api_key) >>> kili.api_keys(api_key=api_key, as_generator=False) \"\"\" saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'user_id' , 'api_key_id' , 'api_key' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } api_keys_generator = row_generator_from_paginated_calls ( skip , first , self . count_api_keys , count_args , self . _query_api_keys , payload_query , fields , disable_tqdm ) if as_generator : return api_keys_generator return list ( api_keys_generator )","title":"api_keys()"},{"location":"api_key/#kili.queries.api_key.__init__.QueriesApiKey.count_api_keys","text":"Count and return the number of api keys with the given constraints Parameters: Name Type Description Default api_key_id Optional[str] The unique id of the api key to retrieve. None user_id Optional[str] Identifier of the user (you can only query your own api keys). None api_key Optional[str] Value of the api key (you can only query your own api keys). None Returns: Type Description int A result object which contains the query if it was successful, or an error message else. Source code in kili/queries/api_key/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_api_keys ( self , api_key_id : Optional [ str ] = None , user_id : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- api_key_id : The unique id of the api key to retrieve. user_id : Identifier of the user (you can only query your own api keys). api_key : Value of the api key (you can only query your own api keys). Returns ------- dict A result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.count_api_keys(user_id=user_id) 3 >>> kili.count_api_keys(api_key=api_key) 1 \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , 'apiKey' : api_key }, 'id' : api_key_id , }, } result = self . auth . client . execute ( GQL_API_KEYS_COUNT , variables ) count = format_result ( 'data' , result ) return count Api key mutations","title":"count_api_keys()"},{"location":"api_key/#kili.mutations.api_key.__init__.MutationsApiKey","text":"Set of User mutations Source code in kili/mutations/api_key/__init__.py class MutationsApiKey : # pylint: disable=too-few-public-methods \"\"\" Set of User mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\" Create an api key to connect to the API Parameters ---------- api_key : A new api key to connect with name : A name used to describe the api key. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"MutationsApiKey"},{"location":"api_key/#kili.mutations.api_key.__init__.MutationsApiKey.append_to_api_keys","text":"Create an api key to connect to the API Parameters: Name Type Description Default api_key str A new api key to connect with required name str A name used to describe the api key. required Source code in kili/mutations/api_key/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_api_keys ( self , api_key : str , name : str ): \"\"\" Create an api key to connect to the API Parameters ---------- api_key : A new api key to connect with name : A name used to describe the api key. \"\"\" variables = { 'data' : { 'key' : api_key , 'name' : name }, 'where' : { 'email' : self . auth . user_email } } result = self . auth . client . execute ( GQL_APPEND_TO_API_KEYS , variables ) return format_result ( 'data' , result )","title":"append_to_api_keys()"},{"location":"asset/","text":"Asset module Asset queries QueriesAsset Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project. skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first : Maximum number of assets to return. consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. external_id_contains : Returned assets have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm : If True, the progress bar will be disabled as_generator : If True, a generator on the assets is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project external_id_contains : Returned assets should have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of consensus for the asset. label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- dict a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count assets ( self , asset_id = None , project_id = None , skip = 0 , fields = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in = None , consensus_mark_gt = None , consensus_mark_lt = None , disable_tqdm = False , external_id_contains = None , first = None , format = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , label_type_in = None , metadata_where = None , skipped = None , status_in = None , updated_at_gte = None , updated_at_lte = None , as_generator = False ) Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the assets is returned. False Examples: >>> kili . assets ( project_id = project_id ) # returns the assets list of the project >>> kili . assets ( asset_id = asset_id ) >>> kili . assets ( project_id = project_id , as_generator = True ) # returns a generator of the project assets Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project. skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first : Maximum number of assets to return. consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. external_id_contains : Returned assets have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm : If True, the progress bar will be disabled as_generator : If True, a generator on the assets is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) count_assets ( self , asset_id = None , project_id = None , asset_id_in = None , external_id_contains = None , metadata_where = None , status_in = None , consensus_mark_gt = None , consensus_mark_lt = None , honeypot_mark_gt = None , honeypot_mark_lt = None , label_type_in = None , label_author_in = None , label_consensus_mark_gt = None , label_consensus_mark_lt = None , label_created_at = None , label_created_at_gt = None , label_created_at_lt = None , label_honeypot_mark_gt = None , label_honeypot_mark_lt = None , label_json_response_contains = None , skipped = None , updated_at_gte = None , updated_at_lte = None ) Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project external_id_contains : Returned assets should have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of consensus for the asset. label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- dict a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count Asset mutations MutationsAsset Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset ) append_many_to_dataset ( self , project_id , content_array = None , external_id_array = None , is_honeypot_array = None , status_array = None , json_content_array = None , json_metadata_array = None ) Append assets to a project For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. None json_content_array Optional[List[List[Union[dict, str]]]] Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. None Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) delete_many_from_dataset ( self , asset_ids ) Delete assets from a project Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset ) update_properties_in_assets ( self , asset_ids , external_ids = None , priorities = None , json_metadatas = None , consensus_marks = None , honeypot_marks = None , to_be_labeled_by_array = None , contents = None , json_contents = None , status_array = None , is_used_for_consensus_array = None , is_honeypot_array = None ) Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset )","title":"Asset"},{"location":"asset/#asset-module","text":"Asset queries","title":"Asset module"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset","text":"Set of Asset queries Source code in kili/queries/asset/__init__.py class QueriesAsset : \"\"\" Set of Asset queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project. skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first : Maximum number of assets to return. consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. external_id_contains : Returned assets have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm : If True, the progress bar will be disabled as_generator : If True, a generator on the assets is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator ) def _query_assets ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ \"skip\" : skip , \"first\" : first }) _gql_assets = gql_assets ( fragment_builder ( fields , AssetType )) result = self . auth . client . execute ( _gql_assets , payload ) assets = format_result ( 'data' , result , Asset ) return assets @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project external_id_contains : Returned assets should have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of consensus for the asset. label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- dict a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesAsset"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.assets","text":"Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project. None skip int Number of assets to skip (they are ordered by their date of creation, first to last). 0 fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['content', 'createdAt', 'externalId', 'id', 'isHoneypot', 'jsonMetadata', 'labels.author.id', 'labels.author.email', 'labels.createdAt', 'labels.id', 'labels.jsonResponse', 'skipped', 'status'] first Optional[int] Maximum number of assets to return. None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None external_id_contains Optional[List[str]] Returned assets have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of honeypot for the asset. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None format Optional[str] If equal to 'pandas', returns a pandas DataFrame None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the assets is returned. False Examples: >>> kili . assets ( project_id = project_id ) # returns the assets list of the project >>> kili . assets ( asset_id = asset_id ) >>> kili . assets ( project_id = project_id , as_generator = True ) # returns a generator of the project assets Returns: Type Description Union[List[dict], Generator[dict, NoneType], pandas.core.frame.DataFrame] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'content' , 'createdAt' , 'externalId' , 'id' , 'isHoneypot' , 'jsonMetadata' , 'labels.author.id' , 'labels.author.email' , 'labels.createdAt' , 'labels.id' , 'labels.jsonResponse' , 'skipped' , 'status' ], asset_id_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , disable_tqdm : bool = False , external_id_contains : Optional [ List [ str ]] = None , first : Optional [ int ] = None , format : Optional [ str ] = None , # pylint: disable=redefined-builtin honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , label_type_in : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , skipped : Optional [ bool ] = None , status_in : Optional [ List [ str ]] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ], pd . DataFrame ]: # pylint: disable=line-too-long \"\"\" Gets an asset list, an asset generator or a pandas DataFrame that match a set of constraints. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project. skip : Number of assets to skip (they are ordered by their date of creation, first to last). fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. first : Maximum number of assets to return. consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. external_id_contains : Returned assets have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of honeypot for the asset. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices: {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" format: If equal to 'pandas', returns a pandas DataFrame disable_tqdm : If True, the progress bar will be disabled as_generator : If True, a generator on the assets is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples -------- >>> kili.assets(project_id=project_id) # returns the assets list of the project >>> kili.assets(asset_id=asset_id) >>> kili.assets(project_id=project_id, as_generator=True) # returns a generator of the project assets \"\"\" if format == \"pandas\" and as_generator : raise ValueError ( \"Argument values as_generator==True and format== \\\" pandas \\\" are not compatible.\" ) if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'skip' , 'first' , 'disable_tqdm' , 'format' , 'fields' , 'self' , 'as_generator' ]} # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } asset_generator = row_generator_from_paginated_calls ( skip , first , self . count_assets , count_args , self . _query_assets , payload_query , fields , disable_tqdm ) if format == \"pandas\" : return pd . DataFrame ( list ( asset_generator )) if as_generator : return asset_generator return list ( asset_generator )","title":"assets()"},{"location":"asset/#kili.queries.asset.__init__.QueriesAsset.count_assets","text":"Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters: Name Type Description Default asset_id Optional[str] The unique id of the asset to retrieve. None asset_id_in Optional[List[str]] A list of the ids of the assets to retrieve. None project_id Optional[str] Identifier of the project None external_id_contains Optional[List[str]] Returned assets should have an external id that belongs to that list, if given. None metadata_where Optional[dict] Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. None status_in Optional[List[str]] Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None consensus_mark_gt Optional[float] Minimum amount of consensus for the asset. None consensus_mark_lt Optional[float] Maximum amount of consensus for the asset. None honeypot_mark_gt Optional[float] Minimum amount of honeypot for the asset. None honeypot_mark_lt Optional[float] Maximum amount of consensus for the asset. None label_type_in Optional[List[str]] Returned assets should have a label whose type belongs to that list, if given. None label_author_in Optional[List[str]] Returned assets should have a label whose status belongs to that list, if given. None label_consensus_mark_gt Optional[float] Returned assets should have a label whose consensus is greater than this number. None label_consensus_mark_lt Optional[float] Returned assets should have a label whose consensus is lower than this number. None label_created_at Optional[str] Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_gt Optional[str] Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_created_at_lt Optional[str] Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" None label_honeypot_mark_gt Optional[float] Returned assets should have a label whose honeypot is greater than this number. None label_honeypot_mark_lt Optional[float] Returned assets should have a label whose honeypot is lower than this number. None label_json_response_contains Optional[List[str]] Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. None skipped Optional[bool] Returned assets should be skipped None updated_at_gte Optional[str] Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" None Examples: >>> kili . count_assets ( project_id = project_id ) 250 >>> kili . count_assets ( asset_id = asset_id ) 1 Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_assets ( self , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None , asset_id_in : Optional [ List [ str ]] = None , external_id_contains : Optional [ List [ str ]] = None , metadata_where : Optional [ dict ] = None , status_in : Optional [ List [ str ]] = None , consensus_mark_gt : Optional [ float ] = None , consensus_mark_lt : Optional [ float ] = None , honeypot_mark_gt : Optional [ float ] = None , honeypot_mark_lt : Optional [ float ] = None , label_type_in : Optional [ List [ str ]] = None , label_author_in : Optional [ List [ str ]] = None , label_consensus_mark_gt : Optional [ float ] = None , label_consensus_mark_lt : Optional [ float ] = None , label_created_at : Optional [ str ] = None , label_created_at_gt : Optional [ str ] = None , label_created_at_lt : Optional [ str ] = None , label_honeypot_mark_gt : Optional [ float ] = None , label_honeypot_mark_lt : Optional [ float ] = None , label_json_response_contains : Optional [ List [ str ]] = None , skipped : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of assets with the given constraints Parameters beginning with 'label_' apply to labels, others apply to assets. Parameters ---------- asset_id : The unique id of the asset to retrieve. asset_id_in : A list of the ids of the assets to retrieve. project_id : Identifier of the project external_id_contains : Returned assets should have an external id that belongs to that list, if given. metadata_where : Filters by the values of the metadata of the asset. - metadata_where = {key1: \"value1\"} to filter on assets whose metadata have key \"key1\" with value \"value1\" - metadata_where = {key1: [\"value1\", \"value2\"]} to filter on assets whose metadata have key \"key1\" with value \"value1\" or value \"value2 - metadata_where = {key2: [2, 10]} to filter on assets whose metadata have key \"key2\" with a value between 2 and 10. status_in : Returned assets should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} consensus_mark_gt : Minimum amount of consensus for the asset. consensus_mark_lt : Maximum amount of consensus for the asset. honeypot_mark_gt : Minimum amount of honeypot for the asset. honeypot_mark_lt : Maximum amount of consensus for the asset. label_type_in : Returned assets should have a label whose type belongs to that list, if given. label_author_in : Returned assets should have a label whose status belongs to that list, if given. label_consensus_mark_gt : Returned assets should have a label whose consensus is greater than this number. label_consensus_mark_lt : Returned assets should have a label whose consensus is lower than this number. label_created_at : Returned assets should have a label whose creation date is equal to this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_gt : Returned assets should have a label whose creation date is greater than this date. Formatted string should have format: \"YYYY-MM-DD\" label_created_at_lt : Returned assets should have a label whose creation date is lower than this date. Formatted string should have format: \"YYYY-MM-DD\" label_honeypot_mark_gt : Returned assets should have a label whose honeypot is greater than this number. label_honeypot_mark_lt : Returned assets should have a label whose honeypot is lower than this number. label_json_response_contains : Returned assets should have a substring of the label's jsonResponse that belongs to that list, if given. skipped : Returned assets should be skipped updated_at_gte : Returned assets should have a label whose update date is greated or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" updated_at_lte : Returned assets should have a label whose update date is lower or equal to this date. Formatted string should have format: \"YYYY-MM-DD\" Returns ------- dict a result object which contains the query if it was successful, or an error message else. Example ------- >>> kili.count_assets(project_id=project_id) 250 >>> kili.count_assets(asset_id=asset_id) 1 \"\"\" variables = { 'where' : { 'id' : asset_id , 'project' : { 'id' : project_id , }, 'externalIdIn' : external_id_contains , 'statusIn' : status_in , 'consensusMarkGte' : consensus_mark_gt , 'consensusMarkLte' : consensus_mark_lt , 'honeypotMarkGte' : honeypot_mark_gt , 'honeypotMarkLte' : honeypot_mark_lt , 'idIn' : asset_id_in , 'metadata' : metadata_where , 'label' : { 'typeIn' : label_type_in , 'authorIn' : label_author_in , 'consensusMarkGte' : label_consensus_mark_gt , 'consensusMarkLte' : label_consensus_mark_lt , 'createdAt' : label_created_at , 'createdAtGte' : label_created_at_gt , 'createdAtLte' : label_created_at_lt , 'honeypotMarkGte' : label_honeypot_mark_gt , 'honeypotMarkLte' : label_honeypot_mark_lt , 'jsonResponseContains' : label_json_response_contains , }, 'skipped' : skipped , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_ASSETS_COUNT , variables ) count = format_result ( 'data' , result ) return count Asset mutations","title":"count_assets()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset","text":"Set of Asset mutations Source code in kili/mutations/asset/__init__.py class MutationsAsset : \"\"\" Set of Asset mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset )","title":"MutationsAsset"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.append_many_to_dataset","text":"Append assets to a project For more detailed examples on how to import assets, see the recipe . For more detailed examples on how to import text assets, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required content_array Optional[List[str]] List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. None external_id_array Optional[List[str]] List of external ids given to identify the assets. If None, random identifiers are created. None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None status_array Optional[List[str]] By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. None json_content_array Optional[List[List[Union[dict, str]]]] Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb None json_metadata_array Optional[List[dict]] The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. None Examples: >>> kili . append_many_to_dataset ( project_id = project_id , content_array = [ 'https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png' ]) Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_many_to_dataset ( self , project_id : str , content_array : Optional [ List [ str ]] = None , external_id_array : Optional [ List [ str ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None , status_array : Optional [ List [ str ]] = None , json_content_array : Optional [ List [ List [ Union [ dict , str ]]]] = None , json_metadata_array : Optional [ List [ dict ]] = None ): # pylint: disable=line-too-long \"\"\" Append assets to a project For more detailed examples on how to import assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_assets.ipynb). For more detailed examples on how to import text assets, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb). Parameters ---------- project_id : Identifier of the project content_array : List of elements added to the assets of the project - For a Text project, the content can be either raw text, or URLs to TEXT assets. - For an Image / PDF project, the content can be either URLs or paths to existing images/pdf on your computer. - For a Video project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs. Must not be None except if you provide json_content_array. external_id_array : List of external ids given to identify the assets. If None, random identifiers are created. is_honeypot_array: Whether to use the asset for honeypot status_array : By default, all imported assets are set to 'TODO'. Other options: 'ONGOING', 'LABELED', 'REVIEWED'. json_content_array : Useful for 'FRAME' or 'TEXT' projects only. For FRAME projects, each element is a sequence of frames, i.e. a list of URLs to images or a list of paths to images. For TEXT projects, each element is a json_content dict, formatted according to documentation on how to import rich-text assets: https://github.com/kili-technology/kili-playground/blob/master/recipes/import_text_assets.ipynb json_metadata_array : The metadata given to each asset should be stored in a json like dict with keys. Add metadata visible on the asset with the following keys: \"imageUrl\", \"text\", \"url\". Example: json_metadata_array = [{'imageUrl': '','text': '','url': ''}] to upload one asset. For video, you can specify a value with key 'processingParameters' to specify the sampling rate (default: 30). Example: json_metadata_array = [{'processingParameters': {'framesPlayedPerSecond': 10}}] to upload one asset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.append_many_to_dataset( project_id=project_id, content_array=['https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png']) \"\"\" playground = QueriesProject ( self . auth ) projects = playground . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT input_type = projects [ 0 ][ 'inputType' ] data , request = process_append_many_to_dataset_parameters ( input_type , content_array , external_id_array , is_honeypot_array , status_array , json_content_array , json_metadata_array ) variables = { 'data' : data , 'where' : { 'id' : project_id } } result = self . auth . client . execute ( request , variables ) return format_result ( 'data' , result , Asset )","title":"append_many_to_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.delete_many_from_dataset","text":"Delete assets from a project Parameters: Name Type Description Default asset_ids List[str] The list of identifiers of the assets to delete. required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_many_from_dataset ( self , asset_ids : List [ str ]): \"\"\" Delete assets from a project Parameters ---------- asset_ids : The list of identifiers of the assets to delete. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'idIn' : asset_ids }} result = self . auth . client . execute ( GQL_DELETE_MANY_FROM_DATASET , variables ) return format_result ( 'data' , result , Asset )","title":"delete_many_from_dataset()"},{"location":"asset/#kili.mutations.asset.__init__.MutationsAsset.update_properties_in_assets","text":"Update the properties of one or more assets. Parameters: Name Type Description Default asset_ids List[str] The asset IDs to modify required external_ids Optional[List[str]] Change the external id of the assets None priorities Optional[List[int]] You can change the priority of the assets By default, all assets have a priority of 0. None json_metadatas Optional[List[Union[dict, str]]] The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} None consensus_marks Optional[List[float]] Should be between 0 and 1 None honeypot_marks Optional[List[float]] Should be between 0 and 1 None to_be_labeled_by_array Optional[List[List[str]]] If given, each element of the list should contain the emails of the labelers authorized to label the asset. None contents Optional[List[str]] For a NLP project, the content can be directly in text format For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs None json_contents Optional[List[str]] For a NLP project, the json_content is a a text formatted using RichText For a Video project, the json_content is a json containg urls pointing to each frame of the video. None status_array Optional[List[str]] Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None is_used_for_consensus_array Optional[List[bool]] Whether to use the asset to compute consensus kpis or not None is_honeypot_array Optional[List[bool]] Whether to use the asset for honeypot None Examples: >>> kili . update_properties_in_assets ( asset_ids = [ \"ckg22d81r0jrg0885unmuswj8\" , \"ckg22d81s0jrh0885pdxfd03n\" ], consensus_marks = [ 1 , 0.7 ], contents = [ None , 'https://to/second/asset.png' ], external_ids = [ 'external-id-of-your-choice-1' , 'external-id-of-your-choice-2' ], honeypot_marks = [ 0.8 , 0.5 ], is_honeypot_array = [ True , True ], is_used_for_consensus_array = [ True , False ], priorities = [ None , 2 ], status_array = [ 'LABELED' , 'REVIEWED' ], to_be_labeled_by_array = [[ 'test+pierre@kili-technology.com' ], None ], ) Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/asset/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_assets ( self , asset_ids : List [ str ], external_ids : Optional [ List [ str ]] = None , priorities : Optional [ List [ int ]] = None , json_metadatas : Optional [ List [ Union [ dict , str ]]] = None , consensus_marks : Optional [ List [ float ]] = None , honeypot_marks : Optional [ List [ float ]] = None , to_be_labeled_by_array : Optional [ List [ List [ str ]]] = None , contents : Optional [ List [ str ]] = None , json_contents : Optional [ List [ str ]] = None , status_array : Optional [ List [ str ]] = None , is_used_for_consensus_array : Optional [ List [ bool ]] = None , is_honeypot_array : Optional [ List [ bool ]] = None ): \"\"\" Update the properties of one or more assets. Parameters ---------- asset_ids : List[str] The asset IDs to modify external_ids : Change the external id of the assets priorities : List[int], optional (default = None) You can change the priority of the assets By default, all assets have a priority of 0. json_metadatas : The metadata given to an asset should be stored in a json like dict with keys \"imageUrl\", \"text\", \"url\". json_metadata = {'imageUrl': '','text': '','url': ''} consensus_marks : Should be between 0 and 1 honeypot_marks : Should be between 0 and 1 to_be_labeled_by_array : If given, each element of the list should contain the emails of the labelers authorized to label the asset. contents : - For a NLP project, the content can be directly in text format - For an Image / Video / Pdf project, the content must be hosted on a web server, and you point Kili to your data by giving the URLs json_contents : - For a NLP project, the json_content is a a text formatted using RichText - For a Video project, the json_content is a json containg urls pointing to each frame of the video. status_array : Each element should be in {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} is_used_for_consensus_array : Whether to use the asset to compute consensus kpis or not is_honeypot_array : Whether to use the asset for honeypot Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples -------- >>> kili.update_properties_in_assets( asset_ids=[\"ckg22d81r0jrg0885unmuswj8\", \"ckg22d81s0jrh0885pdxfd03n\"], consensus_marks=[1, 0.7], contents=[None, 'https://to/second/asset.png'], external_ids=['external-id-of-your-choice-1', 'external-id-of-your-choice-2'], honeypot_marks=[0.8, 0.5], is_honeypot_array=[True, True], is_used_for_consensus_array=[True, False], priorities=[None, 2], status_array=['LABELED', 'REVIEWED'], to_be_labeled_by_array=[['test+pierre@kili-technology.com'], None], ) \"\"\" formatted_json_metadatas = None if json_metadatas is None : formatted_json_metadatas = None else : if isinstance ( json_metadatas , list ): formatted_json_metadatas = list ( map ( format_metadata , json_metadatas )) else : raise Exception ( 'json_metadatas' , 'Should be either a None or a list of None, string, list or dict' ) where_array = [{ 'id' : asset_id } for asset_id in asset_ids ] nb_assets_to_modify = len ( where_array ) if nb_assets_to_modify > 100 : raise Exception ( f 'Too many assets ( { nb_assets_to_modify } ) updated at a time' ) data_array = [{} for i in range ( len ( where_array ))] list_of_properties = [ external_ids , priorities , formatted_json_metadatas , consensus_marks , honeypot_marks , to_be_labeled_by_array , contents , json_contents , status_array , is_used_for_consensus_array , is_honeypot_array ] data = list ( map ( partial ( convert_to_list_of_none , length = nb_assets_to_modify ), list_of_properties )) property_names = [ 'externalId' , 'priority' , 'jsonMetadata' , 'consensusMark' , 'honeypotMark' , 'toBeLabeledBy' , 'content' , 'jsonContent' , 'status' , 'isUsedForConsensus' , 'isHoneypot' ] to_be_labeled_by_array = data [ 5 ] should_reset_to_be_labeled_by_array = list ( map ( is_none_or_empty , to_be_labeled_by_array )) for i , properties in enumerate ( zip ( * data )): for _property , property_value in zip ( property_names , properties ): data_array [ i ][ _property ] = property_value for i in range ( nb_assets_to_modify ): data_array [ i ][ 'shouldResetToBeLabeledBy' ] = should_reset_to_be_labeled_by_array [ i ] variables = { 'whereArray' : where_array , 'dataArray' : data_array } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ASSETS , variables ) return format_result ( 'data' , result , Asset )","title":"update_properties_in_assets()"},{"location":"issue/","text":"Issue module Issue queries QueriesIssue dataclass Set of Issue queries Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\" Set of Issue queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- dict the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count count_issues ( self , project_id = None ) Count and return the number of api keys with the given constraints Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int the number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- dict the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count issues ( self , fields = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first = 100 , project_id = None , skip = 0 , disable_tqdm = False , as_generator = False ) Gets a generator or a list of issues that match a set of criteria Parameters: Name Type Description Default fields Optional[List[str]] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the issues is returned. False Examples: # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"Issue"},{"location":"issue/#issue-module","text":"Issue queries","title":"Issue module"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue","text":"Set of Issue queries Source code in kili/queries/issue/__init__.py @dataclass class QueriesIssue : \"\"\" Set of Issue queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator ) def _query_issues ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_issues = gql_issues ( fragment_builder ( fields , IssueType )) result = self . auth . client . execute ( _gql_issues , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- dict the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesIssue"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.count_issues","text":"Count and return the number of api keys with the given constraints Parameters: Name Type Description Default project_id Optional[str] Project ID the issue belongs to. None Returns: Type Description int the number of issues with the parameters provided Source code in kili/queries/issue/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_issues ( self , project_id : Optional [ str ] = None ) -> int : \"\"\" Count and return the number of api keys with the given constraints Parameters ---------- project_id : Project ID the issue belongs to. Returns ------- dict the number of issues with the parameters provided \"\"\" variables = { 'where' : { 'project' : { 'id' : project_id , }, }, } result = self . auth . client . execute ( GQL_ISSUES_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_issues()"},{"location":"issue/#kili.queries.issue.__init__.QueriesIssue.issues","text":"Gets a generator or a list of issues that match a set of criteria Parameters: Name Type Description Default fields Optional[List[str]] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['id', 'createdAt', 'hasBeenSeen', 'issueNumber', 'status', 'type'] first Optional[int] Maximum number of issues to return. 100 project_id Optional[str] Project ID the issue belongs to. None skip Optional[int] Number of issues to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the issues is returned. False Examples: # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/issue/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def issues ( self , fields : Optional [ List [ str ]] = [ 'id' , 'createdAt' , 'hasBeenSeen' , 'issueNumber' , 'status' , 'type' ], first : Optional [ int ] = 100 , project_id : Optional [ str ] = None , skip : Optional [ int ] = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of issues that match a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#issue) for all possible fields. first : Maximum number of issues to return. project_id : Project ID the issue belongs to. skip : Number of issues to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the issues is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples -------- ``` # List all issues of a project and their authors >>> kili.issues(project_id=project_id, fields=['author.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { 'project_id' : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'project' : { 'id' : project_id , }, }, } issues_generator = row_generator_from_paginated_calls ( skip , first , self . count_issues , count_args , self . _query_issues , payload_query , fields , disable_tqdm ) if as_generator : return issues_generator return list ( issues_generator )","title":"issues()"},{"location":"label/","text":"Label module Label queries QueriesLabel Set of Label queries Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\" Set of Label queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a label list or a label generator from a project based on a set of criteria Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gt : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lt : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. first : Maximum number of labels to return. honeypot_mark_gt : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lt : Returned labels should have a label whose honeypot is lower than this number. id_contains : Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skip : Number of labels to skip (they are ordered by their date of creation, first to last). skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the labels is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples ------- >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( 'data' , result , Label ) @staticmethod def parse_json_response_for_single_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a single-class classification task \"\"\" categories = QueriesLabel . parse_json_response_for_multi_classification ( json_response ) if len ( categories ) == 0 : return [] return categories [ 0 ] @staticmethod def parse_json_response_for_multi_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a multi-class classification task \"\"\" # pylint: disable=eval-used formatted_json_response = eval ( json_response ) if 'categories' not in formatted_json_response : return [] categories = formatted_json_response [ 'categories' ] return list ( map ( lambda category : category [ 'name' ], categories )) @staticmethod def parse_json_response ( json_response , interface_category ): \"\"\" Parameters ---------- json_response : A valid JSON response interface_category: A valid interface category Returns ------- dict the names of categories from a json_response \"\"\" if interface_category == 'SINGLECLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_single_classification ( json_response ) if interface_category == 'MULTICLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_multi_classification ( json_response ) return json_response # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]): # pylint: disable=line-too-long \"\"\" Get the labels of a project as a pandas DataFrame Parameters ---------- project_id : Identifier of the project fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. asset_fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. Returns ------- labels_df : pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT project = projects [ 0 ] if 'interfaceCategory' not in project : return pd . DataFrame () interface_category = project [ 'interfaceCategory' ] assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) if 'jsonResponse' in labels_df . columns : labels_df [ 'jsonResponse' ] = labels_df [ 'jsonResponse' ] . apply ( lambda json_response : QueriesLabel . parse_json_response ( json_response , interface_category )) return labels_df @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\" Get the number of labels for the given parameters Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gte : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lte : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" honeypot_mark_gte : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte : Returned labels should have a label whose honeypot is lower than this number. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. Returns ------- dict the number of labels with the parameters provided \"\"\" variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_labels ( self , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , honeypot_mark_gte = None , honeypot_mark_lte = None , json_response_contains = None , label_id = None , project_id = None , skipped = None , type_in = None , user_id = None ) Get the number of labels for the given parameters Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Returns: Type Description int the number of labels with the parameters provided Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\" Get the number of labels for the given parameters Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gte : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lte : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" honeypot_mark_gte : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte : Returned labels should have a label whose honeypot is lower than this number. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. Returns ------- dict the number of labels with the parameters provided \"\"\" variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count export_labels_as_df ( self , project_id , fields = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields = [ 'externalId' ]) Get the labels of a project as a pandas DataFrame Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType', 'skipped'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]): # pylint: disable=line-too-long \"\"\" Get the labels of a project as a pandas DataFrame Parameters ---------- project_id : Identifier of the project fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. asset_fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. Returns ------- labels_df : pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT project = projects [ 0 ] if 'interfaceCategory' not in project : return pd . DataFrame () interface_category = project [ 'interfaceCategory' ] assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) if 'jsonResponse' in labels_df . columns : labels_df [ 'jsonResponse' ] = labels_df [ 'jsonResponse' ] . apply ( lambda json_response : QueriesLabel . parse_json_response ( json_response , interface_category )) return labels_df labels ( self , asset_id = None , asset_status_in = None , asset_external_id_in = None , author_in = None , created_at = None , created_at_gte = None , created_at_lte = None , fields = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first = None , honeypot_mark_gte = None , honeypot_mark_lte = None , id_contains = None , json_response_contains = None , label_id = None , project_id = None , skip = 0 , skipped = None , type_in = None , user_id = None , disable_tqdm = False , as_generator = False ) Gets a label list or a label generator from a project based on a set of criteria Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_gt Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" required created_at_lt Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'skipped'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gt Returned labels should have a label whose honeypot is greater than this number. required honeypot_mark_lt Returned labels should have a label whose honeypot is lower than this number. required id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the labels is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a label list or a label generator from a project based on a set of criteria Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gt : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lt : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. first : Maximum number of labels to return. honeypot_mark_gt : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lt : Returned labels should have a label whose honeypot is lower than this number. id_contains : Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skip : Number of labels to skip (they are ordered by their date of creation, first to last). skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the labels is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples ------- >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) parse_json_response ( json_response , interface_category ) staticmethod Parameters: Name Type Description Default json_response A valid JSON response required interface_category A valid interface category required Returns: Type Description dict the names of categories from a json_response Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response ( json_response , interface_category ): \"\"\" Parameters ---------- json_response : A valid JSON response interface_category: A valid interface category Returns ------- dict the names of categories from a json_response \"\"\" if interface_category == 'SINGLECLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_single_classification ( json_response ) if interface_category == 'MULTICLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_multi_classification ( json_response ) return json_response parse_json_response_for_multi_classification ( json_response ) staticmethod Parameters: Name Type Description Default json_response A valid JSON response required Returns: Type Description dict the names of categories from a json_response, for a multi-class classification task Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response_for_multi_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a multi-class classification task \"\"\" # pylint: disable=eval-used formatted_json_response = eval ( json_response ) if 'categories' not in formatted_json_response : return [] categories = formatted_json_response [ 'categories' ] return list ( map ( lambda category : category [ 'name' ], categories )) parse_json_response_for_single_classification ( json_response ) staticmethod Parameters: Name Type Description Default json_response A valid JSON response required Returns: Type Description dict the names of categories from a json_response, for a single-class classification task Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response_for_single_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a single-class classification task \"\"\" categories = QueriesLabel . parse_json_response_for_multi_classification ( json_response ) if len ( categories ) == 0 : return [] return categories [ 0 ] Label mutations MutationsLabel Set of Label mutations Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\" Set of Label mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\" Create predictions for specific assets For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Parameters ---------- project_id : Identifier of the project external_id_array : The external identifiers of the assets for which we want to add predictions model_name_array : In case you want to precise from which model the label originated json_response_array : The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" variables = { 'data' : { 'modelNameArray' : model_name_array , 'jsonResponseArray' : [ dumps ( elem ) for elem in json_response_array ]}, 'where' : { 'externalIdStrictlyIn' : external_id_array , 'project' : { 'id' : project_id }} } result = self . auth . client . execute ( GQL_CREATE_PREDICTIONS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\" Append a label to an asset Parameters ---------- json_response : Label is given here author_id : ID of the author of the label label_asset_external_id : External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id label_asset_id : Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id project_id : Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id label_type : Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} seconds_to_label : Time to create the label skipped : Describe if the label is skipped or not Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\" Update properties of a label Parameters ---------- label_id : Identifier of the label seconds_to_label : Time to create the label model_name : Name of the model json_response : The label is given here Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\" Create honeypot for an asset. Uses the given `json_response` to create a \"REVIEW\" label. This enables Kili to compute a `honeypotMark`, which measures the similarity between this label and other labels. Parameters ---------- json_response : The JSON response of the honeypot label of the asset asset_id : Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id : External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id : Identifier of the project Either provide asset_id or asset_external_id and project_id Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label ) append_to_labels ( self , json_response , author_id = None , label_asset_external_id = None , label_asset_id = None , label_type = 'DEFAULT' , project_id = None , seconds_to_label = 0 , skipped = False ) Append a label to an asset Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id None label_asset_id Optional[str] Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id None label_type str Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 skipped Optional[bool] Describe if the label is skipped or not False Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\" Append a label to an asset Parameters ---------- json_response : Label is given here author_id : ID of the author of the label label_asset_external_id : External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id label_asset_id : Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id project_id : Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id label_type : Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} seconds_to_label : Time to create the label skipped : Describe if the label is skipped or not Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) create_honeypot ( self , json_response , asset_external_id = None , asset_id = None , project_id = None ) Create honeypot for an asset. Uses the given json_response to create a \"REVIEW\" label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\" Create honeypot for an asset. Uses the given `json_response` to create a \"REVIEW\" label. This enables Kili to compute a `honeypotMark`, which measures the similarity between this label and other labels. Parameters ---------- json_response : The JSON response of the honeypot label of the asset asset_id : Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id : External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id : Identifier of the project Either provide asset_id or asset_external_id and project_id Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label ) create_predictions ( self , project_id , external_id_array , model_name_array , json_response_array ) Create predictions for specific assets For more detailed examples on how to create predictions, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\" Create predictions for specific assets For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Parameters ---------- project_id : Identifier of the project external_id_array : The external identifiers of the assets for which we want to add predictions model_name_array : In case you want to precise from which model the label originated json_response_array : The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" variables = { 'data' : { 'modelNameArray' : model_name_array , 'jsonResponseArray' : [ dumps ( elem ) for elem in json_response_array ]}, 'where' : { 'externalIdStrictlyIn' : external_id_array , 'project' : { 'id' : project_id }} } result = self . auth . client . execute ( GQL_CREATE_PREDICTIONS , variables ) return format_result ( 'data' , result , Label ) update_properties_in_label ( self , label_id , seconds_to_label = None , model_name = None , json_response = None ) Update properties of a label Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\" Update properties of a label Parameters ---------- label_id : Identifier of the label seconds_to_label : Time to create the label model_name : Name of the model json_response : The label is given here Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) Label subscription SubscriptionsLabel dataclass Set of Label subscriptions Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\" Set of Label subscriptions \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. See [the related recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/webhooks.ipynb) for more explanation on how to use it. Parameters ---------- project_id : Identifier of the project callback : This function takes as input the id of the asset and its content. Returns ------- return subscription client \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket label_created_or_updated ( self , project_id , callback ) Subscribe a callback to a project, which is executed when a label is created or updated. See the related recipe for more explanation on how to use it. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description return subscription client Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. See [the related recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/webhooks.ipynb) for more explanation on how to use it. Parameters ---------- project_id : Identifier of the project callback : This function takes as input the id of the asset and its content. Returns ------- return subscription client \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"Label"},{"location":"label/#label-module","text":"Label queries","title":"Label module"},{"location":"label/#kili.queries.label.__init__.QueriesLabel","text":"Set of Label queries Source code in kili/queries/label/__init__.py class QueriesLabel : \"\"\" Set of Label queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a label list or a label generator from a project based on a set of criteria Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gt : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lt : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. first : Maximum number of labels to return. honeypot_mark_gt : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lt : Returned labels should have a label whose honeypot is lower than this number. id_contains : Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skip : Number of labels to skip (they are ordered by their date of creation, first to last). skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the labels is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples ------- >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator ) def _query_labels ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_labels = gql_labels ( fragment_builder ( fields , LabelType )) result = self . auth . client . execute ( _gql_labels , payload ) return format_result ( 'data' , result , Label ) @staticmethod def parse_json_response_for_single_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a single-class classification task \"\"\" categories = QueriesLabel . parse_json_response_for_multi_classification ( json_response ) if len ( categories ) == 0 : return [] return categories [ 0 ] @staticmethod def parse_json_response_for_multi_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a multi-class classification task \"\"\" # pylint: disable=eval-used formatted_json_response = eval ( json_response ) if 'categories' not in formatted_json_response : return [] categories = formatted_json_response [ 'categories' ] return list ( map ( lambda category : category [ 'name' ], categories )) @staticmethod def parse_json_response ( json_response , interface_category ): \"\"\" Parameters ---------- json_response : A valid JSON response interface_category: A valid interface category Returns ------- dict the names of categories from a json_response \"\"\" if interface_category == 'SINGLECLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_single_classification ( json_response ) if interface_category == 'MULTICLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_multi_classification ( json_response ) return json_response # pylint: disable=dangerous-default-value @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]): # pylint: disable=line-too-long \"\"\" Get the labels of a project as a pandas DataFrame Parameters ---------- project_id : Identifier of the project fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. asset_fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. Returns ------- labels_df : pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT project = projects [ 0 ] if 'interfaceCategory' not in project : return pd . DataFrame () interface_category = project [ 'interfaceCategory' ] assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) if 'jsonResponse' in labels_df . columns : labels_df [ 'jsonResponse' ] = labels_df [ 'jsonResponse' ] . apply ( lambda json_response : QueriesLabel . parse_json_response ( json_response , interface_category )) return labels_df @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\" Get the number of labels for the given parameters Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gte : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lte : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" honeypot_mark_gte : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte : Returned labels should have a label whose honeypot is lower than this number. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. Returns ------- dict the number of labels with the parameters provided \"\"\" variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesLabel"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.count_labels","text":"Get the number of labels for the given parameters Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_gte Optional[str] Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_lte Optional[str] Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" None honeypot_mark_gte Optional[float] Returned labels should have a label whose honeypot is greater than this number. None honeypot_mark_lte Optional[float] Returned labels should have a label whose honeypot is lower than this number. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None Returns: Type Description int the number of labels with the parameters provided Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None ) -> int : # pylint: disable=line-too-long \"\"\" Get the number of labels for the given parameters Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gte : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lte : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" honeypot_mark_gte : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lte : Returned labels should have a label whose honeypot is lower than this number. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. Returns ------- dict the number of labels with the parameters provided \"\"\" variables = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , } } result = self . auth . client . execute ( GQL_LABELS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_labels()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.export_labels_as_df","text":"Get the labels of a project as a pandas DataFrame Parameters: Name Type Description Default project_id str Identifier of the project required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'createdAt', 'id', 'labelType', 'skipped'] asset_fields List[str] All the fields to request among the possible fields for the assets. See the documentation for all possible fields. ['externalId'] Returns: Type Description pandas DataFrame containing the labels. Source code in kili/queries/label/__init__.py @typechecked def export_labels_as_df ( self , project_id : str , fields : List [ str ] = [ 'author.email' , 'author.id' , 'createdAt' , 'id' , 'labelType' , 'skipped' ], asset_fields : List [ str ] = [ 'externalId' ]): # pylint: disable=line-too-long \"\"\" Get the labels of a project as a pandas DataFrame Parameters ---------- project_id : Identifier of the project fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. asset_fields : All the fields to request among the possible fields for the assets. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#asset) for all possible fields. Returns ------- labels_df : pandas DataFrame containing the labels. \"\"\" projects = QueriesProject ( self . auth ) . projects ( project_id ) assert len ( projects ) == 1 , NO_ACCESS_RIGHT project = projects [ 0 ] if 'interfaceCategory' not in project : return pd . DataFrame () interface_category = project [ 'interfaceCategory' ] assets = QueriesAsset ( self . auth ) . assets ( project_id = project_id , fields = asset_fields + [ 'labels.' + field for field in fields ]) labels = [ dict ( label , ** dict (( f 'asset_ { key } ' , asset [ key ]) for key in asset if key != 'labels' )) for asset in assets for label in asset [ 'labels' ]] labels_df = pd . DataFrame ( labels ) if 'jsonResponse' in labels_df . columns : labels_df [ 'jsonResponse' ] = labels_df [ 'jsonResponse' ] . apply ( lambda json_response : QueriesLabel . parse_json_response ( json_response , interface_category )) return labels_df","title":"export_labels_as_df()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.labels","text":"Gets a label list or a label generator from a project based on a set of criteria Parameters: Name Type Description Default asset_id Optional[str] Identifier of the asset. None asset_status_in Optional[List[str]] Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} None asset_external_id_in Optional[List[str]] Returned labels should have an external id that belongs to that list, if given. None author_in Optional[List[str]] Returned labels should have a label whose status belongs to that list, if given. None created_at Optional[str] Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None created_at_gt Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" required created_at_lt Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" required fields List[str] All the fields to request among the possible fields for the labels. See the documentation for all possible fields. ['author.email', 'author.id', 'id', 'jsonResponse', 'labelType', 'secondsToLabel', 'skipped'] first Optional[int] Maximum number of labels to return. None honeypot_mark_gt Returned labels should have a label whose honeypot is greater than this number. required honeypot_mark_lt Returned labels should have a label whose honeypot is lower than this number. required id_contains Optional[List[str]] Filters out labels not belonging to that list. If empty, no filtering is applied. None json_response_contains Optional[List[str]] Returned labels should have a substring of the jsonResponse that belongs to that list, if given. None label_id Optional[str] Identifier of the label. None project_id Optional[str] Identifier of the project. None skip int Number of labels to skip (they are ordered by their date of creation, first to last). 0 skipped Optional[bool] Returned labels should have a label which is skipped None type_in Optional[List[str]] Returned labels should have a label whose type belongs to that list, if given. None user_id Optional[str] Identifier of the user. None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the labels is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, else an error message. Source code in kili/queries/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def labels ( self , asset_id : Optional [ str ] = None , asset_status_in : Optional [ List [ str ]] = None , asset_external_id_in : Optional [ List [ str ]] = None , author_in : Optional [ List [ str ]] = None , created_at : Optional [ str ] = None , created_at_gte : Optional [ str ] = None , created_at_lte : Optional [ str ] = None , fields : List [ str ] = [ 'author.email' , 'author.id' , 'id' , 'jsonResponse' , 'labelType' , 'secondsToLabel' , 'skipped' ], first : Optional [ int ] = None , honeypot_mark_gte : Optional [ float ] = None , honeypot_mark_lte : Optional [ float ] = None , id_contains : Optional [ List [ str ]] = None , json_response_contains : Optional [ List [ str ]] = None , label_id : Optional [ str ] = None , project_id : Optional [ str ] = None , skip : int = 0 , skipped : Optional [ bool ] = None , type_in : Optional [ List [ str ]] = None , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False , ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a label list or a label generator from a project based on a set of criteria Parameters ---------- asset_id : Identifier of the asset. asset_status_in : Returned labels should have a status that belongs to that list, if given. Possible choices : {'TODO', 'ONGOING', 'LABELED', 'REVIEWED'} asset_external_id_in : Returned labels should have an external id that belongs to that list, if given. author_in : Returned labels should have a label whose status belongs to that list, if given. created_at : Returned labels should have a label whose creation date is equal to this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_gt : Returned labels should have a label whose creation date is greater than this date. Formatted string should have format : \"YYYY-MM-DD\" created_at_lt : Returned labels should have a label whose creation date is lower than this date. Formatted string should have format : \"YYYY-MM-DD\" fields : All the fields to request among the possible fields for the labels. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#label) for all possible fields. first : Maximum number of labels to return. honeypot_mark_gt : Returned labels should have a label whose honeypot is greater than this number. honeypot_mark_lt : Returned labels should have a label whose honeypot is lower than this number. id_contains : Filters out labels not belonging to that list. If empty, no filtering is applied. json_response_contains : Returned labels should have a substring of the jsonResponse that belongs to that list, if given. label_id : Identifier of the label. project_id : Identifier of the project. skip : Number of labels to skip (they are ordered by their date of creation, first to last). skipped : Returned labels should have a label which is skipped type_in : Returned labels should have a label whose type belongs to that list, if given. user_id : Identifier of the user. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the labels is returned. Returns ------- dict a result object which contains the query if it was successful, else an error message. Examples ------- >>> kili.labels(project_id=project_id, fields=['jsonResponse', 'labelOf.externalId']) # returns a list of all labels of a project and their assets external ID >>> kili.labels(project_id=project_id, fields=['jsonResponse'], as_generator=True) # returns a generator of all labels of a project \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k not in [ 'as_generator' , 'disable_tqdm' , 'fields' , 'first' , 'id_contains' , 'self' , 'skip' , ] } # using tqdm with a generator is messy, so it is always disabled disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : label_id , 'asset' : { 'id' : asset_id , 'externalIdIn' : asset_external_id_in , 'statusIn' : asset_status_in , }, 'project' : { 'id' : project_id , }, 'user' : { 'id' : user_id , }, 'createdAt' : created_at , 'createdAtGte' : created_at_gte , 'createdAtLte' : created_at_lte , 'authorIn' : author_in , 'honeypotMarkGte' : honeypot_mark_gte , 'honeypotMarkLte' : honeypot_mark_lte , 'idIn' : id_contains , 'jsonResponseContains' : json_response_contains , 'skipped' : skipped , 'typeIn' : type_in , }, } labels_generator = row_generator_from_paginated_calls ( skip , first , self . count_labels , count_args , self . _query_labels , payload_query , fields , disable_tqdm ) if as_generator : return labels_generator return list ( labels_generator )","title":"labels()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.parse_json_response","text":"Parameters: Name Type Description Default json_response A valid JSON response required interface_category A valid interface category required Returns: Type Description dict the names of categories from a json_response Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response ( json_response , interface_category ): \"\"\" Parameters ---------- json_response : A valid JSON response interface_category: A valid interface category Returns ------- dict the names of categories from a json_response \"\"\" if interface_category == 'SINGLECLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_single_classification ( json_response ) if interface_category == 'MULTICLASS_TEXT_CLASSIFICATION' : return QueriesLabel . parse_json_response_for_multi_classification ( json_response ) return json_response","title":"parse_json_response()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.parse_json_response_for_multi_classification","text":"Parameters: Name Type Description Default json_response A valid JSON response required Returns: Type Description dict the names of categories from a json_response, for a multi-class classification task Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response_for_multi_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a multi-class classification task \"\"\" # pylint: disable=eval-used formatted_json_response = eval ( json_response ) if 'categories' not in formatted_json_response : return [] categories = formatted_json_response [ 'categories' ] return list ( map ( lambda category : category [ 'name' ], categories ))","title":"parse_json_response_for_multi_classification()"},{"location":"label/#kili.queries.label.__init__.QueriesLabel.parse_json_response_for_single_classification","text":"Parameters: Name Type Description Default json_response A valid JSON response required Returns: Type Description dict the names of categories from a json_response, for a single-class classification task Source code in kili/queries/label/__init__.py @staticmethod def parse_json_response_for_single_classification ( json_response ): \"\"\" Parameters ---------- json_response : A valid JSON response Returns ------- dict the names of categories from a json_response, for a single-class classification task \"\"\" categories = QueriesLabel . parse_json_response_for_multi_classification ( json_response ) if len ( categories ) == 0 : return [] return categories [ 0 ] Label mutations","title":"parse_json_response_for_single_classification()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel","text":"Set of Label mutations Source code in kili/mutations/label/__init__.py class MutationsLabel : \"\"\" Set of Label mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\" Create predictions for specific assets For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Parameters ---------- project_id : Identifier of the project external_id_array : The external identifiers of the assets for which we want to add predictions model_name_array : In case you want to precise from which model the label originated json_response_array : The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" variables = { 'data' : { 'modelNameArray' : model_name_array , 'jsonResponseArray' : [ dumps ( elem ) for elem in json_response_array ]}, 'where' : { 'externalIdStrictlyIn' : external_id_array , 'project' : { 'id' : project_id }} } result = self . auth . client . execute ( GQL_CREATE_PREDICTIONS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\" Append a label to an asset Parameters ---------- json_response : Label is given here author_id : ID of the author of the label label_asset_external_id : External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id label_asset_id : Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id project_id : Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id label_type : Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} seconds_to_label : Time to create the label skipped : Describe if the label is skipped or not Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\" Update properties of a label Parameters ---------- label_id : Identifier of the label seconds_to_label : Time to create the label model_name : Name of the model json_response : The label is given here Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\" Create honeypot for an asset. Uses the given `json_response` to create a \"REVIEW\" label. This enables Kili to compute a `honeypotMark`, which measures the similarity between this label and other labels. Parameters ---------- json_response : The JSON response of the honeypot label of the asset asset_id : Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id : External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id : Identifier of the project Either provide asset_id or asset_external_id and project_id Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label )","title":"MutationsLabel"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.append_to_labels","text":"Append a label to an asset Parameters: Name Type Description Default json_response dict Label is given here required author_id Optional[str] ID of the author of the label None label_asset_external_id Optional[str] External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id None label_asset_id Optional[str] Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id None label_type str Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} 'DEFAULT' seconds_to_label Optional[int] Time to create the label 0 skipped Optional[bool] Describe if the label is skipped or not False Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_labels ( self , json_response : dict , author_id : Optional [ str ] = None , label_asset_external_id : Optional [ str ] = None , label_asset_id : Optional [ str ] = None , label_type : str = 'DEFAULT' , project_id : Optional [ str ] = None , seconds_to_label : Optional [ int ] = 0 , skipped : Optional [ bool ] = False ): \"\"\" Append a label to an asset Parameters ---------- json_response : Label is given here author_id : ID of the author of the label label_asset_external_id : External identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id label_asset_id : Identifier of the asset Either provide label_asset_id or label_asset_external_id and project_id project_id : Identifier of the project Either provide label_asset_id or label_asset_external_id and project_id label_type : Can be one of {'AUTOSAVE', 'DEFAULT', 'PREDICTION', 'REVIEW'} seconds_to_label : Time to create the label skipped : Describe if the label is skipped or not Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_labels(label_asset_id=asset_id, json_response={...}) \"\"\" if author_id is None : author_id = self . auth . user_id label_asset_id = infer_id_from_external_id ( self , label_asset_id , label_asset_external_id , project_id ) variables = { 'data' : { 'authorID' : author_id , 'jsonResponse' : dumps ( json_response ), 'labelType' : label_type , 'secondsToLabel' : seconds_to_label , 'skipped' : skipped }, 'where' : { 'id' : label_asset_id } } result = self . auth . client . execute ( GQL_APPEND_TO_LABELS , variables ) return format_result ( 'data' , result , Label )","title":"append_to_labels()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.create_honeypot","text":"Create honeypot for an asset. Uses the given json_response to create a \"REVIEW\" label. This enables Kili to compute a honeypotMark , which measures the similarity between this label and other labels. Parameters: Name Type Description Default json_response dict The JSON response of the honeypot label of the asset required asset_id Optional[str] Identifier of the asset Either provide asset_id or asset_external_id and project_id None asset_external_id Optional[str] External identifier of the asset Either provide asset_id or asset_external_id and project_id None project_id Optional[str] Identifier of the project Either provide asset_id or asset_external_id and project_id None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_honeypot ( self , json_response : dict , asset_external_id : Optional [ str ] = None , asset_id : Optional [ str ] = None , project_id : Optional [ str ] = None ): \"\"\" Create honeypot for an asset. Uses the given `json_response` to create a \"REVIEW\" label. This enables Kili to compute a `honeypotMark`, which measures the similarity between this label and other labels. Parameters ---------- json_response : The JSON response of the honeypot label of the asset asset_id : Identifier of the asset Either provide asset_id or asset_external_id and project_id asset_external_id : External identifier of the asset Either provide asset_id or asset_external_id and project_id project_id : Identifier of the project Either provide asset_id or asset_external_id and project_id Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" asset_id = infer_id_from_external_id ( self , asset_id , asset_external_id , project_id ) variables = { 'data' : { 'jsonResponse' : dumps ( json_response )}, 'where' : { 'id' : asset_id } } result = self . auth . client . execute ( GQL_CREATE_HONEYPOT , variables ) return format_result ( 'data' , result , Label )","title":"create_honeypot()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.create_predictions","text":"Create predictions for specific assets For more detailed examples on how to create predictions, see the recipe . Parameters: Name Type Description Default project_id str Identifier of the project required external_id_array List[str] The external identifiers of the assets for which we want to add predictions required model_name_array List[str] In case you want to precise from which model the label originated required json_response_array List[dict] The predictions are given here. For examples, see the recipe . required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_predictions ( self , project_id : str , external_id_array : List [ str ], model_name_array : List [ str ], json_response_array : List [ dict ]): # pylint: disable=line-too-long \"\"\" Create predictions for specific assets For more detailed examples on how to create predictions, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Parameters ---------- project_id : Identifier of the project external_id_array : The external identifiers of the assets for which we want to add predictions model_name_array : In case you want to precise from which model the label originated json_response_array : The predictions are given here. For examples, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/import_predictions.ipynb). Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" assert len ( external_id_array ) == len ( json_response_array ), \"IDs list and predictions list should have the same length\" assert len ( external_id_array ) == len ( model_name_array ), \"IDs list and model names list should have the same length\" variables = { 'data' : { 'modelNameArray' : model_name_array , 'jsonResponseArray' : [ dumps ( elem ) for elem in json_response_array ]}, 'where' : { 'externalIdStrictlyIn' : external_id_array , 'project' : { 'id' : project_id }} } result = self . auth . client . execute ( GQL_CREATE_PREDICTIONS , variables ) return format_result ( 'data' , result , Label )","title":"create_predictions()"},{"location":"label/#kili.mutations.label.__init__.MutationsLabel.update_properties_in_label","text":"Update properties of a label Parameters: Name Type Description Default label_id str Identifier of the label required seconds_to_label Optional[int] Time to create the label None model_name Optional[str] Name of the model None json_response Optional[dict] The label is given here None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/label/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_label ( self , label_id : str , seconds_to_label : Optional [ int ] = None , model_name : Optional [ str ] = None , json_response : Optional [ dict ] = None ): \"\"\" Update properties of a label Parameters ---------- label_id : Identifier of the label seconds_to_label : Time to create the label model_name : Name of the model json_response : The label is given here Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_label(label_id=label_id, json_response={...}) \"\"\" formatted_json_response = None if json_response is None else dumps ( json_response ) variables = { 'labelID' : label_id , 'secondsToLabel' : seconds_to_label , 'modelName' : model_name , 'jsonResponse' : formatted_json_response } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_LABEL , variables ) return format_result ( 'data' , result , Label ) Label subscription","title":"update_properties_in_label()"},{"location":"label/#kili.subscriptions.label.__init__.SubscriptionsLabel","text":"Set of Label subscriptions Source code in kili/subscriptions/label/__init__.py @dataclass class SubscriptionsLabel : \"\"\" Set of Label subscriptions \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. See [the related recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/webhooks.ipynb) for more explanation on how to use it. Parameters ---------- project_id : Identifier of the project callback : This function takes as input the id of the asset and its content. Returns ------- return subscription client \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"SubscriptionsLabel"},{"location":"label/#kili.subscriptions.label.__init__.SubscriptionsLabel.label_created_or_updated","text":"Subscribe a callback to a project, which is executed when a label is created or updated. See the related recipe for more explanation on how to use it. Parameters: Name Type Description Default project_id str Identifier of the project required callback Callable[[str, str], NoneType] This function takes as input the id of the asset and its content. required Returns: Type Description return subscription client Source code in kili/subscriptions/label/__init__.py @typechecked def label_created_or_updated ( self , project_id : str , callback : Callable [[ str , str ], None ]): # pylint: disable=line-too-long \"\"\" Subscribe a callback to a project, which is executed when a label is created or updated. See [the related recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/webhooks.ipynb) for more explanation on how to use it. Parameters ---------- project_id : Identifier of the project callback : This function takes as input the id of the asset and its content. Returns ------- return subscription client \"\"\" ws_endpoint = self . auth . client . endpoint . replace ( 'http' , 'ws' ) websocket = SubscriptionGraphQLClient ( ws_endpoint ) headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' } authorization = f ' { self . auth . client . token } ' headers [ 'Authorization' ] = authorization variables = { 'projectID' : project_id } websocket . subscribe ( GQL_LABEL_CREATED_OR_UPDATED , variables = variables , callback = callback , headers = headers , authorization = authorization ) return websocket","title":"label_created_or_updated()"},{"location":"lock/","text":"Lock module Lock queries QueriesLock Set of Lock queries Source code in kili/queries/lock/__init__.py class QueriesLock : \"\"\" Set of Lock queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def locks ( self , lock_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'lockType' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of locks respecting a set of criteria Parameters ---------- lock_id : The id of the lock to request. If None, all locks are returned fields : All the fields to request among the possible fields for the locks. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#locks) for all possible fields. first : Maximum number of locks to return. skip : Number of skipped locks (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = {} payload_query = { 'where' : { 'id' : lock_id } } disable_tqdm = disable_tqdm or as_generator or lock_id is not None locks_generator = row_generator_from_paginated_calls ( skip , first , self . count_locks , count_args , self . _query_locks , payload_query , fields , disable_tqdm ) if as_generator : return locks_generator return list ( locks_generator ) def _query_locks ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_locks = gql_locks ( fragment_builder ( fields , Lock )) result = self . auth . client . execute ( _gql_locks , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_locks ( self : any ) -> int : \"\"\" Get the number of locks Parameters ---------- Returns ------- dict the number of locks \"\"\" variables = { 'where' : { 'id' : None } } result = self . auth . client . execute ( GQL_LOCKS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_locks ( self ) Get the number of locks Returns: Type Description int the number of locks Source code in kili/queries/lock/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_locks ( self : any ) -> int : \"\"\" Get the number of locks Parameters ---------- Returns ------- dict the number of locks \"\"\" variables = { 'where' : { 'id' : None } } result = self . auth . client . execute ( GQL_LOCKS_COUNT , variables ) count = format_result ( 'data' , result ) return count locks ( self , lock_id = None , fields = [ 'id' , 'lockType' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Gets a generator or a list of locks respecting a set of criteria Parameters: Name Type Description Default lock_id Optional[str] The id of the lock to request. If None, all locks are returned None fields List[str] All the fields to request among the possible fields for the locks. See the documentation for all possible fields. ['id', 'lockType'] first int Maximum number of locks to return. 100 skip int Number of skipped locks (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/lock/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def locks ( self , lock_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'lockType' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of locks respecting a set of criteria Parameters ---------- lock_id : The id of the lock to request. If None, all locks are returned fields : All the fields to request among the possible fields for the locks. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#locks) for all possible fields. first : Maximum number of locks to return. skip : Number of skipped locks (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = {} payload_query = { 'where' : { 'id' : lock_id } } disable_tqdm = disable_tqdm or as_generator or lock_id is not None locks_generator = row_generator_from_paginated_calls ( skip , first , self . count_locks , count_args , self . _query_locks , payload_query , fields , disable_tqdm ) if as_generator : return locks_generator return list ( locks_generator )","title":"Lock"},{"location":"lock/#lock-module","text":"Lock queries","title":"Lock module"},{"location":"lock/#kili.queries.lock.__init__.QueriesLock","text":"Set of Lock queries Source code in kili/queries/lock/__init__.py class QueriesLock : \"\"\" Set of Lock queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def locks ( self , lock_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'lockType' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of locks respecting a set of criteria Parameters ---------- lock_id : The id of the lock to request. If None, all locks are returned fields : All the fields to request among the possible fields for the locks. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#locks) for all possible fields. first : Maximum number of locks to return. skip : Number of skipped locks (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = {} payload_query = { 'where' : { 'id' : lock_id } } disable_tqdm = disable_tqdm or as_generator or lock_id is not None locks_generator = row_generator_from_paginated_calls ( skip , first , self . count_locks , count_args , self . _query_locks , payload_query , fields , disable_tqdm ) if as_generator : return locks_generator return list ( locks_generator ) def _query_locks ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_locks = gql_locks ( fragment_builder ( fields , Lock )) result = self . auth . client . execute ( _gql_locks , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_locks ( self : any ) -> int : \"\"\" Get the number of locks Parameters ---------- Returns ------- dict the number of locks \"\"\" variables = { 'where' : { 'id' : None } } result = self . auth . client . execute ( GQL_LOCKS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesLock"},{"location":"lock/#kili.queries.lock.__init__.QueriesLock.count_locks","text":"Get the number of locks Returns: Type Description int the number of locks Source code in kili/queries/lock/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_locks ( self : any ) -> int : \"\"\" Get the number of locks Parameters ---------- Returns ------- dict the number of locks \"\"\" variables = { 'where' : { 'id' : None } } result = self . auth . client . execute ( GQL_LOCKS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_locks()"},{"location":"lock/#kili.queries.lock.__init__.QueriesLock.locks","text":"Gets a generator or a list of locks respecting a set of criteria Parameters: Name Type Description Default lock_id Optional[str] The id of the lock to request. If None, all locks are returned None fields List[str] All the fields to request among the possible fields for the locks. See the documentation for all possible fields. ['id', 'lockType'] first int Maximum number of locks to return. 100 skip int Number of skipped locks (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the API key is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/lock/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def locks ( self , lock_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'lockType' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of locks respecting a set of criteria Parameters ---------- lock_id : The id of the lock to request. If None, all locks are returned fields : All the fields to request among the possible fields for the locks. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#locks) for all possible fields. first : Maximum number of locks to return. skip : Number of skipped locks (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the API key is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = {} payload_query = { 'where' : { 'id' : lock_id } } disable_tqdm = disable_tqdm or as_generator or lock_id is not None locks_generator = row_generator_from_paginated_calls ( skip , first , self . count_locks , count_args , self . _query_locks , payload_query , fields , disable_tqdm ) if as_generator : return locks_generator return list ( locks_generator )","title":"locks()"},{"location":"notification/","text":"Notification module Notification queries QueriesNotification Set of Notification queries Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\" Set of Notification queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of notifications respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the notifications See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#notification) for all possible fields. first : Number of notifications to query has_been_seen : If the notifications returned should have been seen. notification_id : If given, will return the notification which has this id skip : Number of notifications to skip (they are ordered by their date of creation, first to last). user_id : If given, returns the notifications of a specific user disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the notifications is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\" Count the number of notifications Parameters ---------- has_been_seen : Filter on notifications that have been seen. user_id : Filter on the notifications of a specific user Returns ------- dict the number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_notifications ( self , has_been_seen = None , user_id = None ) Count the number of notifications Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int the number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\" Count the number of notifications Parameters ---------- has_been_seen : Filter on notifications that have been seen. user_id : Filter on the notifications of a specific user Returns ------- dict the number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count notifications ( self , fields = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first = 100 , has_been_seen = None , notification_id = None , skip = 0 , user_id = None , disable_tqdm = False , as_generator = False ) Gets a generator or a list of notifications respecting a set of criteria Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first int Number of notifications to query 100 has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of notifications respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the notifications See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#notification) for all possible fields. first : Number of notifications to query has_been_seen : If the notifications returned should have been seen. notification_id : If given, will return the notification which has this id skip : Number of notifications to skip (they are ordered by their date of creation, first to last). user_id : If given, returns the notifications of a specific user disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the notifications is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) Notification mutations MutationsNotification Set of Notification mutations Source code in kili/mutations/notification/__init__.py class MutationsNotification : \"\"\" Set of Notification mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_notification ( self , message : str , status : str , url : str , user_id : str ): \"\"\" Create a notification This method is currently only active for Kili administrators. Parameters ---------- message : status : url : user_id : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'message' : message , 'status' : status , 'url' : url , 'userID' : user_id } } result = self . auth . client . execute ( GQL_CREATE_NOTIFICATION , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_notification ( self , notification_id : str , has_been_seen : bool , status : str , url : str ): \"\"\" Modify a notification This method is currently only active for Kili administrators. Parameters ---------- notification_id : hasBeenSeen: status : url : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'id' : notification_id , 'hasBeenSeen' : has_been_seen , 'status' : status , 'url' : url } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_NOTIFICATION , variables ) return format_result ( 'data' , result ) create_notification ( self , message , status , url , user_id ) Create a notification This method is currently only active for Kili administrators. Parameters: Name Type Description Default message str required status str required url str required user_id str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/notification/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_notification ( self , message : str , status : str , url : str , user_id : str ): \"\"\" Create a notification This method is currently only active for Kili administrators. Parameters ---------- message : status : url : user_id : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'message' : message , 'status' : status , 'url' : url , 'userID' : user_id } } result = self . auth . client . execute ( GQL_CREATE_NOTIFICATION , variables ) return format_result ( 'data' , result ) update_properties_in_notification ( self , notification_id , has_been_seen , status , url ) Modify a notification This method is currently only active for Kili administrators. Parameters: Name Type Description Default notification_id str required hasBeenSeen required status str required url str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/notification/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_notification ( self , notification_id : str , has_been_seen : bool , status : str , url : str ): \"\"\" Modify a notification This method is currently only active for Kili administrators. Parameters ---------- notification_id : hasBeenSeen: status : url : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'id' : notification_id , 'hasBeenSeen' : has_been_seen , 'status' : status , 'url' : url } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_NOTIFICATION , variables ) return format_result ( 'data' , result )","title":"Notification"},{"location":"notification/#notification-module","text":"Notification queries","title":"Notification module"},{"location":"notification/#kili.queries.notification.__init__.QueriesNotification","text":"Set of Notification queries Source code in kili/queries/notification/__init__.py class QueriesNotification : \"\"\" Set of Notification queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of notifications respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the notifications See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#notification) for all possible fields. first : Number of notifications to query has_been_seen : If the notifications returned should have been seen. notification_id : If given, will return the notification which has this id skip : Number of notifications to skip (they are ordered by their date of creation, first to last). user_id : If given, returns the notifications of a specific user disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the notifications is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) def _query_notifications ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_notifications = gql_notifications ( fragment_builder ( fields , Notification )) result = self . auth . client . execute ( _gql_notifications , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\" Count the number of notifications Parameters ---------- has_been_seen : Filter on notifications that have been seen. user_id : Filter on the notifications of a specific user Returns ------- dict the number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesNotification"},{"location":"notification/#kili.queries.notification.__init__.QueriesNotification.count_notifications","text":"Count the number of notifications Parameters: Name Type Description Default has_been_seen Optional[bool] Filter on notifications that have been seen. None user_id Optional[str] Filter on the notifications of a specific user None Returns: Type Description int the number of notifications with the parameters provided Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_notifications ( self , has_been_seen : Optional [ bool ] = None , user_id : Optional [ str ] = None ) -> int : \"\"\" Count the number of notifications Parameters ---------- has_been_seen : Filter on notifications that have been seen. user_id : Filter on the notifications of a specific user Returns ------- dict the number of notifications with the parameters provided \"\"\" variables = { 'where' : { 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } result = self . auth . client . execute ( GQL_NOTIFICATIONS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_notifications()"},{"location":"notification/#kili.queries.notification.__init__.QueriesNotification.notifications","text":"Gets a generator or a list of notifications respecting a set of criteria Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the notifications See the documentation for all possible fields. ['createdAt', 'hasBeenSeen', 'id', 'message', 'status', 'userID'] first int Number of notifications to query 100 has_been_seen Optional[bool] If the notifications returned should have been seen. None notification_id Optional[str] If given, will return the notification which has this id None skip int Number of notifications to skip (they are ordered by their date of creation, first to last). 0 user_id Optional[str] If given, returns the notifications of a specific user None disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the notifications is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] Source code in kili/queries/notification/__init__.py @Compatible ([ 'v2' ]) @typechecked def notifications ( self , fields : List [ str ] = [ 'createdAt' , 'hasBeenSeen' , 'id' , 'message' , 'status' , 'userID' ], first : int = 100 , has_been_seen : Optional [ bool ] = None , notification_id : Optional [ str ] = None , skip : int = 0 , user_id : Optional [ str ] = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of notifications respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the notifications See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#notification) for all possible fields. first : Number of notifications to query has_been_seen : If the notifications returned should have been seen. notification_id : If given, will return the notification which has this id skip : Number of notifications to skip (they are ordered by their date of creation, first to last). user_id : If given, returns the notifications of a specific user disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the notifications is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"has_been_seen\" : has_been_seen , \"user_id\" : user_id } disable_tqdm = disable_tqdm or as_generator or notification_id is not None payload_query = { 'where' : { 'id' : notification_id , 'user' : { 'id' : user_id , }, 'hasBeenSeen' : has_been_seen , }, } notifications_generator = row_generator_from_paginated_calls ( skip , first , self . count_notifications , count_args , self . _query_notifications , payload_query , fields , disable_tqdm ) if as_generator : return notifications_generator return list ( notifications_generator ) Notification mutations","title":"notifications()"},{"location":"notification/#kili.mutations.notification.__init__.MutationsNotification","text":"Set of Notification mutations Source code in kili/mutations/notification/__init__.py class MutationsNotification : \"\"\" Set of Notification mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_notification ( self , message : str , status : str , url : str , user_id : str ): \"\"\" Create a notification This method is currently only active for Kili administrators. Parameters ---------- message : status : url : user_id : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'message' : message , 'status' : status , 'url' : url , 'userID' : user_id } } result = self . auth . client . execute ( GQL_CREATE_NOTIFICATION , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_notification ( self , notification_id : str , has_been_seen : bool , status : str , url : str ): \"\"\" Modify a notification This method is currently only active for Kili administrators. Parameters ---------- notification_id : hasBeenSeen: status : url : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'id' : notification_id , 'hasBeenSeen' : has_been_seen , 'status' : status , 'url' : url } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_NOTIFICATION , variables ) return format_result ( 'data' , result )","title":"MutationsNotification"},{"location":"notification/#kili.mutations.notification.__init__.MutationsNotification.create_notification","text":"Create a notification This method is currently only active for Kili administrators. Parameters: Name Type Description Default message str required status str required url str required user_id str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/notification/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_notification ( self , message : str , status : str , url : str , user_id : str ): \"\"\" Create a notification This method is currently only active for Kili administrators. Parameters ---------- message : status : url : user_id : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'message' : message , 'status' : status , 'url' : url , 'userID' : user_id } } result = self . auth . client . execute ( GQL_CREATE_NOTIFICATION , variables ) return format_result ( 'data' , result )","title":"create_notification()"},{"location":"notification/#kili.mutations.notification.__init__.MutationsNotification.update_properties_in_notification","text":"Modify a notification This method is currently only active for Kili administrators. Parameters: Name Type Description Default notification_id str required hasBeenSeen required status str required url str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/notification/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_notification ( self , notification_id : str , has_been_seen : bool , status : str , url : str ): \"\"\" Modify a notification This method is currently only active for Kili administrators. Parameters ---------- notification_id : hasBeenSeen: status : url : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'id' : notification_id , 'hasBeenSeen' : has_been_seen , 'status' : status , 'url' : url } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_NOTIFICATION , variables ) return format_result ( 'data' , result )","title":"update_properties_in_notification()"},{"location":"organization/","text":"Organization module Organization queries QueriesOrganization Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters ---------- email : organization_id : fields : All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first : Maximum number of organizations to return skip : Number of skipped organizations (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the organizations is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\" Count organizations that match a set of criteria Parameters ---------- email : organization_id : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\" Get organization metrics Parameters ---------- organization_id : start_date : end_date : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result ) count_organizations ( self , email = None , organization_id = None ) Count organizations that match a set of criteria Parameters: Name Type Description Default email Optional[str] None organization_id Optional[str] None Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\" Count organizations that match a set of criteria Parameters ---------- email : organization_id : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) organization_metrics ( self , organization_id = None , start_date = datetime . datetime ( 2022 , 4 , 26 , 13 , 23 , 3 , 689791 ), end_date = datetime . datetime ( 2022 , 4 , 26 , 13 , 23 , 3 , 689793 )) Get organization metrics Parameters: Name Type Description Default organization_id str None start_date datetime datetime.datetime(2022, 4, 26, 13, 23, 3, 689791) end_date datetime datetime.datetime(2022, 4, 26, 13, 23, 3, 689793) Returns: Type Description dict a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\" Get organization metrics Parameters ---------- organization_id : start_date : end_date : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result ) organizations ( self , email = None , organization_id = None , fields = [ 'id' , 'name' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters: Name Type Description Default email Optional[str] None organization_id Optional[str] None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first int Maximum number of organizations to return 100 skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters ---------- email : organization_id : fields : All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first : Maximum number of organizations to return skip : Number of skipped organizations (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the organizations is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) Organization mutations MutationsOrganization Set of Organization mutations Source code in kili/mutations/organization/__init__.py class MutationsOrganization : \"\"\" Set of Organization mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_organization ( self , name : str , address : str , zip_code : str , city : str , country : str ): \"\"\" Create an organization Each user must be linked to an organization Parameters ---------- name : address : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'name' : name , 'address' : address , 'zipCode' : zip_code , 'city' : city , 'country' : country } } result = self . auth . client . execute ( GQL_CREATE_ORGANIZATION , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_organization ( self , organization_id : str , name : Optional [ str ] = None , address : Optional [ str ] = None , zip_code : Optional [ str ] = None , city : Optional [ str ] = None , country : Optional [ str ] = None , license : Optional [ dict ] = None ): # pylint: disable=redefined-builtin \"\"\" Modify an organization Parameters ---------- organization_id : name : address : license : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" license_str = None if not license else json . dumps ( license ) variables = { 'id' : organization_id } if name is not None : variables [ 'name' ] = name if address is not None : variables [ 'address' ] = address if license_str is not None : variables [ 'license' ] = license_str if zip_code is not None : variables [ 'zipCode' ] = zip_code if city is not None : variables [ 'city' ] = city if country is not None : variables [ 'country' ] = country result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ORGANIZATION , variables ) return format_result ( 'data' , result ) create_organization ( self , name , address , zip_code , city , country ) Create an organization Each user must be linked to an organization Parameters: Name Type Description Default name str required address str required zip_code str required city str required country str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_organization ( self , name : str , address : str , zip_code : str , city : str , country : str ): \"\"\" Create an organization Each user must be linked to an organization Parameters ---------- name : address : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'name' : name , 'address' : address , 'zipCode' : zip_code , 'city' : city , 'country' : country } } result = self . auth . client . execute ( GQL_CREATE_ORGANIZATION , variables ) return format_result ( 'data' , result ) update_properties_in_organization ( self , organization_id , name = None , address = None , zip_code = None , city = None , country = None , license = None ) Modify an organization Parameters: Name Type Description Default organization_id str required name Optional[str] None address Optional[str] None license Optional[dict] None zip_code Optional[str] None city Optional[str] None country Optional[str] None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_organization ( self , organization_id : str , name : Optional [ str ] = None , address : Optional [ str ] = None , zip_code : Optional [ str ] = None , city : Optional [ str ] = None , country : Optional [ str ] = None , license : Optional [ dict ] = None ): # pylint: disable=redefined-builtin \"\"\" Modify an organization Parameters ---------- organization_id : name : address : license : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" license_str = None if not license else json . dumps ( license ) variables = { 'id' : organization_id } if name is not None : variables [ 'name' ] = name if address is not None : variables [ 'address' ] = address if license_str is not None : variables [ 'license' ] = license_str if zip_code is not None : variables [ 'zipCode' ] = zip_code if city is not None : variables [ 'city' ] = city if country is not None : variables [ 'country' ] = country result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ORGANIZATION , variables ) return format_result ( 'data' , result )","title":"Organization"},{"location":"organization/#organization-module","text":"Organization queries","title":"Organization module"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization","text":"Set of Organization queries Source code in kili/queries/organization/__init__.py class QueriesOrganization : \"\"\" Set of Organization queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters ---------- email : organization_id : fields : All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first : Maximum number of organizations to return skip : Number of skipped organizations (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the organizations is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) def _query_organizations ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_organizations = gql_organizations ( fragment_builder ( fields , Organization )) result = self . auth . client . execute ( _gql_organizations , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\" Count organizations that match a set of criteria Parameters ---------- email : organization_id : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\" Get organization metrics Parameters ---------- organization_id : start_date : end_date : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result )","title":"QueriesOrganization"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.count_organizations","text":"Count organizations that match a set of criteria Parameters: Name Type Description Default email Optional[str] None organization_id Optional[str] None Returns: Type Description int a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None ) -> int : \"\"\" Count organizations that match a set of criteria Parameters ---------- email : organization_id : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } result = self . auth . client . execute ( GQL_ORGANIZATIONS_COUNT , variables ) return format_result ( 'data' , result )","title":"count_organizations()"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.organization_metrics","text":"Get organization metrics Parameters: Name Type Description Default organization_id str None start_date datetime datetime.datetime(2022, 4, 26, 13, 23, 3, 689791) end_date datetime datetime.datetime(2022, 4, 26, 13, 23, 3, 689793) Returns: Type Description dict a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v2' ]) @typechecked def organization_metrics ( self , organization_id : str = None , start_date : datetime = datetime . now (), end_date : datetime = datetime . now ()): \"\"\" Get organization metrics Parameters ---------- organization_id : start_date : end_date : Returns ------- dict a result object which contains the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'organizationId' : organization_id , 'startDate' : start_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , 'endDate' : end_date . isoformat ( sep = 'T' , timespec = 'milliseconds' ) + 'Z' , } } result = self . auth . client . execute ( GQL_ORGANIZATION_METRICS , variables ) return format_result ( 'data' , result )","title":"organization_metrics()"},{"location":"organization/#kili.queries.organization.__init__.QueriesOrganization.organizations","text":"Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters: Name Type Description Default email Optional[str] None organization_id Optional[str] None fields List[str] All the fields to request among the possible fields for the organizations. See the documentation for all possible fields. ['id', 'name'] first int Maximum number of organizations to return 100 skip int Number of skipped organizations (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the organizations is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def organizations ( self , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'id' , 'name' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of organizations that match a set of criteria Returns all organizations: with a given organization id containing a user with a given email Parameters ---------- email : organization_id : fields : All the fields to request among the possible fields for the organizations. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#organization) for all possible fields. first : Maximum number of organizations to return skip : Number of skipped organizations (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the organizations is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- >>> kili.organizations(organization_id=organization_id, fields=['users.email']) [{'users': [{'email': 'john@doe.com'}]}] \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : organization_id , 'user' : { 'email' : email , } } } organizations_generator = row_generator_from_paginated_calls ( skip , first , self . count_organizations , count_args , self . _query_organizations , payload_query , fields , disable_tqdm ) if as_generator : return organizations_generator return list ( organizations_generator ) Organization mutations","title":"organizations()"},{"location":"organization/#kili.mutations.organization.__init__.MutationsOrganization","text":"Set of Organization mutations Source code in kili/mutations/organization/__init__.py class MutationsOrganization : \"\"\" Set of Organization mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_organization ( self , name : str , address : str , zip_code : str , city : str , country : str ): \"\"\" Create an organization Each user must be linked to an organization Parameters ---------- name : address : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'name' : name , 'address' : address , 'zipCode' : zip_code , 'city' : city , 'country' : country } } result = self . auth . client . execute ( GQL_CREATE_ORGANIZATION , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_organization ( self , organization_id : str , name : Optional [ str ] = None , address : Optional [ str ] = None , zip_code : Optional [ str ] = None , city : Optional [ str ] = None , country : Optional [ str ] = None , license : Optional [ dict ] = None ): # pylint: disable=redefined-builtin \"\"\" Modify an organization Parameters ---------- organization_id : name : address : license : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" license_str = None if not license else json . dumps ( license ) variables = { 'id' : organization_id } if name is not None : variables [ 'name' ] = name if address is not None : variables [ 'address' ] = address if license_str is not None : variables [ 'license' ] = license_str if zip_code is not None : variables [ 'zipCode' ] = zip_code if city is not None : variables [ 'city' ] = city if country is not None : variables [ 'country' ] = country result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ORGANIZATION , variables ) return format_result ( 'data' , result )","title":"MutationsOrganization"},{"location":"organization/#kili.mutations.organization.__init__.MutationsOrganization.create_organization","text":"Create an organization Each user must be linked to an organization Parameters: Name Type Description Default name str required address str required zip_code str required city str required country str required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_organization ( self , name : str , address : str , zip_code : str , city : str , country : str ): \"\"\" Create an organization Each user must be linked to an organization Parameters ---------- name : address : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'name' : name , 'address' : address , 'zipCode' : zip_code , 'city' : city , 'country' : country } } result = self . auth . client . execute ( GQL_CREATE_ORGANIZATION , variables ) return format_result ( 'data' , result )","title":"create_organization()"},{"location":"organization/#kili.mutations.organization.__init__.MutationsOrganization.update_properties_in_organization","text":"Modify an organization Parameters: Name Type Description Default organization_id str required name Optional[str] None address Optional[str] None license Optional[dict] None zip_code Optional[str] None city Optional[str] None country Optional[str] None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/organization/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_organization ( self , organization_id : str , name : Optional [ str ] = None , address : Optional [ str ] = None , zip_code : Optional [ str ] = None , city : Optional [ str ] = None , country : Optional [ str ] = None , license : Optional [ dict ] = None ): # pylint: disable=redefined-builtin \"\"\" Modify an organization Parameters ---------- organization_id : name : address : license : zip_code : city : country : Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" license_str = None if not license else json . dumps ( license ) variables = { 'id' : organization_id } if name is not None : variables [ 'name' ] = name if address is not None : variables [ 'address' ] = address if license_str is not None : variables [ 'license' ] = license_str if zip_code is not None : variables [ 'zipCode' ] = zip_code if city is not None : variables [ 'city' ] = city if country is not None : variables [ 'country' ] = country result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ORGANIZATION , variables ) return format_result ( 'data' , result )","title":"update_properties_in_organization()"},{"location":"project/","text":"Project module Project queries QueriesProject Set of Project queries Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\" Set of Project queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'interfaceCategory' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of projects that match a set of criteria Parameters ---------- project_id : Select a specific project through its project_id. search_query : Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" skip : Number of projects to skip (they are ordered by their creation). fields : All the fields to request among the possible fields for the projects. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#project) for all possible fields. first : Maximum number of projects to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the projects is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. Examples ------- >>> # List all my projects >>> kili.projects() \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Parameters ---------- project_id : Select a specific project through its project_id search_query : Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None ) Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id None search_query Optional[str] Returned projects have a title or a description that matches this string. None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None Returns: Type Description int a positive integer corresponding to the number of results of the query if it was successful, or an error message else. Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Parameters ---------- project_id : Select a specific project through its project_id search_query : Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count projects ( self , project_id = None , search_query = None , should_relaunch_kpi_computation = None , updated_at_gte = None , updated_at_lte = None , skip = 0 , fields = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'interfaceCategory' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first = 100 , disable_tqdm = False , as_generator = False ) Get a generator or a list of projects that match a set of criteria Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this string. None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'interfaceCategory', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first int Maximum number of projects to return. 100 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the projects is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'interfaceCategory' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of projects that match a set of criteria Parameters ---------- project_id : Select a specific project through its project_id. search_query : Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" skip : Number of projects to skip (they are ordered by their creation). fields : All the fields to request among the possible fields for the projects. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#project) for all possible fields. first : Maximum number of projects to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the projects is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. Examples ------- >>> # List all my projects >>> kili.projects() \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) Project mutations MutationsProject Set of Project mutations Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\" Set of Project mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\" Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters ---------- project_id : Identifier of the project user_email : The email of the user. This email is used as the unique identifier of the user. role : One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , interface_category : str = 'IV2' , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\" Update properties of a project Parameters ---------- project_id : Identifier of the project consensus_mark : Should be between 0 and 1 consensus_tot_coverage : Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : honeypot_mark : Should be between 0 and 1 instructions : interface_category : Always use 'IV2' input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface : The json parameters of the project, see Edit your interface. min_consensus_size : Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets : Defaults to 0 number_of_assets_with_empty_labels : Defaults to 0 number_of_remaining_assets : Defaults to 0 number_of_reviewed_assets : Defaults to 0 review_coverage : Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings title : Title of the project use_honeypot : Activate / Deactivate the use of honeypot in the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'interfaceCategory' : interface_category , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\" Create a project For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/create_project.ipynb). Parameters ---------- input_type : str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: dict The json parameters of the project, see Edit your interface. title : str description : project_type: Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. Warning: This action is permanent and irreversible. Parameters ---------- project_id : Identifier of the project Returns ------- dict The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\" Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters ---------- role_id : Role identifier of the user. E.g. : 'to-be-deactivated' project_id : Identifier of the project user_id : The email or identifier of the user with updated role role : The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\" Delete users by their role_id Parameters ---------- role_id : Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Parameters ---------- project_user_id : str consensus_mark : Should be between 0 and 1. honeypot_mark : Should be between 0 and 1. number_of_labeled_assets : Number of assets the user labeled in the project. starred : Whether to star the project in the project list. total_duration : Total time the user spent in the project. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) @Compatible () @typechecked def force_project_kpis ( self , project_id : str ) -> None : \"\"\" Compute KPIs for a project Parameters ---------- project_id : Identifier of the project Returns ------- None \"\"\" _ = QueriesAsset ( self . auth ) . assets ( project_id = project_id ) _ = QueriesProject ( self . auth ) . projects ( project_id = project_id ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\" Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete project permanently. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result ) append_to_roles ( self , project_id , user_email , role = 'LABELER' ) Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\" Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters ---------- project_id : Identifier of the project user_email : The email of the user. This email is used as the unique identifier of the user. role : One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) create_project ( self , input_type , json_interface , title , description = '' , project_type = None ) Create a project For more detailed examples on how to create projects, see the recipe . Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str required description str '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\" Create a project For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/create_project.ipynb). Parameters ---------- input_type : str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: dict The json parameters of the project, see Edit your interface. title : str description : project_type: Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) delete_from_roles ( self , role_id ) Delete users by their role_id Parameters: Name Type Description Default role_id str required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\" Delete users by their role_id Parameters ---------- role_id : Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) delete_project ( self , project_id ) Delete project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete project permanently. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result ) force_project_kpis ( self , project_id ) Compute KPIs for a project Parameters: Name Type Description Default project_id str Identifier of the project required Source code in kili/mutations/project/__init__.py @Compatible () @typechecked def force_project_kpis ( self , project_id : str ) -> None : \"\"\" Compute KPIs for a project Parameters ---------- project_id : Identifier of the project Returns ------- None \"\"\" _ = QueriesAsset ( self . auth ) . assets ( project_id = project_id ) _ = QueriesProject ( self . auth ) . projects ( project_id = project_id ) internal_delete_project ( self , project_id ) Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\" Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result ) make_project_public ( self , project_id ) Make a project public. Warning: This action is permanent and irreversible. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict The public token to provide in the public URL Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. Warning: This action is permanent and irreversible. Parameters ---------- project_id : Identifier of the project Returns ------- dict The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) update_properties_in_project ( self , project_id , consensus_mark = None , consensus_tot_coverage = None , description = None , honeypot_mark = None , instructions = None , interface_category = 'IV2' , input_type = None , json_interface = None , min_consensus_size = None , number_of_assets = None , number_of_assets_with_empty_labels = None , number_of_remaining_assets = None , number_of_reviewed_assets = None , review_coverage = None , should_relaunch_kpi_computation = None , title = None , use_honeypot = None ) Update properties of a project Parameters: Name Type Description Default project_id str Identifier of the project required consensus_mark Optional[float] Should be between 0 and 1 None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Optional[str] None honeypot_mark Optional[float] Should be between 0 and 1 None instructions Optional[str] None interface_category str Always use 'IV2' 'IV2' input_type Optional[str] Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_assets_with_empty_labels Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , interface_category : str = 'IV2' , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\" Update properties of a project Parameters ---------- project_id : Identifier of the project consensus_mark : Should be between 0 and 1 consensus_tot_coverage : Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : honeypot_mark : Should be between 0 and 1 instructions : interface_category : Always use 'IV2' input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface : The json parameters of the project, see Edit your interface. min_consensus_size : Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets : Defaults to 0 number_of_assets_with_empty_labels : Defaults to 0 number_of_remaining_assets : Defaults to 0 number_of_reviewed_assets : Defaults to 0 review_coverage : Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings title : Title of the project use_honeypot : Activate / Deactivate the use of honeypot in the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'interfaceCategory' : interface_category , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) update_properties_in_project_user ( self , project_user_id , consensus_mark = None , honeypot_mark = None , number_of_labeled_assets = None , starred = None , total_duration = None ) Update properties of a project-user tuple Parameters: Name Type Description Default project_user_id str required consensus_mark Optional[float] Should be between 0 and 1. None honeypot_mark Optional[float] Should be between 0 and 1. None number_of_labeled_assets Optional[int] Number of assets the user labeled in the project. None starred Optional[bool] Whether to star the project in the project list. None total_duration Optional[int] Total time the user spent in the project. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Parameters ---------- project_user_id : str consensus_mark : Should be between 0 and 1. honeypot_mark : Should be between 0 and 1. number_of_labeled_assets : Number of assets the user labeled in the project. starred : Whether to star the project in the project list. total_duration : Total time the user spent in the project. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) update_properties_in_role ( self , role_id , project_id , user_id , role ) Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\" Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters ---------- role_id : Role identifier of the user. E.g. : 'to-be-deactivated' project_id : Identifier of the project user_id : The email or identifier of the user with updated role role : The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result )","title":"Project"},{"location":"project/#project-module","text":"Project queries","title":"Project module"},{"location":"project/#kili.queries.project.__init__.QueriesProject","text":"Set of Project queries Source code in kili/queries/project/__init__.py class QueriesProject : \"\"\" Set of Project queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'interfaceCategory' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of projects that match a set of criteria Parameters ---------- project_id : Select a specific project through its project_id. search_query : Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" skip : Number of projects to skip (they are ordered by their creation). fields : All the fields to request among the possible fields for the projects. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#project) for all possible fields. first : Maximum number of projects to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the projects is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. Examples ------- >>> # List all my projects >>> kili.projects() \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) def _query_projects ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_projects = gql_projects ( fragment_builder ( fields , Project )) result = self . auth . client . execute ( _gql_projects , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Parameters ---------- project_id : Select a specific project through its project_id search_query : Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesProject"},{"location":"project/#kili.queries.project.__init__.QueriesProject.count_projects","text":"Counts the number of projects with a search_query Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id None search_query Optional[str] Returned projects have a title or a description that matches this string. None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None Returns: Type Description int a positive integer corresponding to the number of results of the query if it was successful, or an error message else. Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects with a search_query Parameters ---------- project_id : Select a specific project through its project_id search_query : Returned projects have a title or a description that matches this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , } } result = self . auth . client . execute ( GQL_PROJECTS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_projects()"},{"location":"project/#kili.queries.project.__init__.QueriesProject.projects","text":"Get a generator or a list of projects that match a set of criteria Parameters: Name Type Description Default project_id Optional[str] Select a specific project through its project_id. None search_query Optional[str] Returned projects with a title or a description matching this string. None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings. None updated_at_gte Optional[str] Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None updated_at_lte Optional[str] Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" None skip int Number of projects to skip (they are ordered by their creation). 0 fields List[str] All the fields to request among the possible fields for the projects. See the documentation for all possible fields. ['consensusTotCoverage', 'id', 'inputType', 'interfaceCategory', 'jsonInterface', 'minConsensusSize', 'reviewCoverage', 'roles.id', 'roles.role', 'roles.user.email', 'roles.user.id', 'title'] first int Maximum number of projects to return. 100 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the projects is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] Source code in kili/queries/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def projects ( self , project_id : Optional [ str ] = None , search_query : Optional [ str ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , updated_at_gte : Optional [ str ] = None , updated_at_lte : Optional [ str ] = None , skip : int = 0 , fields : List [ str ] = [ 'consensusTotCoverage' , 'id' , 'inputType' , 'interfaceCategory' , 'jsonInterface' , 'minConsensusSize' , 'reviewCoverage' , 'roles.id' , 'roles.role' , 'roles.user.email' , 'roles.user.id' , 'title' ], first : int = 100 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Get a generator or a list of projects that match a set of criteria Parameters ---------- project_id : Select a specific project through its project_id. search_query : Returned projects with a title or a description matching this string. should_relaunch_kpi_computation : bool, optional (default = None) Technical field, added to indicate changes in honeypot or consensus settings. updated_at_gte : Returned projects should have a label whose update date is greater or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" updated_at_lte : Returned projects should have a label whose update date is lower or equal to this date. Formatted string should have format : \"YYYY-MM-DD\" skip : Number of projects to skip (they are ordered by their creation). fields : All the fields to request among the possible fields for the projects. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#project) for all possible fields. first : Maximum number of projects to return. disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the projects is returned. Returns ------- a result object which contains the query if it was successful, or an error message else. Examples ------- >>> # List all my projects >>> kili.projects() \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) saved_args = locals () count_args = { k : v for ( k , v ) in saved_args . items () if k in [ 'project_id' , 'search_query' , 'should_relaunch_kpi_computation' , 'updated_at_gte' , 'updated_at_lte' ] } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : project_id , 'searchQuery' : search_query , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'updatedAtGte' : updated_at_gte , 'updatedAtLte' : updated_at_lte , }, } projects_generator = row_generator_from_paginated_calls ( skip , first , self . count_projects , count_args , self . _query_projects , payload_query , fields , disable_tqdm ) if as_generator : return projects_generator return list ( projects_generator ) Project mutations","title":"projects()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject","text":"Set of Project mutations Source code in kili/mutations/project/__init__.py class MutationsProject : \"\"\" Set of Project mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\" Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters ---------- project_id : Identifier of the project user_email : The email of the user. This email is used as the unique identifier of the user. role : One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , interface_category : str = 'IV2' , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\" Update properties of a project Parameters ---------- project_id : Identifier of the project consensus_mark : Should be between 0 and 1 consensus_tot_coverage : Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : honeypot_mark : Should be between 0 and 1 instructions : interface_category : Always use 'IV2' input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface : The json parameters of the project, see Edit your interface. min_consensus_size : Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets : Defaults to 0 number_of_assets_with_empty_labels : Defaults to 0 number_of_remaining_assets : Defaults to 0 number_of_reviewed_assets : Defaults to 0 review_coverage : Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings title : Title of the project use_honeypot : Activate / Deactivate the use of honeypot in the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'interfaceCategory' : interface_category , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\" Create a project For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/create_project.ipynb). Parameters ---------- input_type : str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: dict The json parameters of the project, see Edit your interface. title : str description : project_type: Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. Warning: This action is permanent and irreversible. Parameters ---------- project_id : Identifier of the project Returns ------- dict The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\" Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters ---------- role_id : Role identifier of the user. E.g. : 'to-be-deactivated' project_id : Identifier of the project user_id : The email or identifier of the user with updated role role : The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\" Delete users by their role_id Parameters ---------- role_id : Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Parameters ---------- project_user_id : str consensus_mark : Should be between 0 and 1. honeypot_mark : Should be between 0 and 1. number_of_labeled_assets : Number of assets the user labeled in the project. starred : Whether to star the project in the project list. total_duration : Total time the user spent in the project. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result ) @Compatible () @typechecked def force_project_kpis ( self , project_id : str ) -> None : \"\"\" Compute KPIs for a project Parameters ---------- project_id : Identifier of the project Returns ------- None \"\"\" _ = QueriesAsset ( self . auth ) . assets ( project_id = project_id ) _ = QueriesProject ( self . auth ) . projects ( project_id = project_id ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\" Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete project permanently. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result )","title":"MutationsProject"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.append_to_roles","text":"Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters: Name Type Description Default project_id str Identifier of the project required user_email str The email of the user. This email is used as the unique identifier of the user. required role str One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. 'LABELER' Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def append_to_roles ( self , project_id : str , user_email : str , role : str = 'LABELER' ): \"\"\" Add a user to a project If the user does not exist in your organization, he/she is invited and added both to your organization and project. This function can also be used to change the role of the user in the project. Parameters ---------- project_id : Identifier of the project user_email : The email of the user. This email is used as the unique identifier of the user. role : One of {\"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\"}. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.append_to_roles(project_id=project_id, user_email='john@doe.com') \"\"\" variables = { 'data' : { 'role' : role , 'userEmail' : user_email }, 'where' : { 'id' : project_id } } result = self . auth . client . execute ( GQL_APPEND_TO_ROLES , variables ) return format_result ( 'data' , result )","title":"append_to_roles()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.create_project","text":"Create a project For more detailed examples on how to create projects, see the recipe . Parameters: Name Type Description Default input_type str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} required json_interface dict The json parameters of the project, see Edit your interface. required title str required description str '' project_type Optional[str] Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ( endpoints = [ 'v2' ]) @typechecked def create_project ( self , input_type : str , json_interface : dict , title : str , description : str = '' , project_type : Optional [ str ] = None ): # pylint: disable=line-too-long \"\"\" Create a project For more detailed examples on how to create projects, see [the recipe](https://github.com/kili-technology/kili-playground/blob/master/recipes/create_project.ipynb). Parameters ---------- input_type : str Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface: dict The json parameters of the project, see Edit your interface. title : str description : project_type: Currently, one of { IMAGE_CLASSIFICATION_SINGLE, IMAGE_CLASSIFICATION_MULTI, IMAGE_OBJECT_DETECTION_RECTANGLE, IMAGE_OBJECT_DETECTION_POLYGON, IMAGE_OBJECT_DETECTION_SEMANTIC, OCR, PDF_CLASSIFICATION_SINGLE, PDF_CLASSIFICATION_MULTI, TEXT_CLASSIFICATION_SINGLE, TEXT_CLASSIFICATION_MULTI, TEXT_TRANSCRIPTION, TEXT_NER, VIDEO_CLASSIFICATION_SINGLE, VIDEO_FRAME_CLASSIFICATION, VIDEO_FRAME_OBJECT_TRACKING, SPEECH_TO_TEXT } Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.create_project(input_type='IMAGE', json_interface=json_interface, title='Example') \"\"\" variables = { 'data' : { 'description' : description , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ), 'projectType' : project_type , 'title' : title } } result = self . auth . client . execute ( GQL_CREATE_PROJECT , variables ) return format_result ( 'data' , result )","title":"create_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.delete_from_roles","text":"Delete users by their role_id Parameters: Name Type Description Default role_id str required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_from_roles ( self , role_id : str ): \"\"\" Delete users by their role_id Parameters ---------- role_id : Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : role_id }} result = self . auth . client . execute ( GQL_DELETE_FROM_ROLES , variables ) return format_result ( 'data' , result )","title":"delete_from_roles()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.delete_project","text":"Delete project permanently. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def delete_project ( self , project_id : str ): \"\"\" Delete project permanently. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_PROJECT_DELETE_ASYNCHRONOUSLY , variables ) return format_result ( 'data' , result )","title":"delete_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.force_project_kpis","text":"Compute KPIs for a project Parameters: Name Type Description Default project_id str Identifier of the project required Source code in kili/mutations/project/__init__.py @Compatible () @typechecked def force_project_kpis ( self , project_id : str ) -> None : \"\"\" Compute KPIs for a project Parameters ---------- project_id : Identifier of the project Returns ------- None \"\"\" _ = QueriesAsset ( self . auth ) . assets ( project_id = project_id ) _ = QueriesProject ( self . auth ) . projects ( project_id = project_id )","title":"force_project_kpis()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.internal_delete_project","text":"Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def internal_delete_project ( self , project_id : str ): \"\"\" Delete project permanently. WARNING: This resolver is for internal use by Kili Technology only. Parameters ---------- project_id : Identifier of the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'projectID' : project_id } result = self . auth . client . execute ( GQL_DELETE_PROJECT , variables ) return format_result ( 'data' , result )","title":"internal_delete_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.make_project_public","text":"Make a project public. Warning: This action is permanent and irreversible. Parameters: Name Type Description Default project_id str Identifier of the project required Returns: Type Description dict The public token to provide in the public URL Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def make_project_public ( self , project_id : str ): \"\"\" Make a project public. Warning: This action is permanent and irreversible. Parameters ---------- project_id : Identifier of the project Returns ------- dict The public token to provide in the public URL \"\"\" variables = { 'where' : { 'id' : project_id }} result = self . auth . client . execute ( GQL_MAKE_PROJECT_PUBLIC , variables ) return format_result ( 'data' , result )","title":"make_project_public()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project","text":"Update properties of a project Parameters: Name Type Description Default project_id str Identifier of the project required consensus_mark Optional[float] Should be between 0 and 1 None consensus_tot_coverage Optional[int] Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. None description Optional[str] None honeypot_mark Optional[float] Should be between 0 and 1 None instructions Optional[str] None interface_category str Always use 'IV2' 'IV2' input_type Optional[str] Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} None json_interface Optional[dict] The json parameters of the project, see Edit your interface. None min_consensus_size Optional[int] Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. None number_of_assets Optional[int] Defaults to 0 None number_of_assets_with_empty_labels Optional[int] Defaults to 0 None number_of_remaining_assets Optional[int] Defaults to 0 None number_of_reviewed_assets Optional[int] Defaults to 0 None review_coverage Optional[int] Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface None should_relaunch_kpi_computation Optional[bool] Technical field, added to indicate changes in honeypot or consensus settings None title Optional[str] Title of the project None use_honeypot Optional[bool] Activate / Deactivate the use of honeypot in the project None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_project ( self , project_id : str , consensus_mark : Optional [ float ] = None , consensus_tot_coverage : Optional [ int ] = None , description : Optional [ str ] = None , honeypot_mark : Optional [ float ] = None , instructions : Optional [ str ] = None , interface_category : str = 'IV2' , input_type : Optional [ str ] = None , json_interface : Optional [ dict ] = None , min_consensus_size : Optional [ int ] = None , number_of_assets : Optional [ int ] = None , number_of_assets_with_empty_labels : Optional [ int ] = None , number_of_remaining_assets : Optional [ int ] = None , number_of_reviewed_assets : Optional [ int ] = None , review_coverage : Optional [ int ] = None , should_relaunch_kpi_computation : Optional [ bool ] = None , title : Optional [ str ] = None , use_honeypot : Optional [ bool ] = None ): \"\"\" Update properties of a project Parameters ---------- project_id : Identifier of the project consensus_mark : Should be between 0 and 1 consensus_tot_coverage : Should be between 0 and 100. It is the percentage of the dataset that will be annotated several times. description : honeypot_mark : Should be between 0 and 1 instructions : interface_category : Always use 'IV2' input_type : Currently, one of {AUDIO, IMAGE, PDF, TEXT, URL, VIDEO, NA} json_interface : The json parameters of the project, see Edit your interface. min_consensus_size : Should be between 1 and 10 Number of people that will annotate the same asset, for consensus computation. number_of_assets : Defaults to 0 number_of_assets_with_empty_labels : Defaults to 0 number_of_remaining_assets : Defaults to 0 number_of_reviewed_assets : Defaults to 0 review_coverage : Should be between 0 and 100 Allow to set the percentage of assets that will be queued in the review interface should_relaunch_kpi_computation : Technical field, added to indicate changes in honeypot or consensus settings title : Title of the project use_honeypot : Activate / Deactivate the use of honeypot in the project Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> kili.update_properties_in_project(project_id=project_id, title='New title') \"\"\" verify_argument_ranges ( consensus_tot_coverage , min_consensus_size , review_coverage ) variables = { 'consensusMark' : consensus_mark , 'consensusTotCoverage' : consensus_tot_coverage , 'description' : description , 'honeypotMark' : honeypot_mark , 'instructions' : instructions , 'interfaceCategory' : interface_category , 'inputType' : input_type , 'jsonInterface' : dumps ( json_interface ) if json_interface is not None else None , 'minConsensusSize' : min_consensus_size , 'numberOfAssets' : number_of_assets , 'numberOfAssetsWithSkippedLabels' : number_of_assets_with_empty_labels , 'numberOfRemainingAssets' : number_of_remaining_assets , 'numberOfReviewedAssets' : number_of_reviewed_assets , 'projectID' : project_id , 'reviewCoverage' : review_coverage , 'shouldRelaunchKpiComputation' : should_relaunch_kpi_computation , 'title' : title , 'useHoneyPot' : use_honeypot } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_project_user","text":"Update properties of a project-user tuple Parameters: Name Type Description Default project_user_id str required consensus_mark Optional[float] Should be between 0 and 1. None honeypot_mark Optional[float] Should be between 0 and 1. None number_of_labeled_assets Optional[int] Number of assets the user labeled in the project. None starred Optional[bool] Whether to star the project in the project list. None total_duration Optional[int] Total time the user spent in the project. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_user ( self , project_user_id : str , consensus_mark : Optional [ float ] = None , honeypot_mark : Optional [ float ] = None , number_of_labeled_assets : Optional [ int ] = None , starred : Optional [ bool ] = None , total_duration : Optional [ int ] = None ): \"\"\" Update properties of a project-user tuple Parameters ---------- project_user_id : str consensus_mark : Should be between 0 and 1. honeypot_mark : Should be between 0 and 1. number_of_labeled_assets : Number of assets the user labeled in the project. starred : Whether to star the project in the project list. total_duration : Total time the user spent in the project. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. Examples ------- >>> for project_user in project_users: ... kili.update_properties_in_project_user( project_user_id=project_user['id'], honeypot_mark=0) \"\"\" variables = { 'consensusMark' : consensus_mark , 'honeypotMark' : honeypot_mark , 'numberOfLabeledAssets' : number_of_labeled_assets , 'projectUserID' : project_user_id , 'starred' : starred , 'totalDuration' : total_duration , } result = self . auth . client . execute ( GQL_GQL_UPDATE_PROPERTIES_IN_PROJECT_USER , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project_user()"},{"location":"project/#kili.mutations.project.__init__.MutationsProject.update_properties_in_role","text":"Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters: Name Type Description Default role_id str Role identifier of the user. E.g. : 'to-be-deactivated' required project_id str Identifier of the project required user_id str The email or identifier of the user with updated role required role str The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/project/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_role ( self , role_id : str , project_id : str , user_id : str , role : str ): \"\"\" Update properties of a role To be able to change someone's role, you must be either of: - an admin - a team manager of the project - an admin of the organization Parameters ---------- role_id : Role identifier of the user. E.g. : 'to-be-deactivated' project_id : Identifier of the project user_id : The email or identifier of the user with updated role role : The new role. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\" Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'roleID' : role_id , 'projectID' : project_id , 'userID' : user_id , 'role' : role } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_ROLE , variables ) return format_result ( 'data' , result )","title":"update_properties_in_role()"},{"location":"project_user/","text":"Project User module Project user queries QueriesProjectUser Set of ProjectUser queries Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\" Set of ProjectUser queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Return project users (possibly with their KPIs) that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project fields : All the fields to request among the possible fields for the projectUsers. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first : Maximum number of users to return skip : Number of project users to skip disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( 'data' , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count count_project_users ( self , email = None , id = None , organization_id = None , project_id = None ) Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None Returns: Type Description int a positive integer corresponding to the number of results of the query if it was successful, or an error message else. Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count project_users ( self , email = None , id = None , organization_id = None , project_id = None , fields = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None fields List[str] All the fields to request among the possible fields for the projectUsers. See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first int Maximum number of users to return 100 skip int Number of project users to skip 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/project_user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Return project users (possibly with their KPIs) that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project fields : All the fields to request among the possible fields for the projectUsers. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first : Maximum number of users to return skip : Number of project users to skip disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"Project User"},{"location":"project_user/#project-user-module","text":"Project user queries","title":"Project User module"},{"location":"project_user/#kili.queries.project_user.__init__.QueriesProjectUser","text":"Set of ProjectUser queries Source code in kili/queries/project_user/__init__.py class QueriesProjectUser : \"\"\" Set of ProjectUser queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value,invalid-name @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Return project users (possibly with their KPIs) that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project fields : All the fields to request among the possible fields for the projectUsers. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first : Maximum number of users to return skip : Number of project users to skip disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator ) def _query_project_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_users = gql_project_users ( fragment_builder ( fields , ProjectUser )) result = self . auth . client . execute ( _gql_project_users , payload ) return format_result ( 'data' , result ) # pylint: disable=invalid-name @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesProjectUser"},{"location":"project_user/#kili.queries.project_user.__init__.QueriesProjectUser.count_project_users","text":"Counts the number of projects and their users that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None Returns: Type Description int a positive integer corresponding to the number of results of the query if it was successful, or an error message else. Source code in kili/queries/project_user/__init__.py @typechecked def count_project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None ) -> int : \"\"\" Counts the number of projects and their users that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project Returns ------- dict a positive integer corresponding to the number of results of the query if it was successful, or an error message else. \"\"\" variables = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } result = self . auth . client . execute ( GQL_PROJECT_USERS_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_project_users()"},{"location":"project_user/#kili.queries.project_user.__init__.QueriesProjectUser.project_users","text":"Return project users (possibly with their KPIs) that match a set of criteria Parameters: Name Type Description Default email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None project_id Optional[str] Identifier of the project None fields List[str] All the fields to request among the possible fields for the projectUsers. See the documentation for all possible fields. ['activated', 'id', 'role', 'starred', 'user.email', 'user.id'] first int Maximum number of users to return 100 skip int Number of project users to skip 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the project users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/project_user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def project_users ( self , email : Optional [ str ] = None , id : Optional [ str ] = None , # pylint: disable=redefined-builtin organization_id : Optional [ str ] = None , project_id : Optional [ str ] = None , fields : List [ str ] = [ 'activated' , 'id' , 'role' , 'starred' , 'user.email' , 'user.id' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Return project users (possibly with their KPIs) that match a set of criteria Parameters ---------- email : Email of the user organization_id : Identifier of the user's organization project_id : Identifier of the project fields : All the fields to request among the possible fields for the projectUsers. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectuser) for all possible fields. first : Maximum number of users to return skip : Number of project users to skip disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # Retrieve consensus marks of all users in project >>> kili.project_users(project_id=project_id, fields=['consensusMark', 'user.email']) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"email\" : email , \"id\" : id , \"organization_id\" : organization_id , \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'id' : id , 'project' : { 'id' : project_id , }, 'user' : { 'email' : email , 'organization' : { 'id' : organization_id , } }, } } project_users_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_users , count_args , self . _query_project_users , payload_query , fields , disable_tqdm ) if as_generator : return project_users_generator return list ( project_users_generator )","title":"project_users()"},{"location":"project_version/","text":"Project Version module Project version queries QueriesProjectVersion Set of ProjectVersion queries Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\" Set of ProjectVersion queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of project versions respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the project versions See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectVersions) for all possible fields. first : Number of project versions to query project_id : Filter on Id of project skip : Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project versions is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\" Count the number of project versions Parameters ---------- project_id : Filter on ID of project Returns ------- result: the number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count count_project_versions ( self , project_id ) Count the number of project versions Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int the number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\" Count the number of project versions Parameters ---------- project_id : Filter on ID of project Returns ------- result: the number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count project_version ( self , first = 100 , skip = 0 , fields = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id = None , disable_tqdm = False , as_generator = False ) Gets a generator or a list of project versions respecting a set of criteria Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'project', 'projectId'] first Optional[int] Number of project versions to query 100 project_id str Filter on Id of project None skip Optional[int] Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of project versions respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the project versions See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectVersions) for all possible fields. first : Number of project versions to query project_id : Filter on Id of project skip : Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project versions is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) Project version mutations MutationsProjectVersion dataclass Set of ProjectVersion mutations Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\" Set of ProjectVersion mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\" Update properties of a project version Parameters ---------- project_version_id : Identifier of the project version content : Link to download the project version Returns ------- dict A result object which indicates if the mutation was successful. Examples ------- >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result ) update_properties_in_project_version ( self , project_version_id , content ) Update properties of a project version Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description dict A result object which indicates if the mutation was successful. Source code in kili/mutations/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\" Update properties of a project version Parameters ---------- project_version_id : Identifier of the project version content : Link to download the project version Returns ------- dict A result object which indicates if the mutation was successful. Examples ------- >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"Project Version"},{"location":"project_version/#project-version-module","text":"Project version queries","title":"Project Version module"},{"location":"project_version/#kili.queries.project_version.__init__.QueriesProjectVersion","text":"Set of ProjectVersion queries Source code in kili/queries/project_version/__init__.py class QueriesProjectVersion : \"\"\" Set of ProjectVersion queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of project versions respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the project versions See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectVersions) for all possible fields. first : Number of project versions to query project_id : Filter on Id of project skip : Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project versions is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) def _query_project_versions ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_project_version = gql_project_version ( fragment_builder ( fields , ProjectVersionType )) result = self . auth . client . execute ( _gql_project_version , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\" Count the number of project versions Parameters ---------- project_id : Filter on ID of project Returns ------- result: the number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"QueriesProjectVersion"},{"location":"project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.count_project_versions","text":"Count the number of project versions Parameters: Name Type Description Default project_id str Filter on ID of project required Returns: Type Description int the number of project versions with the parameters provided Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def count_project_versions ( self , project_id : str ) -> int : \"\"\" Count the number of project versions Parameters ---------- project_id : Filter on ID of project Returns ------- result: the number of project versions with the parameters provided \"\"\" variables = { 'where' : { 'projectId' : project_id }, } result = self . auth . client . execute ( GQL_PROJECT_VERSION_COUNT , variables ) count = format_result ( 'data' , result ) return count","title":"count_project_versions()"},{"location":"project_version/#kili.queries.project_version.__init__.QueriesProjectVersion.project_version","text":"Gets a generator or a list of project versions respecting a set of criteria Parameters: Name Type Description Default fields List[str] All the fields to request among the possible fields for the project versions See the documentation for all possible fields. ['createdAt', 'id', 'content', 'name', 'project', 'projectId'] first Optional[int] Number of project versions to query 100 project_id str Filter on Id of project None skip Optional[int] Number of project versions to skip (they are ordered by their date of creation, first to last). 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the project versions is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def project_version ( self , first : Optional [ int ] = 100 , skip : Optional [ int ] = 0 , fields : List [ str ] = [ 'createdAt' , 'id' , 'content' , 'name' , 'project' , 'projectId' ], project_id : str = None , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of project versions respecting a set of criteria Parameters ---------- fields : All the fields to request among the possible fields for the project versions See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#projectVersions) for all possible fields. first : Number of project versions to query project_id : Filter on Id of project skip : Number of project versions to skip (they are ordered by their date of creation, first to last). disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the project versions is returned. Returns ------- result: a result object which contains the query if it was successful, or an error message else. \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"project_id\" : project_id } disable_tqdm = disable_tqdm or as_generator payload_query = { 'where' : { 'projectId' : project_id , }, } project_versions_generator = row_generator_from_paginated_calls ( skip , first , self . count_project_versions , count_args , self . _query_project_versions , payload_query , fields , disable_tqdm ) if as_generator : return project_versions_generator return list ( project_versions_generator ) Project version mutations","title":"project_version()"},{"location":"project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion","text":"Set of ProjectVersion mutations Source code in kili/mutations/project_version/__init__.py @dataclass class MutationsProjectVersion : \"\"\" Set of ProjectVersion mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\" Update properties of a project version Parameters ---------- project_version_id : Identifier of the project version content : Link to download the project version Returns ------- dict A result object which indicates if the mutation was successful. Examples ------- >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"MutationsProjectVersion"},{"location":"project_version/#kili.mutations.project_version.__init__.MutationsProjectVersion.update_properties_in_project_version","text":"Update properties of a project version Parameters: Name Type Description Default project_version_id str Identifier of the project version required content Optional[str] Link to download the project version required Returns: Type Description dict A result object which indicates if the mutation was successful. Source code in kili/mutations/project_version/__init__.py @Compatible ([ 'v2' ]) @typechecked def update_properties_in_project_version ( self , project_version_id : str , content : Optional [ str ]): \"\"\" Update properties of a project version Parameters ---------- project_version_id : Identifier of the project version content : Link to download the project version Returns ------- dict A result object which indicates if the mutation was successful. Examples ------- >>> kili.update_properties_in_project_version( project_version_id=project_version_id, content='test') \"\"\" variables = { 'content' : content , 'id' : project_version_id , } result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_PROJECT_VERSION , variables ) return format_result ( 'data' , result )","title":"update_properties_in_project_version()"},{"location":"user/","text":"User module User queries QueriesUser Set of User queries Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\" Set of User queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of users given a set of criteria Parameters ---------- api_key : Query an user by its API KEY email : Email of the user organization_id : Identifier of the user's organization fields : All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first : Maximum number of users to return. skip : Number of skipped users (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\" Get user count based on a set of constraints Parameters ---------- organization_id : Identifier of the user's organization Returns ------- dict the count of users whose organization ID matches the given ID \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result ) count_users ( self , organization_id = None ) Get user count based on a set of constraints Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int the count of users whose organization ID matches the given ID Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\" Get user count based on a set of constraints Parameters ---------- organization_id : Identifier of the user's organization Returns ------- dict the count of users whose organization ID matches the given ID \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result ) users ( self , api_key = None , email = None , organization_id = None , fields = [ 'email' , 'id' , 'firstname' , 'lastname' ], first = 100 , skip = 0 , disable_tqdm = False , as_generator = False ) Gets a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API KEY None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first int Maximum number of users to return. 100 skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of users given a set of criteria Parameters ---------- api_key : Query an user by its API KEY email : Email of the user organization_id : Identifier of the user's organization fields : All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first : Maximum number of users to return. skip : Number of skipped users (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) User mutations MutationsUser Set of User mutations Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\" Set of User mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\" Add a user to your organization. Parameters ---------- email : Email of the new user, used as user's unique identifier. password : On the first sign in, he will use this password and be able to change it. organization_role : One of \"ADMIN\", \"USER\". firstname : First name of the new user. lastname : Last name of the new user. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\" Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters ---------- email : old_password : new_password_1 : The new password. new_password_2 : A confirmation field for the new password. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\" Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters ---------- email : Email of the person whose password has to be reset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\" Update the properties of a user Parameters ---------- email : str The email is the identifier of the user. firstname : Change the first name of the user. lastname : Change the last name of the user. organization_id : Change the organization the user is related to. organization_role : Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated : In case we want to deactivate a user, but keep it. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result ) create_user ( self , email = None , password = None , organization_role = None , firstname = None , lastname = None ) Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. None password str On the first sign in, he will use this password and be able to change it. None organization_role str One of \"ADMIN\", \"USER\". None firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\" Add a user to your organization. Parameters ---------- email : Email of the new user, used as user's unique identifier. password : On the first sign in, he will use this password and be able to change it. organization_role : One of \"ADMIN\", \"USER\". firstname : First name of the new user. lastname : Last name of the new user. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) reset_password ( self , email ) Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\" Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters ---------- email : Email of the person whose password has to be reset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) update_password ( self , email , old_password , new_password_1 , new_password_2 ) Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email str required old_password str required new_password_1 str The new password. required new_password_2 str A confirmation field for the new password. required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\" Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters ---------- email : old_password : new_password_1 : The new password. new_password_2 : A confirmation field for the new password. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) update_properties_in_user ( self , email , firstname = None , lastname = None , organization_id = None , organization_role = None , activated = None ) Update the properties of a user Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\" Update the properties of a user Parameters ---------- email : str The email is the identifier of the user. firstname : Change the first name of the user. lastname : Change the last name of the user. organization_id : Change the organization the user is related to. organization_role : Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated : In case we want to deactivate a user, but keep it. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"User"},{"location":"user/#user-module","text":"User queries","title":"User module"},{"location":"user/#kili.queries.user.__init__.QueriesUser","text":"Set of User queries Source code in kili/queries/user/__init__.py class QueriesUser : \"\"\" Set of User queries \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth # pylint: disable=dangerous-default-value @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of users given a set of criteria Parameters ---------- api_key : Query an user by its API KEY email : Email of the user organization_id : Identifier of the user's organization fields : All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first : Maximum number of users to return. skip : Number of skipped users (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) def _query_users ( self , skip : int , first : int , payload : dict , fields : List [ str ]): payload . update ({ 'skip' : skip , 'first' : first }) _gql_users = gql_users ( fragment_builder ( fields , User )) result = self . auth . client . execute ( _gql_users , payload ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\" Get user count based on a set of constraints Parameters ---------- organization_id : Identifier of the user's organization Returns ------- dict the count of users whose organization ID matches the given ID \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result )","title":"QueriesUser"},{"location":"user/#kili.queries.user.__init__.QueriesUser.count_users","text":"Get user count based on a set of constraints Parameters: Name Type Description Default organization_id Optional[str] Identifier of the user's organization None Returns: Type Description int the count of users whose organization ID matches the given ID Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def count_users ( self , organization_id : Optional [ str ] = None ) -> int : \"\"\" Get user count based on a set of constraints Parameters ---------- organization_id : Identifier of the user's organization Returns ------- dict the count of users whose organization ID matches the given ID \"\"\" variables = { 'where' : { 'organization' : { 'id' : organization_id , } } } result = self . auth . client . execute ( GQL_USERS_COUNT , variables ) return format_result ( 'data' , result )","title":"count_users()"},{"location":"user/#kili.queries.user.__init__.QueriesUser.users","text":"Gets a generator or a list of users given a set of criteria Parameters: Name Type Description Default api_key Optional[str] Query an user by its API KEY None email Optional[str] Email of the user None organization_id Optional[str] Identifier of the user's organization None fields List[str] All the fields to request among the possible fields for the users. See the documentation for all possible fields. ['email', 'id', 'firstname', 'lastname'] first int Maximum number of users to return. 100 skip int Number of skipped users (they are ordered by creation date) 0 disable_tqdm bool If True, the progress bar will be disabled False as_generator bool If True, a generator on the users is returned. False Returns: Type Description Union[List[dict], Generator[dict, NoneType]] a result object which contains the query if it was successful, or an error message else. Source code in kili/queries/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def users ( self , api_key : Optional [ str ] = None , email : Optional [ str ] = None , organization_id : Optional [ str ] = None , fields : List [ str ] = [ 'email' , 'id' , 'firstname' , 'lastname' ], first : int = 100 , skip : int = 0 , disable_tqdm : bool = False , as_generator : bool = False ) -> Union [ List [ dict ], Generator [ dict , None , None ]]: # pylint: disable=line-too-long \"\"\" Gets a generator or a list of users given a set of criteria Parameters ---------- api_key : Query an user by its API KEY email : Email of the user organization_id : Identifier of the user's organization fields : All the fields to request among the possible fields for the users. See [the documentation](https://cloud.kili-technology.com/docs/python-graphql-api/graphql-api/#user) for all possible fields. first : Maximum number of users to return. skip : Number of skipped users (they are ordered by creation date) disable_tqdm : If True, the progress bar will be disabled as_generator: If True, a generator on the users is returned. Returns ------- dict a result object which contains the query if it was successful, or an error message else. Examples ------- ``` # List all users in my organization >>> organization = kili.organizations() >>> organization_id = organizations[0]['id] >>> kili.users(organization_id=organization_id) ``` \"\"\" if as_generator is False : warnings . warn ( \"From 2022-05-18, the default return type will be a generator. Currently, the default return type is a list. \\n \" \"If you want to force the query return to be a list, you can already call this method with the argument as_generator=False\" , DeprecationWarning ) count_args = { \"organization_id\" : organization_id } disable_tqdm = disable_tqdm or as_generator or ( api_key or email ) is not None payload_query = { 'where' : { 'apiKey' : api_key , 'email' : email , 'organization' : { 'id' : organization_id , } } } users_generator = row_generator_from_paginated_calls ( skip , first , self . count_users , count_args , self . _query_users , payload_query , fields , disable_tqdm ) if as_generator : return users_generator return list ( users_generator ) User mutations","title":"users()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser","text":"Set of User mutations Source code in kili/mutations/user/__init__.py class MutationsUser : \"\"\" Set of User mutations \"\"\" # pylint: disable=too-many-arguments,too-many-locals def __init__ ( self , auth ): \"\"\" Initializes the subclass Parameters ---------- auth : KiliAuth object \"\"\" self . auth = auth @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\" Add a user to your organization. Parameters ---------- email : Email of the new user, used as user's unique identifier. password : On the first sign in, he will use this password and be able to change it. organization_role : One of \"ADMIN\", \"USER\". firstname : First name of the new user. lastname : Last name of the new user. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\" Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters ---------- email : old_password : new_password_1 : The new password. new_password_2 : A confirmation field for the new password. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\" Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters ---------- email : Email of the person whose password has to be reset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result ) @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\" Update the properties of a user Parameters ---------- email : str The email is the identifier of the user. firstname : Change the first name of the user. lastname : Change the last name of the user. organization_id : Change the organization the user is related to. organization_role : Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated : In case we want to deactivate a user, but keep it. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"MutationsUser"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.create_user","text":"Add a user to your organization. Parameters: Name Type Description Default email str Email of the new user, used as user's unique identifier. None password str On the first sign in, he will use this password and be able to change it. None organization_role str One of \"ADMIN\", \"USER\". None firstname Optional[str] First name of the new user. None lastname Optional[str] Last name of the new user. None Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def create_user ( self , email : str = None , password : str = None , organization_role : str = None , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None ): \"\"\" Add a user to your organization. Parameters ---------- email : Email of the new user, used as user's unique identifier. password : On the first sign in, he will use this password and be able to change it. organization_role : One of \"ADMIN\", \"USER\". firstname : First name of the new user. lastname : Last name of the new user. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'email' : email , 'password' : password , 'organizationRole' : organization_role } } if firstname is not None : variables [ 'data' ][ 'firstname' ] = firstname if lastname is not None : variables [ 'data' ][ 'lastname' ] = lastname result = self . auth . client . execute ( GQL_CREATE_USER , variables ) return format_result ( 'data' , result )","title":"create_user()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.reset_password","text":"Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters: Name Type Description Default email str Email of the person whose password has to be reset. required Returns: Type Description dict a result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def reset_password ( self , email : str ): \"\"\" Reset password This resolver only works for on-premise installations without Auth0, if your organization allows Kili to send emails. Parameters ---------- email : Email of the person whose password has to be reset. Returns ------- dict a result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'where' : { 'email' : email }} result = self . auth . client . execute ( GQL_RESET_PASSWORD , variables ) return format_result ( 'data' , result )","title":"reset_password()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.update_password","text":"Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters: Name Type Description Default email str required old_password str required new_password_1 str The new password. required new_password_2 str A confirmation field for the new password. required Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_password ( self , email : str , old_password : str , new_password_1 : str , new_password_2 : str ): \"\"\" Allows you to modify the password that you use to connect to Kili. This resolver only works for on-premise installations without Auth0. Parameters ---------- email : old_password : new_password_1 : The new password. new_password_2 : A confirmation field for the new password. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'data' : { 'oldPassword' : old_password , 'newPassword1' : new_password_1 , 'newPassword2' : new_password_2 }, 'where' : { 'email' : email } } result = self . auth . client . execute ( GQL_UPDATE_PASSWORD , variables ) return format_result ( 'data' , result )","title":"update_password()"},{"location":"user/#kili.mutations.user.__init__.MutationsUser.update_properties_in_user","text":"Update the properties of a user Parameters: Name Type Description Default email str The email is the identifier of the user. required firstname Optional[str] Change the first name of the user. None lastname Optional[str] Change the last name of the user. None organization_id Optional[str] Change the organization the user is related to. None organization_role Optional[str] Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". None activated Optional[bool] In case we want to deactivate a user, but keep it. None Returns: Type Description dict A result object which indicates if the mutation was successful, or an error message else. Source code in kili/mutations/user/__init__.py @Compatible ([ 'v1' , 'v2' ]) @typechecked def update_properties_in_user ( self , email : str , firstname : Optional [ str ] = None , lastname : Optional [ str ] = None , organization_id : Optional [ str ] = None , organization_role : Optional [ str ] = None , activated : Optional [ bool ] = None ): \"\"\" Update the properties of a user Parameters ---------- email : str The email is the identifier of the user. firstname : Change the first name of the user. lastname : Change the last name of the user. organization_id : Change the organization the user is related to. organization_role : Change the role of the user. One of \"ADMIN\", \"TEAM_MANAGER\", \"REVIEWER\", \"LABELER\". activated : In case we want to deactivate a user, but keep it. Returns ------- dict A result object which indicates if the mutation was successful, or an error message else. \"\"\" variables = { 'email' : email , } if firstname is not None : variables [ 'firstname' ] = firstname if lastname is not None : variables [ 'lastname' ] = lastname if organization_id is not None : variables [ 'organizationId' ] = organization_id if organization_role is not None : variables [ 'organizationRole' ] = organization_role if activated is not None : variables [ 'activated' ] = activated result = self . auth . client . execute ( GQL_UPDATE_PROPERTIES_IN_USER , variables ) return format_result ( 'data' , result )","title":"update_properties_in_user()"}]}